# -------------------- CBatalhaReal.cpp --------------------

#include <Windows.h>
#include <stdio.h>
#include <fcntl.h>
#include <time.h>
#include <math.h>
#include <io.h>
#include <errno.h>

#include "..\Basedef.h"
#include "..\CPSock.h"
#include "..\ItemEffect.h"
#include "Language.h"

#include "CItem.h"
#include "Server.h"
#include "GetFunc.h"
#include "SendFunc.h"
#include "ProcessClientMessage.h"
#include "ProcessDBMessage.h"
#include "CReadFiles.h"
#include "CBatalhaReal.h"


bool CBatalhaReal::BatalhaProcess(int conn, int target) // Batalha Real
{ 
	 
}

# -------------------- CBatalhaReal.h --------------------

/*
*   Copyright (C) {2015}  {Victor Klafke, Charles TheHouse}
*
*   This program is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program.  If not, see [http://www.gnu.org/licenses/].
*
*   Contact at: victor.klafke@ecomp.ufsm.br
*/
#pragma once

#include <stdio.h>
#include "..\Basedef.h"


class CBatalhaReal
{
public:
	static bool BatalhaProcess(int conn, int target);
};


# -------------------- CCastleZakum.cpp --------------------

/*
*   Copyright (C) {2015}  {Victor Klafke, Charles TheHouse}
*
*   This program is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program.  If not, see [http://www.gnu.org/licenses/].
*
*   Contact at: victor.klafke@ecomp.ufsm.br
*/
#include <Windows.h>
#include <stdio.h>
#include <fcntl.h>
#include <time.h>
#include <math.h>
#include <io.h>
#include <errno.h>

#include "..\Basedef.h"
#include "..\CPSock.h"
#include "..\ItemEffect.h"
#include "Language.h"

#include "CItem.h"
#include "Server.h"
#include "GetFunc.h"
#include "SendFunc.h"
#include "ProcessClientMessage.h"
#include "ProcessDBMessage.h"
#include "CReadFiles.h"

#include "CCastleZakum.h"

STRUCT_CASTLEQUEST CastleQuest[MAX_CASTLE_QUEST];

const char* const CCastleZakum::CASTLE_QUEST_PATH = "../../Common/Settings/CastleQuest.txt";

int CastleQuestPosition[MAX_CASTLE_POS][4] =
{
#pragma region Hidden
	{ 2221, 1270, 2259, 1246 }, //Primeiro bloco

	//Lado Esquerdo da quest
	{ 2217, 1212, 2234, 1235 },
	{ 2186, 1212, 2205, 1232 },
	{ 2192, 1171, 2212, 1193 },
	{ 2221, 1171, 2238, 1198 },

	//Lado Direito da quest
	{ 2245, 1212, 2261, 1234 },
	{ 2273, 1210, 2291, 1232 },
	{ 2268, 1171, 2287, 1193 },
	{ 2240, 1171, 2258, 1198 },
#pragma endregion
};

int CastleQuestClear = 0;

int CastleQuestTime = -1;
int CastleQuestParty[MAX_PARTY + 1] = { 0, 0, 0, 0, 0, 0, };
int CastleQuestLevel = -1;
char CastleLeader[NAME_LENGTH];

BOOL CCastleZakum::OpenCastleGate(int conn, int gateid, MSG_UpdateItem *m)
{
	int state = pItem[gateid].State;
	int gatestate2 = m->State;

	int gatekey = BASE_GetItemAbility(&pItem[gateid].ITEM, EF_KEYID);

	if (gatekey < 10 || gatekey > 14)
		return FALSE;

	int key = 0;
	int Quest = -1;

	int i = 0;
	for (i = 0; i < MAX_CARRY; i++)
	{
		key = BASE_GetItemAbility(&pMob[conn].MOB.Carry[i], EF_KEYID);
		Quest = BASE_GetItemAbility(&pMob[conn].MOB.Carry[i], EF_QUEST);

		if (key != gatekey || Quest != CastleQuestLevel && gatekey != 10)
			continue;

		break;
	}

	if (key != gatekey || Quest != CastleQuestLevel && gatekey != 10)
	{
		if (pItem[gateid].ITEM.sIndex != 773)
		 SendMsgExp(conn, g_pMessageStringTable[_NN_No_Key], TNColor::Default, false);
		return TRUE;
	}

#pragma region Portão de entrada
	if (gatekey == 10)
	{//Portão principal do castelo zakum onde define qual level será a quest.
		if (Quest < 0 || Quest >= MAX_CASTLE_QUEST)
			return TRUE;

		if (CastleQuestTime != -1)
		{
			int count = 0;

			for (int i = 0; i < MAX_PARTY; i++)
			{
				if (CastleQuestParty[i] == 0 || CastleQuestParty[i] >= MAX_USER)
					continue;

				count++;
			}	 
			SendMsgExp(conn, strFmt(g_pMessageStringTable[_SD_Zakum_Quest_by_S_N], CastleLeader, count), TNColor::Default, false);
			return TRUE;
		}

		//Deleta todos os mobs do mapa que sobraram em alguma outra quest.
		for (int x = 2180; x <= 2296; x++)
		{
			for (int y = 1160; y <= 1269; y++)
			{
				int tmob = pMobGrid[y][x];

				if (tmob < MAX_USER)
					continue;

				int generate = pMob[tmob].GenerateIndex;

				mNPCGen.pList[generate].MinuteGenerate = -1;
				DeleteMob(tmob, 3);
			}
		}

		//Cria todos os mobs para essa quest
		for (int x = CastleQuest[Quest].MOB_INITIAL; x <= CastleQuest[Quest].MOB_END; x++)
		{
			if (x != CastleQuest[Quest].BOSS[0] && x != CastleQuest[Quest].BOSS[1])
				mNPCGen.pList[x].MinuteGenerate = 1;

			GenerateMob(x, 0, 0);
			GenerateMob(x, 0, 0);
		}
		CastleQuestLevel = Quest;
		CastleQuestTime = CastleQuest[Quest].QuestTime-1;

		int Leader = pMob[conn].Leader;

		if (Leader == 0)
			Leader = conn;

		strncpy(CastleLeader, pMob[Leader].MOB.MobName, NAME_LENGTH);

		SendClientSignalParm(Leader, ESCENE_FIELD, _MSG_StartTime, CastleQuest[Quest].QuestTime);

		for (int i = 0; i < MAX_PARTY; i++)
		{
			int partyconn = pMob[Leader].PartyList[i];

			if (partyconn > 0 && partyconn < MAX_USER && partyconn != Leader && pUser[partyconn].Mode == USER_PLAY)
				SendClientSignalParm(partyconn, ESCENE_FIELD, _MSG_StartTime, CastleQuest[Quest].QuestTime);
		}

		for (int x = 0; x < MAX_PARTY + 1; x++)
		{
			if (x == MAX_PARTY)
			{
				CastleQuestParty[MAX_PARTY] = Leader;

				continue;
			}
			CastleQuestParty[x] = pMob[Leader].PartyList[x];
		}
	}
#pragma endregion
#pragma region Portões de dentro
	else if (gatekey >= 11 && gatekey <= 14)
	{
		if (Quest != CastleQuestLevel)
			return TRUE;
	}
#pragma endregion

	memset(&pMob[conn].MOB.Carry[i], 0, sizeof(STRUCT_ITEM));
	SendItem(conn, ITEM_PLACE_CARRY, i, &pMob[conn].MOB.Carry[i]);

	int heigth = 0;

	int isUpdate = UpdateItem(gateid, STATE_OPEN, &heigth);

	if (isUpdate)
		GridMulticast(pItem[gateid].PosX, pItem[gateid].PosY, (MSG_STANDARD*)m, 0);

	sprintf_s(temp, "etc,opengate gateid:%d X:%d Y:%d", gateid, pItem[gateid].PosX, pItem[gateid].PosY);
	SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);
	return TRUE;
}

void CCastleZakum::MobKilled(int target, int conn, int PosX, int PosY)
{
	int GenerateID = pMob[target].GenerateIndex;

	for (int k = 0; k < MAX_CASTLE_QUEST; k++)
	{
		if (GenerateID == CastleQuest[k].BOSS[0] || GenerateID == CastleQuest[k].BOSS[1])
		{
			SendNoticeArea(strFmt(g_pMessageStringTable[_SN_CastleQuest_Killed], pMob[conn].MOB.MobName), 2176, 1160, 2300, 1276);
			CastleQuestClear = 1;

			//Entrega os itens, exp e gold para todos após matarem o boss.

			int partyleader = pMob[conn].Leader;

			if (partyleader <= 0)
				partyleader = conn;

			for (int j = 0; j < MAX_CARRY; j++)
			{
				if (CastleQuest[k].Prize[j].sIndex)
					PutItem(partyleader, &CastleQuest[k].Prize[j]);
			}
			if (CastleQuest[k].ExpPrize[pMob[partyleader].extra.ClassMaster])
			{
				pMob[partyleader].MOB.Exp += CastleQuest[k].ExpPrize[pMob[partyleader].extra.ClassMaster];

				SendMsgExp(partyleader, strFmt(g_pMessageStringTable[_NS_GETEXP], CastleQuest[k].ExpPrize[pMob[partyleader].extra.ClassMaster]), TNColor::Default, false);
			}

			if (CastleQuest[k].CoinPrize)
			{
				unsigned int Coin = pMob[partyleader].MOB.Coin + CastleQuest[k].CoinPrize;

				if (Coin <= 2000000000)
				{					 
					SendMsgExp(partyleader, strFmt(g_pMessageStringTable[_DN_receive_D_gold], CastleQuest[k].CoinPrize), TNColor::Default, false);
					pMob[partyleader].MOB.Coin = Coin;
					SendEtc(partyleader);
				}
				else
				 
				SendMsgExp(partyleader, g_pMessageStringTable[_NN_Cant_get_more_than_2G], TNColor::Default, false);
			}

			for (int i = 0; i < MAX_PARTY && CastleQuest[k].PartyPrize; i++)
			{
				int partymember = pMob[partyleader].PartyList[i];

				if (partymember <= 0 || partymember >= MAX_USER)  //23/01
					continue;

				if (pUser[partymember].Mode != USER_PLAY)
					continue;

				for (int j = 0; j < MAX_CARRY; j++)
				{
					if (CastleQuest[k].Prize[j].sIndex)
						PutItem(partymember, &CastleQuest[k].Prize[j]);
				}

				if (CastleQuest[k].ExpPrize[pMob[partymember].extra.ClassMaster])
				{
					pMob[partymember].MOB.Exp += CastleQuest[k].ExpPrize[pMob[partymember].extra.ClassMaster];
					SendMsgExp(partyleader, strFmt(g_pMessageStringTable[_NS_GETEXP], CastleQuest[k].ExpPrize[pMob[partymember].extra.ClassMaster]), TNColor::Default, false);
				}

				if (CastleQuest[k].CoinPrize)
				{
					unsigned int Coin = pMob[partymember].MOB.Coin + CastleQuest[k].CoinPrize;

					if (Coin <= 2000000000)
					{
						SendMsgExp(partyleader, strFmt(g_pMessageStringTable[_DN_receive_D_gold], CastleQuest[k].CoinPrize), TNColor::Default, false);

						pMob[partymember].MOB.Coin = Coin;
						SendEtc(partymember);
					}
					else
					 
					SendMsgExp(partyleader, g_pMessageStringTable[_NN_Cant_get_more_than_2G], TNColor::Default, false);
				}
			}
		}
	}
}

BOOL CCastleZakum::KeyDrop(int target, int conn, int PosX, int PosY, STRUCT_ITEM *Key)
{
	int ItemKey = BASE_GetItemAbility(Key, EF_KEYID);

	if (ItemKey >= 11 && ItemKey <= 14)
	{
		Key->stEffect[0].cEffect = EF_QUEST;
		Key->stEffect[0].cValue = CastleQuestLevel;

		PutItem(conn, Key);
		return FALSE;
	}
	return TRUE;
}

void CCastleZakum::ProcessSecTimer()
{
	if (SecCounter % 2 == 0)
	{
		if (CastleQuestTime == 0)
		{
			CastleQuestTime = -1;
			ClearArea(2180, 1160, 2296, 1269);

			//Deleta todos os mobs do mapa que sobraram em alguma outra quest.
			for (int x = 2180; x <= 2296; x++)
			{
				for (int y = 1160; y <= 1269; y++)
				{
					int tmob = pMobGrid[y][x];

					if (tmob < MAX_USER)
						continue;

					int generate = pMob[tmob].GenerateIndex;

					mNPCGen.pList[generate].MinuteGenerate = -1;
					DeleteMob(tmob, 3);
				}
			}
		}
		if (CastleQuestTime > 0)
			CastleQuestTime--;
	}
}

void CCastleZakum::ProcessMinTimer()
{
	if (CastleQuestClear == 1)
	{
		CastleQuestClear = 2;
		SendNoticeArea(g_pMessageStringTable[_NN_CastleQuest_Initialize], 2176, 1160, 2300, 1276);
	}
	else if (CastleQuestClear == 2)
	{
		CastleQuestClear = 0;

		ClearArea(2180, 1160, 2296, 1269);

		//Deleta todos os mobs do mapa que sobraram em alguma outra quest.
		for (int x = 2180; x <= 2296; x++)
		{
			for (int y = 1160; y <= 1269; y++)
			{
				int tmob = pMobGrid[y][x];

				if (tmob < MAX_USER)
					continue;

				int generate = pMob[tmob].GenerateIndex;

				mNPCGen.pList[generate].MinuteGenerate = -1;
				DeleteMob(tmob, 3);
			}
		}
	}
}

void CCastleZakum::CheckMove(int conn, int targetx, int targety)
{
	int i = MAX_PARTY + 1;

	for (i = 0; i < MAX_PARTY + 1; i++)
	{
		if (CastleQuestParty[i] == conn)
			break;
	}
	for (int k = 0; k < MAX_CASTLE_POS; k++)
	{
		if (i == MAX_PARTY + 1 && targetx >= CastleQuestPosition[k][0] && targety >= CastleQuestPosition[k][1] && targetx <= CastleQuestPosition[k][2] && targety <= CastleQuestPosition[k][3])
		{
			DoTeleport(conn, pMob[conn].TargetX, pMob[conn].TargetY);
			return;
		}
	}
}

void CCastleZakum::ReadCastleQuest()
{
	FILE *fs = fopen(CASTLE_QUEST_PATH, "rt");

	if (fs == NULL)
	{
		MessageBoxA(hWndMain, "CastleQuest.txt não foi encontrado.", CASTLE_QUEST_PATH, MB_OK);

		return;
	}

	int Num = -1;

	char tp[1024];

	memset(tp, 0, 1023);

	while (1)
	{
		char *getret = fgets(tp, 1024, fs);

		if (getret == NULL)
			break;


		if (tp[0] == 47) //'\ '
			continue;

		else if (tp[0] == '#')
		{
			if (Num >= MAX_CASTLE_QUEST)
				break;

			Num++;

			memset(&CastleQuest[Num], 0, sizeof(STRUCT_CASTLEQUEST));
		}

		else if (tp[0] != 13)
		{
			int pars = ParseCastleString(Num, tp);

			if (pars == 0)
				continue;
		}
	}
	fclose(fs);
}

int  CCastleZakum::ParseCastleString(int Num, char *str)
{
	char str1[128];
	str1[0] = 0;

	char str2[128];
	str2[0] = 0;

	char str3[128];
	str3[0] = 0;

	int  value = 0;
	int secondvalue = 0;

	sscanf(str, "%s %s %s", str1, str2, str3);

	if (str[0] == 47)
		return FALSE;

	if (str[0] == 0)
		return FALSE;

	STRUCT_ITEM Item;
	memset(&Item, 0, sizeof(STRUCT_ITEM));

	char item_str1[256];
	char item_str2[256];
	char item_str3[256];
	char item_str4[256];
	char item_str5[256];
	char item_str6[256];
	char item_str7[256];

	int item_value[7] = { 0, 0, 0, 0, 0, 0, 0 };

	sscanf(str, "%s %s %s %s %s %s %s %s", str1, item_str1, item_str2, item_str3, item_str4, item_str5, item_str6, item_str7);
	item_value[0] = atoi(item_str1);
	item_value[1] = atoi(item_str2);
	item_value[2] = atoi(item_str3);
	item_value[3] = atoi(item_str4);
	item_value[4] = atoi(item_str5);
	item_value[5] = atoi(item_str6);
	item_value[6] = atoi(item_str7);

	value = atoi(str2);
	secondvalue = atoi(str3);

	if (strlen(str2) > 80)
		return FALSE;

	_strupr(str1);
	_strupr(str2);

	if (!strcmp(str1, "MOB_INITIAL:"))
		CastleQuest[Num].MOB_INITIAL = value;

	else if (!strcmp(str1, "MOB_END:"))
		CastleQuest[Num].MOB_END = value;

	else if (!strcmp(str1, "BOSS1:"))
		CastleQuest[Num].BOSS[0] = value;

	else if (!strcmp(str1, "BOSS2:"))
		CastleQuest[Num].BOSS[1] = value;

	else if (!strcmp(str1, "COINPRIZE:"))
		CastleQuest[Num].CoinPrize = value;

	else if (!strcmp(str1, "EXPPRIZE_ARCH:"))
		CastleQuest[Num].ExpPrize[1] = value;

	else if (!strcmp(str1, "EXPPRIZE_MORTAL:"))
		CastleQuest[Num].ExpPrize[2] = value;

	else if (!strcmp(str1, "EXPPRIZE_CELESTIAL:"))
	{
		CastleQuest[Num].ExpPrize[3] = value;
		CastleQuest[Num].ExpPrize[4] = value;
	}

	else if (!strcmp(str1, "EXPPRIZE_SUBCELESTIAL:"))
		CastleQuest[Num].ExpPrize[2] = value;

	else if (!strcmp(str1, "PARTYPRIZE:"))
		CastleQuest[Num].PartyPrize = strcmp(str2, "ON") == 0 ? 1 : 0;

	else if (!strcmp(str1, "QUESTTIME:"))
		CastleQuest[Num].QuestTime = value;

	else
	{
		for (int i = 0; i < MAX_CARRY; i++)
		{
			sprintf_s(temp, "PRIZE_%d:", i);

			if (!strcmp(str1, temp))
			{
				CastleQuest[Num].Prize[i].sIndex = item_value[0];
				CastleQuest[Num].Prize[i].stEffect[0].cEffect = item_value[1];
				CastleQuest[Num].Prize[i].stEffect[0].cValue = item_value[2];
				CastleQuest[Num].Prize[i].stEffect[1].cEffect = item_value[3];
				CastleQuest[Num].Prize[i].stEffect[1].cValue = item_value[4];
				CastleQuest[Num].Prize[i].stEffect[2].cEffect = item_value[5];
				CastleQuest[Num].Prize[i].stEffect[2].cValue = item_value[6];

				return TRUE;
			}
		}
	}
	return TRUE;
}

# -------------------- CCastleZakum.h --------------------

/*
*   Copyright (C) {2015}  {Victor Klafke, Charles TheHouse}
*
*   This program is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program.  If not, see [http://www.gnu.org/licenses/].
*
*   Contact at: victor.klafke@ecomp.ufsm.br
*/
#pragma once

#include <stdio.h>
#include "..\Basedef.h"


class CCastleZakum
{
private:
	static const char* const CASTLE_QUEST_PATH;

public:
	static BOOL OpenCastleGate(int conn, int gateid, MSG_UpdateItem *m);
	static void MobKilled(int target, int conn, int PosX, int PosY);
	static BOOL KeyDrop(int target, int conn, int PosX, int PosY, STRUCT_ITEM *Key);

	static void ProcessSecTimer();
	static void ProcessMinTimer();

	static void CheckMove(int conn, int targetx, int targety);

	static void ReadCastleQuest();
	static int  ParseCastleString(int Num, char *str);
};


# -------------------- CColiseu.h --------------------

/*
*   Copyright (C) {2015}  {Victor Klafke, Charles TheHouse}
*
*   This program is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program.  If not, see [http://www.gnu.org/licenses/].
*
*   Contact at: victor.klafke@ecomp.ufsm.br
*/
#pragma once

#include <stdio.h>
#include "..\Basedef.h"


class CCOLISEU
{ 
public: 
	static void ColoProcessN(tm* timeinfo);
	static void ColoProcessM(tm* timeinfo);
	static void ColoProcessA(tm* timeinfo);
};


# -------------------- CColiseuA.cpp --------------------

#include <Windows.h>
#include <stdio.h>
#include <fcntl.h>
#include <time.h>
#include <math.h>
#include <io.h>
#include <errno.h>

#include "..\Basedef.h"
#include "..\CPSock.h"
#include "..\ItemEffect.h"
#include "Language.h"

#include "CItem.h"
#include "Server.h"
#include "GetFunc.h"
#include "SendFunc.h"
#include "ProcessClientMessage.h"
#include "ProcessDBMessage.h"
#include "CReadFiles.h"
#include "CColiseu.h"

void CCOLISEU::ColoProcessA(tm* timeinfo)
{//bySexycode
	int Rand = rand() % 100; 
#pragma region Coliseu (A)

	if (timeinfo->tm_wday != 0 && timeinfo->tm_wday != 6 && timeinfo->tm_hour == ColoHourA)
	{
		if (ColoStateA == 0 && timeinfo->tm_min == 00 && timeinfo->tm_sec >= 0)
		{
			//sprintf(temp, "Os portões do Coliseu será fechado em %d minutos.", 3);
			//SendNotice(temp);
			//Log("Coliseu[A]-log Anuncio fechamento de portao", 0, 0);
			ColoStateA = 1; 
		}

		if (ColoStateA == 1 && timeinfo->tm_min >= 3)
		{
			SetColoseumDoor(3);
			//Log("Coliseu[A]-log Fechou os portoes da frente", 0, 0);
			ColoStateA = 2;
		}

		if (ColoStateA == 2 && timeinfo->tm_min >= 4)
		{
			if (Rand >= 50)
				GenerateColoseum(COLISEU_A_INITIAL);
			if (Rand <= 49)
				GenerateColoseum(COLISEU_A_END);

			//sprintf(temp, "Os Monstros do Coliseu resurgiram.");
			//SendNotice(temp);
			//Log("Coliseu[A]-log WAVE 01 DE MOBS", 0, 0);
			ColoStateA = 3;
		}

		if (ColoStateA == 3 && timeinfo->tm_min >= 5)
		{
			SetColoseumDoor2(1);
			//SendNotice(temp);
			//Log("Coliseu[A]-log Liberou os muros de dentro", 0, 0);
			ColoStateA = 4;
		}


		if (ColoStateA == 4 && timeinfo->tm_min >= 6)
		{
			if (Rand >= 50)
				GenerateColoseum(COLISEU_A_INITIAL);
			GenerateColoseum(COLISEU_A_INITIAL);
			if (Rand <= 49)
				GenerateColoseum(COLISEU_A_END);
			GenerateColoseum(COLISEU_A_END);
			//Log("Coliseu[A]-log WAVE 02 DE MOBS", 0, 0);
			ColoStateA = 5;
		}
		if (ColoStateA == 5 && timeinfo->tm_min >= 7)
		{
			if (Rand >= 50)
				GenerateColoseum(COLISEU_A_INITIAL);
			GenerateColoseum(COLISEU_A_INITIAL);
			if (Rand <= 49)
				GenerateColoseum(COLISEU_A_END);
			GenerateColoseum(COLISEU_A_END);
			//Log("Coliseu[A]-log WAVE 03 DE MOBS", 0, 0);
			ColoStateA = 6;
		}
		if (ColoStateA == 6 && timeinfo->tm_min >= 9)
		{
			if (Rand >= 50)
				GenerateColoseum(COLISEU_A_INITIAL);
			GenerateColoseum(COLISEU_A_INITIAL);
			if (Rand <= 49)
				GenerateColoseum(COLISEU_A_END);
			GenerateColoseum(COLISEU_A_END);
			//Log("Coliseu[A]-log WAVE 04 DE MOBS", 0, 0);
			ColoStateA = 7;
		}

		if (ColoStateA == 7 && timeinfo->tm_min >= 13)
		{
			if (Rand >= 50)
				GenerateColoseum(COLISEU_A_INITIAL);
			GenerateColoseum(COLISEU_A_INITIAL);
			if (Rand <= 49)
				GenerateColoseum(COLISEU_A_END);
			GenerateColoseum(COLISEU_A_END);
			//Log("Coliseu[A]-log WAVE 05 DE MOBS", 0, 0);
			ColoStateA = 8;
		}
		if (ColoStateA == 8 && timeinfo->tm_min >= 15)
		{
			SetColoseumDoor(1);
			SetColoseumDoor2(2);
			DeleteColoseum();
			ClearArea(2604, 1708, 2648, 1744);
			//Log("Coliseu[A]-log Encerrou o Coliseu", 0, 0);
			ColoStateA = 0; 
		}
	}
#pragma endregion

}



# -------------------- CColiseuM.cpp --------------------

#include <Windows.h>
#include <stdio.h>
#include <fcntl.h>
#include <time.h>
#include <math.h>
#include <io.h>
#include <errno.h>

#include "..\Basedef.h"
#include "..\CPSock.h"
#include "..\ItemEffect.h"
#include "Language.h"

#include "CItem.h"
#include "Server.h"
#include "GetFunc.h"
#include "SendFunc.h"
#include "ProcessClientMessage.h"
#include "ProcessDBMessage.h"
#include "CReadFiles.h"
#include "CColiseu.h"

void CCOLISEU::ColoProcessM(tm* timeinfo)
{//bySexycode
	int Rand = rand() % 100;
	 
#pragma region Coliseu (M)

	if (timeinfo->tm_wday != 0 && timeinfo->tm_wday != 6 && timeinfo->tm_hour == ColoHourM)
	{
		if (ColoStateM == 0 && timeinfo->tm_min == 00 && timeinfo->tm_sec >= 0)
		{
			//sprintf(temp, "Os portões do Coliseu será fechado em %d minutos.", 3);
			//SendNotice(temp);
			//Log("Coliseu[M]-log Anuncio fechamento de portao", 0, 0);
			ColoStateM = 1; 
		}

		if (ColoStateM == 1 && timeinfo->tm_min >= 3)
		{
			SetColoseumDoor(3);
			//Log("Coliseu[M]-log Fechou os portoes da frente", 0, 0);
			ColoStateM = 2;
		}

		if (ColoStateM == 2 && timeinfo->tm_min >= 4)
		{
			if (Rand >= 50)
				GenerateColoseum(COLISEU_M_INITIAL);
			if (Rand <= 49)
				GenerateColoseum(COLISEU_M_END);

			//sprintf(temp, "Os Monstros do Coliseu resurgiram.");
			//SendNotice(temp);
			//Log("Coliseu[M]-log WAVE 01 DE MOBS", 0, 0);
			ColoStateM = 3;
		}

		if (ColoStateM == 3 && timeinfo->tm_min >= 5)
		{
			SetColoseumDoor2(1);
			//SendNotice(temp);
			//Log("Coliseu[M]-log Liberou os muros de dentro", 0, 0);
			ColoStateM = 4;
		}


		if (ColoStateM == 4 && timeinfo->tm_min >= 6)
		{
			if (Rand >= 50)
				GenerateColoseum(COLISEU_M_INITIAL);
			GenerateColoseum(COLISEU_M_INITIAL);
			if (Rand <= 49)
				GenerateColoseum(COLISEU_M_END);
			GenerateColoseum(COLISEU_M_END);
			//Log("Coliseu[M]-log WAVE 02 DE MOBS", 0, 0);
			ColoStateM = 5;
		}
		if (ColoStateM == 5 && timeinfo->tm_min >= 7)
		{
			if (Rand >= 50)
				GenerateColoseum(COLISEU_M_INITIAL);
			GenerateColoseum(COLISEU_M_INITIAL);
			if (Rand <= 49)
				GenerateColoseum(COLISEU_M_END);
			GenerateColoseum(COLISEU_M_END);
			//Log("Coliseu[M]-log WAVE 03 DE MOBS", 0, 0);
			ColoStateM = 6;
		}
		if (ColoStateM == 6 && timeinfo->tm_min >= 9)
		{
			if (Rand >= 50)
				GenerateColoseum(COLISEU_M_INITIAL);
			GenerateColoseum(COLISEU_M_INITIAL);
			if (Rand <= 49)
				GenerateColoseum(COLISEU_M_END);
			GenerateColoseum(COLISEU_M_END);
			//Log("Coliseu[M]-log WAVE 04 DE MOBS", 0, 0);
			ColoStateM = 7;
		}

		if (ColoStateM == 7 && timeinfo->tm_min >= 13)
		{
			if (Rand >= 50)
				GenerateColoseum(COLISEU_M_INITIAL);
			GenerateColoseum(COLISEU_M_INITIAL);
			if (Rand <= 49)
				GenerateColoseum(COLISEU_M_END);
			GenerateColoseum(COLISEU_M_END);
			//Log("Coliseu[M]-log WAVE 05 DE MOBS", 0, 0);
			ColoStateM = 8;
		}
		if (ColoStateM == 8 && timeinfo->tm_min >= 15)
		{
			SetColoseumDoor(1);
			SetColoseumDoor2(2);
			DeleteColoseum();
			ClearArea(2604, 1708, 2648, 1744);
			//Log("Coliseu[M]-log Encerrou o Coliseu", 0, 0);
			ColoStateM = 0; 
		}
	}
#pragma endregion
	 

}



# -------------------- CColiseuN.cpp --------------------

#include <Windows.h>
#include <stdio.h>
#include <fcntl.h>
#include <time.h>
#include <math.h>
#include <io.h>
#include <errno.h>

#include "..\Basedef.h"
#include "..\CPSock.h"
#include "..\ItemEffect.h"
#include "Language.h"

#include "CItem.h"
#include "Server.h"
#include "GetFunc.h"
#include "SendFunc.h"
#include "ProcessClientMessage.h"
#include "ProcessDBMessage.h"
#include "CReadFiles.h"
#include "CColiseu.h"

void CCOLISEU::ColoProcessN(tm* timeinfo)
{//bySexycode
	int Rand = rand() % 100;

#pragma region Coliseu (N)

	if (timeinfo->tm_wday != 0 && timeinfo->tm_wday != 6 && timeinfo->tm_hour == ColoHourN)
	{
		if (ColoStateN == 0 && timeinfo->tm_min == 00 && timeinfo->tm_sec >= 0)
		{
			SendNotice(strFmt("Os portões do Coliseu será fechado em %d minutos.", 3));
			//Log("Coliseu[N]-log Anuncio fechamento de portao", 0, 0);
			ColoStateN = 1; 
		}

		if (ColoStateN == 1 && timeinfo->tm_min >= 3)
		{
			SetColoseumDoor(3);
			//Log("Coliseu[N]-log Fechou os portoes da frente", 0, 0);
			ColoStateN = 2;
		}

		if (ColoStateN == 2 && timeinfo->tm_min >= 4)
		{
			if (Rand >= 50)
				GenerateColoseum(COLISEU_N_INITIAL);
			if (Rand <= 49)
				GenerateColoseum(COLISEU_N_END);

			SendNotice("Os Monstros do Coliseu resurgiram.");
			//Log("Coliseu[N]-log WAVE 01 DE MOBS", 0, 0);
			ColoStateN = 3;
		}

		if (ColoStateN == 3 && timeinfo->tm_min >= 5)
		{
			SetColoseumDoor2(1);
			//SendNotice(temp);
			//Log("Coliseu[N]-log Liberou os muros de dentro", 0, 0);
			ColoStateN = 4;
		}


		if (ColoStateN == 4 && timeinfo->tm_min >= 6)
		{
			if (Rand >= 50)
				GenerateColoseum(COLISEU_N_INITIAL);
			GenerateColoseum(COLISEU_N_INITIAL);
			if (Rand <= 49)
				GenerateColoseum(COLISEU_N_END);
			GenerateColoseum(COLISEU_N_END);
			//Log("Coliseu[N]-log WAVE 02 DE MOBS", 0, 0);
			ColoStateN = 5;
		}
		if (ColoStateN == 5 && timeinfo->tm_min >= 7)
		{
			if (Rand >= 50)
				GenerateColoseum(COLISEU_N_INITIAL);
			GenerateColoseum(COLISEU_N_INITIAL);
			if (Rand <= 49)
				GenerateColoseum(COLISEU_N_END);
			GenerateColoseum(COLISEU_N_END);
			//Log("Coliseu[N]-log WAVE 03 DE MOBS", 0, 0);
			ColoStateN = 6;
		}
		if (ColoStateN == 6 && timeinfo->tm_min >= 9)
		{
			if (Rand >= 50)
				GenerateColoseum(COLISEU_N_INITIAL);
			GenerateColoseum(COLISEU_N_INITIAL);
			if (Rand <= 49)
				GenerateColoseum(COLISEU_N_END);
			GenerateColoseum(COLISEU_N_END);
			//Log("Coliseu[N]-log WAVE 04 DE MOBS", 0, 0);
			ColoStateN = 7;
		}

		if (ColoStateN == 7 && timeinfo->tm_min >= 13)
		{
			if (Rand >= 50)
				GenerateColoseum(COLISEU_N_INITIAL);
			GenerateColoseum(COLISEU_N_INITIAL);
			if (Rand <= 49)
				GenerateColoseum(COLISEU_N_END);
			GenerateColoseum(COLISEU_N_END);
			//Log("Coliseu[N]-log WAVE 05 DE MOBS", 0, 0);
			ColoStateN = 8;
		} 
		if (ColoStateN == 8 && timeinfo->tm_min >= 15)
		{
			SetColoseumDoor(1);
			SetColoseumDoor2(2);
			DeleteColoseum(); 
			ClearArea(2604, 1708, 2648, 1744);
			//Log("Coliseu[N]-log Encerrou o Coliseu", 0, 0);
			ColoStateN = 0; 
		}
	}
#pragma endregion 
}

 

# -------------------- CCubo.cpp --------------------

/*
*   Copyright (C) {2015}  {Victor Klafke, Charles TheHouse}
*
*   This program is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program.  If not, see [http://www.gnu.org/licenses/].
*
*   Contact at: victor.klafke@ecomp.ufsm.br
*/
#include <Windows.h>
#include <stdio.h>
#include <fcntl.h>
#include <time.h>
#include <math.h>
#include <io.h>
#include <errno.h>

#include "..\Basedef.h"
#include "..\CPSock.h"
#include "..\ItemEffect.h"
#include "Language.h"

#include "CItem.h"
#include "Server.h"
#include "GetFunc.h"
#include "SendFunc.h"
#include "ProcessClientMessage.h"
#include "ProcessDBMessage.h"
#include "CReadFiles.h"

#include "CCubo.h"

STRUCT_CUBOFILE CuboN;
STRUCT_CUBOFILE CuboM;
STRUCT_CUBOFILE CuboA;

const char* const CCubo::CUBO_QUEST_PATH = "../../Common/Settings/Cubo.txt";
const char* const CCubo::CUBON_QUEST_PATH = "../../Common/Settings/CuboCoordN.txt";
const char* const CCubo::CUBOM_QUEST_PATH = "../../Common/Settings/CuboCoordM.txt";
const char* const CCubo::CUBOA_QUEST_PATH = "../../Common/Settings/CuboCoordA.txt";

void CCubo::Initialize()
{
	memset(&CuboN, 0, sizeof(STRUCT_CUBOFILE));
	memset(&CuboM, 0, sizeof(STRUCT_CUBOFILE));
	memset(&CuboA, 0, sizeof(STRUCT_CUBOFILE));

	LoadCubo();
	LoadCuboCoordN();
	LoadCuboCoordM();
	LoadCuboCoordA();

	CuboN.Room = 0;
	CuboN.pRoom = 0;
	CuboM.Room = 0;
	CuboM.pRoom = 0;
	CuboA.Room = 0;
	CuboA.pRoom = 0;

	for (int room = 0; room < 25; room++)
	{
		CuboN.Mobs[room] = CUBO_N_INITIAL + room;
		CuboN.Status[room] = FALSE;
	}

	GenerateMob(CUBO_N_INITIAL, 0, 0);
}

void CCubo::MobKilled(int target, int conn, int PosX, int PosY)
{
	int GenerateIndex = pMob[target].GenerateIndex;

	if (GenerateIndex == CuboN.Mobs[CuboN.Room])
	{
		int CurrentNumMob = mNPCGen.pList[CuboN.Mobs[CuboN.Room]].CurrentNumMob;

		if (CurrentNumMob == 1)
		{
			CuboN.Status[CuboN.Room] = TRUE;

			struct tm when;
			time_t now;
			time(&now);
			when = *localtime(&now);

			int TimeNow = when.tm_sec, TimeBack = when.tm_sec;
			TimeNow += 14;

			if (TimeNow > 59)
			{
				int Sec = TimeNow - 59;
				TimeNow = Sec;
			}

			CuboN.Time[CuboN.Room] = TimeNow;

			printf("Tempo Atual: %d e Tempo do Teleporte: %d\n", TimeBack, CuboN.Time[CuboN.Room]);

			if (pUser[conn].Mode == USER_PLAY && (pMob[conn].TargetX / 128) == 13 && (pMob[conn].TargetY / 128) == 31)
			{
				char Title[96];
				sprintf_s(Title, "<<_No._%d_>>", CuboN.CurrentQuestion[CuboN.Room] + 1);
				SendBigMessage(conn, Title, CuboN.Question[CuboN.Room]);
			}

			MSG_STANDARDPARM sm;
			memset(&sm, 0, sizeof(MSG_STANDARDPARM));

			sm.Type = _MSG_StartTime;
			sm.ID = ESCENE_FIELD;
			sm.Size = sizeof(MSG_STANDARDPARM);
			sm.Parm = 14;

			MapaMulticast(13, 31, (MSG_STANDARD*)&sm, 0);
		}
	}
}

void CCubo::ProcessSecTimer()
{
	if (SecCounter % 2 == 0)
	{
		struct tm when;
		time_t now;
		time(&now);
		when = *localtime(&now);

		char UserName[NAME_LENGTH];

#pragma region Cubo N
		int Users_CuboN = GetUserInArea(1664, 3968, 1792, 4096, UserName);

		if (Users_CuboN > 0 && CuboN.pRoom > Users_CuboN)
			CuboN.pRoom = Users_CuboN;

		if (CuboN.Status[CuboN.Room] == TRUE)
		{
			if (when.tm_sec == CuboN.Time[CuboN.Room])
			{
				for (int i = 1; i < MAX_USER; i++)
				{
					if (pUser[i].Mode == USER_PLAY && (pMob[i].TargetX / 128) == 13 && (pMob[i].TargetY / 128) == 31)
					{
						int ReqTeleport = GetCuboTeleportPositionN(i, CuboN.Room);

						if (ReqTeleport)
						{
							if (CuboN.Room >= 24)
							{
								DoRecall(i);
								 
								SendMsgExp(i, "Você concluiu a Quest!", TNColor::Default, false);
								CuboN.Room = 0;
								CuboN.pRoom = 0;

								printf("Finalizou - Sala: %d / Players: %d\n", CuboN.Room, CuboN.pRoom);
							}
							else
							{
								int Bonus = 8000 + (CuboN.Room * 1000);

								DoTeleport(i, *mNPCGen.pList[CuboN.Mobs[CuboN.Room + 1]].SegmentListX, *mNPCGen.pList[CuboN.Mobs[CuboN.Room + 1]].SegmentListY);							 
								SendMsgExp(i, strFmt("Correto! Andar %d. (Bônus %d EXP)", CuboN.Room + 2, Bonus), TNColor::Default, false);
								pMob[i].MOB.Exp += Bonus;

								GenerateMob(CuboN.Mobs[CuboN.Room + 1], 0, 0);

								printf("Correto - Sala: %d / Players: %d\n", CuboN.Room, CuboN.pRoom);
							}
						}
						else
						{
							DoRecall(i);
							 
							SendMsgExp(i, "Errou!", TNColor::Default, false);
							CuboN.pRoom--;

							if (CuboN.pRoom < 0)
								CuboN.pRoom = 0;

							//int User = GetUserInArea(1664, 3968, 1792, 4096, UserName);

							if (CuboN.pRoom == 0)
							{
								CuboN.Room = 0;
								CuboN.pRoom = 0;
								ClearArea(1664, 3968, 1792, 4096);//Cubo N

								GenerateMob(CUBO_N_INITIAL, 0, 0);

								printf("Foi tudo zerado!");
							}

							printf("Errou - Sala: %d / Players: %d\n", CuboN.Room, CuboN.pRoom);
						}
					}
				}

				CuboN.Status[CuboN.Room] = FALSE;

				if (CuboN.pRoom > 0)
					CuboN.Room++;
			}
		}
	}
#pragma endregion
}

bool CCubo::LoadCubo()
{
	FILE *fp = fopen(CUBO_QUEST_PATH, "r+");

	if (fp == NULL)
		return FALSE;

	char line[1024];

	for (int x = 0; x < 25; x++)
	{
		int index = 0, num = 0;

		fgets(line, sizeof(line), fp);

		sscanf(line, "%d %d %100[^=]", &num, &index, CuboN.Question[x]);
		sscanf(line, "%d %d %100[^=]", &num, &index, CuboM.Question[x]);
		sscanf(line, "%d %d %100[^=]", &num, &index, CuboA.Question[x]);

		CuboN.CurrentQuestion[x] = num;
		CuboN.Question[x][strlen(CuboN.Question[x]) - 1] = '\0';

		CuboM.CurrentQuestion[x] = num;
		CuboM.Question[x][strlen(CuboM.Question[x]) - 1] = '\0';

		CuboA.CurrentQuestion[x] = num;
		CuboA.Question[x][strlen(CuboA.Question[x]) - 1] = '\0';

		if (index == 0)
		{
			CuboN.Answer[x] = FALSE;
			CuboM.Answer[x] = FALSE;
			CuboA.Answer[x] = FALSE;
		}
		else if (index == 1)
		{
			CuboN.Answer[x] = TRUE;
			CuboM.Answer[x] = TRUE;
			CuboA.Answer[x] = TRUE;
		}
		else
			return FALSE;
	}

	fclose(fp);
	return TRUE;
}

bool CCubo::LoadCuboCoordN()
{
	FILE *fp = fopen(CUBON_QUEST_PATH, "r+");

	if (fp == NULL)
		return FALSE;

	char line[1024];
	int Xr = 0;
	int Or = 0;

	while (fgets(line, sizeof(line), fp))
	{
		if (*line == '\n' || *line == '#')
			continue;

		char *p = line;

		while (*p != '\0')
		{
			if (*p == ',')
				*p = ' ';
			else if (*p == '[')
				*p = ' ';
			else if (*p == ']')
				*p = ' ';

			p++;
		}

		char VF;
		int indessx;

		sPoint Cord;
		memset(&Cord, 0, sizeof(sPoint));
		sscanf(line, "%c %d %4d %4d", &VF, &indessx, &Cord.PosX, &Cord.PosY);

		if (VF == 'O')
		{
			CuboN.O[Or].PosX = Cord.PosX;
			CuboN.O[Or].PosY = Cord.PosY;
			Or++;
		}
		else if (VF == 'X')
		{
			CuboN.X[Xr].PosX = Cord.PosX;
			CuboN.X[Xr].PosY = Cord.PosY;
			Xr++;
		}
	}

	fclose(fp);
	return TRUE;
}

bool CCubo::LoadCuboCoordM()
{
	FILE *fp = fopen(CUBOM_QUEST_PATH, "r+");

	if (fp == NULL)
		return FALSE;

	char line[1024];
	int Xr = 0;
	int Or = 0;

	while (fgets(line, sizeof(line), fp))
	{
		if (*line == '\n' || *line == '#')
			continue;

		char *p = line;

		while (*p != '\0')
		{
			if (*p == ',')
				*p = ' ';
			else if (*p == '[')
				*p = ' ';
			else if (*p == ']')
				*p = ' ';

			p++;
		}

		char VF;
		int indessx;

		sPoint Cord;
		memset(&Cord, 0, sizeof(sPoint));
		sscanf(line, "%c %d %4d %4d", &VF, &indessx, &Cord.PosX, &Cord.PosY);

		if (VF == 'O')
		{
			CuboM.O[Or].PosX = Cord.PosX;
			CuboM.O[Or].PosY = Cord.PosY;
			Or++;
		}
		else if (VF == 'X')
		{
			CuboM.X[Xr].PosX = Cord.PosX;
			CuboM.X[Xr].PosY = Cord.PosY;
			Xr++;
		}
	}

	fclose(fp);
	return TRUE;
}

bool CCubo::LoadCuboCoordA()
{
	FILE *fp = fopen(CUBOA_QUEST_PATH, "r+");

	if (fp == NULL)
		return FALSE;

	char line[1024];
	int Xr = 0;
	int Or = 0;

	while (fgets(line, sizeof(line), fp))
	{
		if (*line == '\n' || *line == '#')
			continue;

		char *p = line;

		while (*p != '\0')
		{
			if (*p == ',')
				*p = ' ';
			else if (*p == '[')
				*p = ' ';
			else if (*p == ']')
				*p = ' ';

			p++;
		}

		char VF;
		int indessx;

		sPoint Cord;
		memset(&Cord, 0, sizeof(sPoint));
		sscanf(line, "%c %d %4d %4d", &VF, &indessx, &Cord.PosX, &Cord.PosY);

		if (VF == 'O')
		{
			CuboA.O[Or].PosX = Cord.PosX;
			CuboA.O[Or].PosY = Cord.PosY;
			Or++;
		}
		else if (VF == 'X')
		{
			CuboA.X[Xr].PosX = Cord.PosX;
			CuboA.X[Xr].PosY = Cord.PosY;
			Xr++;
		}
	}

	fclose(fp);
	return TRUE;
}

# -------------------- CCubo.h --------------------

/*
*   Copyright (C) {2015}  {Victor Klafke, Charles TheHouse}
*
*   This program is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program.  If not, see [http://www.gnu.org/licenses/].
*
*   Contact at: victor.klafke@ecomp.ufsm.br
*/
#pragma once

#include <stdio.h>
#include "..\Basedef.h"

extern STRUCT_CUBOFILE CuboN;
extern STRUCT_CUBOFILE CuboM;
extern STRUCT_CUBOFILE CuboA;

class CCubo
{
private:
	static const char* const CUBO_QUEST_PATH;
	static const char* const CUBON_QUEST_PATH;
	static const char* const CUBOM_QUEST_PATH;
	static const char* const CUBOA_QUEST_PATH;
public:
	static void Initialize();

	static void MobKilled(int target, int conn, int PosX, int PosY);
	static void ProcessSecTimer();

	static bool LoadCubo();
	static bool LoadCuboCoordN();
	static bool LoadCuboCoordM();
	static bool LoadCuboCoordA();
};

# -------------------- Chests.h --------------------

#pragma once

#include <stdio.h>
#include "..\Basedef.h"

STRUCT_ITEM Evento[5][5];
int rate[5][5];
int BausIndex[5];

# -------------------- CItem.cpp --------------------

/*
*   Copyright (C) {2015}  {Victor Klafke, Charles TheHouse}
*
*   This program is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program.  If not, see [http://www.gnu.org/licenses/].
*
*   Contact at: victor.klafke@ecomp.ufsm.br
*/
#include "CItem.h"


CItem::CItem()
{
	Mode       = 0;
    GridCharge = 0;
    State      = 0;
    Rotate     = 0;
	Delay      = 0;
	ItemQuest  = 0;
}

CItem::~CItem()
{

}

# -------------------- CItem.h --------------------

/*
*   Copyright (C) {2015}  {Victor Klafke, Charles TheHouse}
*
*   This program is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program.  If not, see [http://www.gnu.org/licenses/].
*
*   Contact at: victor.klafke@ecomp.ufsm.br
*/
#ifndef __CITEM__
#define __CITEM__

#include "../Basedef.h"

class CItem
{  
public:
	STRUCT_ITEM ITEM;
	int  Mode;       
	int  PosX, PosY;
	int  GridCharge;
	int  State;
	int  Rotate;
	int  Delay;
	int  Decay;
	int  Height;
	int  Money;
	int  Open;
	int  ItemQuest;
	char Unk[20];

public:
	CItem();
	~CItem();
};
extern CItem pItem[MAX_ITEM];

#endif

# -------------------- CMob.cpp --------------------

/*
*   Copyright (C) {2015}  {Victor Klafke, Charles TheHouse}
*
*   This program is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program.  If not, see [http://www.gnu.org/licenses/].
*
*   Contact at: victor.klafke@ecomp.ufsm.br
*/
#include <Windows.h>

#include "../ItemEffect.h"

#include "CMob.h"
#include "Server.h"
#include "GetFunc.h"
#include "SendFunc.h"


CMob::CMob()
{
	Mode = MOB_EMPTY;
	LastX = 0xFFFFFFFF;
	LastY = 0xFFFFFFFF;
	Leader = 0;
	WaitSec = 0;
	PotionCount = 0;
	Summoner = 0;
	Evocation = 0;
	GuildDisable = 0;
	LastReqParty = 0;
	ProcessorCounter = 0;

	memset(&Tab, 0, sizeof(Tab));
	memset(&Snd, 0, sizeof(Snd));
	memset(&extra, 0, sizeof(STRUCT_MOBEXTRA));
	memset(&Rebuy, 0, sizeof(STRUCT_REBUY));
}

CMob::~CMob()
{

}

void CMob::ProcessorSecTimer()
{
	//ProcessorCounter++;
}
/*int	CMob::StandingByProcessor7556(void)
{
	int rt = 0;

	/*if (MOB.BaseScore.MaxHp)
	{
	if (MOB.BaseScore.Hp <= 0 && Mode != MOB_COMBAT)
	{

	}
	MOB.BaseScore.Hp--;
	}

	int Face = MOB.Equip[0].sIndex;

	if (Affect[0].Type != 24 && Face == 358)
	{
		rt |= 1;
		return rt;
	}

	if (RouteType == 5)
	{
		if (Leader > 0 && Leader <= MAX_USER)
		{
			if (Affect[0].Type == 24 || Face >= 315 && Face <= 346)
			{
				int _summoner = Summoner;

				if (_summoner > 0 && _summoner < MAX_USER)
				{
					int _leader = 0;

					if (Leader == _summoner)
						_leader = 1;

					for (int i = 0; i < MAX_PARTY; i++)
					{
						if (pMob[Leader].PartyList[i] == _summoner)
							_leader = 1;
					}

					if (_leader)
					{
						if (Affect[0].Type != 24 || Affect[0].Value)
						{
							if (pUser[_summoner].Mode == USER_PLAY)
							{
								int Distance = BASE_GetDistance(TargetX, TargetY, pMob[_summoner].TargetX, pMob[_summoner].TargetY);

								if (Distance < 20)
								{
									if (Distance <= 2 || Distance >= 20)
									{
										return rt;
									}
									else
									{
										SegmentX = pMob[_summoner].TargetX;
										SegmentY = pMob[_summoner].TargetY;
										GetTargetPos(_summoner);
										rt = rt | 0x01;
										return rt;
									}
								}
								else
								{
									NextX = pMob[_summoner].TargetX;
									NextY = pMob[_summoner].TargetY;
									rt = rt | 0x02;
									return rt;
								}
							}
							else
							{
								rt |= 1;
								return rt;
							}
						}
						else
						{
							rt |= 1;
							return rt;
						}
					}
					else
					{
						rt |= 1;
						return rt;
					}
				}
				else
				{
					rt |= 1;
					return rt;
				}
			}
			else
			{
				rt |= 1;
				return rt;
			}
		}
		else
		{
			rt |= 1;
			return rt;
		}
	}
	else
	{
		if (!Leader)
		{
			int enemy = GetEnemyFromView();

			if (enemy)
			{
				if (TargetX < SegmentX + 12 && TargetX > SegmentX - 12 && TargetY < SegmentY + 12 && TargetY > SegmentY - 12)
				{
					return enemy | 0x10000000;
				}
			}
		}
		if (RouteType == 6 && TargetX == SegmentX && TargetY == SegmentY)
		{
			return 0;
		}
		if (SegmentX == TargetX && SegmentY == TargetY)
		{
			if (WaitSec <= 0 || RouteType == 6)
			{
				int Seg = SegmentWait[SegmentProgress];

				if (Seg > 0)
				{
					WaitSec = Seg;
					return rt;
				}
			}
			else
			{
				WaitSec -= 6;

				if (WaitSec > 0)
				{
					if (RouteType && TargetX != SegmentListX[0] || TargetY != SegmentListY[0])
					{
						if (MOB.BaseScore.AttackRun & 0xF)
						{
							rt |= 0x10;
							return rt;
						}
						else
						{
							return 0;
						}
					}
					else
					{
						return 0;
					}

				}
				WaitSec = 0;
			}

			int SetSeg = SetSegment();

			if (SetSeg == 1)
			{
				return rt;
			}

			if (SetSeg == 2)
			{
				return rt | 1;
			}
		}

		GetNextPos(0);

		if (NextX != TargetX || NextY != TargetY)
		{
			return rt | 1;
		}
		else
		{
			SetSegment();
			return rt | 1;
		}
	}
	return rt;
}*/
int  CMob::StandingByProcessor(void)
{
	int rt = FALSE, Face = MOB.Equip[0].sIndex;

	/*if (Affect[0].Type != 24 && Face == 358)
	{
		rt |= 1;
		return rt;
	}*/

	if (RouteType == 5)
	{
		if (Leader <= 0 || Leader >= MAX_USER)
		{
			rt |= 0x100;
			return rt;
		}

		// Condor, Dragao Negro, Gorila, VeridFinal, Urso, Tigre, Succubus, Javali e Lobo
		if (Affect[0].Type != 24 && (Face < 315 || Face > 345))
		{
			rt |= 0x100;
			return rt;
		}

		int summoner = Summoner;

		if (summoner <= 0 || summoner >= MAX_USER)
		{
			rt |= 1;
			return rt;
		}

		int _leader = 0;
		if (Leader == summoner)
			_leader = 1;

		for (int i = 0; i < MAX_PARTY; ++i)
		{
			if (pMob[Leader].PartyList[i] == summoner)
				_leader = 1;
		}

		if (_leader == 0)
		{
			rt |= 1;
			return rt;
		}

		if (pUser[summoner].Mode != USER_PLAY)
		{
			rt |= 1;
			return rt;
		}

		int Distance = BASE_GetDistance(TargetX, TargetY, pMob[summoner].TargetX, pMob[summoner].TargetY);
		if (Distance >= 13)
		{
			NextX = pMob[summoner].TargetX;
			NextY = pMob[summoner].TargetY;
			rt = rt | 0x02;
			return rt;
		}

		if (Distance <= 4 || Distance >= 13)
			return rt;

		SegmentX = pMob[summoner].TargetX;
		SegmentY = pMob[summoner].TargetY;

		GetTargetPos(summoner);
		rt = rt | 0x01;
		return rt;
	}
	else
	{
		if (Leader == 0)
		{
			int enemy = GetEnemyFromView();

			if (enemy && TargetX <= SegmentX + HALFGRIDX && TargetX >= SegmentX - HALFGRIDX && TargetY >= SegmentY - HALFGRIDY && TargetY <= SegmentY + HALFGRIDY)
				return enemy | 0x10000000;

		}

		if (RouteType == 6 && TargetX == SegmentX && TargetY == SegmentY)
			return 0;

		if (SegmentX == TargetX && SegmentY == TargetY)
		{
			if (SegmentProgress == 4 && RouteType == 3)
			{
				if (WaitSec <= 0)
					return 0x10000;
				else
					WaitSec -= 6;

				return 0;
			}
			if (WaitSec <= 0 || RouteType == 6)
			{
				int Seg = SegmentWait[SegmentProgress];
				if (Seg > 0)
				{
					WaitSec = Seg;
					return 0;
				}
			}
			else
			{
				WaitSec -= 6;
				if (WaitSec > 0)
				{
					if (RouteType && TargetX != SegmentListX[0] || TargetY != SegmentListY[0])
					{
						if (MOB.BaseScore.AttackRun & 0xF)
							return rt | 0x10;

						return 0;
					}
					else
						return 0;
				}
				WaitSec = 0;
			}
			int SetSeg = SetSegment();

			if (SetSeg == 1)
				return 0;

			if (SetSeg == 2)
				return rt | 1;

			if (SetSeg == 0x10)
				return rt | 1;
		}

		if (MOB.Clan == 3)
			CGetNextRandomPos();
		else
			GetNextPos(0);

		if (NextX != TargetX || NextY != TargetY)
			return rt | 1;
		else
		{
			SetSegment();
			return rt;
		}
	}

	return rt;
}
/*original w2pp*/
//int  CMob::BattleProcessor()
//{
//	SelectTargetFromEnemyList();
//
//	if (CurrentTarget == 0)
//	{
//		Mode = MOB_PEACE;
//
//		return 0;
//	}
//
//	if (RouteType == 5)
//	{
//		if (Leader <= 0 || Leader >= MAX_USER)
//			return 32;
//
//		int SummonerId = Summoner;
//
//		if (SummonerId <= 0 || SummonerId >= MAX_USER)
//			return 256;
//
//		int IsSummon = 0;
//
//		if (Leader == SummonerId)
//			IsSummon = 1;
//
//		for (int i = 0; i < MAX_PARTY; i++)
//		{
//			if (pMob[Leader].PartyList[i] == SummonerId)
//				IsSummon = 1;
//		}
//		for (int i = 0; i < MAX_PARTY; i++)
//		{
//			if (pMob[Leader].Evocations[i] == SummonerId)
//				IsSummon = 1;
//		}
//
//		if (IsSummon == 0)
//			return 256;
//
//		int dis = BASE_GetDistance(TargetX, TargetY, pMob[SummonerId].TargetX, pMob[SummonerId].TargetY);
//
//		if (dis >= 20)
//		{
//			NextX = pMob[SummonerId].TargetX;
//			NextY = pMob[SummonerId].TargetY;
//			return 2;
//		}
//
//	}
//
//	int BaseInt = MOB.BaseScore.Int;
//
//	if (BaseInt < rand() % 100)
//	{
//		return 0x010000;
//	}
//
//	int BaseDex = MOB.BaseScore.Dex;
//	int tx = pMob[CurrentTarget].TargetX;
//	int ty = pMob[CurrentTarget].TargetY;
//	int Range = GenerateIndex == KEFRA_BOSS ? 25 : BASE_GetMobAbility(&MOB, EF_RANGE);
//	int dis = BASE_GetDistance(TargetX, TargetY, tx, ty);
//
//	if (RouteType != 5 && (TargetX > SegmentX + HALFGRIDX || TargetX < SegmentX - HALFGRIDX || TargetY > SegmentY + HALFGRIDY || TargetY < SegmentY - HALFGRIDY))
//	{
//		CurrentTarget = 0;
//
//		for (int i = 0; i < MAX_ENEMY; i++)
//			EnemyList[i] = 0;
//
//		Mode = MOB_PEACE;
//
//		GetNextPos(1);
//
//		if (NextX == TargetX && NextY == TargetY)
//			return 0;
//		else
//			return 16;
//	}
//	if (dis <= Range)
//	{
//		int Rand = rand() % 100;
//
//		if (Range >= 4 && dis <= 4 && Rand > BaseDex)
//			return 256;
//
//		int bx = tx;
//		int by = ty;
//
//		//BASE_GetHitPosition(TargetX, TargetY, &tx, &ty, pHeightGrid);
//
//		if (tx == bx && ty == by)
//			return 4096;
//		else
//			return 256;
//
//	}
//
//	return 1;
//}
//int CMob::BattleProcessor()
//{
//	int Face = MOB.Equip[0].sIndex;
//
//	if (Affect[0].Type == 24 || Face != 358)
//	{
//		SelectTargetFromEnemyList();
//
//		if (CurrentTarget)
//		{
//			if (RouteType == 5)
//			{
//				if (Leader <= 0 || Leader >= 1000)
//					return 32;
//
//				int _summoner = Summoner;
//
//				if (_summoner <= 0 || _summoner >= 1000)
//					return 32;
//
//				int hp = MOB.CurrentScore.Hp;
//
//				if (hp <= 0)
//					return 32;
//
//				if (Affect[0].Type != 24 && (Face < 315 || Face > 346))
//					return 32;
//
//				int isSummon = 0;
//
//				if (Leader == _summoner)
//					isSummon = 1;
//
//				for (int i = 0; i < MAX_PARTY; i++)
//				{
//					if (pMob[Leader].PartyList[i] == _summoner)
//						isSummon = 1;
//				}
//
//				for (int i = 0; i < MAX_PARTY; i++)
//				{
//					if (pMob[Leader].Evocations[i] == _summoner)
//						isSummon = 1;
//				}
//				if (!isSummon)
//					return 32;
//
//				int distance = BASE_GetDistance(TargetX, TargetY, pMob[_summoner].TargetX, pMob[_summoner].TargetY);
//
//				if (distance >= 20)
//				{
//					NextX = pMob[_summoner].TargetX;
//					NextY = pMob[_summoner].TargetY;
//					return 2;
//				}
//			}
//
//			int BaseInt = MOB.BaseScore.Int;
//
//			if (BaseInt < rand() % 100)
//				return 65536;
//
//			int BaseDex = MOB.BaseScore.Dex;
//			int tx = pMob[CurrentTarget].TargetX;
//			int ty = pMob[CurrentTarget].TargetY;
//			int Range = GenerateIndex == KEFRA_BOSS ? 25 : BASE_GetMobAbility(&MOB, EF_RANGE);
//			int dis = BASE_GetDistance(TargetX, TargetY, tx, ty);
//
//			//if (sub_401BE5(&MOB))
//			//if (GetTargetPos7556(0))
//			//	Range = 26;
//			//if (sub_401BE5(&pMob[1724 * *(WORD *)(&MOB + 1504)]) && (Face == 307 || Face == 245))
//			//if (GetTargetPos7556(CurrentTarget) && (Face == 307 || Face == 245))
//				//Range = 26;
//
//			if (RouteType != 5 && (TargetX > SegmentX + HALFGRIDX || TargetX < SegmentX - HALFGRIDX || TargetY > SegmentY + HALFGRIDY || TargetY < SegmentY - HALFGRIDY))
//			{
//				CurrentTarget = 0;
//
//				for (int i = 0; i < MAX_ENEMY; i++)
//					EnemyList[i] = 0;
//
//				Mode = 4;
//
//				GetNextPos(1);
//
//				if (NextX != TargetX || NextY != TargetY)
//					return 16;
//				else
//					return 0;
//			}
//
//			if (dis <= Range)
//			{
//				int _rand = rand() % 100;
//
//				if (Range >= 4 && dis <= 4 && _rand > BaseDex)// && MOB.BaseScore.AttackRun & 0xF)
//					return 256;
//
//				int btx = tx;
//				int	bty = ty;
//
//						//if (!GetTargetPos7556(0))
//						//{
//						//	int UNK_1 = 0;
//
//						//	if (TargetX >= 2341 && TargetX <= 2393 && TargetY >= 3907 && TargetY <= 3954) //&& *(DWORD*)(&MOB + 1632))
//						//		UNK_1 = 1;
//
//						//	if (!UNK_1)
//						//		BASE_GetHitPosition(TargetX, TargetY, &tx, &ty, *pHeightGrid);
//						//}
//
//				if (TargetX == btx && TargetY == bty)
//					return 4096;
//				else
//					return 256;
//			}
//			else
//				return 1;
//		}
//		else
//		{
//			Mode = 4;
//			return 0;
//		}
//	}
//	else
//		return 32;
//}

int CMob::BattleProcessor()
{
	SelectTargetFromEnemyList();

	if (CurrentTarget == 0)
	{
		Mode = MOB_PEACE;

		return 0;
	}

	int Face = MOB.Equip[0].sIndex;

	if (RouteType == 5)
	{
		if (Leader <= 0 || Leader >= MAX_USER)
			return 32;

		int SummonerId = Summoner;

		if (SummonerId <= 0 || SummonerId >= MAX_USER)
			return 256;

		if (Affect[0].Type != 24 && (MOB.Equip[0].sIndex < 315 || MOB.Equip[0].sIndex > 345))
			return 32;

		int IsSummon = 0;

		if (Leader == SummonerId)
			IsSummon = 1;

		for (int i = 0; i < MAX_PARTY; i++)
		{
			if (pMob[Leader].PartyList[i] == SummonerId)
				IsSummon = 1;
		}

		if (IsSummon == 0)
			return 256;

		int dis = BASE_GetDistance(TargetX, TargetY, pMob[SummonerId].TargetX, pMob[SummonerId].TargetY);

		if (dis >= 20)
		{
			NextX = pMob[SummonerId].TargetX;
			NextY = pMob[SummonerId].TargetY;
			return 2;
		}
	}

	int BaseInt = MOB.BaseScore.Int;

	if (BaseInt < rand() % 100)
		return 0x010000;

	int BaseDex = MOB.BaseScore.Dex;
	int tx = pMob[CurrentTarget].TargetX;
	int ty = pMob[CurrentTarget].TargetY;
	int Range = GenerateIndex == KEFRA_BOSS ? 25 : BASE_GetMobAbility(&MOB, EF_RANGE);
	int dis = BASE_GetDistance(TargetX, TargetY, tx, ty);

	//if (RouteType != 5 && (TargetX > SegmentX + 30 || TargetX < SegmentX - 30 || TargetY > SegmentY + 30 || TargetY < SegmentY - 30))
	if (RouteType != 5 && (TargetX > SegmentX + HALFGRIDX || TargetX < SegmentX - HALFGRIDX || TargetY > SegmentY + HALFGRIDY || TargetY < SegmentY - HALFGRIDY))
	{
		CurrentTarget = 0;

		for (int i = 0; i < MAX_ENEMY; i++)
			EnemyList[i] = 0;

		Mode = MOB_PEACE;

		GetNextPos(1);

		if (NextX == TargetX && NextY == TargetY)
			return 0;
		else
			return 16;
	}
	if (dis <= Range)
	{
		//if (GetEmptyMobGrid(0, &NextX, &NextY) == TRUE)
		//	BASE_GetHitPosition(TargetX, TargetY, &tx, &ty, (char*)pHeightGrid);

		int Rand = rand() % 100;

		if (Range >= 4 && dis <= 4 && Rand > BaseDex)
			return 256;

		int bx = tx;
		int by = ty;

		if (tx == bx && ty == by)
			return 4096;
		else
			return 256;
	}

	if (Face == 358)
		return 0;

	return 1;
}

void CMob::AddEnemyList(short TargetId)
{
	if (TargetId <= 0)
		return;

	if (TargetId <= MAX_USER)
		if (pMob[TargetId].MOB.Rsv & RSV_HIDE)
			return;

	if (TargetId <= MAX_USER)
		if (pMob[TargetId].MOB.Merchant & 1)
			return;

	int i = 0;

	for (i = 0; i < MAX_ENEMY; i++)
		if (EnemyList[i] == TargetId)
			return;

	for (i = 0; i < MAX_ENEMY; i++)
		if (EnemyList[i] == 0)
			break;

	if (i == MAX_ENEMY)
		return;

	EnemyList[i] = TargetId;

	if (GenerateIndex == KEFRA_BOSS)
	{
		for (i = 0; i < MAX_USER; i++)
		{
			if (pUser[i].Mode != USER_PLAY)
				continue;

			if (pMob[i].Mode == USER_EMPTY)
				continue;

			if (pMob[i].TargetX < (TargetX - 30) || pMob[i].TargetX >(TargetX + 30) || pMob[i].TargetY < (TargetY - 30) || pMob[i].TargetY >(TargetY + 30))
				continue;

			int c = 0;

			for (c = 0; c < MAX_ENEMY; c++)
				if (EnemyList[c] == TargetId)
					return;

			for (c = 0; c < MAX_ENEMY; c++)
				if (EnemyList[c] == 0)
					break;

			if (c == MAX_ENEMY)
				continue;

			EnemyList[c] = TargetId;
		}
	}
}

void CMob::RemoveEnemyList(short TargetId)
{
	if (TargetId <= 0)
		return;

	for (int i = 0; i < MAX_ENEMY; i++)
	{
		if (EnemyList[i] == TargetId)
		{
			EnemyList[i] = 0;

			return;
		}
	}
}

void CMob::SelectTargetFromEnemyList(void)
{
	CurrentTarget = 0;

	int Enemy[MAX_ENEMY] = { 0, 0, 0, 0 };

	for (int i = 0; i < MAX_ENEMY; i++)
		Enemy[i] = MAX_USER;

	int dis = 7;

	if (MOB.Clan == 4 || MOB.Clan == 7 || MOB.Clan == 8)
		dis = 12;

	if ((TargetX / 128) < 12 && (TargetY / 128) > 25)
		dis = 8;

	if (GenerateIndex == KEFRA_BOSS)
		dis = HALFGRIDX;

	for (int i = 0; i < MAX_ENEMY; i++)
	{
		int myenemy = EnemyList[i];

		if (myenemy <= 0 || myenemy >= MAX_MOB)
			continue;

		if (pMob[myenemy].Mode == MOB_EMPTY)
		{
			EnemyList[i] = 0;
			continue;
		}

		if (pMob[myenemy].MOB.CurrentScore.Hp <= 0)
		{
			EnemyList[i] = 0;
			continue;
		}

		if (myenemy >= MAX_USER)
			goto LABEL_51;

		if (pMob[myenemy].MOB.Rsv & 0x10)
		{
			EnemyList[i] = 0;
			continue;
		}
		if (pMob[myenemy].MOB.BaseScore.Level > MAX_LEVEL && ((pMob[myenemy].MOB.Merchant & 1) == 0))
		{
			EnemyList[i] = 0;
			continue;
		}

	LABEL_51:

		if (pMob[myenemy].TargetX >= TargetX - dis && pMob[myenemy].TargetX <= TargetX + dis &&
			pMob[myenemy].TargetY >= TargetY - dis && pMob[myenemy].TargetY <= TargetY + dis)
		{
			Enemy[i] = BASE_GetDistance(TargetX, TargetY, pMob[myenemy].TargetX, pMob[myenemy].TargetY);

			if (myenemy > MAX_USER)
				Enemy[i] += 2;
		}
		else
			EnemyList[i] = 0;

	}

	int NoTarget = MAX_USER;
	int nextenemy = 0;
	for (int i = 0; i < MAX_ENEMY; i++)
	{
		if (EnemyList[i])
		{
			if (NoTarget >= Enemy[i])
			{
				nextenemy = EnemyList[i];
				NoTarget = Enemy[i];
			}
		}
	}
	if (NoTarget == MAX_USER)
		CurrentTarget = 0;

	else
		CurrentTarget = nextenemy;
}

int CMob::SetSegment()
{
	int iterator;

	if (RouteType == 6)
	{
		SegmentProgress = 0;
		SegmentDirection = 0;
		SegmentX = SegmentListX[SegmentProgress];
		SegmentY = SegmentListY[SegmentProgress];
		WaitSec = 0;
		return 0;
	}
	else
	{
		if (RouteType >= 0 && RouteType <= 4)
		{
			while (1)
			{
				while (1)
				{
					while (1)
					{
						if (SegmentDirection)
							SegmentProgress--;
						else
							SegmentProgress++;

						if (SegmentProgress > -1)
							break;

						if (!RouteType)
						{
							SegmentDirection = 0;
							SegmentProgress = 0;
							iterator = 2;
							goto LABEL_40;
						}

						if (RouteType == 1)
						{
							SegmentDirection = 0;
							SegmentProgress = 0;
						}
						else
						{
							if (RouteType == 2)
							{
								SegmentDirection = 0;
								SegmentProgress = 0;
							}
							else
							{
								if (RouteType == 3)
								{
									iterator = 2;
									goto LABEL_40;
								}
								if (RouteType == 4)
								{
									goto LABEL_40;
								}
							}
						}
					}

					if (SegmentProgress >= 5)
						break;

					if (SegmentListX[SegmentProgress])
					{
						iterator = 0;
						goto LABEL_40;
					}
				}

				if (!RouteType)
					break;

				if (RouteType == 1)
				{
					iterator = 2;
					goto LABEL_40;
				}

				if (RouteType != 2 && RouteType != 3)
				{
					if (RouteType == 4)
						SegmentProgress = -1;
				}
				else
				{
					SegmentProgress = 4;
					SegmentDirection = 1;
				}
			}

			SegmentProgress = 4;
			Mode = 4;
			MOB.BaseScore.Merchant = MOB.Merchant;
			int len = strlen(Route);
			int rt = 0;

			if (len > 0)
			{
				rt = Route[len];

				rt = rt - 48;

				if (rt >= 1)
				{
					if (rt <= 9)
					{
						rt = rt * 16;

						MOB.Merchant |= rt;
					}
				}
			}
			GetCurrentScore(MAX_USER);
			iterator = 1;

		LABEL_40:
			SegmentX = SegmentListX[SegmentProgress];
			SegmentY = SegmentListY[SegmentProgress];

			WaitSec = 0;
			return iterator;
		}
		else
			return 0;
	}
}

/*
int CMob::SetSegment()
{
	if (RouteType == 6)
	{
		SegmentProgress = 0;
		SegmentDirection = 0;
		SegmentX = SegmentListX[SegmentProgress];
		SegmentY = SegmentListY[SegmentProgress];

		WaitSec = 0;
		return 0;
	}

	if (RouteType <= 0 && RouteType > 4)
	{
		Log("Wrong SetSegment", MOB.MobName, 0);
		return 0;
	}

	int iterator;
	while (1)
	{
		if (SegmentDirection == 0)
			SegmentProgress = SegmentProgress + 1;
		else
			SegmentProgress = SegmentProgress - 1;

		if (SegmentProgress == -1)
		{
			if (RouteType == 0)
			{
				SegmentProgress = 0;
				SegmentDirection = 0;
				iterator = 2;
				Log("SetSegment SegmentProgress -1 but route type 0", MOB.MobName, 0);
				break;
			}

			if (RouteType == 1)
			{
				SegmentProgress = 0;
				SegmentDirection = 0;
			}
			else if (RouteType == 2)
			{
				SegmentProgress = 0;
				SegmentDirection = 0;
			}
			else if (RouteType == 3)
			{
				iterator = 2;
				break;
			}

			else if (RouteType == 4)
			{
				Log("SetSegment SegmentProgress -1 but route type 4", MOB.MobName, 0);
				break;
			}
			continue;
		}

		if (SegmentProgress == 5)
		{
			if (RouteType == 0)
			{
				SegmentProgress = 4;
				Mode = 4;
				MOB.BaseScore.Merchant = MOB.Merchant;
				int len = strlen(Route);
				int rt = 0;

				if (len > 0)
				{
					rt = Route[len];

					rt = (rt & 0xFF) - 48;

					if ((rt & 0xFF) >= 1 && (rt & 0xFF) <= 9)
					{
						rt = (rt & 0xFF) << 4;

						MOB.Merchant = MOB.Merchant | (rt & 0xFF);

					}
				}

				GetCurrentScore(MAX_USER);

				iterator = 1;
				break;
			}

			if (RouteType == 1)
			{
				iterator = 2;
				break;
			}

			if (RouteType == 2 || RouteType == 3)
			{
				SegmentProgress = 4;
				SegmentDirection = 1;
				continue;
			}

			if (RouteType == 4)
			{
				SegmentProgress = -1;
				continue;
			}
			continue;
		}

		if (SegmentListX[SegmentProgress] == 0)
			continue;

		iterator = 0;
		break;
	}

	SegmentX = SegmentListX[SegmentProgress];
	SegmentY = SegmentListY[SegmentProgress];

	WaitSec = 0;
	return iterator;
}
*/
void CMob::GetCurrentScore(int idx)
{
	if (idx < MAX_USER)
		pMob[idx].MOB.Clan = 0;

	if (idx < MAX_USER && MOB.BaseScore.Level < 2000)
	{
		MOB.Resist[0] = BASE_GetMobAbility(&MOB, EF_RESIST1) >= 200 ? 200 : BASE_GetMobAbility(&MOB, EF_RESIST1);
		MOB.Resist[1] = BASE_GetMobAbility(&MOB, EF_RESIST2) >= 200 ? 200 : BASE_GetMobAbility(&MOB, EF_RESIST2);
		MOB.Resist[2] = BASE_GetMobAbility(&MOB, EF_RESIST3) >= 200 ? 200 : BASE_GetMobAbility(&MOB, EF_RESIST3);
		MOB.Resist[3] = BASE_GetMobAbility(&MOB, EF_RESIST4) >= 200 ? 200 : BASE_GetMobAbility(&MOB, EF_RESIST4);

		if (MOB.Resist[0] >= 200)
			MOB.Resist[0] = 200;

		if (MOB.Resist[1] >= 200)
			MOB.Resist[1] = 200;

		if (MOB.Resist[2] >= 200)
			MOB.Resist[2] = 200;

		if (MOB.Resist[3] >= 200)
			MOB.Resist[3] = 200;

		MOB.Equip[0].stEffect[0].cEffect = 0;
		MOB.Equip[0].stEffect[0].cValue = 0;

		MOB.Rsv = 0;

	}
	else if (idx >= MAX_USER)
	{
		int GenerateID = GenerateIndex;

		if (GenerateID <= 0 || GenerateID >= 7000)
		{
			if (MOB.Equip[0].sIndex == 220 || MOB.Equip[0].sIndex == 357 || MOB.Equip[0].sIndex == 219)
			{
				MOB.Resist[0] = 90;
				MOB.Resist[1] = 90;
				MOB.Resist[2] = 90;
				MOB.Resist[3] = 90;
			}
		}
		else
		{
			int R0 = mNPCGen.pList[GenerateID].Leader.Resist[0];

			if (R0 > 100)
				R0 = 100;

			MOB.Resist[0] = R0;

			int R1 = mNPCGen.pList[GenerateID].Leader.Resist[1];

			if (R1 > 100)
				R1 = 100;

			MOB.Resist[1] = R1;

			int R2 = mNPCGen.pList[GenerateID].Leader.Resist[2];

			if (R2 > 100)
				R2 = 100;

			MOB.Resist[2] = R2;

			int R3 = mNPCGen.pList[GenerateID].Leader.Resist[3];

			if (R3 > 100)
				R3 = 100;

			MOB.Resist[3] = R3;
		}

		MOB.Rsv = 0;
	}

	Parry = BASE_GetMobAbility(&MOB, EF_PARRY);

	if (idx < MAX_USER)
	{
		pUser[idx].Range = BASE_GetMobAbility(&MOB, EF_RANGE);
		pUser[idx].Range = 23;
	}

	ExpBonus = 0;
	DropBonus = 0;
	ForceDamage = 0;
	ReflectDamage = 0;
	ForceMobDamage = 0;
	Accuracy = 0;
	HpAbs = 0;
	CitizenDrop = 0;

	BASE_GetCurrentScore(MOB, Affect, &extra, &ExpBonus, &ForceMobDamage, idx >= MAX_USER ? 1 : 0, &Accuracy, &HpAbs, &ForceDamage);

	//Fada Verde 3D
	if (MOB.Equip[13].sIndex == 3900)
		ExpBonus += 16;

	//Fada Azul 3D
	if (MOB.Equip[13].sIndex == 3901)
		DropBonus += 32;

	//Fada Vermelha
	if (MOB.Equip[13].sIndex == 3902 || MOB.Equip[13].sIndex == 3905 || MOB.Equip[13].sIndex == 3908)
	{
		ExpBonus += 32;
		DropBonus += 16;
	}

	//Fada Verde
	if (MOB.Equip[13].sIndex == 3903 || MOB.Equip[13].sIndex == 3906 || MOB.Equip[13].sIndex == 3911 || MOB.Equip[13].sIndex == 3912 || MOB.Equip[13].sIndex == 3913)
		ExpBonus += 16;

	//Fada Verde Azul 
	if (MOB.Equip[13].sIndex == 3904 || MOB.Equip[13].sIndex == 3907)
		DropBonus += 32;

	//trajes
	if (MOB.Equip[12].sIndex >= 4200 && MOB.Equip[12].sIndex <= 4275)
	{
		ExpBonus += 10;
		if ((MOB.Equip[14].sIndex >= 2360 && MOB.Equip[14].sIndex <= 2389) && MOB.Equip[14].stEffect[2].cValue > 0)
			ExpBonus += 5;
	}
	//trajes montaria
	if ((MOB.Equip[14].sIndex >= 2360 && MOB.Equip[14].sIndex <= 2389) && MOB.Equip[14].stEffect[2].cValue > 0)
	{
		DropBonus += 10;
		if (MOB.Equip[12].sIndex >= 4200 && MOB.Equip[12].sIndex <= 4275)
			DropBonus += 5;
	}

	//Concentração
	if ((MOB.LearnedSkill & 0x10000000) != 0)
		Accuracy += 50;

	if (MOB.Resist[0] < 0 && idx < MAX_USER)
		MOB.Resist[0] = 0;

	if (MOB.Resist[1] < 0 && idx < MAX_USER)
		MOB.Resist[1] = 0;

	if (MOB.Resist[2] < 0 && idx < MAX_USER)
		MOB.Resist[2] = 0;

	if (MOB.Resist[3] < 0 && idx < MAX_USER)
		MOB.Resist[3] = 0;

	if (MOB.CurrentScore.Hp > MOB.CurrentScore.MaxHp)
		MOB.CurrentScore.Hp = MOB.CurrentScore.MaxHp;

	if (MOB.CurrentScore.Mp > MOB.CurrentScore.MaxMp)
		MOB.CurrentScore.Mp = MOB.CurrentScore.MaxMp;

	int w1 = BASE_GetItemAbility(&MOB.Equip[6], EF_DAMAGE);
	int w2 = BASE_GetItemAbility(&MOB.Equip[7], EF_DAMAGE);

	int fw1 = (w1 / 2);
	int fw2 = (w2 / 2);

	//Pericia do caçador
	if ((MOB.LearnedSkill & 0x400) && MOB.Class == 3)
	{
		fw1 = w1;
		fw2 = w2;
	}

	//Mestre das Armas
	if ((MOB.LearnedSkill & 0x200) && MOB.Class == 0)
	{
		fw1 = w1;
		fw2 = w2;
	}

	if (MOB.Class == 2)
	{
		// Armadura Elemental
		if ((MOB.LearnedSkill & 0x20000) && g_pItemList[MOB.Equip[7].sIndex].nPos == 128 || (MOB.LearnedSkill & 0x800000) != 0)
			ReflectDamage += ((MOB.CurrentScore.Special[3] + 1) / 6);

		//Escudo do tormento
		if ((MOB.LearnedSkill & 0x80000) && g_pItemList[MOB.Equip[7].sIndex].nPos == 128)
			MOB.CurrentScore.Ac += (BASE_GetItemAbility(&MOB.Equip[7], EF_AC) + 1) / 7;
	}

	if (w1 >= w2)
		WeaponDamage = w1 + fw2;
	else
		WeaponDamage = w2 + fw1;

	/*
	int Critical = BASE_GetMobAbility(&MOB, EF_CRITICAL);

	if (Critical >= 1000)
		Critical = 1000;

	int CtDex = 0;

	if (MOB.Class)
	{
		if (MOB.Class == 2)
		{
			if (MOB.LearnedSkill & 0x20000) // Armadura Elemental
				ReflectDamage += MOB.CurrentScore.Special[2];

			if (MOB.LearnedSkill & 0x80000) // Escudo do Tormento
			{
				if (g_pItemList[MOB.Equip[7].sIndex].nPos == 128)
					MOB.CurrentScore.Ac = 105 * MOB.CurrentScore.Ac / 100;
			}
		}
		else
		{
			if (MOB.Class == 3)
			{
				if (MOB.LearnedSkill & 0x40000) // Visão da Caçadora
				{
					CtDex = MOB.CurrentScore.Dex;
					CtDex /= 20;
				}

				if (MOB.LearnedSkill & 0x400000) // Proteção das Sombras
				{
					int ItemAbility = BASE_GetItemAbility(&MOB.Equip[6], EF_WTYPE);

					if (ItemAbility == 41)
						MOB.CurrentScore.Ac += MOB.CurrentScore.Special[3];
				}
			}
		}
	}
	else
	{
		if (MOB.LearnedSkill & 0x80)
		{
			int Resist = MOB.Resist[2] + 20;

			if (Resist > 100)
				Resist = 100;

			MOB.Resist[2] = Resist;
		}
		if (MOB.LearnedSkill & 0x8000)
		{
			CtDex = 100;
			MOB.CurrentScore.Ac = 120 * MOB.CurrentScore.Ac / 100;
		}
	}

	int MobCritical = MOB.Critical;
	MobCritical = (CtDex + Critical + MobCritical) / 4;

	if (MobCritical > 255)
		MobCritical = 255;

	MOB.Critical = MobCritical;
	*/

	int idx1 = MOB.Equip[6].sIndex;
	int nPos = g_pItemList[idx1].nPos;

	if (idx1 >= 0 || idx1 < MAX_ITEMLIST)
	{
		if (nPos == 64 || nPos == 192)
		{
			int isanc = BASE_GetItemSanc(&MOB.Equip[6]);

			if (isanc >= 9)
				WeaponDamage += 40;
		}
	}

	int idx2 = MOB.Equip[7].sIndex;
	int nPos2 = g_pItemList[idx2].nPos;

	if (idx2 >= 0 || idx2 < MAX_ITEMLIST)
	{
		if (nPos2 == 64 || nPos2 == 192)
		{
			int isanc = BASE_GetItemSanc(&MOB.Equip[7]);

			if (isanc >= 9)
				WeaponDamage += 40;
		}
	}

	for (int i = 0; i < 16; i++)
	{
		int ItemId = MOB.Equip[i].sIndex;
		int itemGem = BASE_GetItemGem(&MOB.Equip[i]);
		int itemSanc = BASE_GetItemSanc(&MOB.Equip[i]);

		int pDrop = 0;
		int pExp = 0;
		int pDamage = 0;
		int pReflect = 0;

		if (ItemId <= 0 || ItemId > MAX_ITEMLIST)
			continue;

		if (g_pItemList[ItemId].Grade == 5)
			pDrop += 8;

		if (g_pItemList[ItemId].Grade == 6)
			pDamage += i == 20;

		if (g_pItemList[ItemId].Grade == 7)
			pExp += 2;

		if (g_pItemList[ItemId].Grade == 8)
			pReflect += 20;

		int isanc = 0;

		if (itemSanc == REF_10)
			isanc = 1;

		else if (itemSanc == REF_11)
			isanc = 2;

		else if (itemSanc == REF_12)
			isanc = 3;

		else if (itemSanc == REF_13)
			isanc = 4;

		else if (itemSanc == REF_14)
			isanc = 5;

		else if (itemSanc == REF_15)
			isanc = 6;

		if (itemGem == 0)
			pDrop += 8;

		if (itemGem == 1)
			pDamage += (g_pItemList[ItemId].Grade == 6 ? 80 : 40) * isanc;

		if (itemGem == 2)
			pExp += 2;

		if (itemGem == 3)
			pReflect += (g_pItemList[ItemId].Grade == 8 ? 80 : 40) * isanc;

		DropBonus += pDrop;
		ExpBonus += pExp;
		ReflectDamage += pReflect;
		ForceDamage += pDamage;

	}

	if (extra.Citizen == ServerIndex + 1)
		CitizenDrop += 10;

	if (KefraLive != 0)
		CitizenDrop += 20;

	if (MOB.Exp >= 100000000 && extra.Citizen != 0)
	{
		int DropCalculoByExp = MOB.Exp / 100000000;

		if (DropCalculoByExp > 80)
			DropCalculoByExp = 80;

		CitizenDrop += DropCalculoByExp;
	}

	DropBonus += CitizenDrop;

	PvPDamage = 0;
	ReflectPvP = 0;

	int AtaquePvP = BASE_GetMobAbility(&MOB, EF_HWORDGUILD);

	AtaquePvP = (AtaquePvP + 1) / 10;

	PvPDamage = AtaquePvP;

	int DefesaPvP = BASE_GetMobAbility(&MOB, EF_LWORDGUILD);

	DefesaPvP = (DefesaPvP + 1) / 10;

	ReflectPvP = DefesaPvP;

	//Novos Slots
	if (idx < MAX_USER && pUser[idx].Mode == USER_PLAY) {
		for (int i = 0; i < 2; i++) {
			int slot = 0;
			slot = pUser[idx].Slot;
			MOB.CurrentScore.Ac += BASE_GetItemAbility(&pUser[idx].Joias[slot][i], EF_AC);
			MOB.Magic += BASE_GetItemAbility(&pUser[idx].Joias[slot][i], EF_MAGIC);
			MOB.CurrentScore.MaxHp += MOB.CurrentScore.MaxHp * BASE_GetItemAbility(&pUser[idx].Joias[slot][i], EF_HPADD) / 100;
			MOB.CurrentScore.MaxMp += MOB.CurrentScore.MaxMp * BASE_GetItemAbility(&pUser[idx].Joias[slot][i], EF_MPADD) / 100;
			MOB.CurrentScore.Damage += BASE_GetItemAbility(&pUser[idx].Joias[slot][i], EF_DAMAGE);

			MOB.CurrentScore.Ac += BASE_GetBonusItemAbility(&pUser[idx].Joias[slot][i], EF_AC);
			MOB.Magic += BASE_GetBonusItemAbility(&pUser[idx].Joias[slot][i], EF_MAGIC);
			MOB.CurrentScore.MaxHp += MOB.CurrentScore.MaxHp * BASE_GetBonusItemAbility(&pUser[idx].Joias[slot][i], EF_HPADD) / 100;
			MOB.CurrentScore.MaxMp += MOB.CurrentScore.MaxMp * BASE_GetBonusItemAbility(&pUser[idx].Joias[slot][i], EF_MPADD) / 100;
			MOB.CurrentScore.Damage += BASE_GetBonusItemAbility(&pUser[idx].Joias[slot][i], EF_DAMAGE);
		}

		//BALANCEAMENTO Skills
		//Huntress
		if (MOB.Class == 3) {
			int Evo = pMob[idx].extra.ClassMaster;

			// Sobrevivência
			if (MOB.LearnedSkill & 128)
			{
				if (Evo == MORTAL) {
					//MOB.CurrentScore.Ac += 50;
					MOB.Critical += 10; // 10 = 1%, 100 = 10% etc
					Parry += 10; //Evasão 10 = 1%, 100 = 10% etc
				}
				if (Evo == ARCH) {
					//MOB.CurrentScore.Ac += 100;
				}
				if (Evo >= CELESTIAL) {
					//MOB.CurrentScore.Ac += 150;
				}
			}
			//Troca
			if (MOB.LearnedSkill & 32768) {
				int tpos = BASE_GetItemAbility(&MOB.Equip[6], EF_POS);

				if (tpos == 192) {
					if (Evo == MORTAL) {
						MOB.CurrentScore.Damage += 400;
						MOB.CurrentScore.Ac += 100;
					}
					if (Evo == ARCH) {
						MOB.CurrentScore.Damage += 800;
						MOB.CurrentScore.Ac += 200;
					}
					if (Evo >= CELESTIAL) {
						MOB.CurrentScore.Damage += 1200;
						MOB.CurrentScore.Ac += 250;
					}
				}
			}
			//Captura
			if (MOB.LearnedSkill & 8388608)
			{
				int Type = BASE_GetItemAbility(&MOB.Equip[6], EF_WTYPE);
				if (Type == 41) {
					if (Evo == MORTAL) {
						MOB.CurrentScore.Ac += 200;
					}
					if (Evo == ARCH) {
						MOB.CurrentScore.Ac += 400;
					}
					if (Evo >= CELESTIAL) {
						MOB.CurrentScore.Ac += 600;
					}
				}
			}
		}
		//Foema
		if (MOB.Class == 1) {
			int Evo = pMob[idx].extra.ClassMaster;

			//Magia Branca
			if (MOB.LearnedSkill & 128)
			{
				if (Evo == MORTAL) {
					MOB.CurrentScore.MaxHp += 500;
					MOB.CurrentScore.Ac += 200;
				}
				if (Evo == ARCH) {
					MOB.CurrentScore.MaxHp += 1000;
					MOB.CurrentScore.Ac += 400;
				}
				if (Evo >= CELESTIAL) {
					MOB.CurrentScore.MaxHp += 1500;
					MOB.CurrentScore.Ac += 600;
				}
			}
			//Magia Negra
			if (MOB.LearnedSkill & 32768)
			{
				if (Evo == MORTAL) {
					MOB.Magic += 5;
				}
				if (Evo == ARCH) {
					MOB.Magic += 10;
				}
				if (Evo >= CELESTIAL) {
					MOB.Magic += 15;
				}
			}
			// Magia Especial
			if (MOB.LearnedSkill & 8388608)
			{
				int Type = BASE_GetItemAbility(&MOB.Equip[6], EF_WTYPE);

				if (Evo == MORTAL) {
					MOB.CurrentScore.Damage += 200;
					MOB.CurrentScore.Ac += 100;
				}
				if (Evo == ARCH) {
					MOB.CurrentScore.Damage += 400;
					MOB.CurrentScore.Ac += 200;
				}
				if (Evo >= CELESTIAL) {
					MOB.CurrentScore.Damage += 600;
					MOB.CurrentScore.Ac += 300;
				}
			}
		}
		//BeastMaster
		if (MOB.Class == 2) {
			int Evo = pMob[idx].extra.ClassMaster;

			// Elemental
			if (MOB.LearnedSkill & 128)
			{
				if (Evo == MORTAL) {
					//MOB.Magic += 5;
					MOB.CurrentScore.Ac += 50;
				}
				if (Evo == ARCH) {
					//MOB.Magic += 10;
					MOB.CurrentScore.Ac += 100;
				}
				if (Evo >= CELESTIAL) {
					//MOB.Magic += 15;
					MOB.CurrentScore.Ac += 150;
				}
			}
			// Evocação
			if (MOB.LearnedSkill & 32768)
			{
				if (Evo == MORTAL) {
					MOB.CurrentScore.Damage += 200;
					MOB.CurrentScore.Ac += 100;
				}
				if (Evo == ARCH) {
					MOB.CurrentScore.Damage += 400;
					MOB.CurrentScore.Ac += 200;
				}
				if (Evo >= CELESTIAL) {
					MOB.CurrentScore.Damage += 600;
					MOB.CurrentScore.Ac += 300;
				}
			}
			// Natureza
			if (MOB.LearnedSkill & 8388608)
			{
				if (Evo == MORTAL) {
					MOB.CurrentScore.MaxHp += 500;
					MOB.CurrentScore.Ac += 150;
					//MOB.Magic += 0;
				}
				if (Evo == ARCH) {
					MOB.CurrentScore.MaxHp += 1000;
					MOB.CurrentScore.Ac += 300;
					//MOB.Magic += 0;
				}
				if (Evo >= CELESTIAL) {
					MOB.CurrentScore.MaxHp += 1500;
					MOB.CurrentScore.Ac += 450;
					//MOB.Magic += 0;
				}
			}
		}
		//Transknight
		if (MOB.Class == 0) {
			int Evo = pMob[idx].extra.ClassMaster;

			// Confiança ou Espada Mágica
			if (MOB.LearnedSkill & 128 || MOB.LearnedSkill & 8388608)
			{
				if (Evo == MORTAL) {
					MOB.CurrentScore.MaxHp += 500;
					MOB.CurrentScore.Ac += 150;
					//MOB.Magic += 0;
				}
				if (Evo == ARCH) {
					MOB.CurrentScore.MaxHp += 1000;
					MOB.CurrentScore.Ac += 300;
					//MOB.Magic += 0;
				}
				if (Evo >= CELESTIAL) {
					MOB.CurrentScore.MaxHp += 1500;
					MOB.CurrentScore.Ac += 450;
					//MOB.Magic += 0;
				}
			}
			// Trans
			if (MOB.LearnedSkill & 32768)
			{
				if (Evo == MORTAL) {
					MOB.CurrentScore.Damage += 200;
					MOB.CurrentScore.Ac += 100;
				}
				if (Evo == ARCH) {
					MOB.CurrentScore.Damage += 400;
					MOB.CurrentScore.Ac += 200;
				}
				if (Evo >= CELESTIAL) {
					MOB.CurrentScore.Damage += 600;
					MOB.CurrentScore.Ac += 300;
				}
			}
		}
	}
}

void CMob::GetTargetPosDistance(int tz)
{
	if ((MOB.BaseScore.AttackRun & 0xF) == 0)
	{
		NextX = TargetX;
		NextY = TargetY;

		return;
	}

	int speed = BASE_GetSpeed(&MOB.CurrentScore);
	int distance = (speed * SECBATTLE) / 4; // SECBATTLE(?) = 8

	if (distance >= MAX_ROUTE)
		distance = MAX_ROUTE - 1;

	LastX = TargetX;
	LastY = TargetY;
	NextX = LastX;
	NextY = LastY;

	if (pMob[tz].TargetX > LastX)
		NextX = NextX - (1 + rand() % 2);

	else if (pMob[tz].TargetX < LastX)
		NextX = NextX + (1 + rand() % 2);

	if (pMob[tz].TargetY > LastY)
		NextY = NextY - (1 + rand() % 2);
	else if (pMob[tz].TargetY < LastY)
		NextY = NextY + (1 + rand() % 2);

	GetEmptyMobGrid(0, &NextX, &NextY);

	int dis = 0;

	for (dis = distance; dis >= 0; dis--)
	{
		BASE_GetRoute(LastX, LastY, &NextX, &NextY, Route, dis, (char*)pHeightGrid);

		if (pMobGrid[NextY][NextX] == 0)
			break;

		if (dis != distance)
		{
			GetEmptyMobGrid(0, &NextX, &NextY);

			BASE_GetRoute(LastX, LastY, &NextX, &NextY, Route, dis, (char*)pHeightGrid);

			if (pMobGrid[NextY][NextX] == 0)
				break;
		}
	}

	if (dis == -1 || Route[0] == 0)
	{
		NextX = TargetX;
		NextY = TargetY;

		Route[0] = 0;
	}
}

void CMob::GetRandomPos()
{
	if ((MOB.BaseScore.AttackRun & 15) == 0)
	{
		NextX = TargetX;
		NextY = TargetY;

		return;
	}

	int speed = BASE_GetSpeed(&MOB.CurrentScore);
	int distance = speed * SECBATTLE / 4;

	if (distance >= MAX_ROUTE)
		distance = MAX_ROUTE - 1;

	LastX = TargetX;
	LastY = TargetY;
	NextX = LastX + rand() % 7 - 3;
	NextY = LastY + rand() % 7 - 3;

	GetEmptyMobGrid(0, &NextX, &NextY);

	int i = 0;

	for (i = distance; i >= 0; i--)
	{
		BASE_GetRoute(LastX, LastY, &NextX, &NextY, Route, i, (char*)pHeightGrid);

		if (pMobGrid[NextY][NextX] == 0)
			break;

		if (i != distance)
		{
			GetEmptyMobGrid(0, &NextX, &NextY);

			BASE_GetRoute(LastX, LastY, &NextX, &NextY, Route, i, (char*)pHeightGrid);

			if (pMobGrid[NextY][NextX] == 0)
				break;
		}
	}

	if (i == -1 || Route[0] == 0)
	{
		NextX = TargetX;
		NextY = TargetY;

		Route[0] = 0;
	}
}

int CMob::GetTargetPos7556(int target)
{
	if (MOB.BaseScore.AttackRun & 0xF)
	{
		int speed = BASE_GetSpeed(&MOB.CurrentScore);
		int distance = speed * SECBATTLE / 4;

		if (distance >= 24)
			distance = 23;

		LastX = TargetX;
		LastY = TargetY;
		NextX = pMob[target].TargetX;
		NextY = pMob[target].TargetY;

		return GetEmptyMobGrid(0, &NextX, &NextY);

		int i = 0;

		for (i = distance; i >= 0; i--)
		{
			BASE_GetRoute(LastX, LastY, &NextX, &NextY, Route, i, (char*)pHeightGrid);

			return pMobGrid[NextY][NextX];

			if (!pMobGrid[NextY][NextX])
				break;

			if (i != distance)
			{
				GetEmptyMobGrid(0, &NextX, &NextY);

				BASE_GetRoute(LastX, LastY, &NextX, &NextY, Route, i, (char*)pHeightGrid);

				return pMobGrid[NextY][NextX];

				if (!pMobGrid[NextY][NextX])
					break;
			}

			return i - 1;
		}

		if (i == -1 || Route[0] == 0)
		{
			NextX = TargetX;
			NextY = TargetY;

			Route[0] = 0;
		}
	}
	else
	{
		NextX = TargetX;
		NextY = TargetY;
	}
}

void CMob::GetTargetPos(int tz)
{
	if (MOB.Equip[0].sIndex == 219 || MOB.Equip[0].sIndex == 220)
	{
		NextX = TargetX;
		NextY = TargetY;
		return;
	}

	if ((MOB.BaseScore.AttackRun & 15) == 0)
	{
		NextX = pMob[tz].TargetX;
		NextY = pMob[tz].TargetY;

		return;
	}

	int speed = BASE_GetSpeed(&MOB.CurrentScore);
	int distance = speed * SECBATTLE / 4;

	if (distance >= MAX_ROUTE)
		distance = MAX_ROUTE - 1;

	LastX = TargetX;
	LastY = TargetY;
	NextX = pMob[tz].TargetX;
	NextY = pMob[tz].TargetY;

	int getdistance = BASE_GetDistance(TargetX, TargetY, pMob[tz].TargetX, pMob[tz].TargetY);

	if (getdistance > 1 && getdistance <= 3)
		GetEmptyMobGrid(0, &NextX, &NextY);

	int i = 0;

	for (i = distance; i >= 0; i--)
	{
		BASE_GetRoute(LastX, LastY, &NextX, &NextY, Route, i, (char*)pHeightGrid);

		if (pMobGrid[NextY][NextX] == 0)
			break;

		if (i != distance)
		{
			GetEmptyMobGrid(0, &NextX, &NextY);

			BASE_GetRoute(LastX, LastY, &NextX, &NextY, Route, i, (char*)pHeightGrid);

			if (pMobGrid[NextY][NextX] == 0)
				break;
		}
	}

	if (i == -1 || Route[0] == 0)
	{
		NextX = TargetX;
		NextY = TargetY;

		Route[0] = 0;
	}
}

int  CMob::CheckGetLevel()
{
	int ret = 0;
	int cls = MOB.Class;
	int CurSeg = 0;

	if (MOB.BaseScore.Level >= MAX_LEVEL)
		return 0;

	int cur = MOB.BaseScore.Level;

	int max_level = 0;

	int IsMortal = MAX_LEVEL;

	if (extra.ClassMaster == MORTAL || extra.ClassMaster == ARCH)
		max_level = MAX_LEVEL;

	else if (extra.ClassMaster == CELESTIAL || extra.ClassMaster == SCELESTIAL || extra.ClassMaster == CELESTIALCS ||
		extra.ClassMaster == HARDCORE) {
		max_level = 199;
		IsMortal = 199;
	}
		
	if (cur >= max_level)
		return 0;	

	long long exp = MOB.Exp;
	long long curexp = max_level == IsMortal ? g_pNextLevel[cur] : g_pNextLevel_2[cur];
	long long nextexp = max_level == IsMortal ? g_pNextLevel[cur + 1] : g_pNextLevel_2[cur + 1];
	long long deltaexp = (nextexp - curexp) / 4;
	long long Segment1 = curexp + deltaexp;
	long long Segment2 = curexp + (deltaexp * 2);
	long long Segment3 = curexp + (deltaexp * 3);
	long long Segment4 = nextexp;

	if (exp > Segment3)
		CurSeg = 3;
	else if (exp > Segment2)
		CurSeg = 2;
	else if (exp > Segment1)
		CurSeg = 1;

	/*
	if (extra.ClassMaster == CELESTIAL && (cur == 39 && extra.QuestInfo.Celestial.Lv40 == 0 || cur == 89 && extra.QuestInfo.Celestial.Lv90 == 0 || cur == 239 && extra.QuestInfo.Celestial.Lv240 == 0 ||
		cur == 279 && extra.QuestInfo.Celestial.Lv280 == 0 || cur == 319 && extra.QuestInfo.Celestial.Lv320 == 0 || cur == 359 && extra.QuestInfo.Celestial.Lv360 == 0))
		return 0;*/

	if (extra.ClassMaster == CELESTIAL && (cur == 39 && extra.QuestInfo.Celestial.Lv40 == 0 || cur == 89 && extra.QuestInfo.Celestial.Lv90 == 0))
		return 0;

	/*
	if (extra.ClassMaster == CELESTIALCS && (cur == 239 && extra.QuestInfo.Celestial.Lv240 == 0 || cur == 279 && extra.QuestInfo.Celestial.Lv280 == 0 ||
		cur == 319 && extra.QuestInfo.Celestial.Lv320 == 0 || cur == 359 && extra.QuestInfo.Celestial.Lv360 == 0))
		return 0;

	if (extra.ClassMaster == SCELESTIAL && (cur == 239 && extra.QuestInfo.Celestial.Lv240 == 0 || cur == 279 && extra.QuestInfo.Celestial.Lv280 == 0 ||
		cur == 319 && extra.QuestInfo.Celestial.Lv320 == 0 || cur == 359 && extra.QuestInfo.Celestial.Lv360 == 0))
		return 0;*/

	if (extra.ClassMaster == ARCH && (cur == 354 && extra.QuestInfo.Arch.Level355 == 0 || cur == 369 && extra.QuestInfo.Arch.Level370 == 0))
		return 0;

	if (exp >= nextexp)
	{
		MOB.BaseScore.Level++;

		if (extra.ClassMaster == MORTAL) {
			MOB.BaseScore.MaxHp = MOB.BaseScore.MaxHp + g_pIncrementHp[cls];
			MOB.BaseScore.MaxMp = MOB.BaseScore.MaxMp + g_pIncrementMp[cls];
		}
		else {
			MOB.BaseScore.MaxHp = MOB.BaseScore.MaxHp + g_pIncrementHp_2[cls];
			MOB.BaseScore.MaxMp = MOB.BaseScore.MaxMp + g_pIncrementMp_2[cls];
		}

		MOB.CurrentScore.Hp = MOB.CurrentScore.MaxHp;
		MOB.CurrentScore.Mp = MOB.CurrentScore.MaxMp;

		if (extra.ClassMaster == MORTAL)
		{
			if (MOB.BaseScore.Level >= 200)
				MOB.SkillBonus += 4;
			else
				MOB.SkillBonus += 3;

			MOB.SpecialBonus += 2;

			BASE_GetBonusScorePoint(&MOB, &extra);

			MOB.BaseScore.Ac++;
		}
		else if (extra.ClassMaster == ARCH)
		{
			if (MOB.BaseScore.Level >= 200)
				MOB.SkillBonus += 4;
			else
				MOB.SkillBonus += 3;

			MOB.SpecialBonus += 2;

			BASE_GetBonusScorePoint(&MOB, &extra);

			MOB.BaseScore.Ac += 2;
		}
		else if (extra.ClassMaster == CELESTIAL || extra.ClassMaster == SCELESTIAL || extra.ClassMaster == CELESTIALCS || extra.ClassMaster == HARDCORE)
		{
			if (MOB.BaseScore.Level >= 200)
				MOB.SkillBonus += 2;

			BASE_GetBonusScorePoint(&MOB, &extra);
			MOB.BaseScore.Ac += 2;
		}

		GetCurrentScore(0);

		ret = 4;
		Segment = 0;
	}
	else if (exp >= Segment3 && Segment < 3)
	{
		ret = 3;
		Segment = 3;
	}
	else if (exp >= Segment2 && Segment < 2)
	{
		ret = 2;
		Segment = 2;
	}
	else if (exp >= Segment1 && Segment < 1)
	{
		ret = 1;
		Segment = 1;
	}
	else
		return ret;

	if (ret >= 1 && ret <= 3)
	{
		MOB.CurrentScore.Hp = MOB.CurrentScore.MaxHp;
		MOB.CurrentScore.Mp = MOB.CurrentScore.MaxMp;

		GetCurrentScore(0);

		return ret;
	}

	return ret;
}

void CMob::CGetNextRandomPos()
{
	if (GenerateIndex == 3440 || GenerateIndex == 3441 || GenerateIndex == 3442 || GenerateIndex == 3443 ||
		GenerateIndex == 3811 || GenerateIndex == 6060 || GenerateIndex == 6061 || GenerateIndex == 6062 ||
		GenerateIndex == 6063)
	{
		NextX = TargetX;
		NextY = TargetY;
		return;
	}

	if (MOB.BaseScore.AttackRun & 0xF)
	{
		int speed = BASE_GetSpeed(&MOB.CurrentScore);
		int distance = 0;

		if (RouteType == 5)
			distance = 4 * speed / 4;
		else
			distance = 6 * speed / 4;

		int str = MOB.BaseScore.Str;

		if (str)
		{
			str = RouteType == 5 ? 4 * str / 4 : 6 * str / 4;

			if (distance > str)
				distance = str;
		}

		if (distance >= 24)
			distance = 23;

		LastX = TargetX;
		LastY = TargetY;
		NextX = SegmentX + rand() % 5 - 2;
		NextY = SegmentY + rand() % 5 - 2;

		int i = 0;

		for (i = distance;; i--)
		{
			if (i > 0)
			{
				BASE_GetRoute(LastX, LastY, &NextX, &NextY, Route, i, (char*)pHeightGrid);

				if (pMobGrid[NextY][NextX])
				{
					if (i == distance)
						continue;

					GetEmptyMobGrid(0, &NextX, &NextY);

					BASE_GetRoute(LastX, LastY, &NextX, &NextY, Route, i, (char*)pHeightGrid);

					if (pMobGrid[NextY][NextX])
						continue;
				}
			}
			break;
		}

		if (i < 0 || Route[0] == 0)
		{
			NextX = TargetX;
			NextY = TargetY;

			Route[0] = 0;
		}
	}
	else
	{
		NextX = TargetX;
		NextY = TargetY;
	}
}

void CMob::GetNextRandomPos()
{
	if (MOB.BaseScore.AttackRun & 0xF)
	{
		int speed = BASE_GetSpeed(&MOB.CurrentScore);
		int distance = 0;

		if (RouteType == 5)
			distance = 4 * speed / 4;
		else
			distance = 6 * speed / 4;

		int str = MOB.BaseScore.Str;

		if (str)
		{
			str = RouteType == 5 ? 4 * str / 4 : 6 * str / 4;

			if (distance > str)
				distance = str;
		}

		if (distance >= 24)
			distance = 23;

		LastX = TargetX;
		LastY = TargetY;

		if (!strcmp((char*)MOB.MobName, "Perzen") == 0 &&
			!strcmp((char*)MOB.MobName, "Perzen Normal") == 0 &&
			!strcmp((char*)MOB.MobName, "Perzen Arcano") == 0 &&
			!strcmp((char*)MOB.MobName, "Perzen Mistico") == 0 &&
			!strcmp((char*)MOB.MobName, "Kibita") == 0 &&
			!strcmp((char*)MOB.MobName, "Fame BeastSB") == 0 &&
			!strcmp((char*)MOB.MobName, "Fame FoemaSB") == 0 &&
			!strcmp((char*)MOB.MobName, "Fame HunterSB") == 0 &&
			!strcmp((char*)MOB.MobName, "Fame TransSB") == 0)
		{
			NextX = SegmentX + rand() % 5 - 2;
			NextY = SegmentY + rand() % 5 - 2;
		}
		else
		{
			NextX = SegmentX;
			NextY = SegmentY;
		}

		int i = 0;

		for (i = distance;; i--)
		{
			if (i > 0)
			{
				BASE_GetRoute(LastX, LastY, &NextX, &NextY, Route, i, (char*)pHeightGrid);

				if (pMobGrid[NextY][NextX])
				{
					if (i == distance)
						continue;

					GetEmptyMobGrid(0, &NextX, &NextY);

					BASE_GetRoute(LastX, LastY, &NextX, &NextY, Route, i, (char*)pHeightGrid);

					if (pMobGrid[NextY][NextX])
						continue;
				}
			}
			break;
		}

		if (i < 0 || Route[0] == 0)
		{
			NextX = TargetX;
			NextY = TargetY;

			Route[0] = 0;
		}
	}
	else
	{
		NextX = TargetX;
		NextY = TargetY;
	}
}

void CMob::GetNextPos(int battle)
{
	if (MOB.Equip[0].sIndex == 219 || MOB.Equip[0].sIndex == 220 || GenerateIndex == KEFRA_BOSS)
	{
		NextX = TargetX;
		NextY = TargetY;
		return;
	}

	if ((MOB.BaseScore.AttackRun & 0xF) == 0)
	{
		NextX = TargetX;
		NextY = TargetY;
		return;
	}

	int speed = BASE_GetSpeed(&MOB.CurrentScore);
	int distance = speed * SECBATTLE / 4;

	if (distance >= MAX_ROUTE)
		distance = MAX_ROUTE - 1;

	if (battle)
	{
		int str = MOB.BaseScore.Str + 1;
		int res = str;

		if (res > distance)
			res = distance;
	}
	else
	{
		if (distance > MOB.BaseScore.Str)
			distance = MOB.BaseScore.Str;
	}

	LastX = TargetX;
	LastY = TargetY;
	NextX = SegmentX;
	NextY = SegmentY;

	GetEmptyMobGrid(0, &NextX, &NextY);

	if (NextX == -1)
		return;

	int i = 0;

	for (i = distance; i >= 0; i--)
	{
		BASE_GetRoute(LastX, LastY, &NextX, &NextY, Route, i, (char*)pHeightGrid);

		if (pMobGrid[NextY][NextX] == 0)
			break;

		if (i != distance)
		{
			GetEmptyMobGrid(0, &NextX, &NextY);

			BASE_GetRoute(LastX, LastY, &NextX, &NextY, Route, i, (char*)pHeightGrid);

			if (pMobGrid[NextY][NextX] == 0)
				break;
		}
	}

	if (i == -1 || Route[0] == 0)
	{
		NextX = TargetX;
		NextY = TargetY;

		Route[0] = 0;
	}
}

int CMob::GetEnemyFromView(void)
{
	int SizeX = 9;
	int SizeY = 9;

	int StartX = TargetX - 4;
	int StartY = TargetY - 4;

	if (MOB.Clan == 7 || MOB.Clan == 8)
	{
		SizeX = HALFGRIDX;
		SizeY = HALFGRIDY;
		StartX = TargetX - 6;
		StartY = TargetY - 6;
	}

	int sx1 = StartX;
	int sy1 = StartY;
	int sx2 = StartX + SizeX;
	int sy2 = StartY + SizeY;

	for (int y = sy1; y < sy2; y++)
	{
		for (int x = sx1; x < sx2; x++)
		{
			if (x < 0 || x >= MAX_GRIDX || y < 0 || y >= MAX_GRIDY)
				continue;

			int tmob = pMobGrid[y][x];

			if (x == TargetX && y == TargetY)
				continue;

			if (pMob[tmob].MOB.CurrentScore.Hp > 0 && pMob[tmob].Mode)
			{
				if ((tmob < MAX_USER && pMob[tmob].MOB.Rsv & 0x10))
					continue;

				if (MOB.Clan < 0 || MOB.Clan >= 9 || pMob[tmob].MOB.Clan < 0 || pMob[tmob].MOB.Clan >= 9)
				{
					//Log("err,clan out or range", MOB.MobName, 0);
					return 0;
				}
				if (g_pClanTable[MOB.Clan][pMob[tmob].MOB.Clan] == 0)
					return tmob;
			}
		}
	}

	return 0;
}

void CMob::AddChaosPoints(int points)
{
	int currentPoints = (int)MOB.Carry[KILL_MARK].stEffect[KILL_MARK_CHAOS_POINTS].cEffect;

	currentPoints += points;

	if (currentPoints < 0) 
		currentPoints = 0; 

	if (currentPoints > 75)
		currentPoints = 75;

	MOB.Carry[KILL_MARK].stEffect[KILL_MARK_CHAOS_POINTS].cEffect = (unsigned char)currentPoints;
}
 
void CMob::Clear()
{
	Mode = MOB_EMPTY;
	LastX = 0xFFFFFFFF;
	LastY = 0xFFFFFFFF;
	TargetX = 0;
	TargetY = 0;
	Leader = 0;
	WaitSec = 0;
	PotionCount = 0;
	Summoner = 0;
	GuildDisable = 0;
	LastReqParty = 0;
	ProcessorCounter = 0;
	ClientIndex = 0;

	memset(&Rebuy, 0, sizeof(STRUCT_REBUY));
	memset(&MOB, 0, sizeof(STRUCT_MOB));
	memset(&Tab, 0, sizeof(Tab));
	memset(&Snd, 0, sizeof(Snd));
	memset(&extra, 0, sizeof(STRUCT_MOBEXTRA));
}


# -------------------- CMob.h --------------------

/*
*   Copyright (C) {2015}  {Victor Klafke, Charles TheHouse}
*
*   This program is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program.  If not, see [http://www.gnu.org/licenses/].
*
*   Contact at: victor.klafke@ecomp.ufsm.br
*/
#ifndef __CMOB__
#define __CMOB__

#include "..\Basedef.h"

#define MAX_ENEMY 13

#define MOB_EMPTY 0  // There's no mob on the slot
#define MOB_USERDOCK    1
#define MOB_USER		2
#define MOB_IDLE        3
#define MOB_PEACE		4
#define MOB_COMBAT      5
#define MOB_RETURN		6
#define MOB_FLEE		7
#define MOB_ROAM		8
#define MOB_WAITDB		9

class CMob
{
public:
	STRUCT_MOB    MOB; // 0 - 804
	STRUCT_AFFECT Affect[MAX_AFFECT]; // 805 - 1061
	int Mode; // 1062 - 1065
	int Leader; // 1066 - 1069
    int Formation; // 1070 - 1073
	int RouteType; // 1074 - 1077
	int LastX; // 1078 - 1081
	int LastY; // 1082 - 1085
	int LastTime; // 1086 - 1089
	int LastSpeed; // 1090 - 1093
	int TargetX; // 1094 - 1097
	int TargetY; // 1098 - 1101
	int NextX; // 1102 - 1105
	int NextY; // 1106 - 1109
	int NextAction; // 1110 - 1113
	char Route[MAX_ROUTE]; // 1114 - 1137
	int WaitSec; // 1138 - 1141
	char Unk5[12]; // 1142 - 1153
	int Segment; // 1154 - 1157
	int SegmentX; // 1158 - 1161
	int SegmentY; // 1162 - 1165
	int SegmentListX[5]; // 1166 - 1185
	int SegmentListY[5]; // 1186 - 1205
	int SegmentWait[5]; // 1206 - 1225
	int SegmentRange[5]; // 1226 - 1245
	int SegmentDirection; // 1246 - 1249
	int SegmentProgress; // 1250 - 1253
	int GenerateIndex; // 1254 - 1257
	short CurrentTarget; // 1258 - 1259
	short EnemyList[MAX_ENEMY]; // 1260 - 1285
	short PartyList[MAX_PARTY]; // 1286 - 1309
	short Unk7; // 1310 - 1311
	int WeaponDamage; // 1312 - 1315
	int Summoner; // 1316 - 1319
	int PotionCount; // 1320 - 1323
	int Parry; // 1324 - 1327
	int GuildDisable; // 1328 - 1331
	int DropBonus; // 1332 - 1335
	int ExpBonus; // 1336 - 1339
	int ForceDamage; // 1340 - 1343
	int ReflectDamage;  // 1344 - 1347
	int PosX; // 1348 - 1351
	int PosY; // 1352 - 1355
	//********************
	STRUCT_MOBEXTRA extra; // 1356 - 2117

	struct
	{ 
		INT16 TotalPages;
		INT16 CurrentPage;
		LeilaoStoreAux List[MAX_SLOT_LEILAO_AUTOTRADE];
	} AutoTrade;
	BOOL IsAutoTrading;

	char Tab[36]; // 2118 - 2153
	char Snd[96]; // 2154 - 2249

	int ForceMobDamage; // 2250 - 2253
	int Accuracy; // 2254 - 2257
	int HpAbs; // 2258 - 2261

	int PvPDamage; // 2262 - 2265
	int ReflectPvP; // 2266 - 2269

	int MaxCarry; // 2270 - 2273
	int QuestFlag; // 2274 - 2277

	int LastReqParty; // 2278 - 2281
	unsigned int ProcessorCounter; // 2282 - 2285
	int IsSummon;

	int CitizenDrop; // 2286 - 2289

	short MissPlayer; // 2290 - 2291
	short DivineBlessing; // 2292 - 2293
	int RateRegen; // 2294 - 2297
	int JoiaOn;
	char sPremioNovato[10]; // 2298 - 2307

	STRUCT_REBUY Rebuy[MAX_ITEM_REBUY]; // 2308 - 2367

	short Evocations[MAX_PARTY];
	short Evocation;
	int CheckQuest;
	int CheckLojinha;
	int CheckEvento;
	int KillCount;
	
	int LanNFlag; // 2274 - 2277
	int LanMFlag; // 2274 - 2277
	int LanAFlag; // 2274 - 2277

	int PesaNFlag; // 2274 - 2277
	int PesaMFlag; // 2274 - 2277
	int PesaAFlag; // 2274 - 2277

	int AguaNFlag; // 2274 - 2277
	int AguaMFlag; // 2274 - 2277
	int AguaAFlag; // 2274 - 2277

	int CartaNFlag; // 2274 - 2277
	int CartaMFlag; // 2274 - 2277
	int CartaAFlag; // 2274 - 2277

	int CuboNFlag; // 2274 - 2277
	int CuboMFlag; // 2274 - 2277
	int CuboAFlag; // 2274 - 2277

	int FiltroID[50];
	int FiltroState;
	int AbrirPainel;

public:

	CMob();
	~CMob();

	void ProcessorSecTimer         ();
	int  StandingByProcessor       (void);
	int  BattleProcessor           ();
	void AddEnemyList              (short TargetId);
	void RemoveEnemyList	       (short TargetId);
	void SelectTargetFromEnemyList (void);
	int  SetSegment                (void);                // 1:ShipMove   0:DeleteObject
	void GetCurrentScore           (int idx); 
	void GetTargetPosDistance      (int tz);
	void GetRandomPos              ();
	void GetTargetPos              (int tz);
	int  GetTargetPos7556		   (int target);
	int  CheckGetLevel             ();
	void GetNextPos				   (int battle);
	void GetNextRandomPos		   ();
	void CGetNextRandomPos		   ();
   	int  GetEnemyFromView	       (void);
	void AddChaosPoints(int points);
	void Clear();
	int ClientIndex;
};

extern CMob pMob[MAX_MOB];
#endif

# -------------------- CNPCGene.cpp --------------------

/*
*   Copyright (C) {2015}  {Victor Klafke, Charles TheHouse}
*
*   This program is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program.  If not, see [http://www.gnu.org/licenses/].
*
*   Contact at: victor.klafke@ecomp.ufsm.br
*/
#include <Windows.h>
#include <stdio.h>
#include <string.h>
#include <string>
#include <vector>
#include <list>
#include <map>

#include "CNPCGene.h"
#include "Server.h"
#include "wMySQL.h"

using namespace std;

CNPCGenerator::CNPCGenerator()
{
	NumList = 0;
	NumRegion = 0;

	memset(pList, 0, sizeof(NPCGENLIST)* MAX_NPCGENERATOR);
	memset(pRegion, 0, sizeof(MAPREGION)* MAX_NPCGENERATOR);
}

CNPCGenerator::~CNPCGenerator()
{
}

int CNPCGenerator::ReadNPCGenerator()
{
	FILE *fp = fopen("NPCGener.new.txt", "wt");
	FILE *fs = fopen("NPCGener.txt", "rt");

	if (fs == NULL)
	{
		MessageBoxA(hWndMain, "NPCGener.txt¦í ¥", "+-¦Ô+¡ ¢Ããð", MB_OK);

		return 0;
	}

	int Num = -1;

	char tp[1024];

	memset(tp, 0, 1023);

	while (1)
	{
		char *getret = fgets(tp, 1024, fs);

		if (getret == NULL)
			break;


		if (tp[0] == 47) //'\ '
		{
			char tmp1[128];
			char tmp2[128];

			sscanf(tp, "%s %s", &tmp1, &tmp2);

			if (tmp1 && tmp2 && tmp2[0] != '*')
				fprintf(fp, "\n\n%s", &tp);
		}

		else if (tp[0] == '#')
		{
			Num++;

			for (int i = 0; i < 5; i++)
			{
				pList[Num].SegmentListX[i] = 0;
				pList[Num].SegmentListY[i] = 0;
				pList[Num].SegmentRange[i] = 0;
			}
			fprintf(fp, "// ********************************************\n");

			if (tp[1] == '*')
				fprintf(fp, "#*\t[%4d]\n", Num);

			else
				fprintf(fp, "#\t[%4d]\n", Num);
		}

		else if (tp[0] != 13)
		{
			int pars = ParseString(Num, tp);

			if (pars == 0)
				continue;

			char tmp1[128];
			char tmp2[128];

			sscanf(tp, "%s %s", &tmp1, &tmp2);

			int len = strlen(tmp1);

			if (len > 8 && tmp1[0] != 'Í')
				fprintf(fp, "\t%s\t%s\n", &tmp1, &tmp2);

			else if(tmp1[0] != 'Í')
				fprintf(fp, "\t%s\t\t%s\n", &tmp1, &tmp2);
		}
	}

	NumList = Num + 1;

	fclose(fs);
	fclose(fp);

	return 1;
}

int CNPCGenerator::ParseString(int i, char *str)
{
	char str1[128];
	str1[0] = 0;

	char str2[128];
	str2[0] = 0;

	char str3[128];
	str3[0] = 0;

	int  value = 0;
	int secondvalue = 0;

	sscanf(str, "%s %s %s", str1, str2, str3);

	if (str[0] == 47)
		return FALSE;

	if (str[0] == 0) 
		return FALSE;

	value = atoi(str2);
	secondvalue = atoi(str3);

	if (strlen(str2) > 80)
		return FALSE;


	if (!strcmp(str1, "MinuteGenerate:"))
		pList[i].MinuteGenerate = value;

	else if (!strcmp(str1, "MaxNumMob:"))
		pList[i].MaxNumMob = value;

	else if (!strcmp(str1, "MinGroup:"))
		pList[i].MinGroup = value;

	else if (!strcmp(str1, "MaxGroup:"))
		pList[i].MaxGroup = value;

	else if (!strcmp(str1, "Leader:"))
	{
		if (!strcmp(str2, "0"))
			return FALSE;

		strncpy(pList[i].Leader.MobName, str2, NAME_LENGTH);

		BOOL ret = ReadMob(&pList[i].Leader, "npc");

		if (ret == FALSE)
			MessageBox(hWndMain, str2, "Can't read NPC file in NPCGener.txt", NULL);

		else
			pList[i].Mode = MOB_USE;
	}

	else if (!strcmp(str1, "Follower:"))
	{
		if (!strcmp(str2, "0"))
			return FALSE;

		strncpy(pList[i].Follower.MobName, str2, NAME_LENGTH);

		BOOL ret = ReadMob(&pList[i].Follower, "npc");

		if (ret == FALSE)
			MessageBox(hWndMain, str2, "Can't read NPC file in NPCGener.txt", NULL);

		else
			pList[i].Mode = MOB_USE;
	}
	else if (!strcmp(str1, "RouteType:"))
		pList[i].RouteType = value;

	else if (!strcmp(str1, "Formation:"))
		pList[i].Formation = value;

	else if (!strcmp(str1, "StartWait:"))
		pList[i].SegmentWait[0] = value;

	else if (!strcmp(str1, "StartRange:"))
		pList[i].SegmentRange[0] = value;

	else if (!strcmp(str1, "StartX:"))
	{
		if(value <= 0 || value >= MAX_GRIDX)
			MessageBoxA(NULL, str1, pList[i].Leader.MobName, MB_OK);

		pList[i].SegmentListX[0] = value;
	}
	else if (!strcmp(str1, "StartY:"))
	{
		if(value <= 0 || value >= MAX_GRIDX)
			MessageBoxA(NULL, str1, pList[i].Leader.MobName, MB_OK);
		pList[i].SegmentListY[0] = value;
	}
	else if (!strcmp(str1, "DestRange:"))
		pList[i].SegmentRange[4] = value;

	else if (!strcmp(str1, "DestX:"))
		pList[i].SegmentListX[4] = value;

	else if (!strcmp(str1, "DestY:"))
		pList[i].SegmentListY[4] = value;

	else if (!strcmp(str1, "DestWait:"))
		pList[i].SegmentWait[4] = value;

	else if (!strcmp(str1, "Segment1Range:"))
		pList[i].SegmentRange[1] = value;

	else if (!strcmp(str1, "Segment1X:"))
		pList[i].SegmentListX[1] = value;

	else if (!strcmp(str1, "Segment1Y:"))
		pList[i].SegmentListY[1] = value;

	else if (!strcmp(str1, "Segment1Wait:"))
		pList[i].SegmentWait[1] = value;

	else if (!strcmp(str1, "Segment2Range:"))
		pList[i].SegmentRange[2] = value;

	else if (!strcmp(str1, "Segment2X:"))
		pList[i].SegmentListX[2] = value;

	else if (!strcmp(str1, "Segment2Y:"))
		pList[i].SegmentListY[2] = value;

	else if (!strcmp(str1, "Segment2Wait:"))
		pList[i].SegmentWait[2] = value;

	else if (!strcmp(str1, "Segment3Range:"))
		pList[i].SegmentRange[3] = value;

	else if (!strcmp(str1, "Segment3X:"))
		pList[i].SegmentListX[3] = value;

	else if (!strcmp(str1, "Segment3Y:"))
		pList[i].SegmentListY[3] = value;

	else if (!strcmp(str1, "Segment3Wait:"))
		pList[i].SegmentWait[3] = value;

	else if (!strcmp(str1, "StartAction:"))
		SetAct(pList[i].SegmentAction[0], str2);

	else if (!strcmp(str1, "Segment1Action:"))
		SetAct(pList[i].SegmentAction[1], str2);

	else if (!strcmp(str1, "Segment2Action:"))
		SetAct(pList[i].SegmentAction[2], str2);

	else if (!strcmp(str1, "Segment3Action:"))
		SetAct(pList[i].SegmentAction[3], str2);

	else
		return FALSE;

	return TRUE;
}

void CNPCGenerator::ReadRegion()
{
	FILE *fp = NULL;

	fp = fopen("Regions.txt", "rb");

	if (fp == NULL)
	{
		MessageBoxA(hWndMain, "Não foi possivel carregar regions.txt", "WARNING!", MB_OK);
		return;
	}

	while (1)
	{
		char *ret = fgets(temp, 1023, fp);

		if (ret == NULL)
			break;

		sscanf(temp, "%d, %d, %d, %d = %s", &pRegion[NumRegion].minX, &pRegion[NumRegion].minY, &pRegion[NumRegion].maxX, &pRegion[NumRegion].maxY, pRegion[NumRegion].RegionName);

		NumRegion++;
	}
	fclose(fp);
}

void CNPCGenerator::DropList()
{
	list<char*> MobList;
	int Number = 0;

	auto& pc = cSQL::instance();
	sprintf(xQuery, "TRUNCATE `droplist`");
	pc.wQuery(xQuery);

	for (int i = 0; i < NumList; i++)
	{
		int Leader = 1;
		int Follower = 1;

		for (list<char*>::iterator l = MobList.begin(); l != MobList.end(); ++l)
		{
			if (strncmp(*l, pList[i].Leader.MobName, strlen(pList[i].Leader.MobName)) == 0)
				Leader = 0;

			if (strncmp(*l, pList[i].Follower.MobName, strlen(pList[i].Leader.MobName)) == 0)
				Follower = 0;
		}

		if (Leader == 0 && Follower == 0)
			continue;

		if (pList[i].MinuteGenerate == -1)
			continue;

		STRUCT_MOB* MOB = &pList[i].Leader;

		if (MOB->Merchant != 0)
			continue;

		int EmptyMob = 0;

		for (int x = 0; x < MAX_CARRY; x++) {
			if (MOB->Carry[x].sIndex != 0)
				EmptyMob = 1;
		}

		if (EmptyMob == 0)
			continue;

		if (Leader)
		{	
			int region = 0;

			int x = mNPCGen.pList[i].SegmentListX[0];
			int y = mNPCGen.pList[i].SegmentListY[0];

			//armia
			if ((x >= 2171 && y >= 2045 && x <= 2720 && y <= 2322) ||
				(x >= 2055 && y >= 1927 && x <= 2166 && y <= 2059) ||
				(x >= 2164 && y >= 2054 && x <= 2684 && y <= 2170) ||
				(x >= 2313 && y >= 2170 && x <= 2428 && y <= 2296)) 
				region = 1;
			
			//erion
			else if (x >= 2435 && y >= 1914 && x <= 2680 && y <= 2168)
				region = 2;

			//arzan
			else if ((x >= 1788 && y >= 1538 && x <= 2185 && y <= 1785) ||
				(x >= 2180 && y >= 1533 && x <= 2435 && y <= 1787) ||
				(x >= 2187 && y >= 1155 && x <= 2298 && y <= 1297) ||
				(x >= 2179 && y >= 1293 && x <= 2295 && y <= 1534)) 
				region = 3;
			
			//deserto
			else if ((x >= 1137 && y >= 1669 && x <= 1282 && y <= 1786) ||
				(x >= 1282 && y >= 1664 && x <= 1396 && y <= 1785) ||
				(x >= 1283 && y >= 1788 && x <= 1397 && y <= 1910) ||
				(x >= 1397 && y >= 1671 && x <= 1521 && y <= 1785) ||
				(x >= 1522 && y >= 1675 && x <= 1669 && y <= 1787)) 
				region = 4;
			
			//gelo
			else if (x >= 3391 && y >= 2649 && x <= 4027 && y <= 3255)
				region = 5;

			//dungeon
			else if ((x >= 127 && y >= 3710 && x <= 767 && y <= 6841) ||
				(x >= 381 && y >= 3841 && x <= 511 && y <= 4086) ||
				(x >= 632 && y >= 3847 && x <= 1022 && y <= 4091) ||
				(x >= 898 && y >= 3712 && x <= 1143 && y <= 3830) ||
				(x >= 911 && y >= 3727 && x <= 1137 && y <= 3825)) 
				region = 6;
			
			//submundo
			else if ((x >= 1283 && y >= 3714 && x <= 1538 && y <= 3838) ||
				(x >= 1153 && y >= 3966 && x <= 1533 && y <= 4089)) 
				region = 7;
			
			//kefra
			else if ((x >= 2179 && y >= 3850 && x <= 2303 && y <= 4091) ||
				(x >= 2304 && y >= 3850 && x <= 2435 && y <= 4091) ||
				(x >= 2436 && y >= 3850 && x <= 2551 && y <= 4093)) 
				region = 8;
			
			//lan n
			else if (x >= 3581 && y >= 3583 && x <= 3705 && y <= 3705)
				region = 9;

			//lan m
			else if (x >= 3717 && y >= 3463 && x <= 3833 && y <= 3577)
				region = 10;

			//lan a
			else if (x >= 3851 && y >= 3595 && x <= 3977 && y <= 3707)
				region = 11;

			//vale
			else if (x >= 2191 && y >= 3600 && x <= 2291 && y <= 3695)
				region = 12;


			if (region != 0) {
				sprintf(xQuery, "INSERT INTO `droplist` (`nome`) VALUES ('%s')", pList[i].Leader.MobName);
				pc.wQuery(xQuery);
			}
			
			sprintf(xQuery, "UPDATE droplist SET region = '%d' WHERE nome = '%s'", region, pList[i].Leader.MobName);
			pc.wQuery(xQuery);

			int Slot = 0;

			for (int k = 0; k < MAX_CARRY; k++)
			{									
				sprintf(xQuery, "UPDATE droplist SET slot%d = '%d' WHERE nome = '%s'", k, MOB->Carry[k].sIndex, pList[i].Leader.MobName);
				pc.wQuery(xQuery);
				dListItem[Number][Slot] = MOB->Carry[k].sIndex;
				Slot++;
			}
			Number++;
			MobList.push_back(MOB->MobName);
		}
	}
}

void CNPCGenerator::UpdateDropList()
{
	list<char*> MobList;
	int Number = 0;
	
	auto& pc = cSQL::instance();

	for (int i = 0; i < NumList; i++)
	{
		int Leader = 1;
		int Follower = 1;

		for (list<char*>::iterator l = MobList.begin(); l != MobList.end(); ++l)
		{
			if (strncmp(*l, pList[i].Leader.MobName, strlen(pList[i].Leader.MobName)) == 0)
				Leader = 0;

			if (strncmp(*l, pList[i].Follower.MobName, strlen(pList[i].Leader.MobName)) == 0)
				Follower = 0;
		}

		if (Leader == 0 && Follower == 0)
			continue;

		if (pList[i].MinuteGenerate == -1)
			continue;

		STRUCT_MOB* MOB = &pList[i].Leader;

		if (MOB->Merchant != 0)
			continue;

		int EmptyMob = 0;

		for (int x = 0; x < MAX_CARRY; x++) {
			if (MOB->Carry[x].sIndex != 0)
				EmptyMob = 1;
		}

		if (EmptyMob == 0)
			continue;

		if (Leader)
		{

			int region = 0;

			int x = mNPCGen.pList[i].SegmentListX[0];
			int y = mNPCGen.pList[i].SegmentListY[0];

			//armia
			if ((x >= 2171 && y >= 2045 && x <= 2720 && y <= 2322) ||
				(x >= 2055 && y >= 1927 && x <= 2166 && y <= 2059) ||
				(x >= 2164 && y >= 2054 && x <= 2684 && y <= 2170) ||
				(x >= 2313 && y >= 2170 && x <= 2428 && y <= 2296)) 
				region = 1;
			
			//erion
			else if (x >= 2435 && y >= 1914 && x <= 2680 && y <= 2168)
				region = 2;

			//arzan
			else if ((x >= 1788 && y >= 1538 && x <= 2185 && y <= 1785) ||
				(x >= 2180 && y >= 1533 && x <= 2435 && y <= 1787) ||
				(x >= 2187 && y >= 1155 && x <= 2298 && y <= 1297) ||
				(x >= 2179 && y >= 1293 && x <= 2295 && y <= 1534)) 
				region = 3;
			
			//deserto
			else if ((x >= 1137 && y >= 1669 && x <= 1282 && y <= 1786) ||
				(x >= 1282 && y >= 1664 && x <= 1396 && y <= 1785) ||
				(x >= 1283 && y >= 1788 && x <= 1397 && y <= 1910) ||
				(x >= 1397 && y >= 1671 && x <= 1521 && y <= 1785) ||
				(x >= 1522 && y >= 1675 && x <= 1669 && y <= 1787)) 
				region = 4;
			
			//gelo
			else if (x >= 3391 && y >= 2649 && x <= 4027 && y <= 3255)
				region = 5;

			//dungeon
			else if ((x >= 127 && y >= 3710 && x <= 767 && y <= 6841) ||
				(x >= 381 && y >= 3841 && x <= 511 && y <= 4086) ||
				(x >= 632 && y >= 3847 && x <= 1022 && y <= 4091) ||
				(x >= 898 && y >= 3712 && x <= 1143 && y <= 3830) ||
				(x >= 911 && y >= 3727 && x <= 1137 && y <= 3825)) 
				region = 6;
			
			//submundo
			else if ((x >= 1283 && y >= 3714 && x <= 1538 && y <= 3838) ||
				(x >= 1153 && y >= 3966 && x <= 1533 && y <= 4089)) 
				region = 7;
			
			//kefra
			else if ((x >= 2179 && y >= 3850 && x <= 2303 && y <= 4091) ||
				(x >= 2304 && y >= 3850 && x <= 2435 && y <= 4091) ||
				(x >= 2436 && y >= 3850 && x <= 2551 && y <= 4093)) 
				region = 8;
			
			//lan n
			else if (x >= 3581 && y >= 3583 && x <= 3705 && y <= 3705)
				region = 9;

			//lan m
			else if (x >= 3717 && y >= 3463 && x <= 3833 && y <= 3577)
				region = 10;

			//lan a
			else if (x >= 3851 && y >= 3595 && x <= 3977 && y <= 3707)
				region = 11;

			//vale
			else if (x >= 2173 && y >= 3583 && x <= 2307 && y <= 3711)
				region = 12;


			sprintf(xQuery, "UPDATE droplist SET region = '%d' WHERE nome = '%s'", region, pList[i].Leader.MobName);
			pc.wQuery(xQuery);

			int Slot = 0;

			for (int k = 0; k < MAX_CARRY; k++)
			{
				if (MOB->Carry[k].sIndex != dListItem[Number][Slot]) {
					sprintf(xQuery, "UPDATE droplist SET slot%d = '%d' WHERE nome = '%s'", k, MOB->Carry[k].sIndex, pList[i].Leader.MobName);
					pc.wQuery(xQuery);
				}
				dListItem[Number][Slot] = MOB->Carry[k].sIndex;
				Slot++;
			}
			Number++;
			MobList.push_back(MOB->MobName);
		}
	}
}

//void CNPCGenerator::DropList()
//{
//	list<char*> MobList;
//	int Number = 0;
//
//	char filename[256];
//	strncpy(filename, "Zona_Desconhecida", sizeof(filename));
//	sprintf_s(temp, "./Drop/%s.txt", filename);
//	FILE* fp = fopen(temp, "a+");
//
//	for (int y = 0; y < 170; y++) {
//		for (int x = 0; x < 64; x++)
//			dListItem[y][x] = 0;
//
//		strncpy(dListMobName[y], "", 16);
//	}
//
//	for (int i = 0; i < NumList; i++)
//	{
//		int Leader = 1;
//		int Follower = 1;
//		
//		for (list<char*>::iterator l = MobList.begin(); l != MobList.end(); ++l)
//		{
//			if (strncmp(*l, pList[i].Leader.MobName, strlen(pList[i].Leader.MobName)) == 0)
//				Leader = 0;
//
//			if (strncmp(*l, pList[i].Follower.MobName, strlen(pList[i].Leader.MobName)) == 0)
//				Follower = 0;
//		}
//
//		if (Leader == 0 && Follower == 0)
//			continue;
//
//		if (pList[i].MinuteGenerate == -1)
//			continue;
//
//		STRUCT_MOB* MOB = &pList[i].Leader;
//
//		if (MOB->Merchant != 0)
//			continue;
//
//		int EmptyMob = 0;
//
//		for (int x = 0; x < MAX_CARRY; x++) {
//			if (MOB->Carry[x].sIndex != 0)
//				EmptyMob = 1;
//		}
//
//		if (EmptyMob == 0)
//			continue;
//		
//		if (Number == 169)
//			break;
//
//		if (Leader)
//		{	
//			fprintf(fp, "----------------------\n");
//			fprintf(fp, "MobName: %s, X:%d, Y:%d\n", MOB->MobName, pList[i].SegmentListX[0], pList[i].SegmentListY[0]);
//
//			int Slot = 0;
//
//			for (int k = 0; k < MAX_CARRY; k++)
//			{			
//				if (MOB->Carry[k].sIndex == 0)
//					continue;
//
//				bool Exist = false;
//				for (int z = 0; z < MAX_CARRY; z++) {
//					if (MOB->Carry[k].sIndex == dListItem[Number][z]) {
//						Exist = true;
//						break;
//					}
//				}
//
//				if (Exist)
//					continue;
//
//				dListItem[Number][Slot] = MOB->Carry[k].sIndex;
//				fprintf(fp, "%d,", MOB->Carry[k].sIndex);
//				Slot++;
//			}
//			strncpy(dListMobName[Number], MOB->MobName, 16);
//			fprintf(fp, "\nMob: %d\n", Number);
//			Number++;
//			MobList.push_back(MOB->MobName);
//		}
//	}
//	fclose(fp);
//}


void CNPCGenerator::LevelList()
{
	list<char*> MobList;

	for (int i = 0; i < NumList; i++)
	{
		int Leader = 1;
		int Follower = 1;

		for (list<char*>::iterator l = MobList.begin(); l != MobList.end(); ++l)
		{
			if (strncmp(*l, pList[i].Leader.MobName, strlen(pList[i].Leader.MobName)) == 0)
				Leader = 0;

			if (strncmp(*l, pList[i].Follower.MobName, strlen(pList[i].Leader.MobName)) == 0)
				Follower = 0;
		}

		if (Leader == 0 && Follower == 0)
			continue;

		char filename[256];

		int j = 0;

		for (j = 0; j < NumRegion; j++)
		{
			if (pList[i].SegmentListX[0] >= pRegion[j].minX && pList[i].SegmentListY[0] >= pRegion[j].minY &&
				pList[i].SegmentListX[0] <= pRegion[j].maxX && pList[i].SegmentListY[0] <= pRegion[j].maxY)
			{
				strncpy(filename, pRegion[j].RegionName, sizeof(filename));
				break;
			}
		}

		if (j == NumRegion)
			strncpy(filename, "Zona_Desconhecida", sizeof(filename));

		sprintf_s(temp, "./LevelList/%s.txt", filename);
		FILE *fp = fopen(temp, "a+");

		if (Leader)
		{
			STRUCT_MOB *MOB = &pList[i].Leader;

			fprintf(fp, "MobName: %s Level:%d\r\n\n", MOB->MobName, MOB->BaseScore.Level);

			fputs("\r\n", fp);

			MobList.push_back(MOB->MobName);
		}

		for (list<char*>::iterator l = MobList.begin(); l != MobList.end(); ++l)
		{
			if (strncmp(*l, pList[i].Follower.MobName, strlen(pList[i].Leader.MobName)) == 0)
				Follower = 0;
		}

		if (Follower)
		{
			STRUCT_MOB *MOB = &pList[i].Follower;

			fprintf(fp, "MobName: %s Level:%d\r\n\n", MOB->MobName, MOB->BaseScore.Level);

			fputs("\r\n", fp);

			MobList.push_back(MOB->MobName);
		}

		fclose(fp);
	}
}


CNPCSummon::CNPCSummon()
{
}

CNPCSummon::~CNPCSummon()
{
}

void CNPCSummon::Initialize()
{
	int MobFound = 0;

	BASE_InitModuleDir();

	strncpy((char*)Mob[0].MobName, "Condor", sizeof(Mob[0].MobName));

	MobFound = ReadMob(&Mob[0], "BaseSummon");

	if (!MobFound)
		MessageBoxA(hWndMain, Mob[0].MobName, "Can't read NPC 0", MB_OK);

	strncpy((char*)Mob[1].MobName, "Javali", sizeof(Mob[1].MobName));

	MobFound = ReadMob(&Mob[1], "BaseSummon");

	if (!MobFound)
		MessageBoxA(hWndMain, Mob[1].MobName, "Can't read NPC 1", MB_OK);

	strncpy((char*)Mob[2].MobName, "Lobo", sizeof(Mob[2].MobName));

	MobFound = ReadMob(&Mob[2], "BaseSummon");

	if (!MobFound)
		MessageBoxA(hWndMain, Mob[2].MobName, "Can't read NPC 2", MB_OK);

	strncpy((char*)Mob[3].MobName, "Urso", sizeof(Mob[3].MobName));

	MobFound = ReadMob(&Mob[3], "BaseSummon");

	if (!MobFound)
		MessageBoxA(hWndMain, Mob[3].MobName, "Can't read NPC 3", MB_OK);

	strncpy((char*)Mob[4].MobName, "Tigre", sizeof(Mob[4].MobName));

	MobFound = ReadMob(&Mob[4], "BaseSummon");

	if (!MobFound)
		MessageBoxA(hWndMain, Mob[4].MobName, "Can't read NPC 4", MB_OK);

	strncpy((char*)Mob[5].MobName, "Gorila", sizeof(Mob[5].MobName));

	MobFound = ReadMob(&Mob[5], "BaseSummon");

	if (!MobFound)
		MessageBoxA(hWndMain, Mob[5].MobName, "Can't read NPC 5", MB_OK);

	strncpy((char*)Mob[6].MobName, "Dragao_Negro", sizeof(Mob[6].MobName));

	MobFound = ReadMob(&Mob[6], "BaseSummon");

	if (!MobFound)
		MessageBoxA(hWndMain, Mob[6].MobName, "Can't read NPC 6", MB_OK);

	strncpy((char*)Mob[7].MobName, "Succubus", sizeof(Mob[7].MobName));

	MobFound = ReadMob(&Mob[7], "BaseSummon");

	if (!MobFound)
		MessageBoxA(hWndMain, Mob[7].MobName, "Can't read NPC 7", MB_OK);

	strncpy((char*)Mob[8].MobName, "Porco", sizeof(Mob[8].MobName));

	MobFound = ReadMob(&Mob[8], "BaseSummon");

	if (!MobFound)
		MessageBoxA(hWndMain, Mob[8].MobName, "Can't read NPC 8", MB_OK);

	strncpy((char*)Mob[9].MobName, "Javali_", sizeof(Mob[9].MobName));

	MobFound = ReadMob(&Mob[9], "BaseSummon");

	if (!MobFound)
		MessageBoxA(hWndMain, Mob[9].MobName, "Can't read NPC 9", MB_OK);

	strncpy((char*)Mob[10].MobName, "Porco", sizeof(Mob[10].MobName));

	MobFound = ReadMob(&Mob[10], "BaseSummon");

	if (!MobFound)
		MessageBoxA(hWndMain, Mob[10].MobName, "Can't read NPC 10", MB_OK);

	strncpy((char*)Mob[11].MobName, "Javali", sizeof(Mob[11].MobName));

	MobFound = ReadMob(&Mob[11], "BaseSummon");

	if (!MobFound)
		MessageBoxA(hWndMain, Mob[11].MobName, "Can't read NPC 11", MB_OK);

	strncpy((char*)Mob[12].MobName, "Lobo", sizeof(Mob[12].MobName));

	MobFound = ReadMob(&Mob[12], "BaseSummon");

	if (!MobFound)
		MessageBoxA(hWndMain, Mob[12].MobName, "Can't read NPC 12", MB_OK);

	strncpy((char*)Mob[13].MobName, "Dragao_menor", sizeof(Mob[13].MobName));

	MobFound = ReadMob(&Mob[13], "BaseSummon");

	if (!MobFound)
		MessageBoxA(hWndMain, Mob[13].MobName, "Can't read NPC 13", MB_OK);

	strncpy((char*)Mob[14].MobName, "Urso", sizeof(Mob[14].MobName));

	MobFound = ReadMob(&Mob[14], "BaseSummon");

	if (!MobFound)
		MessageBoxA(hWndMain, Mob[14].MobName, "Can't read NPC 14", MB_OK);

	strncpy((char*)Mob[15].MobName, "Dente_de_Sabre", sizeof(Mob[15].MobName));

	MobFound = ReadMob(&Mob[15], "BaseSummon");

	if (!MobFound)
		MessageBoxA(hWndMain, Mob[15].MobName, "Can't read NPC 15", MB_OK);

	strncpy((char*)Mob[16].MobName, "Sem_Sela_N", sizeof(Mob[16].MobName));

	MobFound = ReadMob(&Mob[16], "BaseSummon");

	if (!MobFound)
		MessageBoxA(hWndMain, Mob[16].MobName, "Can't read NPC 16", MB_OK);

	strncpy((char*)Mob[17].MobName, "Fantasma_N", sizeof(Mob[17].MobName));

	MobFound = ReadMob(&Mob[17], "BaseSummon");

	if (!MobFound)
		MessageBoxA(hWndMain, Mob[17].MobName, "Can't read NPC 17", MB_OK);

	strncpy((char*)Mob[18].MobName, "Leve_N", sizeof(Mob[18].MobName));

	MobFound = ReadMob(&Mob[18], "BaseSummon");

	if (!MobFound)
		MessageBoxA(hWndMain, Mob[18].MobName, "Can't read NPC 18", MB_OK);

	strncpy((char*)Mob[19].MobName, "Equip_N", sizeof(Mob[19].MobName));

	MobFound = ReadMob(&Mob[19], "BaseSummon");

	if (!MobFound)
		MessageBoxA(hWndMain, Mob[19].MobName, "Can't read NPC 19", MB_OK);

	strncpy((char*)Mob[20].MobName, "Andaluz_N", sizeof(Mob[20].MobName));

	MobFound = ReadMob(&Mob[20], "BaseSummon");

	if (!MobFound)
		MessageBoxA(hWndMain, Mob[20].MobName, "Can't read NPC 20", MB_OK);

	strncpy((char*)Mob[21].MobName, "Sem_Sela_B", sizeof(Mob[21].MobName));

	MobFound = ReadMob(&Mob[21], "BaseSummon");

	if (!MobFound)
		MessageBoxA(hWndMain, Mob[21].MobName, "Can't read NPC 21", MB_OK);

	strncpy((char*)Mob[22].MobName, "Fantasma_B", sizeof(Mob[22].MobName));

	MobFound = ReadMob(&Mob[22], "BaseSummon");

	if (!MobFound)
		MessageBoxA(hWndMain, Mob[22].MobName, "Can't read NPC 22", MB_OK);

	strncpy((char*)Mob[23].MobName, "Leve_B", sizeof(Mob[23].MobName));

	MobFound = ReadMob(&Mob[23], "BaseSummon");

	if (!MobFound)
		MessageBoxA(hWndMain, Mob[23].MobName, "Can't read NPC 23", MB_OK);

	strncpy((char*)Mob[24].MobName, "Equip_B", sizeof(Mob[24].MobName));

	MobFound = ReadMob(&Mob[24], "BaseSummon");

	if (!MobFound)
		MessageBoxA(hWndMain, Mob[24].MobName, "Can't read NPC 24", MB_OK);

	strncpy((char*)Mob[25].MobName, "Andaluz_B", sizeof(Mob[25].MobName));

	MobFound = ReadMob(&Mob[25], "BaseSummon");

	if (!MobFound)
		MessageBoxA(hWndMain, Mob[25].MobName, "Can't read NPC 25", MB_OK);

	strncpy((char*)Mob[26].MobName, "Fenrir", sizeof(Mob[26].MobName));

	MobFound = ReadMob(&Mob[26], "BaseSummon");

	if (!MobFound)
		MessageBoxA(hWndMain, Mob[26].MobName, "Can't read NPC 26", MB_OK);

	strncpy((char*)Mob[27].MobName, "Dragao", sizeof(Mob[27].MobName));

	MobFound = ReadMob(&Mob[27], "BaseSummon");

	if (!MobFound)
		MessageBoxA(hWndMain, Mob[27].MobName, "Can't read NPC 27", MB_OK);

	strncpy((char*)Mob[28].MobName, "FenrirSombra", sizeof(Mob[28].MobName));

	MobFound = ReadMob(&Mob[28], "BaseSummon");

	if (!MobFound)
		MessageBoxA(hWndMain, Mob[28].MobName, "Can't read NPC 28", MB_OK);

	strncpy((char*)Mob[29].MobName, "Tigre_de_Fogo", sizeof(Mob[29].MobName));

	MobFound = ReadMob(&Mob[29], "BaseSummon");

	if (!MobFound)
		MessageBoxA(hWndMain, Mob[29].MobName, "Can't read NPC 29", MB_OK);

	strncpy((char*)Mob[30].MobName, "Dragao_Vermelho", sizeof(Mob[30].MobName));

	MobFound = ReadMob(&Mob[30], "BaseSummon");

	if (!MobFound)
		MessageBoxA(hWndMain, Mob[30].MobName, "Can't read NPC 30", MB_OK);

	strncpy((char*)Mob[31].MobName, "Unicornio", sizeof(Mob[31].MobName));

	MobFound = ReadMob(&Mob[31], "BaseSummon");

	if (!MobFound)
		MessageBoxA(hWndMain, Mob[31].MobName, "Can't read NPC 31", MB_OK);

	strncpy((char*)Mob[32].MobName, "Pegasus", sizeof(Mob[32].MobName));

	MobFound = ReadMob(&Mob[32], "BaseSummon");

	if (!MobFound)
		MessageBoxA(hWndMain, Mob[32].MobName, "Can't read NPC 32", MB_OK);

	strncpy((char*)Mob[33].MobName, "Unisus", sizeof(Mob[33].MobName));

	MobFound = ReadMob(&Mob[33], "BaseSummon");

	if (!MobFound)
		MessageBoxA(hWndMain, Mob[33].MobName, "Can't read NPC 33", MB_OK);

	strncpy((char*)Mob[34].MobName, "Grifo", sizeof(Mob[34].MobName));

	MobFound = ReadMob(&Mob[34], "BaseSummon");

	if (!MobFound)
		MessageBoxA(hWndMain, Mob[34].MobName, "Can't read NPC 34", MB_OK);

	strncpy((char*)Mob[35].MobName, "Hipogrifo", sizeof(Mob[35].MobName));

	MobFound = ReadMob(&Mob[35], "BaseSummon");

	if (!MobFound)
		MessageBoxA(hWndMain, Mob[35].MobName, "Can't read NPC 35", MB_OK);

	strncpy((char*)Mob[36].MobName, "Grifo_Sangrento", sizeof(Mob[36].MobName));

	MobFound = ReadMob(&Mob[36], "BaseSummon");

	if (!MobFound)
		MessageBoxA(hWndMain, Mob[36].MobName, "Can't read NPC 36", MB_OK);

	strncpy((char*)Mob[37].MobName, "Svadilfire", sizeof(Mob[37].MobName));

	MobFound = ReadMob(&Mob[37], "BaseSummon");

	if (!MobFound)
		MessageBoxA(hWndMain, Mob[37].MobName, "Can't read NPC 37", MB_OK);

	strncpy((char*)Mob[38].MobName, "Sleipnir", sizeof(Mob[38].MobName));

	MobFound = ReadMob(&Mob[38], "BaseSummon");

	if (!MobFound)
		MessageBoxA(hWndMain, Mob[38].MobName, "Can't read NPC 38", MB_OK);

	strncpy((char*)Mob[39].MobName, "Pantera_Negra", sizeof(Mob[39].MobName));

	MobFound = ReadMob(&Mob[39], "BaseSummon");

	if (!MobFound)
		MessageBoxA(hWndMain, Mob[39].MobName, "Can't read NPC 39", MB_OK);

	strncpy((char*)Mob[40].MobName, "VeridFinal", sizeof(Mob[40].MobName));

	MobFound = ReadMob(&Mob[40], "BaseSummon");

	if (!MobFound)
		MessageBoxA(hWndMain, Mob[40].MobName, "Can't read NPC 40", MB_OK);
}

void SetAct(char *dest, char *act)
{
	if (strlen(act) >= 79)
	{
		MessageBox(hWndMain, act, "NPC Generater's Action can't be larger than 80.", NULL);

		return;
	}

	strcpy(dest, act);
}

# -------------------- CNPCGene.h --------------------

/*
*   Copyright (C) {2015}  {Victor Klafke, Charles TheHouse}
*
*   This program is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program.  If not, see [http://www.gnu.org/licenses/].
*
*   Contact at: victor.klafke@ecomp.ufsm.br
*/
#ifndef __CNPCGENE__
#define __CNPCGENE__

#include "..\Basedef.h"

#define MOB_FREE 0
#define MOB_USE 1

#define MAX_SEGMENT 5

struct NPCGENLIST // BDEA94
{
	int  Mode; //  0 - 3
	int  MinuteGenerate;  // 4 - 7
	int  MaxNumMob;     // 8 - 11
	int  CurrentNumMob;     // 12 - 15
	int  MinGroup;     // 16 - 19
	int  MaxGroup;     // 20 - 23
	int  SegmentListX[MAX_SEGMENT]; // 24
	int  SegmentListY[MAX_SEGMENT]; 
	int  SegmentRange[MAX_SEGMENT]; 
	int  SegmentWait[MAX_SEGMENT]; 
	char SegmentAction[MAX_SEGMENT][80]; 
	char FightAction[4][80]; 
	char FleeAction[4][80];
	char DieAction[4][80];
	int  Formation;
	int  RouteType;
	int	 Offset;

	STRUCT_MOB   Leader;                    // ¸¿ÀÇ ¼¼ºÎ ³»¿ë.
	STRUCT_MOB   Follower;                  // ¶Ê¸¶´Ï ¼¼ºÎ³»¿ë
};

struct MAPREGION
{
	int minX;
	int minY;
	int maxX;
	int maxY;

	char RegionName[128];
};

class CNPCSummon
{	
public:
	STRUCT_MOB Mob[MAX_SUMMONLIST];

public:

	CNPCSummon(); 
	~CNPCSummon();
	void Initialize();	
};

class CNPCGenerator 
{	
public:

	NPCGENLIST pList [MAX_NPCGENERATOR];
	int NumOld		 [MAX_NPCGENERATOR];
	int NumList;

	MAPREGION pRegion[MAX_NPCGENERATOR];
	int NumRegion;

public:

	CNPCGenerator();  
	~CNPCGenerator();

	int  ReadNPCGenerator();
	int  ParseString(int i, char *str);
	void ReadRegion();
	void DropList();
	void UpdateDropList();
	void LevelList();
};

void SetAct(char *dest, char *act);


#endif

# -------------------- CReadFiles.cpp --------------------

/*
*   Copyright (C) {2015}  {Victor Klafke, Charles TheHouse}
*
*   This program is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program.  If not, see [http://www.gnu.org/licenses/].
*
*   Contact at: victor.klafke@ecomp.ufsm.br
*/
#include <Windows.h>
#include <stdio.h>
#include <fcntl.h>
#include <time.h>
#include <math.h>
#include <io.h>
#include <errno.h>

#include "..\Basedef.h"
#include "..\CPSock.h"
#include "..\ItemEffect.h"

#include "CReadFiles.h"
#include "Server.h"
#include "Language.h"

const char* const CReadFiles::SANC_RATE_PATH = "../../Common/Settings/SancRate.txt";
const char* const CReadFiles::QUESTS_RATE_PATH = "../../Common/Settings/QuestsRate.txt";
const char* const CReadFiles::COMP_RATE_PATH = "../../Common/Settings/CompRate.txt";
const char* const CReadFiles::MOB_MERC_PATH = "../../Common/Settings/MobMerc.txt";
const char* const CReadFiles::ADMIN_PATH = "../../DBSRV/Run/Admin.txt";
const char* const CReadFiles::MAC_BLOCK_PATH = "../../DBSRV/Run/Mac.txt";
const char* const CReadFiles::CHALL_PATH = "../../Common/Chall_%2.2d_%2.2d.txt";
const char* const CReadFiles::GUILD_PATH = "../../Common/Guild_%2.2d_%2.2d.txt";
const char* const CReadFiles::GUILDCHAMP_PATH = "../../Common/ChampionCity_%2.2d_%2.2d.csv";


int CReadFiles::QuestCoin[5] = { 2000, 2500, 3000, 3750, 47500 };

int CReadFiles::QuestExp[5][2] =
{
	{ 5000, 5000 },
	{ 10000, 10000 },
	{ 50000, 50000 },
	{ 100000, 100000 },
	{ 200000, 200000 }
};

int CReadFiles::QuestLevel[5][4] =
{
	{ 39, 115, 39, 115 },
	{ 115, 190, 115, 190 },
	{ 190, 265, 190, 265 },
	{ 265, 320, 265, 320 },
	{ 320, 350, 320, 350 }
};

CReadFiles::CReadFiles()
{
	ReadSancRate();	
	ReadQuestsRate();
	ReadCompRate();
	ReadAdmin();
	ReadMacblock();
	ReadChallanger();
	ReadGuild();
}

void CReadFiles::ReadSancRate()
{
	FILE *fp = NULL;

	fp = fopen(SANC_RATE_PATH, "r");

	if (fp == NULL)
	{
		MessageBoxA(hWndMain, "Não foi possivel encontrar o arquivo.", SANC_RATE_PATH, MB_OK);
		return;
	}

	while (1)
	{
		char *ret = fgets(temp, 1023, fp);

		if (ret == NULL)
			break;

		char str1[128];
		char str2[128];
		char str3[128];
		// char str4[128];

		sscanf(temp, "%s %s %s", str1, str2, str3);

		int val1 = atoi(str1);
		int val2 = atoi(str2);
		int val3 = atoi(str3);

		_strupr(str1);

		if (strcmp(str1, "PO") == 0)
		{
			if (val2 < 0 || val2 >= 12)
			{
				MessageBoxA(hWndMain, "Índice inválido. (1)", SANC_RATE_PATH, MB_OK);
				continue;
			}

			if (val3 < 0 || val3 > 100)
			{
				MessageBoxA(hWndMain, "Índice inválido. (2)", SANC_RATE_PATH, MB_OK);
				continue;
			}

			g_pSancRate[0][val2] = val3;
		}

		else if (strcmp(str1, "PL") == 0)
		{
			if (val2 < 0 || val2 >= 12)
			{
				MessageBoxA(hWndMain, "Índice inválido. (1)", SANC_RATE_PATH, MB_OK);
				continue;
			}

			if (val3 < 0 || val3 > 100)
			{
				MessageBoxA(hWndMain, "Índice inválido. (2)", SANC_RATE_PATH, MB_OK);
				continue;
			}

			g_pSancRate[1][val2] = val3;
		}

		else if (strcmp(str1, "ÂMAGO") == 0)
		{
			if (val2 < 0 || val2 >= 12)
			{
				MessageBoxA(hWndMain, "Índice inválido. (1)", SANC_RATE_PATH, MB_OK);
				continue;
			}

			if (val3 < 0 || val3 > 100)
			{
				MessageBoxA(hWndMain, "Índice inválido. (2)", SANC_RATE_PATH, MB_OK);
				continue;
			}

			g_pSancRate[0][val2] = val3;
		}

		else if (strcmp(str1, "PO_A") == 0)
		{
			if (val2 < 0 || val2 > 9)
			{
				MessageBoxA(hWndMain, "Índice inválido. (1)", SANC_RATE_PATH, MB_OK);
				continue;
			}

			g_pSancGrade[0][0] = val2;
		}

		else if (strcmp(str1, "PO_B") == 0)
		{
			if (val2 < 0 || val2 > 9)
			{
				MessageBoxA(hWndMain, "Índice inválido. (1)", SANC_RATE_PATH, MB_OK);
				continue;
			}

			g_pSancGrade[0][1] = val2;
		}

		else if (strcmp(str1, "PO_C") == 0)
		{
			if (val2 < 0 || val2 > 9)
			{
				MessageBoxA(hWndMain, "Índice inválido. (1)", SANC_RATE_PATH, MB_OK);
				continue;
			}

			g_pSancGrade[0][2] = val2;
		}

		else if (strcmp(str1, "PO_D") == 0)
		{
			if (val2 < 0 || val2 > 9)
			{
				MessageBoxA(hWndMain, "Índice inválido. (1)", SANC_RATE_PATH, MB_OK);
				continue;
			}

			g_pSancGrade[0][3] = val2;
		}

		else if (strcmp(str1, "PO_E") == 0)
		{
			if (val2 < 0 || val2 > 9)
			{
				MessageBoxA(hWndMain, "Índice inválido. (1)", SANC_RATE_PATH, MB_OK);
				continue;
			}

			g_pSancGrade[0][4] = val2;
		}

		else if (strcmp(str1, "PL_A") == 0)
		{
			if (val2 < 0 || val2 > 9)
			{
				MessageBoxA(hWndMain, "Índice inválido. (1)", SANC_RATE_PATH, MB_OK);
				continue;
			}

			g_pSancGrade[1][0] = val2;
		}

		else if (strcmp(str1, "PL_B") == 0)
		{
			if (val2 < 0 || val2 > 9)
			{
				MessageBoxA(hWndMain, "Índice inválido. (1)", SANC_RATE_PATH, MB_OK);
				continue;
			}

			g_pSancGrade[1][1] = val2;
		}

		else if (strcmp(str1, "PL_C") == 0)
		{
			if (val2 < 0 || val2 > 9)
			{
				MessageBoxA(hWndMain, "Índice inválido. (1)", SANC_RATE_PATH, MB_OK);
				continue;
			}

			g_pSancGrade[1][2] = val2;
		}

		else if (strcmp(str1, "PL_D") == 0)
		{
			if (val2 < 0 || val2 > 9)
			{
				MessageBoxA(hWndMain, "Índice inválido. (1)", SANC_RATE_PATH, MB_OK);
				continue;
			}

			g_pSancGrade[1][3] = val2;
		}

		else if (strcmp(str1, "PL_E") == 0)
		{
			if (val2 < 0 || val2 > 9)
			{
				MessageBoxA(hWndMain, "Índice inválido. (1)", SANC_RATE_PATH, MB_OK);
				continue;
			}

			g_pSancGrade[1][4] = val2;
		}
	}

	fclose(fp);
}

void CReadFiles::ReadQuestsRate()
{
	FILE *fp = NULL;

	fp = fopen(QUESTS_RATE_PATH, "r");

	if (fp == NULL)
	{
		MessageBoxA(hWndMain, "Não foi possivel encontrar o arquivo.", QUESTS_RATE_PATH, MB_OK);
		return;
	}

	while (1)
	{
		char *ret = fgets(temp, 1023, fp);

		if (ret == NULL)
			break;

		char str1[128];
		char str2[128];
		char str3[128];
		char str4[128];
		char str5[128];
		char str6[128];

		sscanf(temp, "%s %s %s %s %s %s", str1, str2, str3, str4, str5, str6);

		int val1 = atoi(str1);
		int val2 = atoi(str2);
		int val3 = atoi(str3);
		int val4 = atoi(str4);
		int val5 = atoi(str5);
		int val6 = atoi(str6);

		_strupr(str1);

		if (strcmp(str1, "EXP") == 0)
		{
			if (val2 < 0 || val2 >= 5)
			{
				MessageBoxA(hWndMain, "Índice inválido. (1)", QUESTS_RATE_PATH, MB_OK);
				continue;
			}

			if (val3 < 0 || val3 >= 2000000000 || val4 < 0 || val4 >= 2000000000)
			{
				MessageBoxA(hWndMain, "Índice inválido. (2)", QUESTS_RATE_PATH, MB_OK);
				continue;
			}

			QuestExp[val2][0] = val3;
			QuestExp[val2][1] = val4;
		}

		else if (strcmp(str1, "COIN") == 0)
		{
			if (val2 < 0 || val2 >= 5)
			{
				MessageBoxA(hWndMain, "Índice inválido. (1)", QUESTS_RATE_PATH, MB_OK);
				continue;
			}

			if (val3 < 0 || val3 > 2000000000)
			{
				MessageBoxA(hWndMain, "Índice inválido. (2)", QUESTS_RATE_PATH, MB_OK);
				continue;
			}

			QuestCoin[val2] = val3;
		}

		else if (strcmp(str1, "LEVEL") == 0)
		{
			if (val2 < 0 || val2 >= 5)
			{
				MessageBoxA(hWndMain, "Índice inválido. (1)", QUESTS_RATE_PATH, MB_OK);
				continue;
			}
			int minLv = val3;
			int maxLv = val4;
			int minLv2 = val5;
			int maxLv2 = val6;


			if (minLv < 0 || minLv >= 400 || maxLv < 0 || maxLv >= 400 || minLv2 < 0 || minLv2 >= 400 || maxLv2 < 0 || maxLv2 >= 400)
			{
				MessageBoxA(hWndMain, "Índice inválido. (2)", QUESTS_RATE_PATH, MB_OK);
				continue;
			}

			QuestLevel[val2][0] = minLv;
			QuestLevel[val2][1] = maxLv;
			QuestLevel[val2][2] = minLv2;
			QuestLevel[val2][3] = maxLv2;
		}
	}

	fclose(fp);
}

void CReadFiles::ReadCompRate()
{
	FILE *fp = NULL;

	fp = fopen(COMP_RATE_PATH, "r");

	if (fp == NULL)
	{
		MessageBoxA(hWndMain, "Não foi possivel encontrar o arquivo.", COMP_RATE_PATH, MB_OK);
		return;
	}

	while (1)
	{
		char *ret = fgets(temp, 1023, fp);

		if (ret == NULL)
			break;

		char str1[128];
		char str2[128];
		char str3[128];
		// char str4[128];

		sscanf(temp, "%s %s %s", str1, str2, str3);

		int val1 = atoi(str1);
		int val2 = atoi(str2);
		int val3 = atoi(str3);

		_strupr(str1);

		if (strcmp(str1, "EHRE") == 0)
		{
			if (val3 < 0 || val3 > 100)
			{
				MessageBoxA(hWndMain, "Índice inválido. (1)", COMP_RATE_PATH, MB_OK);
				continue;
			}

			if (strcmp(str2, "PACOTE_ORI") == 0)
				g_pEhreRate[1] = val3;
			
			else if (strcmp(str2, "MISTERIOSA") == 0)
				g_pEhreRate[2] = val3;
			
			else if (strcmp(str2, "ESPIRITUAL") == 0)
				g_pEhreRate[3] = val3;
			
			else if (strcmp(str2, "AMUNRA") == 0)
				g_pEhreRate[4] = val3;
			
			else if (strcmp(str2, "TRAJE_MONTARIA") == 0)
				g_pEhreRate[6] = val3;
			
			else if (strcmp(str2, "RETIRAR_TRAJE_MONTARIA") == 0)
				g_pEhreRate[7] = val3;

			else if (strcmp(str2, "SOUL") == 0)
				g_pEhreRate[8] = val3;
		}

		else if (strcmp(str1, "DEDEKINTO") == 0)
		{
			if (val3 < 0 || val3 > 100)
			{
				MessageBoxA(hWndMain, "Índice inválido. (1)", COMP_RATE_PATH, MB_OK);
				continue;
			}

			if (strcmp(str2, "PEDRA_AMUNRA") == 0)
				g_pDedekintoRate[1] = val3;
			
			else if (strcmp(str2, "PROTECAO_DIVINA") == 0)
				g_pDedekintoRate[2] = val3;
		}

		else if (strcmp(str1, "TINY") == 0)
		{
			if (val3 < 0 || val3 > 100)
			{
				MessageBoxA(hWndMain, "Índice inválido. (1)", COMP_RATE_PATH, MB_OK);
				continue;
			}

			if (strcmp(str2, "CHANCEBASE") == 0)
				g_pTinyBase = val3;
		}

		else if (strcmp(str1, "SHANY") == 0)
		{
			if (val3 < 0 || val3 > 100)
			{
				MessageBoxA(hWndMain, "Índice inválido. (1)", COMP_RATE_PATH, MB_OK);
				continue;
			}

			if (strcmp(str2, "CHANCEBASE") == 0)
				g_pShanyBase = val3;
		}

		else if (strcmp(str1, "AILYN") == 0)
		{
			if (val3 < 0 || val3 > 100)
			{
				MessageBoxA(hWndMain, "Índice inválido. (1)", COMP_RATE_PATH, MB_OK);
				continue;
			}

			if (strcmp(str2, "CHANCEBASE") == 0)
				g_pAilynBase = val3;
		}

		else if (strcmp(str1, "AGATHA") == 0)
		{
			if (val3 < 0 || val3 > 100)
			{
				MessageBoxA(hWndMain, "Índice inválido. (1)", COMP_RATE_PATH, MB_OK);
				continue;
			}

			if (strcmp(str2, "CHANCEBASE") == 0)
				g_pAgathaBase = val3;
		}

		else if (strcmp(str1, "ODIN") == 0)
		{
			if (val3 < 0 || val3 > 100)
			{
				MessageBoxA(hWndMain, "Índice inválido. (1)", COMP_RATE_PATH, MB_OK);
				continue;
			}

			if (strcmp(str2, "ITEM_CELESTIAL") == 0)
				g_pOdinRate[1] = val3;

			else if (strcmp(str2, "ITEM_12_SECRETA") == 0)
				g_pItemSancRate12[0] = val3;

			else if (strcmp(str2, "ITEM_12_REF_0") == 0)
				g_pItemSancRate12[1] = val3;

			else if (strcmp(str2, "ITEM_12_REF_1") == 0)
				g_pItemSancRate12[2] = val3;

			else if (strcmp(str2, "ITEM_12_REF_2") == 0)
				g_pItemSancRate12[3] = val3;

			else if (strcmp(str2, "ITEM_12_REF_3") == 0)
				g_pItemSancRate12[4] = val3;

			else if (strcmp(str2, "ITEM_12_REF_4") == 0)
				g_pItemSancRate12[5] = val3;

			else if (strcmp(str2, "ITEM_12_REF_5") == 0)
				g_pItemSancRate12[6] = val3;

			else if (strcmp(str2, "ITEM_12_REF_6") == 0)
				g_pItemSancRate12[7] = val3;

			else if (strcmp(str2, "ITEM_12_REF_7") == 0)
				g_pItemSancRate12[8] = val3;

			else if (strcmp(str2, "ITEM_12_REF_8") == 0)
				g_pItemSancRate12[9] = val3;

			else if (strcmp(str2, "ITEM_12_REF_9") == 0)
				g_pItemSancRate12[10] = val3;

			else if (strcmp(str2, "ITEM_12_MINUS_12") == 0)
				g_pItemSancRate12Minus[0] = val3;

			else if (strcmp(str2, "ITEM_12_MINUS_13") == 0)
				g_pItemSancRate12Minus[1] = val3;

			else if (strcmp(str2, "ITEM_12_MINUS_14") == 0)
				g_pItemSancRate12Minus[2] = val3;

			else if (strcmp(str2, "ITEM_12_MINUS_15") == 0)
				g_pItemSancRate12Minus[3] = val3;

			else if (strcmp(str2, "PISTA") == 0)
				g_pOdinRate[3] = val3;

			else if (strcmp(str2, "DESTRAVE_LV40") == 0)
				g_pOdinRate[4] = val3;

			else if (strcmp(str2, "PEDRA_DA_FURIA") == 0)
				g_pOdinRate[5] = val3;

			else if (strcmp(str2, "SECRETA_AGUA") == 0)
				g_pOdinRate[6] = val3;

			else if (strcmp(str2, "SECRETA_TERRA") == 0)
				g_pOdinRate[7] = val3;

			else if (strcmp(str2, "SECRETA_SOL") == 0)
				g_pOdinRate[8] = val3;

			else if (strcmp(str2, "SECRETA_VENTO") == 0)
				g_pOdinRate[9] = val3;

			else if (strcmp(str2, "SEMENTE_CRISTAL") == 0)
				g_pOdinRate[10] = val3;

			else if (strcmp(str2, "CAPA_CELESTIAL") == 0)
				g_pOdinRate[11] = val3;
		}

		else if (strcmp(str1, "COMPOSITOR") == 0)
		{
			if (val3 < 0 || val3 > 100)
			{
				MessageBoxA(hWndMain, "Índice inválido. (1)", COMP_RATE_PATH, MB_OK);
				continue;
			}

			if (strcmp(str2, "ITEM_+7") == 0)
				g_pAnctChance[0] = val3;
			
			else if (strcmp(str2, "ITEM_+8") == 0)
				g_pAnctChance[1] = val3;
			
			else if (strcmp(str2, "ITEM_+9") == 0)
				g_pAnctChance[2] = val3;
		}
	}

	fclose(fp);
}

void CReadFiles::ReadMobMerc()
{
	FILE *fs = fopen(MOB_MERC_PATH, "rt");

	if (fs == NULL)
	{
		MessageBoxA(hWndMain, "MobMerc.txt não foi encontrado.", MOB_MERC_PATH, MB_OK);

		return;
	}

	int Num = -1;

	char tp[1024];

	memset(tp, 0, 1023);

	while (1)
	{
		char *getret = fgets(tp, 1024, fs);

		if (getret == NULL)
			break;


		if (tp[0] == 47) //'\ '
			continue;

		else if (tp[0] == '#')
		{
			if (Num >= MAX_MOB_MERC)
				break;

			Num++;

			memset(&pMobMerc[Num], 0, sizeof(STRUCT_MERC));
		}

		else if (tp[0] != 13)
		{
			int pars = ParseMobMercString(Num, tp);

			if (pars == 0)
				continue;
		}
	}
	fclose(fs);
}

void CReadFiles::ReadAdmin()
{
	char ttt[256];

	FILE *fp = fopen(ADMIN_PATH, "r");

	if (fp == NULL)
		return;

	while (1)
	{
		int a, b, c, d;
		a = b = c = d = 0;

		char * ret = fgets((char*)ttt, 127, fp);

		if (ret == NULL)
			break;

		int idx = -1;

		for (int i = 0; i < 255; i++)
			if (ttt[i] == '.')
				ttt[i] = ' ';

		sscanf(ttt, "%d %d %d %d %d", &idx, &a, &b, &c, &d);

		unsigned int ip = (d << 24) + (c << 16) + (b << 8) + a;

		if (idx < 0 || idx >= MAX_ADMIN)
			continue;

		pAdminIP[idx] = ip;
	};

	fclose(fp);
}

void CReadFiles::ReadMacblock()
{
	char ttt[256];
	char tt_mac[256];
	FILE* fp = fopen(MAC_BLOCK_PATH, "r");

	if (fp == NULL)
		return;

	while (1)
	{
		int a, b, c, d;
		a = b = c = d = 0;

		char* ret = fgets((char*)ttt, 127, fp);

		if (ret == NULL)
			break;

		int idx = -1;

		for (int i = 0; i < 255; i++)
			if (ttt[i] == '.')
				ttt[i] = ' ';

		sscanf(ttt, "%d %s", &idx, tt_mac);

		if (idx < 0 || idx >= MAX_MAC || tt_mac[0] == 0)
			continue;

		strncpy(pMac[idx].MacAddrs, tt_mac, sizeof(pMac[idx].MacAddrs));
	};

	fclose(fp);
}

void CReadFiles::ReadChallanger()
{
	char dir[256];

	sprintf_s(dir, CHALL_PATH, ServerGroup, ServerIndex);

	FILE *fp;

	fp = fopen(dir, "rt");

	if (fp == NULL)
		fp = fopen("Chall.txt", "rt");

	if (fp == NULL)
	{
		//Log("err,reading chall.txt - can't open.txt", "-system", 0);

		return;
	}

	for (int i = 0; i < ValidGuild; i++)
		fscanf(fp, "%d", &pChallangerMoney[i]);

	fclose(fp);
}

void CReadFiles::WriteChallanger()
{
	char dir[256];

	sprintf_s(dir, CHALL_PATH, ServerGroup, ServerIndex);

	FILE *fp;

	fp = fopen(dir, "wt");

	if (fp == NULL)
		fp = fopen("Chall.txt", "wt");

	if (fp == NULL)
	{
		//Log("err,writing chall.txt - can't open for write", "-system", 0);

		return;
	}

	for (int i = 0; i < ValidGuild; i++)
	{
		fprintf(fp, "%d ", pChallangerMoney[i]);
		fprintf(fp, "\n");
	}

	fclose(fp);
}

void CReadFiles::ReadGuild()
{
	GuildCounter = 0;

	char dir[256];

	sprintf_s(dir, GUILD_PATH, ServerGroup, ServerIndex);

	FILE *fp = NULL;

	fp = fopen(dir, "rb");

	if (fp == 0)
		fp = fopen("Guild.txt", "rb");

	if (fp == 0)
	{
		//Log("err,Reading Guild error - can't open Guild.txt", "-system", 0);
		return;
	}

	for (int i = 0; i < 5; i++)
	{
		g_pGuildZone[i].ChargeGuild = 0;
		g_pGuildZone[i].ChallangeGuild = 0;
	}

	fscanf(fp, "%d", &GuildCounter);

	for (int i = 0; i < 5; i++)
		fscanf(fp, " %d", &g_pGuildZone[i].ChargeGuild);

	for (int i = 0; i < 5; i++)
		fscanf(fp, " %d", &g_pGuildZone[i].ChallangeGuild);

	for (int i = 0; i < 5; i++)
	{
		fscanf(fp, " %d", &g_pGuildZone[i].CityTax);

		if (g_pGuildZone[i].CityTax < 0 || g_pGuildZone[i].CityTax > 20)
			g_pGuildZone[i].CityTax = 10;
	}

	for (int i = 0; i < 5; i++)
		fscanf(fp, " %d", &g_pGuildZone[i].Clan);

	for (int i = 0; i < 5; i++)
		fscanf(fp, " %d", &g_pGuildZone[i].Victory);

	fclose(fp);

	if (GuildCounter == 0)
		;
		//Log("err, Reading Guild error - Guild counter zero", "-system", 0);
	

}

void CReadFiles::WriteGuild()
{
	char dir[256];

	sprintf_s(dir, GUILD_PATH, ServerGroup, ServerIndex);

	FILE *fp = NULL;

	fp = fopen(dir, "wt");

	if (fp == NULL)
		fp = fopen("Guild.txt", "wt");

	if (fp == NULL)
	{
		//Log("err,Writting Guild error - can't open Guild.txt", "-system", 0);

		return;
	}

	fprintf(fp, "%d", GuildCounter);

	for (int i = 0; i < 5; i++)
		fprintf(fp, " %d", g_pGuildZone[i].ChargeGuild);

	fprintf(fp, "\n");

	for (int i = 0; i < 5; i++)
		fprintf(fp, " %d", g_pGuildZone[i].ChallangeGuild);

	fprintf(fp, "\n");

	for (int i = 0; i < 5; i++)
		fprintf(fp, " %d", g_pGuildZone[i].CityTax);

	fprintf(fp, "\n");

	for (int i = 0; i < 5; i++)
		fprintf(fp, " %d", g_pGuildZone[i].Clan);

	fprintf(fp, "\n");

	for (int i = 0; i < 5; i++)
		fprintf(fp, " %d", g_pGuildZone[i].Victory);

	fclose(fp);


	memset(dir, 0, sizeof(dir));
	sprintf_s(dir, GUILDCHAMP_PATH, ServerGroup, ServerIndex);

	fp = fopen(dir, "wt");

	if (fp == NULL)
	{
		//Log("err,Writting Guild error - can't open GuildChamp.txt", "-system", 0);

		return;
	}

	char CityName[5][64] = { "Armia", "Arzan", "Erion", "Noatun", "Nipplehein" };

	for (int i = 0; i < 5; i++)
	{
		char GuildName[128];
		char Guildmark[128];

		BASE_GetGuildName(ServerGroup, g_pGuildZone[i].ChargeGuild, GuildName);
		
		sprintf_s(Guildmark, "b01%06d.bmp", g_pGuildZone[i].ChargeGuild);

		fprintf(fp, "%s,%s,%s", CityName[i], GuildName, Guildmark);    //Ranking guild

		fprintf(fp, "\n");
	}

	fclose(fp);
}

# -------------------- CReadFiles.h --------------------

/*
*   Copyright (C) {2015}  {Victor Klafke, Charles TheHouse}
*
*   This program is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program.  If not, see [http://www.gnu.org/licenses/].
*
*   Contact at: victor.klafke@ecomp.ufsm.br
*/
#ifndef __CREAD_FILES_H__
#define __CREAD_FILES_H__

#include <stdio.h>
#include "..\Basedef.h"

class CReadFiles
{
public:
	CReadFiles();

	static void ReadSancRate();
	static void ReadQuestsRate();
	static void ReadCompRate();
	static void ReadMobMerc();
	static void ReadAdmin();
	static void ReadMacblock();
	static void ReadChallanger();
	static void WriteChallanger();
	static void ReadGuild();
	static void WriteGuild();

public:
	static int QuestExp[5][2];
	static int QuestCoin[5];
	static int QuestLevel[5][4];

private:
	static const char* const SANC_RATE_PATH;
	static const char* const QUESTS_RATE_PATH;
	static const char* const COMP_RATE_PATH;
	static const char* const MOB_MERC_PATH;
	static const char* const ADMIN_PATH;
	static const char* const MAC_BLOCK_PATH;
	static const char* const CHALL_PATH;
	static const char* const GUILD_PATH;
	static const char* const GUILDCHAMP_PATH;
};

#endif // __CREAD_FILES_H__

# -------------------- CUser.cpp --------------------

/*
*   Copyright (C) {2015}  {Victor Klafke, Charles TheHouse}
*
*   This program is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program.  If not, see [http://www.gnu.org/licenses/].
*
*   Contact at: victor.klafke@ecomp.ufsm.br
*/
#include <Windows.h>

#include "CUser.h"
#include "Server.h"


CUser::CUser()
{	
	Mode		     = USER_EMPTY;
	Unk3			 = 0;
	IsBillConnect    = 0;
	LastReceiveTime  = 0;

	memset(Cargo, 0, sizeof(Cargo));

	Admin			 = 0;
	CastleStatus	 = 0;
	MuteChat		 = 0;
	UseItemTime		 = 0;
	Message			 = 0;
	AttackTime		 = 0;
	LastClientTick	 = 0;
	PotionTime		 = 0;
	OnlyTrade		 = 0;

	WaitDB = 0;
}

CUser::~CUser()
{

}

BOOL CUser::AcceptUser(int ListenSocket)
{
	SOCKADDR_IN acc_sin; 
	int Size = sizeof(acc_sin);

	int tSock = accept(ListenSocket, (struct sockaddr FAR *)&acc_sin, (int FAR *)&(Size));

	if(tSock < 0) 
		return FALSE;

	if(WSAAsyncSelect(tSock, hWndMain, WSA_READ, FD_READ | FD_CLOSE ) > 0) 
	{	
		closesocket(tSock);

		return FALSE;
	}

	cSock.Sock          = tSock;
	cSock.nRecvPosition = 0;
	cSock.nProcPosition = 0;
	cSock.nSendPosition = 0;

	char *tmp  = inet_ntoa(acc_sin.sin_addr);
	IP		   = acc_sin.sin_addr.S_un.S_addr;
	Mode	   = USER_ACCEPT;
	Unk3	   = 0;

	return TRUE;
}

int CUser::CloseUser()
{
     cSock.CloseSocket();
	 cSock.Sock		= 0;
	 IsBillConnect  = 0;	 
	 Mode = USER_EMPTY;
	 AccountName[0] = 0;
	 return TRUE;
}

# -------------------- CUser.h --------------------

/*
*   Copyright (C) {2015}  {Victor Klafke, Charles TheHouse}
*
*   This program is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program.  If not, see [http://www.gnu.org/licenses/].
*
*   Contact at: victor.klafke@ecomp.ufsm.br
*/
#ifndef __CUSER__
#define __CUSER__

#include "..\Basedef.h"
#include "..\CPSock.h"

//-------Connecting User Modes----------------------------------------------------------------------------
#define USER_EMPTY       0 // There's no user on this slot
#define USER_ACCEPT      1
#define USER_LOGIN       2
//-------SelScreen User Modes----------------------------------------------------------------------------
#define USER_SELCHAR     11   // Waiting DB to send the SELCHAR struct
#define USER_CHARWAIT    12   // Waiting DB confirmation of char login
#define USER_WAITDB		 13	  // Waiting DB response to confirm
//#define USER_CREWAIT     14   // Waiting DB confirmation of character creation

//-------Ingame User Modes----------------------------------------------------------------------
#define USER_PLAY        22 // User is ingame playing with a character
#define USER_SAVING4QUIT 24 // User is saving game right before quitting

#define RUNEACTIVE 46
#define ENERGYMAX 47
#define ENERGYPOS 48

class CUser
{
public:
	char AccountName[ACCOUNTNAME_LENGTH]; // 0 - 16
	int Slot; // 16 // Number of the slot of the selected character
	unsigned int IP; // 20

	int IsAutoTrading; //28

	int chave1; //novato
	int chave2;
	int chave3;
	int chave4;
	int Keys[50];
	// 0 = Level
	// 1 a 15 = Trajes de Montaria
	// 49 = CheckEvento

	/*Variaveis::CUser sistema de leilão*/	 
	ULONGLONG sxCountSerch; 




	struct
	{
		time_t VipTime;
		time_t RwdTime;
		time_t Time1;
		time_t Time2;
		time_t Time3;
		time_t Time4;
		time_t Time5;
		time_t Time6;
	} Timer;

	STRUCT_ITEM Joias[4][2];
	STRUCT_ITEM Outros[4][10];

	int CountMob1;
	int CountMob2;
	int CountMob3;
	int QuestAtiva;

	time_t LastQuestDay;

	int Mode; // 24
	int TradeMode; // 28 // TradeMode ?
	CPSock cSock; // 32 - 32
	char Unk2[400]; // 64
	int Unk3; // 464
	STRUCT_ITEM Cargo[MAX_CARGO]; // 468 - 1024
	int Coin; // 1492
	unsigned short cProgress; // 1496
	short Unk_1498; // 1498
	bool WaitDB;

	////////////////////////////////////////////////
	// Trade ?									 //
	//////////////////////////////////////////////

	MSG_Trade Trade; // 1500 // size correto, deve ser uma struct //    Trade; ???

	////////////////////////////////////////////
	// AutoTrade ?							 //
	//////////////////////////////////////////
	 

	/////////////////////////////////////////

	int LastAttack; // 1788 // LastAttack ??
	int LastAttackTick; // 1792 // LastAttackTick ???
	int LastMove; // 1796 // LastMove ??
	int LastAction; // 1800 // LastAction ??
	int LastActionTick; // 1804 // LastActionTick??
	int LastIllusionTick; // 1808 // LastIllusionTick??
	int NumError; // 1812 // NumError ??
	int Unk_1816; // 1816
	STRUCT_SELCHAR SelChar; // 1820 - 744
	char LastChat[16]; // 2564 // LastChat ?
	int IsBillConnect; // 2580
	char Unk5[36]; // 2584
	unsigned char CharShortSkill[16]; // 2620
	int GemaX; // 2628
	int GemaY; // 2632
	int Whisper; // 2636 // Whisper ?
	int Guildchat; // 2640 // Guildchat ?
	int PartyChat; // 2644 // PartyChat ?
	int Chatting; //2648 Chatting??
	char Unk_2648[24]; // 2652
	int PKMode; // 2676 // PKMode ??
	int ReqHp; // 2680
	int ReqMp; // 2684
	int Unk_2688; // 2688
	char MacAddress[18];
	int Unk_2708; // 2708
	int RankingTarget; // 2712 // RankingTarget ???
	int RankingType; // 2716 // RankingType ???
	int LastReceiveTime; // 2720
	int Admin; // 2724
	int Unk_2728; // 2728 // Related to BILLING (Child!?!)
	unsigned int Unk_2732; // 2732 // Something related to BILLING (ReqBillSec?????)
	int Unk_2736; // 2736
	int Range; // 2740
	int CastleStatus; // 2744
	char Unk9[400]; // 2748 // LastSkillTick // size correto é 400.
	 int Donate;
	 int Honra;
	 int BossLocal1;
	int MuteChat;
	int KingChat;

	unsigned int UseItemTime;
	unsigned int Message;
	unsigned int DroplistTime;
	unsigned int AttackTime;
	unsigned int LastClientTick;
	ULONGLONG PotionTime;
	unsigned int PergaState;
	unsigned int PergaCount;
	unsigned int MoveItemTime;
	unsigned int Lasclick;
	ULONGLONG EventDelay;
	ULONGLONG CaptchaDelay;
	unsigned int Carptcha;
	unsigned int Territorio;
	time_t TempoDiario;

	ULONGLONG Atraso;
	ULONGLONG FiltroDelay;
	ULONGLONG MailItemDelay;
	ULONGLONG SendMailItemDelay;
	ULONGLONG RankingDelay;
	ULONGLONG TowerWarDelay;
	ULONGLONG DonateDelay;
	ULONGLONG DonateShopDelay;
	ULONGLONG RequestShopDelay;
	ULONGLONG DropListDelay;
	unsigned int QuestDiaria;
	unsigned int DiariaState;
	ULONGLONG AtrasocharLogout;
	int NumCreated;
	 
	int OnlyTrade;
	int TimeLojinha;
	STRUCT_ACCOUNTFILE File;
	int Vidas;


	struct _Ingame
	{
		struct {
			unsigned int IntervalTime;
		} Skill[103];
		int AttackMode;
		unsigned int LastAttackTime;
		char PartyPassword[6];



		char PassWord[16];

		char Login[16];


		bool autoStore; 

		bool GrupoAceitarSolicitação;

		int CheckPista;
		int CheckPesa;
		int CheckAgua;

		int DonateBuyItem;
		bool MobDonateStore;
		bool CanBuy;
		char MobName[10][16];
		int MobFace[10];
		int MobEffect[10];
		int Window;
		int MarketState;
		int MacroSala;
		int MacroState;
		int MacroType;
	} Ingame;

public:
	CUser();
	~CUser();
	int   AcceptUser(int ListenSocket);
	int CloseUser();
};


#endif

# -------------------- CWarTower.cpp --------------------

/*
*   Copyright (C) {2015}  {Victor Klafke, Charles TheHouse}
*
*   This program is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program.  If not, see [http://www.gnu.org/licenses/].
*
*   Contact at: victor.klafke@ecomp.ufsm.br
*/
#include <Windows.h>
#include <stdio.h>
#include <fcntl.h>
#include <time.h>
#include <math.h>
#include <io.h>
#include <errno.h> 
#include "..\Basedef.h"
#include "..\CPSock.h"
#include "..\ItemEffect.h"
#include "Language.h" 
#include "CItem.h"
#include "Server.h"
#include "GetFunc.h"
#include "SendFunc.h"
#include "ProcessClientMessage.h"
#include "ProcessDBMessage.h"
#include "CReadFiles.h"  
#include "CWarTower.h"
#include "wMySQL.h"

void CWarTower::GuildProcess(tm* timeinfo)
{
	if (NewbieEventServer == 1 && timeinfo->tm_wday != 0 && timeinfo->tm_wday != 6 && timeinfo->tm_hour == GTorreHour && GTorreStatus == 1)
	{
		if (GTorreState == 0 && timeinfo->tm_min == 0 && timeinfo->tm_sec >= 0)
		{
			SendNotice(strFmt(g_pMessageStringTable[_DN_CHANNELWAR_BEGIN], 5));
			GTorreState = 1;
			GTorreGuild = 0;
		}

		if (GTorreState == 1 && timeinfo->tm_min == 5 && timeinfo->tm_sec >= 0)
		{
			ClearArea(2445, 1850, 2546, 1920);

			GenerateMob(GTORRE, 0, 0);

			SendNotice(g_pMessageStringTable[_DN_BASEWORSTART]);
			GTorreState = 2;
		}

		//A Guerra acabou a guilda que está defendendo a torre recebe 100 de fama.
		if (GTorreState == 2 && timeinfo->tm_min == 35)
		{
			ClearArea(2445, 1850, 2546, 1920);

			for (int i = MAX_USER; i < MAX_MOB; i++)
			{
				if (pMob[i].GenerateIndex == GTORRE)
				{
					if (pMob[i].MOB.Guild)
					{
						int Group = ServerGroup;
						int Server = pMob[i].MOB.Guild / MAX_GUILD;
						int usGuild = pMob[i].MOB.Guild;

						char guildname[256];

						BASE_GetGuildName(Group, usGuild, guildname);

						MSG_GuildInfo sm;

						sm.Type = _MSG_GuildInfo;
						sm.Size = sizeof(MSG_GuildInfo);
						sm.ID = 0;

						sm.Guild = usGuild;
						GuildInfo[usGuild].Fame += 100;

						auto& pc = cSQL::instance();
						sprintf(xQuery, "UPDATE `guilds` SET fame = '%d' WHERE `guild` = '%d'", GuildInfo[usGuild].Fame + 100, usGuild);
						pc.wQuery(xQuery);

						sm.GuildInfo = GuildInfo[usGuild];

						DBServerSocket.SendOneMessage((char*)&sm, sizeof(MSG_GuildInfo));

						SystemLog("-system", "-", 0, strFmt("etc,war_tower1 guild:%d guild_fame:%d", usGuild, GuildInfo[usGuild].Fame));

						BASE_GetGuildName(ServerGroup, usGuild, guildname);
						SendNotice(strFmt("Guerra de torre finalizada! Vencedor: %s", guildname));
					}

					DeleteMob(i, 1);
				}
			}

			GTorreState = 0;
			GTorreGuild = 0;
		}
	}
}

void CWarTower::MobKilled(int target, int conn, int PosX, int PosY)
{
	int GenerateID = pMob[target].GenerateIndex;

	if (GenerateID == GTORRE && GTorreState)
	{
		if (pMob[conn].MOB.Guild)
		{
			int Group = ServerGroup;
			int Server = pMob[conn].MOB.Guild / MAX_GUILD;
			int usGuild = pMob[conn].MOB.Guild;

			char guildname[256];

			BASE_GetGuildName(Group, usGuild, guildname);

			SendNotice(strFmt("O player %s da guilda %s derrubou a torre!", pMob[conn].MOB.MobName, guildname));

			GTorreGuild = pMob[conn].MOB.Guild;
		}

		ClearArea(2445, 1850, 2546, 1920);

		GenerateMob(GTORRE, 0, 0);
	}
}

void CWarTower::GGenerateMob(int index, int PosX, int PosY, int tmob)
{
	if (index == GTORRE && GTorreGuild)
	{
		pMob[tmob].MOB.Guild = GTorreGuild;
		pMob[tmob].MOB.GuildLevel = 0;
	}
}

BOOL CWarTower::TowerAttack(int conn, int idx)
{
	if (pMob[idx].GenerateIndex != GTORRE)
		return TRUE;

	if (pMob[conn].MOB.Guild == 0 || pMob[conn].MOB.Guild == pMob[idx].MOB.Guild)
		return FALSE;

	return TRUE;
}

# -------------------- CWarTower.h --------------------

/*
*   Copyright (C) {2015}  {Victor Klafke, Charles TheHouse}
*
*   This program is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program.  If not, see [http://www.gnu.org/licenses/].
*
*   Contact at: victor.klafke@ecomp.ufsm.br
*/
#pragma once

#include <stdio.h>
#include "..\Basedef.h"


class CWarTower
{
public:
	CWarTower();

public:

	static void GuildProcess(tm *timeinfo);

	static void MobKilled(int target, int conn, int PosX, int PosY);
	static void GGenerateMob(int index, int PosX, int PosY, int tmob);
	static BOOL TowerAttack(int conn, int idx);
};


# -------------------- DonateShop.cpp --------------------

#pragma once

#include "ProcessClientMessage.h"
#include <iostream>
#include <cstdlib>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <random>
#include <ctime>
#include "SendFunc.h"
#include "Functions.h"
#include "wMySQL.h"

bool StoreAgroup(int itemId)
{
	int List[] = {
		3314, 4140, 3312, 3343, 3336, 3310, 3311, 3407, 3408, 3409, 3410, 3411, 3412, 3413, 3414, 3415, 3416, 3417, 2426, 3330, 777
	};

	for (int i = 0; i < (sizeof(List) / 4); i++) {
		if (itemId == List[i])
			return true;
	}
	return false;
}

void ReqDonateShop(int conn, char* pMsg)
{
	if (conn <= 0 || conn >= MAX_USER)
		return;

	if (pUser[conn].Mode != USER_PLAY)
		return;

	if (pUser[conn].cSock.Sock == 0)
		return;

	MSG_ReqShopDonate* m = (MSG_ReqShopDonate*)pMsg;

	int Size = m->Size;

	if (Size > sizeof(MSG_ReqShopDonate)) //CONTROLE DE SIZE
	{
		SendClientMessage(conn, "Impossível executar ação, tente mais tarde.");
		return;
	}

	if (pUser[conn].DonateShopDelay != 0)
	{
		int isTime = GetTickCount64() - pUser[conn].DonateShopDelay; // ATRASO PACOTE

		if (isTime < 3000)
		{
			SendClientMessage(conn, "Aguarde 3 segundo para uma nova Tentativa.");
			return;
		}

	}
	pUser[conn].DonateShopDelay = GetTickCount64();

	int nShop = m->Store;
	int nPage = m->Page;
	int nItemPos = m->ItemPos;
	int nQnt = m->Qnt;

	if (nShop < 0 || nShop > 2)
		return;

	if (nPage < 0 || nPage > 4)
		return;

	if (nItemPos < 0 || nItemPos > 14)
		return;

	if (nQnt <= 0 || nQnt > 120)
		return;

	int ItemIndex = cStoreItens[nShop][nPage][nItemPos][0];
	int Price = (cStoreItens[nShop][nPage][nItemPos][1] * nQnt);

	if (ItemIndex <= 0 || ItemIndex >= MAX_ITEMLIST)
		return;

	auto& pc = cSQL::instance();

	int Donate = 0;

	sprintf(hQuery, "SELECT * FROM `accounts` WHERE `username` = '%s'", pUser[conn].AccountName);
	MYSQL_ROW row;
	MYSQL* wSQL = pc.wStart();
	MYSQL_RES* result = pc.wRes(wSQL, hQuery);

	if (result == NULL)
		return;

	while ((row = mysql_fetch_row(result)) != NULL)
	{
		Donate = atoi(row[6]);
	}

	if (Donate < Price)
	{
		SendClientMessage(conn, "Saldo de Rubis Insuficiente");
		return;
	}

	int FreeSlot = 0;
	int slotsInv = 30;
	int SlotReq = 1;

	bool Agroup = false;

	if (StoreAgroup(ItemIndex) == true)
		Agroup = true;

	if (Agroup == false)
		SlotReq = nQnt;

	if (pMob[conn].MOB.Carry[60].sIndex == 3467)
		slotsInv += 15;
	if (pMob[conn].MOB.Carry[61].sIndex == 3467)
		slotsInv += 15;

	for (int i = 0; i < slotsInv; i++) {
		if (pMob[conn].MOB.Carry[i].sIndex == 0)
			FreeSlot += 1;
	}
	if (FreeSlot < SlotReq) {
		SendClientMessage(conn, "Não há espaço disponível no Inventário");
		return;
	}

	STRUCT_ITEM item;
	memset(&item, 0, sizeof(STRUCT_ITEM));
	item.sIndex = ItemIndex;
	item.stEffect[0].cEffect = Agroup ? 61 : 0;
	item.stEffect[0].cValue = Agroup ? nQnt : 0;

	int tQnt = nQnt;

	if (Agroup == false)
	{
		while (nQnt >= 1) {
			PutItem(conn, &item);
			nQnt -= 1;
		}
	}
	else {
		PutItem(conn, &item);
	}

	sprintf(xQuery, "UPDATE accounts SET donate = '%d' WHERE username = '%s' ", (Donate - Price), pUser[conn].AccountName);
	pc.wQuery(xQuery);

	SendClientMessage(conn, strFmt("Comprou [x%d] %s por [%d] Rubis", tQnt, g_pItemList[ItemIndex].Name, Price));
	ItemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, strFmt("Comprou [x%d] %s por [%d] Rubis | Restantes: %d", tQnt, g_pItemList[ItemIndex].Name, Price, Donate - Price));
	UpdateDonate(conn);
}

void TradeDonate(int conn, char* pMsg)
{

	MSG_SendPix* m = (MSG_SendPix*)pMsg;

	int Size = m->Size;

	if (Size > 24) //CONTROLE DE SIZE
	{
		SendClientMessage(conn, "Impossível executar ação, tente mais tarde.");
		return;
	}

	if (conn <= 0 || conn >= MAX_USER)
		return;

	if (pUser[conn].Mode != USER_PLAY)
		return;

	if (pUser[conn].cSock.Sock == 0)
		return;

	int value = m->qnt;

	if (value < 100)
		return;

	if (pUser[conn].Atraso != 0)
	{
		int isTime = GetTickCount64() - pUser[conn].Atraso; // ATRASO PACOTE

		if (isTime < 3000)
		{
			SendClientMessage(conn, "Aguarde 3 segundo para uma nova Tentativa.");
			return;
		}

	}
	pUser[conn].Atraso = GetTickCount64();

	auto& pc = cSQL::instance();

	int Donate = 0;
	std::string mypix;
	sprintf(hQuery, "SELECT * FROM `accounts` WHERE `username` = '%s'", pUser[conn].AccountName);
	MYSQL_ROW row;
	MYSQL* wSQL = pc.wStart();
	MYSQL_RES* result = pc.wRes(wSQL, hQuery);

	if (result == NULL)
		return;

	while ((row = mysql_fetch_row(result)) != NULL)
	{
		mypix = row[20];
		Donate = atoi(row[6]);
	}
	pc.wQuery(xQuery);

	if (Donate < value)
	{
		SendClientMessage(conn, "Saldo Insuficiente");
		return;
	}

	auto& pc2 = cSQL::instance();

	int Donate2 = 0;
	std::string pixrecive;
	std::string pixkey = { m->chave };

	sprintf(hQuery, "SELECT * FROM `accounts` WHERE `pix` = '%s'", m->chave);
	MYSQL_ROW row2;
	MYSQL* wSQL2 = pc2.wStart();
	MYSQL_RES* result2 = pc2.wRes(wSQL2, hQuery);

	if (result2 == NULL)
		return;

	while ((row2 = mysql_fetch_row(result2)) != NULL)
	{
		pixrecive = row2[20];
		Donate2 = atoi(row2[6]);
	}

	if (pixrecive != pixkey) {
		SendClientMessage(conn, "Jogador Não Encontrado");
		return;
	}

	if (mypix == pixrecive) {
		SendClientMessage(conn, "Não pode enviar para si mesmo");
		return;
	}

	int Value = value;

	sprintf(xQuery, "UPDATE accounts SET donate = '%d' WHERE pix = '%s' ", (Donate2 + Value), m->chave);
	pc2.wQuery(xQuery);

	auto& pc3 = cSQL::instance();
	sprintf(xQuery, "UPDATE accounts SET donate = '%d' WHERE username = '%s' ", (Donate - value), pUser[conn].AccountName);
	pc3.wQuery(xQuery);

	SendClientMessage(conn, strFmt("[%d] Rubis enviados para a chave[%s]", value, m->chave));
	ItemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, strFmt("[%d] Rubis enviados para a chave[%s] | Saldo: %d", value, m->chave, Donate - value));
	UpdateDonate(conn);
	return;
}

void UpdateShopDonate1() {
	auto& pc = cSQL::instance();

	int Index[75] = {};
	int Value[75] = {};
	int Estoque[75] = {};
	int i = 0;

	sprintf(hQuery, "SELECT * FROM `donatestore1` LIMIT 75");
	MYSQL_ROW row;
	MYSQL* wSQL = pc.wStart();
	MYSQL_RES* result = pc.wRes(wSQL, hQuery);

	if (result == NULL)
		return;

	while ((row = mysql_fetch_row(result)) != NULL)
	{
		Index[i] = atoi(row[2]);
		Value[i] = atoi(row[3]);
		Estoque[i] = atoi(row[4]);
		i++;
	}

	for (int y = 0; y < 15; y++) {
		cStoreItens[0][0][y][0] = Index[y];
		cStoreItens[0][0][y][1] = Value[y];
		cStoreItens[0][0][y][2] = Estoque[y];
	}
	for (int z = 15; z < 30; z++) {
		cStoreItens[0][1][z - 15][0] = Index[z];
		cStoreItens[0][1][z - 15][1] = Value[z];
		cStoreItens[0][1][z - 15][2] = Estoque[z];
	}
	for (int x = 30; x < 45; x++) {
		cStoreItens[0][2][x - 30][0] = Index[x];
		cStoreItens[0][2][x - 30][1] = Value[x];
		cStoreItens[0][2][x - 30][2] = Estoque[x];
	}
	for (int x = 45; x < 60; x++) {
		cStoreItens[0][3][x - 45][0] = Index[x];
		cStoreItens[0][3][x - 45][1] = Value[x];
		cStoreItens[0][3][x - 45][2] = Estoque[x];
	}
	for (int x = 60; x < 75; x++) {
		cStoreItens[0][4][x - 60][0] = Index[x];
		cStoreItens[0][4][x - 60][1] = Value[x];
		cStoreItens[0][4][x - 60][2] = Estoque[x];
	}
}
void UpdateShopDonate2() {
	auto& pc = cSQL::instance();

	int Index[75] = {};
	int Value[75] = {};
	int Estoque[75] = {};
	int i = 0;

	sprintf(hQuery, "SELECT * FROM `donatestore2` LIMIT 75");
	MYSQL_ROW row;
	MYSQL* wSQL = pc.wStart();
	MYSQL_RES* result = pc.wRes(wSQL, hQuery);

	if (result == NULL)
		return;

	while ((row = mysql_fetch_row(result)) != NULL)
	{
		Index[i] = atoi(row[2]);
		Value[i] = atoi(row[3]);
		Estoque[i] = atoi(row[4]);
		i++;
	}

	for (int y = 0; y < 15; y++) {
		cStoreItens[1][0][y][0] = Index[y];
		cStoreItens[1][0][y][1] = Value[y];
		cStoreItens[1][0][y][2] = Estoque[y];
	}
	for (int z = 15; z < 30; z++) {
		cStoreItens[1][1][z - 15][0] = Index[z];
		cStoreItens[1][1][z - 15][1] = Value[z];
		cStoreItens[1][1][z - 15][2] = Estoque[z];
	}
	for (int x = 30; x < 45; x++) {
		cStoreItens[1][2][x - 30][0] = Index[x];
		cStoreItens[1][2][x - 30][1] = Value[x];
		cStoreItens[1][2][x - 30][2] = Estoque[x];
	}
	for (int x = 45; x < 60; x++) {
		cStoreItens[1][3][x - 45][0] = Index[x];
		cStoreItens[1][3][x - 45][1] = Value[x];
		cStoreItens[1][3][x - 45][2] = Estoque[x];
	}
	for (int x = 60; x < 75; x++) {
		cStoreItens[1][4][x - 60][0] = Index[x];
		cStoreItens[1][4][x - 60][1] = Value[x];
		cStoreItens[1][4][x - 60][2] = Estoque[x];
	}
}
void UpdateShopDonate3() {
	auto& pc = cSQL::instance();

	int Index[75] = {};
	int Value[75] = {};
	int Estoque[75] = {};
	int i = 0;

	sprintf(hQuery, "SELECT * FROM `donatestore3` LIMIT 75");
	MYSQL_ROW row;
	MYSQL* wSQL = pc.wStart();
	MYSQL_RES* result = pc.wRes(wSQL, hQuery);

	if (result == NULL)
		return;

	while ((row = mysql_fetch_row(result)) != NULL)
	{
		Index[i] = atoi(row[2]);
		Value[i] = atoi(row[3]);
		Estoque[i] = atoi(row[4]);
		i++;
	}

	for (int y = 0; y < 15; y++) {
		cStoreItens[2][0][y][0] = Index[y];
		cStoreItens[2][0][y][1] = Value[y];
		cStoreItens[2][0][y][2] = Estoque[y];
	}
	for (int z = 15; z < 30; z++) {
		cStoreItens[2][1][z - 15][0] = Index[z];
		cStoreItens[2][1][z - 15][1] = Value[z];
		cStoreItens[2][1][z - 15][2] = Estoque[z];
	}
	for (int x = 30; x < 45; x++) {
		cStoreItens[2][2][x - 30][0] = Index[x];
		cStoreItens[2][2][x - 30][1] = Value[x];
		cStoreItens[2][2][x - 30][2] = Estoque[x];
	}
	for (int x = 45; x < 60; x++) {
		cStoreItens[2][3][x - 45][0] = Index[x];
		cStoreItens[2][3][x - 45][1] = Value[x];
		cStoreItens[2][3][x - 45][2] = Estoque[x];
	}
	for (int x = 60; x < 75; x++) {
		cStoreItens[2][4][x - 60][0] = Index[x];
		cStoreItens[2][4][x - 60][1] = Value[x];
		cStoreItens[2][4][x - 60][2] = Estoque[x];
	}
}

void SendShopDonate(int conn) {

	if (conn <= 0 || conn >= MAX_USER)
		return;

	if (pUser[conn].Mode != USER_PLAY)
		return;

	if (pUser[conn].cSock.Sock == 0)
		return;

	if (pUser[conn].RequestShopDelay != 0)
	{
		int isTime = GetTickCount64() - pUser[conn].RequestShopDelay; // ATRASO PACOTE

		if (isTime < 15000)
		{
			return;
		}

	}
	pUser[conn].RequestShopDelay = GetTickCount64();


	MSG_UpdateDonateStore sm;
	memset(&sm, 0, sizeof(MSG_UpdateDonateStore));

	sm.Type = _MSG_UpdateDonateStore;
	sm.Size = sizeof(MSG_UpdateDonateStore);
	sm.ID = conn;

	for (int i = 0; i < 3; i++) {
		for (int x = 0; x < 5; x++) {
			for (int z = 0; z < 15; z++) {
				for (int c = 0; c < 3; c++) {
					sm.cStoreItens[i][x][z][c] = cStoreItens[i][x][z][c];
				}
			}
		}
	}

	int Size = sm.Size;

	if (Size > sizeof(MSG_UpdateDonateStore))
	{
		sm.Size = 0;
		return;
	}

	if (!pUser[conn].cSock.AddMessage((char*)&sm, sizeof(MSG_UpdateDonateStore)))
		CloseUser(conn);
}

# -------------------- DropControl.cpp --------------------

#include "..\Basedef.h"
#include "..\ItemEffect.h"
#include "Language.h"
#include "Server.h"
#include "GetFunc.h"
#include "SendFunc.h"
#include "CCastleZakum.h"
#include "Functions.h"


int ControleDropGold(int conn, int target, int DropedGold)
{
	int GoldFinal = DropedGold;





	return GoldFinal;
}

STRUCT_ITEM* ControleDropItem(int conn, int target, int bonus, int PosX, int PosY, STRUCT_ITEM* Item)
{
	STRUCT_ITEM* ItemDrop = Item;

	if (ItemDrop->sIndex != 0 && CCastleZakum::KeyDrop(target, conn, PosX, PosY, ItemDrop) == TRUE)
	{
		SetItemBonus(ItemDrop, pMob[target].MOB.CurrentScore.Level, 0, bonus);

		BlockAdd(ItemDrop, EF_DAMAGE, 27, 63);
		BlockAdd(ItemDrop, EF_MAGIC, 12, 28);

		BlockAdd(ItemDrop, EF_DAMAGEADD, 27, 63);
		BlockAdd(ItemDrop, EF_MAGICADD, 12, 28);

		//Filtro de Drop
		if (AutoDrop(conn, ItemDrop->sIndex) == false)
			return ItemDrop;

		if (DropItemControl(ItemDrop->sIndex) == false)
			return ItemDrop;

		//Retira o drop duplo da lan
		if ((pMob[conn].TargetX > 3604 && pMob[conn].TargetY > 3604 && pMob[conn].TargetX < 3691 && pMob[conn].TargetY < 3690) ||
			(pMob[conn].TargetX > 3732 && pMob[conn].TargetY > 3476 && pMob[conn].TargetX < 3819 && pMob[conn].TargetY < 3563) ||
			(pMob[conn].TargetX > 3860 && pMob[conn].TargetY > 3604 && pMob[conn].TargetX < 3946 && pMob[conn].TargetY < 3690)
			) {

			int List[]{
				419, 420, 4019, 2404, 2399, 4026, 2400, 2405, 4020, 2403, 2398
			};
			for (int i = 0; i < (sizeof(List) / 4); i++) {
				if (ItemDrop->sIndex == List[i])
					return ItemDrop;
			}
		}

		/*if (ItemDrop->sIndex == 1740 || ItemDrop->sIndex == 1741)
			SendNotice(strFmt("O jogador [%s] dropou uma [%s]", pMob[conn].MOB.MobName, g_pItemList[ItemDrop->sIndex].Name));*/

		//agrupador automatico teste
		if (AgroupList(conn, ItemDrop->sIndex) == true) {
			SendItemagrupar(conn, ItemDrop->sIndex);

			if (LogList(ItemDrop->sIndex) == true) {
				snprintf(temp, sizeof(temp), "MobName:%s dropou o item: %s:%d %d.%d.%d.%d.%d.%d do mob:%s", pMob[conn].MOB.MobName, g_pItemList[ItemDrop->sIndex].Name, ItemDrop->sIndex, ItemDrop->stEffect[0].cEffect, ItemDrop->stEffect[0].cValue, ItemDrop->stEffect[1].cEffect, ItemDrop->stEffect[1].cValue, ItemDrop->stEffect[2].cEffect, ItemDrop->stEffect[2].cValue, pMob[target].MOB.MobName);
				MobDropLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);
			}

			return ItemDrop;
		}

		if (PutItem(conn, ItemDrop))
		{
			if (LogList(ItemDrop->sIndex) == true) {
				snprintf(temp, sizeof(temp), "MobName:%s dropou o item: %s:%d %d.%d.%d.%d.%d.%d do mob:%s", pMob[conn].MOB.MobName, g_pItemList[ItemDrop->sIndex].Name, ItemDrop->sIndex, ItemDrop->stEffect[0].cEffect, ItemDrop->stEffect[0].cValue, ItemDrop->stEffect[1].cEffect, ItemDrop->stEffect[1].cValue, ItemDrop->stEffect[2].cEffect, ItemDrop->stEffect[2].cValue, pMob[target].MOB.MobName);
				MobDropLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);
			}
		}

		int PedacoEquilibrio = ItemDrop->sIndex == 4125;
		if (PedacoEquilibrio)
			DoTeleport(conn, 1970 + rand() % 2, 1580 + rand() % 2);
	}
	return ItemDrop;
}

bool AutoDrop(int conn, int itemId)
{
	if ((pMob[conn].MOB.Equip[13].sIndex == 3901 || pMob[conn].MOB.Equip[13].sIndex == 3902 || pMob[conn].MOB.Equip[13].sIndex == 3916) && pMob[conn].FiltroState == 1) {
		
		if (pMob[conn].FiltroID[0] == 1) {
			int Amagos[] = {
				2396, //Âmago_de_Cav_s/Sela_N
				2397, //Âmago_de_Cav_Fantasm_N
				2398, //Âmago_de_Cavalo_Leve_N
				2399, //Âmago_de_Cavalo_Equip_N
				2400, //Âmago_de_Andaluz_N
				2401, //Âmago_de_Ca_s/Sela_B
				2402, //Âmago_de_Cav_Fantasm_B
				2403, //Âmago_de_Cavalo_Leve_B
				2404, //Âmago_de_Cavalo_Equip_B
				2405, //Âmago_de_Andaluz_B
				2406, //Âmago_de_Fenrir
				2411, //Âmago_de_Unicórnio
				2412, //Âmago_de_Pégasus
				2413, //Âmago_de_Unisus
				2390, //Âmago_de_Porco
				2391, //Âmago_de_Javali
				2392, //Âmago_de_Lobo
				2393, //Âmago_de_Dragão_Menor
				2394, //Âmago_de_Urso
				2395 //Âmago_de_Dente_de_Sabre
			};
			for (int i = 0; i < (sizeof(Amagos) / 4); i++) {
				if (Amagos[i] == itemId)
					return true;
			}
		}
		if (pMob[conn].FiltroID[1] == 1) {
			int Kit10[] = {
				2441, //Diamante
				2442, //Esmeralda
				2443, //Coral
				2444, //Garnet
				1774 //Pedra_do_Sábio
			};
			for (int i = 0; i < (sizeof(Kit10) / 4); i++) {
				if (Kit10[i] == itemId)
					return true;
			}
		}
		if (pMob[conn].FiltroID[2] == 1) {
			int Poeiras[] = {
				419, //Resto_de_Oriharucon
				420, //Resto_de_Lactolerium
				412, //Poeira_de_Oriharucon
				413, //Poeira_de_Lactolerium
				4026 //Moeda_de_1kk
			};
			for (int i = 0; i < (sizeof(Poeiras) / 4); i++) {
				if (Poeiras[i] == itemId)
					return true;
			}
		}
		if (pMob[conn].FiltroID[3] == 1) {
			int Classe[] = {
				4019, //Classe_D
				4020 //Classe_E
			};
			for (int i = 0; i < (sizeof(Classe) / 4); i++) {
				if (Classe[i] == itemId)
					return true;
			}
		}
		if (pMob[conn].FiltroID[4] == 1) {
			int Entradas[] = {
				4038, //Vela_do_Coveiro
				4039, //Colheita_do_Jardineiro
				4040, //Cura_do_Batedor
				4041, //Mana_do_Batedor
				4042, //Emblema_do_Guarda
				5134 //Pista_da_Runas
			};
			for (int i = 0; i < (sizeof(Entradas) / 4); i++) {
				if (Entradas[i] == itemId)
					return true;
			}
		}
		if (pMob[conn].FiltroID[5] == 1) {
			int BoxQuest[] = {
				4117, //Caixa_da_Sabedoria
				4118, //Lágrima_Angelical
				4119, //Coração_do_Kaizen
				4120, //Olho_de_Sangue
				4121, //Pedra_Espiritual_dos_Elfos
				4122 //Molar_de_Gárgula
			};
			for (int i = 0; i < (sizeof(BoxQuest) / 4); i++) {
				if (BoxQuest[i] == itemId)
					return true;
			}
		}
		if (pMob[conn].FiltroID[6] == 1) {
			int ItensEvolução[] = {
				1740, //Alma_do_Unicórnio
				1741, //Alma_da_Fênix
				1742, //Pedra_da_Imortalidade
				1744, //Pedra_da_Inteligência
				1745, //Pedra_da_Sabedoria
				1746, //Pedra_da_Misericórdia
				1747, //Pedra_do_Abismo
				1748, //Pedra_da_Beleza
				1749, //Pedra_da_Vitória
				1750, //Pedra_da_Originalidade
				1751, //Pedra_do_Reino
				1752, //Pedra_do_Lorde_Orc
				1753, //Pedra_do_Esqueleto
				1754, //Pedra_de_Dragão_Lich
				1755, //Pedra_do_Demonlord
				1756, //Pedra_de_Mantícora
				1757, //Pedra_de_Gárgula_de_Fogo
				1758, //Pedra_do_Lugefer
				1759 //Pedra_do_Rei_Demonlord
			};
			for (int i = 0; i < (sizeof(ItensEvolução) / 4); i++) {
				if (ItensEvolução[i] == itemId)
					return true;
			}
		}
		if (pMob[conn].FiltroID[7] == 1) {
			int Runas[] = {
				5110, //Ansuz
				5111, //Uraz
				5112, //Thurisaz
				5113, //Fehu
				5114, //Raidho
				5115, //Kenaz
				5116, //Naudhiz
				5117, //Gebo
				5118, //Wunjo
				5119, //Hagalaz
				5120, //Isa
				5121, //Jara
				5122, //Eihwaz
				5123, //Perthro
				5124, //Elhaz
				5125, //Sowilo
				5126, //Berkano
				5127, //Ehwaz
				5128, //Tiwaz
				5129, //Mannaz
				5130, //Laguz
				5131, //Dagaz
				5132, //Ing
				5133 //Othel
			};
			for (int i = 0; i < (sizeof(Runas) / 4); i++) {
				if (Runas[i] == itemId)
					return true;
			}
		}
		if (pMob[conn].FiltroID[8] == 1) {
			int SetDHT[] = {
				1641, //Chapéu_de_Teia(N),7.0,136.114.0.0.168,37,138000,2,2246,1,EF_CLASS,8,EF_GRID,0,EF_AC,81,EF_SAVEMANA,7,EF_ITEMLEVEL,4
				1642, //Chapéu_de_Teia(M),7.0,144.121.0.0.177,37,142000,2,2246,2,EF_CLASS,8,EF_GRID,0,EF_AC,86,EF_SAVEMANA,8,EF_ITEMLEVEL,4
				1643, //Chapéu_de_Teia(A),7.0,153.128.0.0.188,37,145000,2,2246,3,EF_CLASS,8,EF_GRID,0,EF_AC,91,EF_SAVEMANA,8,EF_MPADD,10,EF_ITEMLEVEL,4
				1644, //Peitoral_de_Teia(N),7.0,142.119.0.0.175,37,188000,4,2247,1,EF_CLASS,8,EF_GRID,0,EF_AC,106,EF_HPADD,4,EF_ITEMLEVEL,4
				1645, //Peitoral_de_Teia(M),7.0,150.126.0.0.185,37,191000,4,2247,2,EF_CLASS,8,EF_GRID,0,EF_AC,112,EF_CRITICAL,45,EF_HPADD,4,EF_ITEMLEVEL,4
				1646, //Peitoral_de_Teia(A),7.0,159.133.0.0.195,37,195000,4,2247,3,EF_CLASS,8,EF_GRID,0,EF_AC,119,EF_CRITICAL,35,EF_HPADD,5,EF_ITEMLEVEL,4
				1647, //Calça_de_Teia(N),7.0,139.117.0.0.171,37,170000,8,2248,1,EF_CLASS,8,EF_GRID,0,EF_AC,92,EF_HPADD,4,EF_ITEMLEVEL,4
				1648, //Calça_de_Teia(M),7.0,147.123.0.0.181,37,173000,8,2248,2,EF_CLASS,8,EF_GRID,0,EF_AC,97,EF_CRITICAL,45,EF_HPADD,4,EF_ITEMLEVEL,4
				1649, //Calça_de_Teia(A),7.0,156.130.0.0.192,37,176000,8,2248,3,EF_CLASS,8,EF_GRID,0,EF_AC,103,EF_CRITICAL,35,EF_HPADD,5,EF_ITEMLEVEL,4
				1650, //Braçadeira_de_Teia(N),7.0,129.109.0.0.159,37,126000,16,2249,1,EF_CLASS,8,EF_GRID,0,EF_AC,73,EF_MPADD,6,EF_ITEMLEVEL,4
				1651, //Braçadeira_de_Teia(M),7.0,137.115.0.0.169,37,129000,16,2249,2,EF_CLASS,8,EF_GRID,0,EF_AC,75,EF_ACADD,17,EF_MPADD,6,EF_ITEMLEVEL,4
				1652, //Braçadeira_de_Teia(A),7.0,146.122.0.0.180,37,131000,16,2249,3,EF_CLASS,8,EF_GRID,0,EF_AC,78,EF_ACADD,17,EF_MPADD,7,EF_ITEMLEVEL,4
				1653, //Botas_de_Teia(N),7.0,132.111.0.0.163,37,141000,32,2250,1,EF_CLASS,8,EF_GRID,0,EF_AC,73,EF_RUNSPEED,2,EF_REGENMP,30,EF_ITEMLEVEL,4
				1654, //Botas_de_Teia(M),7.0,140.118.0.0.173,37,144000,32,2250,2,EF_CLASS,8,EF_GRID,0,EF_AC,77,EF_RUNSPEED,2,EF_REGENMP,30,EF_ITEMLEVEL,4
				1655 //Botas_de_Teia(A),7.0,149.125.0.0.183,37,148000,32,2250,3,EF_CLASS,8,EF_GRID,0,EF_AC,81,EF_RUNSPEED,2,EF_REGENMP,35,EF_ITEMLEVEL,4
			};
			for (int i = 0; i < (sizeof(SetDHT) / 4); i++) {
				if (SetDHT[i] == itemId)
					return true;
			}
		}
		if (pMob[conn].FiltroID[9] == 1) {
			int SetEHT[] = {
				1660, //Elmo_Legionário,19.0,283.0.0.0.0,40,160000,2,3861,1,EF_CLASS,8,EF_GRID,0,EF_AC,102,EF_SAVEMANA,10,EF_MPADD,10,EF_ITEMLEVEL,5
				1661, //Armadura_Legionária,19.0,283.0.0.0.0,40,160000,4,3862,1,EF_CLASS,8,EF_GRID,0,EF_AC,132,EF_CRITICAL,45,EF_HPADD,8,EF_ITEMLEVEL,5
				1662, //Calça_Legionária,19.0,283.0.0.0.0,40,160000,8,3863,1,EF_CLASS,8,EF_GRID,0,EF_AC,112,EF_CRITICAL,45,EF_HPADD,9,EF_ITEMLEVEL,5
				1663, //Manoplas_Legionárias,19.0,283.0.0.0.0,40,160000,16,3864,1,EF_CLASS,8,EF_GRID,0,EF_AC,88,EF_ACADD,20,EF_MPADD,9,EF_ITEMLEVEL,5
				1664 //Botas_Legionárias,19.0,283.0.0.0.0,40,160000,32,3865,1,EF_CLASS,8,EF_GRID,0,EF_AC,90,EF_RUNSPEED,2,EF_REGENMP,45,EF_ITEMLEVEL,5
			};
			for (int i = 0; i < (sizeof(SetEHT) / 4); i++) {
				if (SetEHT[i] == itemId)
					return true;
			}
		}
		if (pMob[conn].FiltroID[10] == 1) {
			int SetArchHT[] = {
				1656, //Armadura_Rake,41.0,227.0.0.0.0,39,178000,4,2247,1,EF_CLASS,8,EF_GRID,0,EF_AC,156,EF_CRITICAL,45,EF_HPADD,8,EF_ITEMLEVEL,5,EF_MOBTYPE,1
				1657, //Calça_Rake,41.0,230.0.0.0.0,39,178000,8,2248,1,EF_CLASS,8,EF_GRID,0,EF_AC,135,EF_CRITICAL,45,EF_HPADD,8,EF_ITEMLEVEL,5,EF_MOBTYPE,1
				1658, //Manoplas_Rake,41.0,220.0.0.0.0,39,176000,16,2249,1,EF_CLASS,8,EF_GRID,0,EF_AC,104,EF_ACADD,17,EF_MPADD,8,EF_ITEMLEVEL,5,EF_MOBTYPE,1
				1659 //Botas_Rake,41.0,223.0.0.0.0,39,174000,32,2250,1,EF_CLASS,8,EF_GRID,0,EF_AC,106,EF_RUNSPEED,2,EF_REGENMP,40,EF_ITEMLEVEL,5,EF_MOBTYPE,1
			};
			for (int i = 0; i < (sizeof(SetArchHT) / 4); i++) {
				if (SetArchHT[i] == itemId)
					return true;
			}
		}
		if (pMob[conn].FiltroID[11] == 1) {
			int ArmaDHT[] = {
				825, //Arco_Divino,32.0,156.162.0.240.0,42,125000,64,2547,0,EF_CLASS,10,EF_GRID,0,EF_DAMAGE,258,EF_RANGE,5,EF_WTYPE,101,EF_ATTSPEED,1,EF_ITEMLEVEL,4
				840, //Garra_Draconiana,34.0,158.219.0.0.192,43,129000,64,2607,0,EF_CLASS,9,EF_GRID,0,EF_DAMAGE,307,EF_RANGE,0,EF_WTYPE,41,EF_AC,34,EF_ITEMLEVEL,4,EF_DEX,45
				870 //Espada_Vorpal,36.0,156.395.0.268.0,45,123000,192,2727,0,EF_CLASS,255,EF_GRID,0,EF_DAMAGE,228,EF_RANGE,2,EF_WTYPE,1,EF_ITEMLEVEL,4

			};
			for (int i = 0; i < (sizeof(ArmaDHT) / 4); i++) {
				if (ArmaDHT[i] == itemId)
					return true;
			}
		}
		if (pMob[conn].FiltroID[12] == 1) {
			int ArmaEHT[] = {
				3556, //Arco_Guardião,2809.0,260.0.0.0.0,42,251000,64,3621,0,EF_CLASS,10,EF_GRID,0,EF_DAMAGE,290,EF_RANGE,5,EF_WTYPE,101,EF_ATTSPEED,1,EF_MOBTYPE,2,EF_ITEMLEVEL,5
				3561, //Dianus,2810.0,254.0.0.0.0,43,251000,64,3641,0,EF_CLASS,9,EF_GRID,0,EF_DAMAGE,340,EF_RANGE,0,EF_WTYPE,41,EF_AC,40,EF_MOBTYPE,2,EF_ITEMLEVEL,5,EF_DEX,60
				3571 //Vingadora,2813.0,257.0.0.0.0,45,251000,192,3681,0,EF_CLASS,255,EF_GRID,0,EF_DAMAGE,245,EF_RANGE,2,EF_WTYPE,1,EF_MOBTYPE,2,EF_ITEMLEVEL,5

			};
			for (int i = 0; i < (sizeof(ArmaEHT) / 4); i++) {
				if (ArmaEHT[i] == itemId)
					return true;
			}
		}
		if (pMob[conn].FiltroID[13] == 1) {
			int ArmaArchHT[] = {
				826, //Skytalos,762.0,290.0.0.0.0,42,270000,64,2551,0,EF_CLASS,10,EF_GRID,0,EF_DAMAGE,305,EF_RANGE,5,EF_WTYPE,101,EF_ATTSPEED,1,EF_MOBTYPE,1,EF_ITEMLEVEL,5
				841, //Khyrius,763.0,282.0.0.0.0,43,270000,64,2611,0,EF_CLASS,9,EF_GRID,0,EF_DAMAGE,354,EF_RANGE,1,EF_WTYPE,41,EF_AC,45,EF_MOBTYPE,1,EF_ITEMLEVEL,5,EF_DEX,75
				871 //Caliburn,766.0,285.0.0.0.0,45,270000,192,2731,0,EF_CLASS,255,EF_GRID,0,EF_DAMAGE,255,EF_RANGE,2,EF_WTYPE,1,EF_MOBTYPE,1,EF_ITEMLEVEL,5

			};
			for (int i = 0; i < (sizeof(ArmaArchHT) / 4); i++) {
				if (ArmaArchHT[i] == itemId)
					return true;
			}
		}
		if (pMob[conn].FiltroID[14] == 1) {
			int SetDTK[] = {
				1206, //Elmo_Embutido(N),14.0,141.219.0.0.147,8,138000,2,2186,1,EF_CLASS,1,EF_GRID,0,EF_AC,83,EF_SAVEMANA,8,EF_ITEMLEVEL,4
				1207, //Elmo_Embutido(M),14.0,148.230.0.0.154,8,142000,2,2186,2,EF_CLASS,1,EF_GRID,0,EF_AC,87,EF_SAVEMANA,9,EF_ITEMLEVEL,4
				1208, //Elmo_Embutido(A),14.0,154.239.0.0.160,8,145000,2,2186,3,EF_CLASS,1,EF_GRID,0,EF_AC,92,EF_SAVEMANA,9,EF_MPADD,10,EF_ITEMLEVEL,4
				1209, //Armadura_Embutida(N),14.0,147.228.0.0.153,8,188000,4,2187,1,EF_CLASS,1,EF_GRID,0,EF_AC,108,EF_HPADD,5,EF_ITEMLEVEL,4
				1210, //Armadura_Embutida(M),14.0,152.236.0.0.158,8,191000,4,2187,2,EF_CLASS,1,EF_GRID,0,EF_AC,114,EF_CRITICAL,45,EF_HPADD,5,EF_ITEMLEVEL,4
				1211, //Armadura_Embutida(A),14.0,159.246.0.0.165,8,195000,4,2187,3,EF_CLASS,1,EF_GRID,0,EF_AC,120,EF_CRITICAL,35,EF_HPADD,6,EF_ITEMLEVEL,4
				1212, //Calça_Embutida(N),14.0,144.224.0.0.150,8,170000,8,2188,1,EF_CLASS,1,EF_GRID,0,EF_AC,94,EF_HPADD,5,EF_ITEMLEVEL,4
				1213, //Calça_Embutida(M),14.0,150.233.0.0.156,8,173000,8,2188,2,EF_CLASS,1,EF_GRID,0,EF_AC,99,EF_CRITICAL,45,EF_HPADD,5,EF_ITEMLEVEL,4
				1214, //Calça_Embutida(A),14.0,157.243.0.0.163,8,176000,8,2188,3,EF_CLASS,1,EF_GRID,0,EF_AC,104,EF_CRITICAL,35,EF_HPADD,6,EF_ITEMLEVEL,4
				1215, //Manoplas_Embutidas(N),14.0,136.212.0.0.142,8,126000,16,2189,1,EF_CLASS,1,EF_GRID,0,EF_AC,73,EF_MPADD,7,EF_ITEMLEVEL,4
				1216, //Manoplas_Embutidas(M),14.0,142.221.0.0.148,8,129000,16,2189,2,EF_CLASS,1,EF_GRID,0,EF_AC,76,EF_ACADD,17,EF_MPADD,7,EF_ITEMLEVEL,4
				1217, //Manoplas_Embutidas(A),14.0,149.231.0.0.155,8,131000,16,2189,3,EF_CLASS,1,EF_GRID,0,EF_AC,80,EF_ACADD,17,EF_MPADD,8,EF_ITEMLEVEL,4
				1218, //Botas_Embutidas(N),14.0,139.216.0.0.145,8,141000,32,2190,1,EF_CLASS,1,EF_GRID,0,EF_AC,74,EF_RUNSPEED,2,EF_REGENMP,35,EF_ITEMLEVEL,4
				1219, //Botas_Embutidas(M),14.0,145.225.0.0.151,8,144000,32,2190,2,EF_CLASS,1,EF_GRID,0,EF_AC,78,EF_RUNSPEED,2,EF_REGENMP,35,EF_ITEMLEVEL,4
				1220 //Botas_Embutidas(A),14.0,151.234.0.0.157,8,148000,32,2190,3,EF_CLASS,1,EF_GRID,0,EF_AC,82,EF_RUNSPEED,2,EF_REGENMP,40,EF_ITEMLEVEL,4
			};
			for (int i = 0; i < (sizeof(SetDTK) / 4); i++) {
				if (SetDTK[i] == itemId)
					return true;
			}
		}
		if (pMob[conn].FiltroID[15] == 1) {
			int SetETK[] = {
				1225, //Elmo_Mortal,19.0,285.0.0.0.0,10,160000,2,3801,1,EF_CLASS,1,EF_GRID,0,EF_AC,108,EF_SAVEMANA,10,EF_MPADD,10,EF_ITEMLEVEL,5
				1226, //Armadura_Mortal,19.0,285.0.0.0.0,10,160000,4,3802,1,EF_CLASS,1,EF_GRID,0,EF_AC,138,EF_CRITICAL,50,EF_HPADD,9,EF_ITEMLEVEL,5
				1227, //Calça_Mortal,19.0,285.0.0.0.0,10,160000,8,3803,1,EF_CLASS,1,EF_GRID,0,EF_AC,122,EF_CRITICAL,50,EF_HPADD,9,EF_ITEMLEVEL,5
				1228, //Monaplas_Mortais,19.0,285.0.0.0.0,10,160000,16,3804,1,EF_CLASS,1,EF_GRID,0,EF_AC,94,EF_ACADD,20,EF_MPADD,8,EF_ITEMLEVEL,5
				1229, //Botas_Mortais,19.0,285.0.0.0.0,10,160000,32,3805,1,EF_CLASS,1,EF_GRID,0,EF_AC,96,EF_RUNSPEED,2,EF_REGENMP,40,EF_ITEMLEVEL,5
			};
			for (int i = 0; i < (sizeof(SetETK) / 4); i++) {
				if (SetETK[i] == itemId)
					return true;
			}
		}
		if (pMob[conn].FiltroID[16] == 1) {
			int SetArchTK[] = {
				1221, //Armadura_Flamejante,41.0,227.0.0.0.0,9,178000,4,2187,1,EF_CLASS,1,EF_GRID,0,EF_AC,156,EF_CRITICAL,45,EF_HPADD,8,EF_ITEMLEVEL,5,EF_MOBTYPE,1
				1222, //Calça_Flamejante,41.0,230.0.0.0.0,9,178000,8,2188,1,EF_CLASS,1,EF_GRID,0,EF_AC,135,EF_CRITICAL,45,EF_HPADD,8,EF_ITEMLEVEL,5,EF_MOBTYPE,1
				1223, //Manoplas_Flamejantes,41.0,220.0.0.0.0,9,176000,16,2189,1,EF_CLASS,1,EF_GRID,0,EF_AC,104,EF_ACADD,17,EF_MPADD,8,EF_ITEMLEVEL,5,EF_MOBTYPE,1
				1224, //Botas_Flamejantes,41.0,223.0.0.0.0,9,174000,32,2190,1,EF_CLASS,1,EF_GRID,0,EF_AC,106,EF_RUNSPEED,3,EF_REGENMP,40,EF_ITEMLEVEL,5,EF_MOBTYPE,1
			};
			for (int i = 0; i < (sizeof(SetArchTK) / 4); i++) {
				if (SetArchTK[i] == itemId)
					return true;
			}
		}
		if (pMob[conn].FiltroID[17] == 1) {
			int ArmaDTK[] = {
				810, //Martelo_Assassino,31.0,157.552.0.0.0,41,130000,192,2487,0,EF_CLASS,255,EF_GRID,0,EF_DAMAGE,229,EF_RANGE,2,EF_WTYPE,11,EF_ITEMLEVEL,4
				855, //Lança_do_Triunfo,35.0,158.145.243.0.0,44,133000,64,2667,0,EF_CLASS,5,EF_GRID,0,EF_DAMAGE,232,EF_RANGE,2,EF_WTYPE,21,EF_MAGIC,50,EF_ITEMLEVEL,4
				911 //Solaris,38.0,159.522.0.158.0,48,150000,64,2891,0,EF_CLASS,1,EF_GRID,0,EF_DAMAGE,333,EF_RANGE,2,EF_WTYPE,3,EF_ITEMLEVEL,4,EF_INT,60
			};
			for (int i = 0; i < (sizeof(ArmaDTK) / 4); i++) {
				if (ArmaDTK[i] == itemId)
					return true;
			}
		}
		if (pMob[conn].FiltroID[18] == 1) {
			int ArmaETK[] = {
				3551, //Asa_Draconiana,2805.0,257.0.0.0.0,41,251000,192,3601,0,EF_CLASS,255,EF_GRID,0,EF_DAMAGE,246,EF_RANGE,2,EF_WTYPE,11,EF_MOBTYPE,2,EF_ITEMLEVEL,5
				3591, //Éden,2807.0,259.0.0.0.0,48,251000,64,3761,0,EF_CLASS,1,EF_GRID,0,EF_DAMAGE,380,EF_RANGE,2,EF_WTYPE,3,EF_MOBTYPE,2,EF_ITEMLEVEL,5,EF_INT,75
				3596, //Demolidor_Celestial,2806.0,260.0.0.0.0,49,251000,64,3781,0,EF_CLASS,1,EF_GRID,0,EF_DAMAGE,382,EF_RANGE,2,EF_WTYPE,13,EF_MOBTYPE,2,EF_ITEMLEVEL,5,EF_CRITICAL,30
				3566 //Foice_Platinada,2812.0,260.0.0.0.0,44,251000,64,3661,0,EF_CLASS,5,EF_GRID,0,EF_DAMAGE,252,EF_RANGE,2,EF_WTYPE,21,EF_MAGIC,53,EF_MOBTYPE,2,EF_ITEMLEVEL,5
			};
			for (int i = 0; i < (sizeof(ArmaETK) / 4); i++) {
				if (ArmaETK[i] == itemId)
					return true;
			}
		}
		if (pMob[conn].FiltroID[19] == 1) {
			int ArmaArchTK[] = {
				811, //Balmung,758.0,285.0.0.0.0,41,270000,192,2491,0,EF_CLASS,255,EF_GRID,0,EF_DAMAGE,256,EF_RANGE,2,EF_WTYPE,11,EF_MOBTYPE,1,EF_ITEMLEVEL,5
				856, //Gleipnir,765.0,290.0.0.0.0,44,270000,64,2671,0,EF_CLASS,5,EF_GRID,0,EF_DAMAGE,258,EF_RANGE,2,EF_WTYPE,21,EF_MAGIC,55,EF_MOBTYPE,1,EF_ITEMLEVEL,5
				912 //Thrasytes,760.0,290.0.0.0.0,48,270000,64,2895,0,EF_CLASS,1,EF_GRID,0,EF_DAMAGE,396,EF_RANGE,2,EF_WTYPE,3,EF_MOBTYPE,1,EF_ITEMLEVEL,5,EF_INT,90
			};
			for (int i = 0; i < (sizeof(ArmaArchTK) / 4); i++) {
				if (ArmaArchTK[i] == itemId)
					return true;
			}
		}
		if (pMob[conn].FiltroID[20] == 1) {
			int SetDBM[] = {
				1491, //Elmo_Elemental(N),12.0,136.155.154.0.0,27,138000,2,2226,1,EF_CLASS,4,EF_GRID,0,EF_AC,80,EF_SAVEMANA,7,EF_ITEMLEVEL,4
				1492, //Elmo_Elemental(M),12.0,144.164.163.0.0,27,142000,2,2226,2,EF_CLASS,4,EF_GRID,0,EF_AC,85,EF_SAVEMANA,8,EF_ITEMLEVEL,4
				1493, //Elmo_Elemental(A),12.0,153.174.173.0.0,27,145000,2,2226,3,EF_CLASS,4,EF_GRID,0,EF_AC,90,EF_SAVEMANA,8,EF_MPADD,10,EF_ITEMLEVEL,4
				1494, //Armadura_Elemental(N),12.0,142.162.161.0.0,27,188000,4,2227,1,EF_CLASS,4,EF_GRID,0,EF_AC,104,EF_HPADD,5,EF_ITEMLEVEL,4
				1495, //Armadura_Elemental(M),12.0,150.171.170.0.0,27,191000,4,2227,2,EF_CLASS,4,EF_GRID,0,EF_AC,111,EF_CRITICAL,45,EF_HPADD,5,EF_ITEMLEVEL,4
				1496, //Armadura_Elemental(A),12.0,159.180.179.0.0,27,195000,4,2227,3,EF_CLASS,4,EF_GRID,0,EF_AC,118,EF_CRITICAL,35,EF_HPADD,6,EF_ITEMLEVEL,4
				1497, //Calça_Elemental(N),12.0,139.158.157.0.0,27,170000,8,2228,1,EF_CLASS,4,EF_GRID,0,EF_AC,91,EF_HPADD,5,EF_ITEMLEVEL,4
				1498, //Calça_Elemental(M),12.0,147.167.166.0.0,27,173000,8,2228,2,EF_CLASS,4,EF_GRID,0,EF_AC,96,EF_CRITICAL,45,EF_HPADD,5,EF_ITEMLEVEL,4
				1499, //Calça_Elemental(A),12.0,156.177.176.0.0,27,176000,8,2228,3,EF_CLASS,4,EF_GRID,0,EF_AC,101,EF_CRITICAL,35,EF_HPADD,6,EF_ITEMLEVEL,4
				1500, //Manoplas_Elementais(N),12.0,129.147.146.0.0,27,126000,16,2229,1,EF_CLASS,4,EF_GRID,0,EF_AC,72,EF_MPADD,6,EF_ITEMLEVEL,4
				1501, //Manoplas_Elementais(M),12.0,137.156.155.0.0,27,129000,16,2229,2,EF_CLASS,4,EF_GRID,0,EF_AC,74,EF_ACADD,17,EF_MPADD,6,EF_ITEMLEVEL,4
				1502, //Manoplas_Elementais(A),12.0,146.166.165.0.0,27,131000,16,2229,3,EF_CLASS,4,EF_GRID,0,EF_AC,78,EF_ACADD,17,EF_MPADD,7,EF_ITEMLEVEL,4
				1503, //Botas_Elementais(N),12.0,132.151.150.0.0,27,141000,32,2230,1,EF_CLASS,4,EF_GRID,0,EF_AC,73,EF_RUNSPEED,2,EF_REGENMP,30,EF_ITEMLEVEL,4
				1504, //Botas_Elementais(M),12.0,140.160.159.0.0,27,144000,32,2230,2,EF_CLASS,4,EF_GRID,0,EF_AC,76,EF_RUNSPEED,2,EF_REGENMP,30,EF_ITEMLEVEL,4
				1505 //Botas_Elementais(A),12.0,149.169.168.0.0,27,148000,32,2230,3,EF_CLASS,4,EF_GRID,0,EF_AC,79,EF_RUNSPEED,2,EF_REGENMP,35,EF_ITEMLEVEL,4
			};
			for (int i = 0; i < (sizeof(SetDBM) / 4); i++) {
				if (SetDBM[i] == itemId)
					return true;
			}
		}
		if (pMob[conn].FiltroID[21] == 1) {
			int SetEBM[] = {
				1510, //Elmo_do_Corvo,19.0,284.0.0.0.0,30,160000,2,3841,1,EF_CLASS,4,EF_GRID,0,EF_AC,100,EF_SAVEMANA,10,EF_MPADD,11,EF_ITEMLEVEL,5
				1511, //Armadura_do_Corvo,19.0,284.0.0.0.0,30,160000,4,3842,1,EF_CLASS,4,EF_GRID,0,EF_AC,128,EF_CRITICAL,45,EF_HPADD,8,EF_ITEMLEVEL,5
				1512, //Calça_do_Corvo,19.0,284.0.0.0.0,30,160000,8,3843,1,EF_CLASS,4,EF_GRID,0,EF_AC,110,EF_CRITICAL,45,EF_HPADD,8,EF_ITEMLEVEL,5
				1513, //Manoplas_do_Corvo,19.0,284.0.0.0.0,30,160000,16,3844,1,EF_CLASS,4,EF_GRID,0,EF_AC,86,EF_ACADD,20,EF_MPADD,9,EF_ITEMLEVEL,5
				1514 //Botas_do_Corvo,19.0,284.0.0.0.0,30,160000,32,3845,1,EF_CLASS,4,EF_GRID,0,EF_AC,88,EF_RUNSPEED,2,EF_REGENMP,45,EF_ITEMLEVEL,5
			};
			for (int i = 0; i < (sizeof(SetEBM) / 4); i++) {
				if (SetEBM[i] == itemId)
					return true;
			}
		}
		if (pMob[conn].FiltroID[22] == 1) {
			int SetArchBM[] = {
				1506, //Armadura_da_Destruição,41.0,227.0.0.0.0,29,178000,4,2227,1,EF_CLASS,4,EF_GRID,0,EF_AC,156,EF_CRITICAL,45,EF_HPADD,8,EF_ITEMLEVEL,5,EF_MOBTYPE,1
				1507, //Calça_da_Destruição,41.0,230.0.0.0.0,29,178000,8,2228,1,EF_CLASS,4,EF_GRID,0,EF_AC,135,EF_CRITICAL,45,EF_HPADD,8,EF_ITEMLEVEL,5,EF_MOBTYPE,1
				1508, //Manoplas_da_Derstruição,41.0,220.0.0.0.0,29,176000,16,2229,1,EF_CLASS,4,EF_GRID,0,EF_AC,104,EF_ACADD,17,EF_MPADD,8,EF_ITEMLEVEL,5,EF_MOBTYPE,1
				1509 //Botas_da_Destruição,41.0,223.0.0.0.0,29,174000,32,2230,1,EF_CLASS,4,EF_GRID,0,EF_AC,106,EF_RUNSPEED,2,EF_REGENMP,40,EF_ITEMLEVEL,5,EF_MOBTYPE,1
			};
			for (int i = 0; i < (sizeof(SetArchBM) / 4); i++) {
				if (SetArchBM[i] == itemId)
					return true;
			}
		}
		if (pMob[conn].FiltroID[23] == 1) {
			int ArmaDBM[] = {
				810, //Martelo_Assassino,31.0,157.552.0.0.0,41,130000,192,2487,0,EF_CLASS,255,EF_GRID,0,EF_DAMAGE,229,EF_RANGE,2,EF_WTYPE,11,EF_ITEMLEVEL,4
				855, //Lança_do_Triunfo,35.0,158.145.243.0.0,44,133000,64,2667,0,EF_CLASS,5,EF_GRID,0,EF_DAMAGE,232,EF_RANGE,2,EF_WTYPE,21,EF_MAGIC,50,EF_ITEMLEVEL,4
				885 //Cruz_Sagrada,37.0,158.256.0.237.0,46,122000,64,2787,0,EF_CLASS,5,EF_GRID,0,EF_DAMAGE,228,EF_RANGE,4,EF_WTYPE,103,EF_ATTSPEED,1,EF_ITEMLEVEL,4
			};
			for (int i = 0; i < (sizeof(ArmaDBM) / 4); i++) {
				if (ArmaDBM[i] == itemId)
					return true;
			}
		}
		if (pMob[conn].FiltroID[24] == 1) {
			int ArmaEBM[] = {
				3551, //Asa_Draconiana,2805.0,257.0.0.0.0,41,251000,192,3601,0,EF_CLASS,255,EF_GRID,0,EF_DAMAGE,246,EF_RANGE,2,EF_WTYPE,11,EF_MOBTYPE,2,EF_ITEMLEVEL,5
				3566, //Foice_Platinada,2812.0,260.0.0.0.0,44,251000,64,3661,0,EF_CLASS,5,EF_GRID,0,EF_DAMAGE,252,EF_RANGE,2,EF_WTYPE,21,EF_MAGIC,53,EF_MOBTYPE,2,EF_ITEMLEVEL,5
				3576 //Karikas,2814.0,258.0.0.0.0,46,251000,64,3701,0,EF_CLASS,5,EF_GRID,0,EF_DAMAGE,254,EF_RANGE,4,EF_WTYPE,103,EF_ATTSPEED,1,EF_MOBTYPE,2,EF_ITEMLEVEL,5
			};
			for (int i = 0; i < (sizeof(ArmaEBM) / 4); i++) {
				if (ArmaEBM[i] == itemId)
					return true;
			}
		}
		if (pMob[conn].FiltroID[25] == 1) {
			int ArmaArchBM[] = {
				811, //Balmung,758.0,285.0.0.0.0,41,270000,192,2491,0,EF_CLASS,255,EF_GRID,0,EF_DAMAGE,256,EF_RANGE,2,EF_WTYPE,11,EF_MOBTYPE,1,EF_ITEMLEVEL,5
				856, //Gleipnir,765.0,290.0.0.0.0,44,270000,64,2671,0,EF_CLASS,5,EF_GRID,0,EF_DAMAGE,258,EF_RANGE,2,EF_WTYPE,21,EF_MAGIC,55,EF_MOBTYPE,1,EF_ITEMLEVEL,5
				886 //Hermai,767.0,284.0.0.0.0,46,270000,64,2791,0,EF_CLASS,5,EF_GRID,0,EF_DAMAGE,264,EF_RANGE,4,EF_WTYPE,103,EF_ATTSPEED,1,EF_MOBTYPE,1,EF_ITEMLEVEL,5
			};
			for (int i = 0; i < (sizeof(ArmaArchBM) / 4); i++) {
				if (ArmaArchBM[i] == itemId)
					return true;
			}
		}
		if (pMob[conn].FiltroID[26] == 1) {
			int SetDFM[] = {
				1341,//Chapéu_de_Mytril(N),11.0,136.113.198.0.0,17,138000,2,2206,1,EF_CLASS,2,EF_GRID,0,EF_AC,79,EF_SAVEMANA,7,EF_ITEMLEVEL,4
				1342,//Chapéu_de_Mytril(M),11.0,144.120.209.0.0,17,142000,2,2206,2,EF_CLASS,2,EF_GRID,0,EF_AC,83,EF_SAVEMANA,8,EF_ITEMLEVEL,4
				1343,//Chapéu_de_Mytril(A),11.0,153.127.222.0.0,17,145000,2,2206,3,EF_CLASS,2,EF_GRID,0,EF_AC,89,EF_SAVEMANA,8,EF_MPADD,10,EF_ITEMLEVEL,4
				1344,//Túnica_de_Mytril(N),11.0,142.118.206.0.0,17,188000,4,2207,1,EF_CLASS,2,EF_GRID,0,EF_AC,103,EF_HPADD,5,EF_ITEMLEVEL,4
				1345,//Túnica_de_Mytril(M),11.0,150.125.218.0.0,17,191000,4,2207,2,EF_CLASS,2,EF_GRID,0,EF_AC,110,EF_CRITICAL,45,EF_HPADD,5,EF_ITEMLEVEL,4
				1346,//Túnica_de_Mytril(A),11.0,159.132.230.0.0,17,195000,4,2207,3,EF_CLASS,2,EF_GRID,0,EF_AC,117,EF_CRITICAL,35,EF_HPADD,6,EF_ITEMLEVEL,4
				1347,//Calça_de_Mytril(N),11.0,139.116.202.0.0,17,170000,8,2208,1,EF_CLASS,2,EF_GRID,0,EF_AC,90,EF_HPADD,5,EF_ITEMLEVEL,4
				1348,//Calça_de_Mytril(M),11.0,147.122.213.0.0,17,173000,8,2208,2,EF_CLASS,2,EF_GRID,0,EF_AC,95,EF_CRITICAL,45,EF_HPADD,5,EF_ITEMLEVEL,4
				1349,//Calça_de_Mytril(A),11.0,156.129.226.0.0,17,176000,8,2208,3,EF_CLASS,2,EF_GRID,0,EF_AC,100,EF_CRITICAL,35,EF_HPADD,6,EF_ITEMLEVEL,4
				1350,//Luvas_de_Mytril(N),11.0,129.108.188.0.0,17,126000,16,2209,1,EF_CLASS,2,EF_GRID,0,EF_AC,71,EF_MPADD,6,EF_ITEMLEVEL,4
				1351,//Luvas_de_Mytril(M),11.0,137.114.199.0.0,17,129000,16,2209,2,EF_CLASS,2,EF_GRID,0,EF_AC,73,EF_ACADD,17,EF_MPADD,6,EF_ITEMLEVEL,4
				1352,//Luvas_de_Mytril(A),11.0,146.121.212.0.0,17,131000,16,2209,3,EF_CLASS,2,EF_GRID,0,EF_AC,76,EF_ACADD,17,EF_MPADD,7,EF_ITEMLEVEL,4
				1353,//Botas_de_Mytril(N),11.0,132.110.192.0.0,17,141000,32,2210,1,EF_CLASS,2,EF_GRID,0,EF_AC,73,EF_RUNSPEED,2,EF_REGENMP,30,EF_ITEMLEVEL,4
				1354,//Botas_de_Mytril(M),11.0,140.117.204.0.0,17,144000,32,2210,2,EF_CLASS,2,EF_GRID,0,EF_AC,75,EF_RUNSPEED,2,EF_REGENMP,30,EF_ITEMLEVEL,4
				1355//Botas_de_Mytril(A),11.0,149.124.216.0.0,17,148000,32,2210,3,EF_CLASS,2,EF_GRID,0,EF_AC,78,EF_RUNSPEED,2,EF_REGENMP,35,EF_ITEMLEVEL,4
			};
			for (int i = 0; i < (sizeof(SetDFM) / 4); i++) {
				if (SetDFM[i] == itemId)
					return true;
			}
		}
		if (pMob[conn].FiltroID[27] == 1) {
			int SetEFM[] = {
				1360,//Elmo_Templário,19.0,281.0.0.0.0,20,160000,2,3821,1,EF_CLASS,2,EF_GRID,0,EF_AC,102,EF_SAVEMANA,10,EF_MPADD,11,EF_ITEMLEVEL,5
				1361,//Túnica_Templária,19.0,281.0.0.0.0,20,160000,4,3822,1,EF_CLASS,2,EF_GRID,0,EF_AC,132,EF_CRITICAL,45,EF_HPADD,8,EF_ITEMLEVEL,5
				1362,//Calça_Templária,19.0,281.0.0.0.0,20,160000,8,3823,1,EF_CLASS,2,EF_GRID,0,EF_AC,112,EF_CRITICAL,45,EF_HPADD,8,EF_ITEMLEVEL,5
				1363,//Manoplas_Templárias,19.0,281.0.0.0.0,20,160000,16,3824,1,EF_CLASS,2,EF_GRID,0,EF_AC,88,EF_ACADD,20,EF_MPADD,9,EF_ITEMLEVEL,5
				1364//Botas_Templárias,19.0,281.0.0.0.0,20,160000,32,3825,1,EF_CLASS,2,EF_GRID,0,EF_AC,90,EF_RUNSPEED,2,EF_REGENMP,45,EF_ITEMLEVEL,5
			};
			for (int i = 0; i < (sizeof(SetEFM) / 4); i++) {
				if (SetEFM[i] == itemId)
					return true;
			}
		}
		if (pMob[conn].FiltroID[28] == 1) {
			int SetArchFM[] = {
				1356,//Túnica_Guardiã,41.0,227.0.0.0.0,19,178000,4,2207,1,EF_CLASS,2,EF_GRID,0,EF_AC,156,EF_CRITICAL,45,EF_HPADD,8,EF_ITEMLEVEL,5,EF_MOBTYPE,1
				1357,//Calça_Guardiã,41.0,230.0.0.0.0,19,178000,8,2208,1,EF_CLASS,2,EF_GRID,0,EF_AC,135,EF_CRITICAL,45,EF_HPADD,8,EF_ITEMLEVEL,5,EF_MOBTYPE,1
				1358,//Manoplas_Guardiãs,41.0,220.0.0.0.0,19,176000,16,2209,1,EF_CLASS,2,EF_GRID,0,EF_AC,104,EF_ACADD,17,EF_MPADD,8,EF_ITEMLEVEL,5,EF_MOBTYPE,1
				1359//Botas_Guardiãs,41.0,223.0.0.0.0,19,174000,32,2210,1,EF_CLASS,2,EF_GRID,0,EF_AC,106,EF_RUNSPEED,2,EF_REGENMP,40,EF_ITEMLEVEL,5,EF_MOBTYPE,1
			};
			for (int i = 0; i < (sizeof(SetArchFM) / 4); i++) {
				if (SetArchFM[i] == itemId)
					return true;
			}
		}	
		if (pMob[conn].FiltroID[29] == 1) {
			int ArmaDFM[] = {
				825, //Arco_Divino,32.0,156.162.0.240.0,42,125000,64,2547,0,EF_CLASS,10,EF_GRID,0,EF_DAMAGE,258,EF_RANGE,5,EF_WTYPE,101,EF_ATTSPEED,1,EF_ITEMLEVEL,4
				870, //Espada_Vorpal,36.0,156.395.0.268.0,45,123000,192,2727,0,EF_CLASS,255,EF_GRID,0,EF_DAMAGE,228,EF_RANGE,2,EF_WTYPE,1,EF_ITEMLEVEL,4
				902, //Cajado_de_Âmbar,916.0,150.81.231.0.0,47,85000,192,2855,0,EF_CLASS,2,EF_GRID,0,EF_DAMAGE,162,EF_RANGE,1,EF_WTYPE,31,EF_MAGIC,24,EF_ITEMLEVEL,4
				900 //Fúria_Divina,33.0,157.147.446.0.0,47,128000,64,2847,0,EF_CLASS,2,EF_GRID,0,EF_DAMAGE,223,EF_RANGE,2,EF_WTYPE,32,EF_MAGIC,50,EF_ITEMLEVEL,4
			};
			for (int i = 0; i < (sizeof(ArmaDFM) / 4); i++) {
				if (ArmaDFM[i] == itemId)
					return true;
			}
		}
		if (pMob[conn].FiltroID[30] == 1) {
			int ArmaEFM[] = {
				3556, //Arco_Guardião,2809.0,260.0.0.0.0,42,251000,64,3621,0,EF_CLASS,10,EF_GRID,0,EF_DAMAGE,290,EF_RANGE,5,EF_WTYPE,101,EF_ATTSPEED,1,EF_MOBTYPE,2,EF_ITEMLEVEL,5
				3571, //Vingadora,2813.0,257.0.0.0.0,45,251000,192,3681,0,EF_CLASS,255,EF_GRID,0,EF_DAMAGE,245,EF_RANGE,2,EF_WTYPE,1,EF_MOBTYPE,2,EF_ITEMLEVEL,5
				3582, //Cajado_Caótico,2808.0,259.0.0.0.0,47,251000,64,3725,0,EF_CLASS,2,EF_GRID,0,EF_DAMAGE,226,EF_RANGE,2,EF_WTYPE,32,EF_MAGIC,55,EF_MOBTYPE,2,EF_ITEMLEVEL,5
				3581, //Força_Eterna,2815.0,255.0.0.0.0,47,251000,192,3721,0,EF_CLASS,2,EF_GRID,0,EF_DAMAGE,164,EF_RANGE,1,EF_WTYPE,31,EF_MAGIC,30,EF_MOBTYPE,2,EF_ITEMLEVEL,5
			};
			for (int i = 0; i < (sizeof(ArmaEFM) / 4); i++) {
				if (ArmaEFM[i] == itemId)
					return true;
			}
		}
		if (pMob[conn].FiltroID[31] == 1) {
			int ArmaArchFM[] = {
				826, //Skytalos,762.0,290.0.0.0.0,42,270000,64,2551,0,EF_CLASS,10,EF_GRID,0,EF_DAMAGE,305,EF_RANGE,5,EF_WTYPE,101,EF_ATTSPEED,1,EF_MOBTYPE,1,EF_ITEMLEVEL,5
				871, //Caliburn,766.0,285.0.0.0.0,45,270000,192,2731,0,EF_CLASS,255,EF_GRID,0,EF_DAMAGE,255,EF_RANGE,2,EF_WTYPE,1,EF_MOBTYPE,1,EF_ITEMLEVEL,5
				903, //Eirenus,761.0,288.0.0.0.0,47,270000,64,2863,0,EF_CLASS,2,EF_GRID,0,EF_DAMAGE,230,EF_RANGE,2,EF_WTYPE,32,EF_MAGIC,57,EF_MOBTYPE,1,EF_ITEMLEVEL,5
				904 //Neorion,768.0,284.0.0.0.0,47,270000,192,2859,0,EF_CLASS,2,EF_GRID,0,EF_DAMAGE,170,EF_RANGE,1,EF_WTYPE,31,EF_MAGIC,32,EF_MOBTYPE,1,EF_ITEMLEVEL,5
			};
			for (int i = 0; i < (sizeof(ArmaArchFM) / 4); i++) {
				if (ArmaArchFM[i] == itemId)
					return true;
			}
		}

		//SendMsgExp(conn, strFmt("Item [%s - ID [%d]] foi deletado pelo autodrop.", g_pItemList[itemId].Name, itemId), TNColor::GreenYellow, false);
		return false;
	}
	else
		return true;
}

bool AgroupList(int conn, int itemId)
{
	//Box Quest
	if (itemId >= 4117 && itemId <= 4121)
		return true;

	//Olho Crescente
	if (itemId == 481)
		return true;

	if (pMob[conn].MOB.Equip[13].sIndex == 3901 || pMob[conn].MOB.Equip[13].sIndex == 3902 || pMob[conn].MOB.Equip[13].sIndex == 3916) {

		int List[] = {
			4026, //Moeda 1kk
			4019, //Classe_D
			4020, //Classe_E
			419, //Resto_de_Oriharucon
			420, //Resto_de_Lactolerium
			412, //Poeira_de_Oriharucon
			413, //Poeira_de_Lactolerium
			578, //Pedra_de_Adamantita
			2441, //Diamante
			2442, //Esmeralda
			2443, //Coral
			2444, //Garnet
			1774, //Pedra_do_Sábio
			3140, //Pedra_da_Luz
			2396, //Âmago_de_Cav_s/Sela_N
			2397, //Âmago_de_Cav_Fantasm_N
			2398, //Âmago_de_Cavalo_Leve_N
			2399, //Âmago_de_Cavalo_Equip_N
			2400, //Âmago_de_Andaluz_N
			2401, //Âmago_de_Ca_s/Sela_B
			2402, //Âmago_de_Cav_Fantasm_B
			2403, //Âmago_de_Cavalo_Leve_B
			2404, //Âmago_de_Cavalo_Equip_B
			2405, //Âmago_de_Andaluz_B
			2406, //Âmago_de_Fenrir
			2411, //Âmago_de_Unicórnio
			2412, //Âmago_de_Pégasus
			2413, //Âmago_de_Unisus
			2390, //Âmago_de_Porco
			2391, //Âmago_de_Javali
			2392, //Âmago_de_Lobo
			2393, //Âmago_de_Dragão_Menor
			2394, //Âmago_de_Urso
			2395 //Âmago_de_Dente_de_Sabre
		};

		for (int i = 0; i < (sizeof(List) / 4); i++) {
			if (itemId == List[i])
				return true;
		}
		return false;
	}
	return false;
}

bool LogList(int itemId)
{
	int List[] = {
		4026, //Moeda 1kk
		412, //Poeira_de_Oriharucon
		413, //Poeira_de_Lactolerium
		1774, //Pedra_do_Sábio
		2441, //Diamante
		2442, //Esmeralda
		2443, //Coral
		2444, //Garnet
		3140, //Pedra_da_Luz
		2399, //Âmago_de_Cavalo_Equip_N
		2404, //Âmago_de_Cavalo_Equip_B
		2400, //Âmago_de_Andaluz_N
		2405, //Âmago_de_Andaluz_B
		2411, //Âmago_de_Unicórnio
		2412, //Âmago_de_Pégasus
		2413, //Âmago_de_Unisus
		2414, //Âmago_de_Grifo
		2416, //Âmago_de_Grifo_Sang
		2417, //Âmago_de_Svadilfari
		2418, //Âmago_de_Sleipnir
		2409, //Âmago_de_Tigre_de_Fogo
		2410, //Âmago_de_Dragão_Verm
		1741, //Alma_da_Fênix
		1740, //Alma_do_Unicórnio
		1742, //Pedra_da_Imortalidade
		5110, //Ansuz
		5111, //Uraz
		5112, //Thurisaz
		5113, //Fehu
		5114, //Raidho
		5115, //Kenaz
		5116, //Naudhiz
		5117, //Gebo
		5118, //Wunjo
		5119, //Hagalaz
		5120, //Isa
		5121, //Jara
		5122, //Eihwaz
		5123, //Perthro
		5124, //Elhaz
		5125, //Sowilo
		5126, //Berkano
		5127, //Ehwaz
		5128, //Tiwaz
		5129, //Mannaz
		5130, //Laguz
		5131, //Dagaz
		5132, //Ing
		5133, //Othel
	};

	for (int i = 0; i < (sizeof(List) / 4); i++) {
		if (itemId == List[i])
			return true;
	}
	return false;
}

void CartaDrop(int conn, int target, int type)
{
	if (type == 1) {
		STRUCT_ITEM item;
		memset(&item, 0, sizeof(STRUCT_ITEM));

		int _rand = rand() % 16;

		if (_rand == 0 || _rand == 1 || _rand == 2)
			item.sIndex = 412; //Poeira Ori

		else if (_rand == 5)
			item.sIndex = 413; //Poeira Lac

		else if (_rand == 12)
			item.sIndex = 421; //cristal i

		else if (_rand == 15)
			item.sIndex = 422; //cristal ii

		SetItemBonus(&item, 0, 0, 0);

		//agrupador automatico teste
		if (AgroupList(conn, item.sIndex) == true && item.sIndex != 0) {
			SendItemagrupar(conn, item.sIndex);

			if (LogList(item.sIndex) == true) {
				snprintf(temp, sizeof(temp), "MobName:%s dropou o item: %s:%d %d.%d.%d.%d.%d.%d do mob:%s", pMob[conn].MOB.MobName, g_pItemList[item.sIndex].Name, item.sIndex, item.stEffect[0].cEffect, item.stEffect[0].cValue, item.stEffect[1].cEffect, item.stEffect[1].cValue, item.stEffect[2].cEffect, item.stEffect[2].cValue, pMob[target].MOB.MobName);
				MobDropLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);
			}

			return;
		}

		if (PutItem(conn, &item) && item.sIndex != 0)
		{
			if (LogList(item.sIndex) == true) {
				snprintf(temp, sizeof(temp), "MobName:%s dropou o item: %s:%d %d.%d.%d.%d.%d.%d do mob:%s", pMob[conn].MOB.MobName, g_pItemList[item.sIndex].Name, item.sIndex, item.stEffect[0].cEffect, item.stEffect[0].cValue, item.stEffect[1].cEffect, item.stEffect[1].cValue, item.stEffect[2].cEffect, item.stEffect[2].cValue, pMob[target].MOB.MobName);
				MobDropLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);
			}

			return;
		}
	}

	if (type == 2) {
		STRUCT_ITEM item;
		memset(&item, 0, sizeof(STRUCT_ITEM));

		int _rand = rand() % 16;

		if (_rand == 0 || _rand == 1)
			item.sIndex = 412; //Poeira Ori

		else if (_rand == 5)
			item.sIndex = 413; //Poeira Lac

		else if (_rand == 15)
			item.sIndex = 423; // cristal iii

		SetItemBonus(&item, 0, 0, 0);

		//agrupador automatico teste
		if (AgroupList(conn, item.sIndex) == true && item.sIndex != 0) {
			SendItemagrupar(conn, item.sIndex);

			if (LogList(item.sIndex) == true) {
				snprintf(temp, sizeof(temp), "MobName:%s dropou o item: %s:%d %d.%d.%d.%d.%d.%d do mob:%s", pMob[conn].MOB.MobName, g_pItemList[item.sIndex].Name, item.sIndex, item.stEffect[0].cEffect, item.stEffect[0].cValue, item.stEffect[1].cEffect, item.stEffect[1].cValue, item.stEffect[2].cEffect, item.stEffect[2].cValue, pMob[target].MOB.MobName);
				MobDropLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);
			}

			return;
		}

		if (PutItem(conn, &item) && item.sIndex != 0)
		{
			if (LogList(item.sIndex) == true) {
				snprintf(temp, sizeof(temp), "MobName:%s dropou o item: %s:%d %d.%d.%d.%d.%d.%d do mob:%s", pMob[conn].MOB.MobName, g_pItemList[item.sIndex].Name, item.sIndex, item.stEffect[0].cEffect, item.stEffect[0].cValue, item.stEffect[1].cEffect, item.stEffect[1].cValue, item.stEffect[2].cEffect, item.stEffect[2].cValue, pMob[target].MOB.MobName);
				MobDropLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);
			}

			return;
		}
	}
	if (type == 3) {
		STRUCT_ITEM item;
		memset(&item, 0, sizeof(STRUCT_ITEM));

		int _rand = rand() % 23;

		if (_rand == 0 || _rand == 1)
			item.sIndex = 2444; //Garnet

		else if (_rand == 2 || _rand == 3)
			item.sIndex = 2443; //Coral

		else if (_rand == 4 || _rand == 5)
			item.sIndex = 2442; //Diamante

		else if (_rand == 6 || _rand == 7)
			item.sIndex = 2441; //Esmeralda

		else if (_rand == 17 || _rand == 18)
			item.sIndex = 424; //cristal iv

		else if (_rand == 22)
			item.sIndex = 425; //cristal v

		SetItemBonus(&item, 0, 0, 0);

		//agrupador automatico teste
		if (AgroupList(conn, item.sIndex) == true && item.sIndex != 0) {
			SendItemagrupar(conn, item.sIndex);

			if (LogList(item.sIndex) == true) {
				snprintf(temp, sizeof(temp), "MobName:%s dropou o item: %s:%d %d.%d.%d.%d.%d.%d do mob:%s", pMob[conn].MOB.MobName, g_pItemList[item.sIndex].Name, item.sIndex, item.stEffect[0].cEffect, item.stEffect[0].cValue, item.stEffect[1].cEffect, item.stEffect[1].cValue, item.stEffect[2].cEffect, item.stEffect[2].cValue, pMob[target].MOB.MobName);
				MobDropLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);
			}

			return;
		}

		if (PutItem(conn, &item) && item.sIndex != 0)
		{
			if (LogList(item.sIndex) == true) {
				snprintf(temp, sizeof(temp), "MobName:%s dropou o item: %s:%d %d.%d.%d.%d.%d.%d do mob:%s", pMob[conn].MOB.MobName, g_pItemList[item.sIndex].Name, item.sIndex, item.stEffect[0].cEffect, item.stEffect[0].cValue, item.stEffect[1].cEffect, item.stEffect[1].cValue, item.stEffect[2].cEffect, item.stEffect[2].cValue, pMob[target].MOB.MobName);
				MobDropLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);
			}

			return;
		}
	}
	if (type == 4) {
		STRUCT_ITEM item;
		memset(&item, 0, sizeof(STRUCT_ITEM));

		int _rand = rand() % 18;

		if (_rand == 0 || _rand == 1 || _rand == 2 || _rand == 3)
			item.sIndex = 412; //Poeira Ori

		else if (_rand == 5 || _rand == 6)
			item.sIndex = 413; //Poeira Lac

		else if (_rand == 14)
			item.sIndex = 427; //cristal vii

		else if (_rand == 17)
			item.sIndex = 426; //cristal vi


		SetItemBonus(&item, 0, 0, 0);

		//agrupador automatico teste
		if (AgroupList(conn, item.sIndex) == true && item.sIndex != 0) {
			SendItemagrupar(conn, item.sIndex);

			if (LogList(item.sIndex) == true) {
				snprintf(temp, sizeof(temp), "MobName:%s dropou o item: %s:%d %d.%d.%d.%d.%d.%d do mob:%s", pMob[conn].MOB.MobName, g_pItemList[item.sIndex].Name, item.sIndex, item.stEffect[0].cEffect, item.stEffect[0].cValue, item.stEffect[1].cEffect, item.stEffect[1].cValue, item.stEffect[2].cEffect, item.stEffect[2].cValue, pMob[target].MOB.MobName);
				MobDropLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);
			}

			return;
		}

		if (PutItem(conn, &item) && item.sIndex != 0)
		{
			if (LogList(item.sIndex) == true) {
				snprintf(temp, sizeof(temp), "MobName:%s dropou o item: %s:%d %d.%d.%d.%d.%d.%d do mob:%s", pMob[conn].MOB.MobName, g_pItemList[item.sIndex].Name, item.sIndex, item.stEffect[0].cEffect, item.stEffect[0].cValue, item.stEffect[1].cEffect, item.stEffect[1].cValue, item.stEffect[2].cEffect, item.stEffect[2].cValue, pMob[target].MOB.MobName);
				MobDropLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);
			}

			return;
		}
	}
}
void LanDrop(int conn, int target)
{
	int Lan = 0;

	if (pMob[conn].TargetX > 3604 && pMob[conn].TargetY > 3604 && pMob[conn].TargetX < 3691 && pMob[conn].TargetY < 3690)
		Lan = 0;

	if (pMob[conn].TargetX > 3732 && pMob[conn].TargetY > 3476 && pMob[conn].TargetX < 3819 && pMob[conn].TargetY < 3563)
		Lan = 1;

	if (pMob[conn].TargetX > 3860 && pMob[conn].TargetY > 3604 && pMob[conn].TargetX < 3946 && pMob[conn].TargetY < 3690)
		Lan = 2;


	STRUCT_ITEM item;
	memset(&item, 0, sizeof(STRUCT_ITEM));
		
	int _rand = rand() % 100;

	if (Lan == 0) {

		// resto ori 40%
		if (_rand > 0 && _rand < 40) {
			item.sIndex = 419;
			item.stEffect[0].cEffect = 0;
			item.stEffect[0].cValue = 0;
			item.stEffect[1].cEffect = 0;
			item.stEffect[1].cValue = 0;
			item.stEffect[2].cEffect = 0;
			item.stEffect[2].cValue = 0;
		}

		// resto de lac 35%
		if (_rand > 39 && _rand < 75) {
			item.sIndex = 420;
			item.stEffect[0].cEffect = 0;
			item.stEffect[0].cValue = 0;
			item.stEffect[1].cEffect = 0;
			item.stEffect[1].cValue = 0;
			item.stEffect[2].cEffect = 0;
			item.stEffect[2].cValue = 0;
		}

		//classe D 10%
		if (_rand > 74 && _rand < 85) {
			item.sIndex = 4019;
			item.stEffect[0].cEffect = 0;
			item.stEffect[0].cValue = 0;
			item.stEffect[1].cEffect = 0;
			item.stEffect[1].cValue = 0;
			item.stEffect[2].cEffect = 0;
			item.stEffect[2].cValue = 0;
		}

		// Amago 5%
		if (_rand > 84 && _rand < 90) {
			item.sIndex = 2403;
			item.stEffect[0].cEffect = 0;
			item.stEffect[0].cValue = 0;
			item.stEffect[1].cEffect = 0;
			item.stEffect[1].cValue = 0;
			item.stEffect[2].cEffect = 0;
			item.stEffect[2].cValue = 0;
		}

		// Amago 5%
		if (_rand > 89 && _rand < 95) {
			item.sIndex = 2398;
			item.stEffect[0].cEffect = 0;
			item.stEffect[0].cValue = 0;
			item.stEffect[1].cEffect = 0;
			item.stEffect[1].cValue = 0;
			item.stEffect[2].cEffect = 0;
			item.stEffect[2].cValue = 0;
		}

		// Barra 1kk 5%
		if (_rand > 94 && _rand < 100) {
			item.sIndex = 4026;
			item.stEffect[0].cEffect = 0;
			item.stEffect[0].cValue = 0;
			item.stEffect[1].cEffect = 0;
			item.stEffect[1].cValue = 0;
			item.stEffect[2].cEffect = 0;
			item.stEffect[2].cValue = 0;
		}
	}

	if (Lan == 1) {

		// resto ori 30%
		if (_rand > 0 && _rand < 30) {
			item.sIndex = 419;
			item.stEffect[0].cEffect = 0;
			item.stEffect[0].cValue = 0;
			item.stEffect[1].cEffect = 0;
			item.stEffect[1].cValue = 0;
			item.stEffect[2].cEffect = 0;
			item.stEffect[2].cValue = 0;
		}

		// resto de lac 20%
		if (_rand > 31 && _rand < 50) {
			item.sIndex = 420;
			item.stEffect[0].cEffect = 0;
			item.stEffect[0].cValue = 0;
			item.stEffect[1].cEffect = 0;
			item.stEffect[1].cValue = 0;
			item.stEffect[2].cEffect = 0;
			item.stEffect[2].cValue = 0;
		}

		//classe E 5%
		if (_rand > 51 && _rand < 57) {
			item.sIndex = 4020;
			item.stEffect[0].cEffect = 0;
			item.stEffect[0].cValue = 0;
			item.stEffect[1].cEffect = 0;
			item.stEffect[1].cValue = 0;
			item.stEffect[2].cEffect = 0;
			item.stEffect[2].cValue = 0;
		}

		// Amago 4%
		if (_rand > 60 && _rand < 65) {
			item.sIndex = 2399;
			item.stEffect[0].cEffect = 0;
			item.stEffect[0].cValue = 0;
			item.stEffect[1].cEffect = 0;
			item.stEffect[1].cValue = 0;
			item.stEffect[2].cEffect = 0;
			item.stEffect[2].cValue = 0;
		}
		// Amago 4%
		if (_rand > 70 && _rand < 75) {
			item.sIndex = 2404;
			item.stEffect[0].cEffect = 0;
			item.stEffect[0].cValue = 0;
			item.stEffect[1].cEffect = 0;
			item.stEffect[1].cValue = 0;
			item.stEffect[2].cEffect = 0;
			item.stEffect[2].cValue = 0;
		}
		// Barra 1kk 10%
		if (_rand > 89 && _rand < 99) {
			item.sIndex = 4026;
			item.stEffect[0].cEffect = 0;
			item.stEffect[0].cValue = 0;
			item.stEffect[1].cEffect = 0;
			item.stEffect[1].cValue = 0;
			item.stEffect[2].cEffect = 0;
			item.stEffect[2].cValue = 0;
		}
	}

	//Filtro de Drop
	if (AutoDrop(conn, item.sIndex) == false && item.sIndex != 0)
		return;

	//agrupador automatico teste
	if (AgroupList(conn, item.sIndex) == true && item.sIndex != 0) {
		SendItemagrupar(conn, item.sIndex);

		if (LogList(item.sIndex) == true) {
			snprintf(temp, sizeof(temp), "MobName:%s dropou o item: %s:%d %d.%d.%d.%d.%d.%d do mob:%s", pMob[conn].MOB.MobName, g_pItemList[item.sIndex].Name, item.sIndex, item.stEffect[0].cEffect, item.stEffect[0].cValue, item.stEffect[1].cEffect, item.stEffect[1].cValue, item.stEffect[2].cEffect, item.stEffect[2].cValue, pMob[target].MOB.MobName);
			MobDropLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);
		}

		return;
	}

	if (PutItem(conn, &item) && item.sIndex != 0)
	{
		if (LogList(item.sIndex) == true) {
			snprintf(temp, sizeof(temp), "MobName:%s dropou o item: %s:%d %d.%d.%d.%d.%d.%d do mob:%s", pMob[conn].MOB.MobName, g_pItemList[item.sIndex].Name, item.sIndex, item.stEffect[0].cEffect, item.stEffect[0].cValue, item.stEffect[1].cEffect, item.stEffect[1].cValue, item.stEffect[2].cEffect, item.stEffect[2].cValue, pMob[target].MOB.MobName);
			MobDropLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);
		}

		return;
	}
}

void BlockAdd(STRUCT_ITEM* item, int Type, int min, int max)
{
	if (min < 0)
		min = 0;

	int soma = 0;
	for (int i = 0; i < 3; i++)
	{
		if (item->stEffect[i].cEffect == Type)
			soma += item->stEffect[i].cValue;
	}

	if (soma > max)
	{
		for (int i = 0; i < 3; i++)
		{
			item->stEffect[i].cEffect = 0;
			item->stEffect[i].cValue = 0;
		}

		item->stEffect[0].cEffect = Type;
		item->stEffect[0].cValue = min;
	}
}

//Controle de Drop por Tempo
bool DropItemControl(int sIndex) {

	int Index = sIndex;

	//Necessário colocar o id do item que queira efetuar o controle por tempo aqui e na ProcessSecMinTimer.cpp
	int List[] = {
		1740, 1741, 671
	};

	for (int i = 0; i < (sizeof(List) / 4); i++) {
		if (List[i] == Index) {
			if (ItemDropControl[Index] == 1) {
				ItemDropControl[Index] = 0;
				return true;
			}
			else
				return false;
		}
	}
	return true;
}

# -------------------- DropList.cpp --------------------

#pragma once

#include "ProcessClientMessage.h"
#include <iostream>
#include <cstdlib>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <random>
#include <ctime>
#include "SendFunc.h"
#include "Functions.h"
#include "wMySQL.h"

void UpdateDropList(int conn, const char* mobname, int region)
{
	MSG_UpdateDropList sm;
	memset(&sm, 0, sizeof(MSG_UpdateDropList));
	sm.Type = _MSG_UpdateDropList;
	sm.Size = sizeof(MSG_UpdateDropList);
	sm.ID = conn;

	auto& pc = cSQL::instance();

	sprintf(xQuery, "SELECT * FROM `droplist` WHERE `nome` = '%s'", mobname);

	MYSQL_ROW row;
	MYSQL* wSQL = pc.wStart();
	MYSQL_RES* result = pc.wRes(wSQL, xQuery);

	if (result == NULL)
		return;

	int Slot = 0;
	int Index = 0;

	while ((row = mysql_fetch_row(result)) != NULL)
	{
		for (int k = 0; k < MAX_CARRY; k++) {

			Index = atoi(row[k + 3]);

			if (Index == 0)
				continue;

			if (Index > MAX_ITEMLIST)
				continue;

			if (Index < 400)
				continue;

			sm.Item[Slot] = Index;
			Slot++;
		}
	}	

	int Size = sm.Size;

	if (Size > sizeof(MSG_UpdateDropList))
	{
		sm.Size = sizeof(MSG_UpdateDropList);
		return;
	}

	if (!pUser[conn].cSock.AddMessage((char*)&sm, sizeof(MSG_UpdateDropList)))
		CloseUser(conn);

}

void ReqDropList(int conn, char* pMsg)
{
	if (conn <= 0 || conn >= MAX_USER)
		return;

	if (pUser[conn].Mode != USER_PLAY)
		return;

	if (pUser[conn].cSock.Sock == 0)
		return;

	MSG_ReqDropList* m = (MSG_ReqDropList*)pMsg;

	if (m->Region < 0 || m->Region >= 13)
		return;

	if (pUser[conn].DropListDelay != 0)
	{
		int isTime = GetTickCount64() - pUser[conn].DropListDelay; // ATRASO PACOTE

		if (isTime < 300)
		{
			SendClientMessage(conn, "Aguarde 1 segundo para uma nova Tentativa.");
			return;
		}

	}
	pUser[conn].DropListDelay = GetTickCount64();

	UpdateDropList(conn, m->MobName, m->Region);
	return;
}

void ReqdListNames(int conn, char* pMsg)
{
	if (conn <= 0 || conn >= MAX_USER)
		return;

	if (pUser[conn].Mode != USER_PLAY)
		return;

	if (pUser[conn].cSock.Sock == 0)
		return;

	if (pUser[conn].Atraso != 0)
	{
		int isTime = GetTickCount64() - pUser[conn].Atraso; // ATRASO PACOTE

		if (isTime < 300)
		{
			SendClientMessage(conn, "Aguarde 1 segundo para uma nova Tentativa.");
			return;
		}

	}
	pUser[conn].Atraso = GetTickCount64();

	MSG_ReqdListNames* m = (MSG_ReqdListNames*)pMsg;

	MSG_SendDListNames p;
	memset(&p, 0, sizeof(MSG_SendDListNames));
	p.Type = _MSG_SendDListNames;
	p.Size = sizeof(MSG_SendDListNames);
	p.ID = conn;

	if (m->Page < 0 || m->Page > 15)
		return;

	int region = m->Page;
	int mob = 0;

	auto& pc = cSQL::instance();

	sprintf(xQuery, "SELECT * FROM `droplist` WHERE `region` = %d LIMIT 30", region);

	MYSQL_ROW row;
	MYSQL* wSQL = pc.wStart();
	MYSQL_RES* result = pc.wRes(wSQL, xQuery);

	if (result == NULL)
		return;

	while ((row = mysql_fetch_row(result)) != NULL)
	{
		strncpy(p.MobName[mob], row[1], 16);
		mob++;
	}	

	int Size = p.Size;
	if (Size > sizeof(MSG_SendDListNames))
	{
		p.Size = sizeof(MSG_SendDListNames);
		return;
	}

	if (!pUser[conn].cSock.AddMessage((char*)&p, sizeof(MSG_SendDListNames)))
		CloseUser(conn);
}



//void ReqDropList(int conn, char* pMsg)
//{
//	if (conn <= 0 || conn >= MAX_USER)
//		return;
//
//	if (pUser[conn].Mode != USER_PLAY)
//		return;
//
//	if (pUser[conn].cSock.Sock == 0)
//		return;
//
//	MSG_ReqDropList* m = (MSG_ReqDropList*)pMsg;
//
//	if (m->State == 1)
//	{
//		if (pUser[conn].DroplistTime != 0)
//		{
//			int isTime = GetTickCount64() - pUser[conn].DroplistTime;
//
//			pUser[conn].DroplistTime = GetTickCount64();
//
//			if (isTime < 10000)
//			{
//				SendClientMessage(conn, "Aguarde 10 segundos para pesquisar novamente");
//				return;
//			}
//		}
//		pUser[conn].DroplistTime = GetTickCount64();
//
//		for (int i = 1000; i < 12800; i++)
//		{
//			int LastFace = 0;
//			int View = GetInView(conn, i);
//			if (View == 1) {
//				auto Mob = GetMobFromIndex(i);
//
//				if (Mob->MOB.Merchant != 0)
//					continue;
//
//				if ((Mob->GenerateIndex >= 3391 && Mob->GenerateIndex <= 3435) ||
//					(Mob->GenerateIndex >= 982 && Mob->GenerateIndex <= 986) ||
//					(Mob->GenerateIndex >= 3784 && Mob->GenerateIndex <= 3792) ||
//					Mob->GenerateIndex == 4531)
//					continue;
//
//				if ((strcmp(Mob->MOB.MobName, "Andaluz B") == 0) || (strcmp(Mob->MOB.MobName, "Andaluz N") == 0) ||
//					(strcmp(Mob->MOB.MobName, "Condor") == 0) || (strcmp(Mob->MOB.MobName, "Dente de Sabre") == 0) ||
//					(strcmp(Mob->MOB.MobName, "Dragao") == 0) || (strcmp(Mob->MOB.MobName, "Dragao Menor") == 0) ||
//					(strcmp(Mob->MOB.MobName, "Grifo") == 0) || (strcmp(Mob->MOB.MobName, "Grifo Sangrento") == 0) ||
//					(strcmp(Mob->MOB.MobName, "Gorila") == 0) || (strcmp(Mob->MOB.MobName, "Hipogrifo") == 0) ||
//					(strcmp(Mob->MOB.MobName, "Javali") == 0) || (strcmp(Mob->MOB.MobName, "Javali ") == 0) ||
//					(strcmp(Mob->MOB.MobName, "Succubus") == 0) || (strcmp(Mob->MOB.MobName, "Tigre") == 0) ||
//					(strcmp(Mob->MOB.MobName, "Urso") == 0) || (strcmp(Mob->MOB.MobName, "Vinha") == 0))
//					continue;
//
//				int Face = Mob->MOB.Equip[0].sIndex;
//				int Effect = Mob->GenerateIndex;
//
//				for (int x = 0; x < 10; x++) {
//					if (pUser[conn].Ingame.MobFace[x] != 0)
//						continue;
//
//					bool MobList = false;
//					for (int y = 0; y < 10; y++) {
//						if (pUser[conn].Ingame.MobFace[y] == Face)
//							MobList = true;
//					}
//
//					if (pUser[conn].Ingame.MobFace[x] == 0 && MobList == false) {
//						pUser[conn].Ingame.MobFace[x] = Face;
//						pUser[conn].Ingame.MobEffect[x] = Effect;
//						strncpy(pUser[conn].Ingame.MobName[x], Mob->MOB.MobName, sizeof(pUser[conn].Ingame.MobName[x]));
//						break;
//					}
//				}
//			}
//		}
//		UpdateDropList(conn);
//		m->State = 0;
//		return;
//	}
//}

# -------------------- EventoClick.cpp --------------------

#pragma once

#include "ProcessClientMessage.h"
#include <iostream>
#include <cstdlib>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <random>
#include <ctime>
#include "SendFunc.h"
#include "Functions.h" 
#include "Chests.h"
#include "wMySQL.h"

#define GUARDA_REAL_I			35
#define GUARDA_REAL_II  		36
#define GUARDA_REAL_III 		37
#define GUARDA_REAL_IV  		38
#define GUARDA_REAL_V   		39
#define GUARDA_REAL_VI  		40

int NumbGen(int Initial, int Final) {
	static std::mt19937 rng(std::random_device{}());
	static std::uniform_int_distribution<int> dist(Initial, Final);
	return dist(rng);
}

void LoadEvent() {

	auto& pc = cSQL::instance();

	sprintf(xQuery, "SELECT * FROM `evento`");
	MYSQL_ROW row;
	MYSQL* wSQL = pc.wStart();
	MYSQL_RES* result = pc.wRes(wSQL, xQuery);

	if (result == NULL)
	{
		return;
	}
	int i = 0;
	while ((row = mysql_fetch_row(result)) != NULL)
	{
		if (i == 5)
			i = 0;
		int npc = atoi(row[2]);
		int Qnt = atoi(row[5]);
		Evento[npc][i].sIndex = atoi(row[4]);
		Evento[npc][i].stEffect[0].cEffect = 0;
		Evento[npc][i].stEffect[0].cValue = 0;
		if (Qnt > 0) {
			Evento[npc][i].stEffect[0].cEffect = 61;
			Evento[npc][i].stEffect[0].cValue = Qnt;
		}
		Evento[npc][i].stEffect[1].cEffect = 0;
		Evento[npc][i].stEffect[1].cValue = 0;
		Evento[npc][i].stEffect[2].cEffect = 0;
		Evento[npc][i].stEffect[2].cValue = 0;
		rate[npc][i] = atoi(row[6]);
		i++;
	}

	auto& pc2 = cSQL::instance();

	sprintf(xQuery, "SELECT * FROM `eventoconfig`");
	MYSQL_ROW row2;
	MYSQL* wSQL2 = pc2.wStart();
	MYSQL_RES* result2 = pc2.wRes(wSQL2, xQuery);

	if (result2 == NULL)
	{
		return;
	}
	while ((row2 = mysql_fetch_row(result2)) != NULL)
	{
		int Npc = atoi(row2[2]);
		BausIndex[Npc] = atoi(row2[3]);
		
	}
}


void EventoClick(int conn, int npc)
{
	if (conn <= 0 || conn >= MAX_USER)
		return;

	if (pUser[conn].Mode != USER_PLAY)
		return;

	if (pUser[conn].cSock.Sock == 0)
		return;

	int NPC = npc;	
	int npcid = 0;
	bool Check = false;
	
	if (NPC == GUARDA_REAL_I) {
		npcid = 0;
		Check = true;
	}
	if (NPC == GUARDA_REAL_II){
		npcid = 1;
		Check = true;
	}
	if (NPC == GUARDA_REAL_III){
		npcid = 2;
		Check = true;
	}
	if (NPC == GUARDA_REAL_IV){
		npcid = 3;
		Check = true;
	}
	if (NPC == GUARDA_REAL_V){
		npcid = 4;
		Check = true;
	}

	if (Check == true) {
		int FreeSlot = 0;
		int slotsInv = 30;
		int ItemCount = 0;
		if (pMob[conn].MOB.Carry[60].sIndex == 3467)
			slotsInv += 15;
		if (pMob[conn].MOB.Carry[61].sIndex == 3467)
			slotsInv += 15;

		int rand_ = NumbGen(0, 99);

		int itemIndex = BausIndex[npcid];

		for (int i = 0; i < slotsInv; i++) {
			if (pMob[conn].MOB.Carry[i].sIndex == itemIndex)
				ItemCount += pMob[conn].MOB.Carry[i].stEffect[0].cEffect == 61 ? pMob[conn].MOB.Carry[i].stEffect[0].cValue : 1;

			if (pMob[conn].MOB.Carry[i].sIndex == 0)
				FreeSlot += 1;
		}
		if (ItemCount < 1) {
			SendClientMessage(conn, "Você precisa de pelo menos 1 Item para efetuar a troca");
			return;
		}
		if (FreeSlot < 1) {
			SendClientMessage(conn, "Não há espaço disponível no Inventário");
			return;
		}

		STRUCT_ITEM item;
		memset(&item, 0, sizeof(STRUCT_ITEM));

		if (rand_ >= 0 && rand_ < rate[npcid][0]) {
			memcpy(&item, &Evento[npcid][0], sizeof(STRUCT_ITEM));
		}
		if (rand_ >= rate[npcid][0] && rand_ < rate[npcid][1]) {
			memcpy(&item, &Evento[npcid][1], sizeof(STRUCT_ITEM));
		}
		if (rand_ >= rate[npcid][1] && rand_ < rate[npcid][2]) {
			memcpy(&item, &Evento[npcid][2], sizeof(STRUCT_ITEM));
		}
		if (rand_ >= rate[npcid][2] && rand_ < rate[npcid][3]) {
			memcpy(&item, &Evento[npcid][3], sizeof(STRUCT_ITEM));
		}
		if (rand_ >= rate[npcid][3] && rand_ < rate[npcid][4]) {
			memcpy(&item, &Evento[npcid][4], sizeof(STRUCT_ITEM));
		}

		if (item.sIndex == 2441) {
			item.sIndex = 2441 + rand() % 4;
		}

		int Eff = item.stEffect[0].cEffect;
		int Qnt = item.stEffect[0].cValue;
		RemoveItem(conn, itemIndex, 1);

		if (Eff == 61 && (pUser[conn].Keys[49] == 1))
		{
			while (Qnt >= 1) {
				SendItemagrupar(conn, item.sIndex);
				Qnt -= 1;
			}
		}
		else
			PutItem(conn, &item);

		SendMsgExp(conn, strFmt("Recebeu [%s]", g_pItemList[item.sIndex].Name), TNColor::CornBlue, false);
	}
}

//void EventoClick(int conn, int npc)
//{
//	if (conn <= 0 || conn >= MAX_USER)
//		return;
//
//	if (pUser[conn].Mode != USER_PLAY)
//		return;
//
//	if (pUser[conn].cSock.Sock == 0)
//		return;
//
//	int NPC = npc;
//
//	int FreeSlot = 0;
//	int slotsInv = 30;
//	int ItemCount = 0;
//	int ItemCount2 = 0;
//	int ItemCount3 = 0;
//	if (pMob[conn].MOB.Carry[60].sIndex == 3467)
//		slotsInv += 15;
//	if (pMob[conn].MOB.Carry[61].sIndex == 3467)
//		slotsInv += 15;
//
//	STRUCT_ITEM item;
//	memset(&item, 0, sizeof(STRUCT_ITEM));
//
//	srand(time(NULL) / 5 * (rand() % 500) * 5);
//	int _rand = rand() % 199;
//	if (_rand > 100)
//	{
//		_rand = _rand - 99;
//	}
//
//	if (NPC == GUARDA_REAL_I)
//	{
//		int itemIndex = 5710;
//
//		for (int i = 0; i < slotsInv; i++) {
//			if (pMob[conn].MOB.Carry[i].sIndex == itemIndex)
//				ItemCount += pMob[conn].MOB.Carry[i].stEffect[0].cEffect == 61 ? pMob[conn].MOB.Carry[i].stEffect[0].cValue : 1;
//
//			if (pMob[conn].MOB.Carry[i].sIndex == 0)
//				FreeSlot += 1;
//		}
//		if (ItemCount < 1) {
//			SendClientMessage(conn, "Você precisa de pelo menos 1 Item para efetuar a troca");
//			return;
//		}
//		if (FreeSlot < 1) {
//			SendClientMessage(conn, "Não há espaço disponível no Inventário");
//			return;
//		}
//
//		if (_rand < 25) { //25%
//			item.sIndex = 420;
//			item.stEffect[0].cEffect = 61;
//			item.stEffect[0].cValue = 3;
//		}
//		else if (_rand < 60) { //35%
//			item.sIndex = 419;
//			item.stEffect[0].cEffect = 61;
//			item.stEffect[0].cValue = 5;
//		}
//		else if (_rand < 85) { //25%
//			item.sIndex = 4019;
//			item.stEffect[0].cEffect = 61;
//			item.stEffect[0].cValue = 3;
//		}
//		else if (_rand < 100) { //15%
//			item.sIndex = 5711;
//			item.stEffect[0].cEffect = 61;
//			item.stEffect[0].cValue = 1;
//		}
//		int Eff = item.stEffect[0].cEffect;
//		int Qnt = item.stEffect[0].cValue;
//		RemoveItem(conn, itemIndex, 1);
//
//		if (Eff == 61 && (pMob[conn].MOB.Equip[13].sIndex == 3901 || pMob[conn].MOB.Equip[13].sIndex == 3902))
//		{
//			while (Qnt >= 1) {
//				SendItemagrupar(conn, item.sIndex);
//				Qnt -= 1;
//			}
//		}
//		else
//			PutItem(conn, &item);
//	}
//	if (NPC == GUARDA_REAL_II)
//	{
//		int itemIndex = 5711;
//
//		for (int i = 0; i < slotsInv; i++) {
//			if (pMob[conn].MOB.Carry[i].sIndex == itemIndex)
//				ItemCount += pMob[conn].MOB.Carry[i].stEffect[0].cEffect == 61 ? pMob[conn].MOB.Carry[i].stEffect[0].cValue : 1;
//
//			if (pMob[conn].MOB.Carry[i].sIndex == 0)
//				FreeSlot += 1;
//		}
//		if (ItemCount < 1) {
//			SendClientMessage(conn, "Você precisa de pelo menos 1 Item para efetuar a troca");
//			return;
//		}
//		if (FreeSlot < 1) {
//			SendClientMessage(conn, "Não há espaço disponível no Inventário");
//			return;
//		}
//
//		int Amagos[3] = { 2399, 2404, 2406 };
//
//		if (_rand < 25) { //25%
//			item.sIndex = Amagos[rand() % 3];
//			item.stEffect[0].cEffect = 61;
//			item.stEffect[0].cValue = 3;
//		}
//		else if (_rand < 60) { //35%
//			item.sIndex = rand() % 4 + 2441;
//			item.stEffect[0].cEffect = 61;
//			item.stEffect[0].cValue = 1;
//		}
//		else if (_rand < 85) { //25%
//			item.sIndex = 4020;
//			item.stEffect[0].cEffect = 61;
//			item.stEffect[0].cValue = 2;
//		}
//		else if (_rand < 100) { //15%
//			item.sIndex = 5712;
//			item.stEffect[0].cEffect = 61;
//			item.stEffect[0].cValue = 1;
//		}
//		int Eff = item.stEffect[0].cEffect;
//		int Qnt = item.stEffect[0].cValue;
//		RemoveItem(conn, itemIndex, 1);
//
//		if (Eff == 61 && (pMob[conn].MOB.Equip[13].sIndex == 3901 || pMob[conn].MOB.Equip[13].sIndex == 3902))
//		{
//			while (Qnt >= 1) {
//				SendItemagrupar(conn, item.sIndex);
//				Qnt -= 1;
//			}
//		}
//		else
//			PutItem(conn, &item);
//	}
//	if (NPC == GUARDA_REAL_III)
//	{
//		int itemIndex = 5712;
//
//		for (int i = 0; i < slotsInv; i++) {
//			if (pMob[conn].MOB.Carry[i].sIndex == itemIndex)
//				ItemCount += pMob[conn].MOB.Carry[i].stEffect[0].cEffect == 61 ? pMob[conn].MOB.Carry[i].stEffect[0].cValue : 1;
//
//			if (pMob[conn].MOB.Carry[i].sIndex == 0)
//				FreeSlot += 1;
//		}
//		if (ItemCount < 1) {
//			SendClientMessage(conn, "Você precisa de pelo menos 1 Item para efetuar a troca");
//			return;
//		}
//		if (FreeSlot < 1) {
//			SendClientMessage(conn, "Não há espaço disponível no Inventário");
//			return;
//		}
//
//		int Joias[5] = { 3200, 3201, 3202, 3204, 3205 };
//
//		if (_rand < 25) { //25%
//			item.sIndex = Joias[rand() % 5];
//			item.stEffect[0].cEffect = 61;
//			item.stEffect[0].cValue = 1;
//		}
//		else if (_rand < 60) { //35%
//			item.sIndex = 3314;
//			item.stEffect[0].cEffect = 61;
//			item.stEffect[0].cValue = 1;
//		}
//		else if (_rand < 85) { //25%
//			item.sIndex = 3140;
//			item.stEffect[0].cEffect = 61;
//			item.stEffect[0].cValue = 3 + rand() % 3;
//		}
//		else if (_rand < 100) { //15%
//			item.sIndex = 5717;
//			item.stEffect[0].cEffect = 61;
//			item.stEffect[0].cValue = 1;
//		}
//		int Eff = item.stEffect[0].cEffect;
//		int Qnt = item.stEffect[0].cValue;
//		RemoveItem(conn, itemIndex, 1);
//
//		if (Eff == 61 && (pMob[conn].MOB.Equip[13].sIndex == 3901 || pMob[conn].MOB.Equip[13].sIndex == 3902))
//		{
//			while (Qnt >= 1) {
//				SendItemagrupar(conn, item.sIndex);
//				Qnt -= 1;
//			}
//		}
//		else
//			PutItem(conn, &item);
//	}
//	if (NPC == GUARDA_REAL_IV)
//	{
//		int itemIndex = 5717;
//
//		for (int i = 0; i < slotsInv; i++) {
//			if (pMob[conn].MOB.Carry[i].sIndex == itemIndex)
//				ItemCount += pMob[conn].MOB.Carry[i].stEffect[0].cEffect == 61 ? pMob[conn].MOB.Carry[i].stEffect[0].cValue : 1;
//
//			if (pMob[conn].MOB.Carry[i].sIndex == 0)
//				FreeSlot += 1;
//		}
//		if (ItemCount < 1) {
//			SendClientMessage(conn, "Você precisa de pelo menos 1 Item para efetuar a troca");
//			return;
//		}
//		if (FreeSlot < 1) {
//			SendClientMessage(conn, "Não há espaço disponível no Inventário");
//			return;
//		}
//
//
//
//		if (_rand < 25) { //25%
//			item.sIndex = 4140;
//			item.stEffect[0].cEffect = 61;
//			item.stEffect[0].cValue = 1;
//		}
//		else if (_rand < 60) { //35%
//			item.sIndex = 5643;
//			item.stEffect[0].cEffect = 61;
//			item.stEffect[0].cValue = 2;
//		}
//		else if (_rand < 85) { //25%
//			item.sIndex = 3207 + rand() % 3;
//			item.stEffect[0].cEffect = 61;
//			item.stEffect[0].cValue = 1;
//		}
//		else if (_rand < 100) { //15%
//			item.sIndex = 5716;
//			item.stEffect[0].cEffect = 61;
//			item.stEffect[0].cValue = 1;
//		}
//		int Eff = item.stEffect[0].cEffect;
//		int Qnt = item.stEffect[0].cValue;
//		RemoveItem(conn, itemIndex, 1);
//
//		if (Eff == 61 && (pMob[conn].MOB.Equip[13].sIndex == 3901 || pMob[conn].MOB.Equip[13].sIndex == 3902))
//		{
//			while (Qnt >= 1) {
//				SendItemagrupar(conn, item.sIndex);
//				Qnt -= 1;
//			}
//		}
//		else
//			PutItem(conn, &item);
//	}
//	if (NPC == GUARDA_REAL_V)
//	{
//		int itemIndex = 5713;
//		int itemIndex2 = 5714;
//		int itemIndex3 = 5715;
//
//		for (int i = 0; i < slotsInv; i++) {
//			if (pMob[conn].MOB.Carry[i].sIndex == itemIndex)
//				ItemCount += pMob[conn].MOB.Carry[i].stEffect[0].cEffect == 61 ? pMob[conn].MOB.Carry[i].stEffect[0].cValue : 1;
//
//			if (pMob[conn].MOB.Carry[i].sIndex == itemIndex2)
//				ItemCount2 += pMob[conn].MOB.Carry[i].stEffect[0].cEffect == 61 ? pMob[conn].MOB.Carry[i].stEffect[0].cValue : 1;
//
//			if (pMob[conn].MOB.Carry[i].sIndex == itemIndex3)
//				ItemCount3 += pMob[conn].MOB.Carry[i].stEffect[0].cEffect == 61 ? pMob[conn].MOB.Carry[i].stEffect[0].cValue : 1;
//
//			if (pMob[conn].MOB.Carry[i].sIndex == 0)
//				FreeSlot += 1;
//		}
//		if (ItemCount < 1 || ItemCount2 < 1 || ItemCount3 < 1) {
//			SendClientMessage(conn, "Você precisa dos Três Pirulitos para efetuar a troca");
//			return;
//		}
//		if (FreeSlot < 1) {
//			SendClientMessage(conn, "Não há espaço disponível no Inventário");
//			return;
//		}
//
//		if (_rand < 35) { //35%
//			item.sIndex = 5643;
//			item.stEffect[0].cEffect = 61;
//			item.stEffect[0].cValue = 2;
//		}
//		else if (_rand < 70) { //35%
//			item.sIndex = 3172;
//			item.stEffect[0].cEffect = 61;
//			item.stEffect[0].cValue = 1;
//		}
//		else if (_rand < 100) { //30%
//			item.sIndex = 5718;
//			item.stEffect[0].cEffect = 61;
//			item.stEffect[0].cValue = 3;
//		}
//
//		int Eff = item.stEffect[0].cEffect;
//		int Qnt = item.stEffect[0].cValue;
//		RemoveItem(conn, itemIndex, 1);
//		RemoveItem(conn, itemIndex2, 1);
//		RemoveItem(conn, itemIndex3, 1);
//
//		if (Eff == 61 && (pMob[conn].MOB.Equip[13].sIndex == 3901 || pMob[conn].MOB.Equip[13].sIndex == 3902))
//		{
//			while (Qnt >= 1) {
//				SendItemagrupar(conn, item.sIndex);
//				Qnt -= 1;
//			}
//		}
//		else
//			PutItem(conn, &item);
//	}
//	if (NPC == GUARDA_REAL_VI)
//	{
//		int itemIndex = 5716;
//
//		for (int i = 0; i < slotsInv; i++) {
//			if (pMob[conn].MOB.Carry[i].sIndex == itemIndex)
//				ItemCount += pMob[conn].MOB.Carry[i].stEffect[0].cEffect == 61 ? pMob[conn].MOB.Carry[i].stEffect[0].cValue : 1;
//
//			if (pMob[conn].MOB.Carry[i].sIndex == 0)
//				FreeSlot += 1;
//		}
//		if (ItemCount < 1) {
//			SendClientMessage(conn, "Traga o Saco de Doces para receber um Pirulito");
//			return;
//		}
//		if (FreeSlot < 1) {
//			SendClientMessage(conn, "Não há espaço disponível no Inventário");
//			return;
//		}
//
//		if (_rand < 34) { //33%
//			item.sIndex = 5713;
//			item.stEffect[0].cEffect = 61;
//			item.stEffect[0].cValue = 1;
//		}
//		else if (_rand < 67) { //33%
//			item.sIndex = 5714;
//			item.stEffect[0].cEffect = 61;
//			item.stEffect[0].cValue = 1;
//		}
//		else if (_rand < 100) { //33%
//			item.sIndex = 5715;
//			item.stEffect[0].cEffect = 61;
//			item.stEffect[0].cValue = 1;
//		}
//
//		int Eff = item.stEffect[0].cEffect;
//		int Qnt = item.stEffect[0].cValue;
//		RemoveItem(conn, itemIndex, 1);
//
//		if (Eff == 61 && (pMob[conn].MOB.Equip[13].sIndex == 3901 || pMob[conn].MOB.Equip[13].sIndex == 3902))
//		{
//			while (Qnt >= 1) {
//				SendItemagrupar(conn, item.sIndex);
//				Qnt -= 1;
//			}
//		}
//		else
//			PutItem(conn, &item);
//	}
//}

# -------------------- Exec_MestreGrifo.cpp --------------------

#include "ProcessClientMessage.h"

void Exec_MSG_MestreGrifo(int conn, int warp, int type)
{
	switch (warp)
	{
	case 0:
		SendClientMessage(conn, "!Przyby³ do miejsca przeznaczenia [Obóz_treningowy].");
		DoTeleport(conn, 2112, 2051);
		break;
	case 1:
		SendClientMessage(conn, "!Przyby³ do miejsca przeznaczenia [Defensor da alma].");
		DoTeleport(conn, 2372, 2099);
		break;
	case 2:
		SendClientMessage(conn, "!Przyby³ do miejsca przeznaczenia [Jardin de deus].");
		DoTeleport(conn, 2220, 1714);
		break;
	case 3:
		SendClientMessage(conn, "!Przyby³ do miejsca przeznaczenia [Dungeon].");
		DoTeleport(conn, 2365, 2249);
		break;
	case 4:
		SendClientMessage(conn, "!Przyby³ do miejsca przeznaczenia [SubMundo].");
		DoTeleport(conn, 1826, 1771);
		break;
	case 5:
		SendClientMessage(conn, "!Przyby³ do miejsca przeznaczenia [SubMundo].");
		DoTeleport(conn, 1826, 1771);
		break;
	}
}

# -------------------- Exec_MSG_LeilaoStore.cpp --------------------

﻿
#include <Windows.h>
#include <stdio.h>
#include <fcntl.h>
#include <time.h>
#include <math.h>
#include <io.h>
#include <errno.h>
#include "..\Basedef.h"
#include "..\CPSock.h"
#include "..\ItemEffect.h"
#include "Language.h"
#include "CItem.h"
#include "Server.h"
#include "ProcessClientMessage.h"
#include "GetFunc.h"
#include "SendFunc.h"
#include "Functions.h"
#include <iostream>  
#include "wMySQL.h"


/*Funções Sistema leilao*/
void goResetLeilao(int clientId)
{
	if (clientId <= MOB_EMPTY || clientId >= MAX_USER || pUser[clientId].Mode != USER_PLAY)
		return;

	pMob[clientId].IsAutoTrading = false;
	memset(&pMob[clientId].AutoTrade, 0, sizeof(pMob[clientId].AutoTrade));
	RemoveMobLeilaoStore(clientId);
	pUser[clientId].sxCountSerch = 0; 

}

void RemoveMobLeilaoStore(int clientId)
{
	bool isPlayer = (clientId > 0 && clientId < 1000);

	if (isPlayer)
	{
		if ((pUser[clientId].Mode != USER_PLAY))
			return;
	}


	INT32 lenName = strlen(pMob[clientId].MOB.MobName);

	for (INT32 i = 1000; i < MAX_MOB; i++)
	{
		if (pMob[i].Mode == 0)
			continue;

		if (!pMob[i].IsAutoTrading)
			continue;

		if (!strncmp(pMob[i].MOB.MobName, pMob[clientId].MOB.MobName, lenName))
		{
			memset(&pMob[i].AutoTrade, 0, sizeof(pMob[0].AutoTrade));
			memset(&pMob[i].IsAutoTrading, 0, sizeof(pMob[0].IsAutoTrading));
			DeleteMob(i, 3);
			break;
		}
	}

	return;
}

INT32 CreateMobLeilaoStore(int posX, int posY, int seller)
{
	INT32 LOCAL_1 = GetEmptyNPCMob();
	if (LOCAL_1 == 0)
		return -1;

	pMob[LOCAL_1] = CMob{};
	strncpy_s(pMob[LOCAL_1].MOB.MobName, "Base", 16);
	memset(&pMob[LOCAL_1].PartyList, 0, sizeof(INT16) * 12);

	INT32 LOCAL_2 = ReadMob(&pMob[LOCAL_1].MOB, "npc");
	if (LOCAL_2 == 0)
		return false;

	strncpy_s(pMob[LOCAL_1].MOB.MobName, pMob[seller].MOB.MobName, 16);
	pMob[LOCAL_1].MOB.MobName[15] = 0;

	for (INT32 LOCAL_3 = 0; LOCAL_3 < 16; LOCAL_3++)
	{
		if (pMob[LOCAL_1].MOB.MobName[LOCAL_3] == '_')
			pMob[LOCAL_1].MOB.MobName[LOCAL_3] = ' ';
		if (pMob[LOCAL_1].MOB.MobName[LOCAL_3] == '@')
			pMob[LOCAL_1].MOB.MobName[LOCAL_3] = ' ';
	}

	memset(&pMob[LOCAL_1].Affect, 0, sizeof(STRUCT_AFFECT) * 32);

	// Trava para não andar: inicializar a posição e manter fixa
	for (INT32 LOCAL_3 = 0; LOCAL_3 < 5; LOCAL_3++)
	{
		pMob[LOCAL_1].SegmentListX[LOCAL_3] = posX;
		pMob[LOCAL_1].SegmentListY[LOCAL_3] = posY;
	}

	strncpy_s(pMob[LOCAL_1].Tab, "", 16);

	pMob[LOCAL_1].MOB.Equip[0].sIndex = 230;
	pMob[LOCAL_1].MOB.Equip[6].sIndex = 0;
	pMob[LOCAL_1].MOB.Equip[7].sIndex = 0;
	pMob[LOCAL_1].MOB.Equip[14].sIndex = 0;
	pMob[LOCAL_1].MOB.CurrentScore.Con = 400;

	pMob[LOCAL_1].GenerateIndex = -1;
	pMob[LOCAL_1].Formation = 0;
	pMob[LOCAL_1].RouteType = 0;
	pMob[LOCAL_1].Mode = 4; // Modo específico para NPC de comércio
	pMob[LOCAL_1].SegmentProgress = 0;
	pMob[LOCAL_1].Leader = 0;
	pMob[LOCAL_1].WaitSec = 10;


	pMob[LOCAL_1].GetCurrentScore(MAX_USER);

	pMob[LOCAL_1].MOB.CurrentScore.Hp = pMob[LOCAL_1].MOB.CurrentScore.MaxHp;
	pMob[LOCAL_1].SegmentDirection = 0;

	memset(&pMob[LOCAL_1].EnemyList, 0, 8);

	int LOCAL_5 = pMob[LOCAL_1].SegmentListX[0];
	int LOCAL_6 = pMob[LOCAL_1].SegmentListY[0];

	INT32 LOCAL_7 = GetEmptyMobGrid(LOCAL_1, &LOCAL_5, &LOCAL_6);
	if (LOCAL_7 == 0)
	{
		pMob[LOCAL_1].Mode = 0;
		pMob[LOCAL_1].MOB.MobName[0] = 0;
		pMob[LOCAL_1].GenerateIndex = -1;
		return -2;
	}

	pMob[LOCAL_1].LastTime = clock();

	pMob[LOCAL_1].SegmentX = LOCAL_5;
	pMob[LOCAL_1].TargetX = LOCAL_5;
	pMob[LOCAL_1].LastX = LOCAL_5;

	pMob[LOCAL_1].SegmentY = LOCAL_6;
	pMob[LOCAL_1].TargetY = LOCAL_6;
	pMob[LOCAL_1].LastY = LOCAL_6;

	INT32 LOCAL_17 = pMob[LOCAL_1].MOB.BaseScore.MaxHp;
	if (LOCAL_17 != 0)
	{
		SetAffect(LOCAL_1, LOCAL_17, 30000, 200);
		SetTick(LOCAL_1, LOCAL_17, 30000, 200);
	}

	pMobGrid[LOCAL_6][LOCAL_5] = LOCAL_1;


	pMob[LOCAL_1].IsAutoTrading = true;

	SendGridMob(seller);
	SendGridMob(LOCAL_1);

	// Certifique-se de que o modo está correto para um NPC de comércio
	pMob[LOCAL_1].Mode = 1; // Substitua por um valor de modo adequado

	return LOCAL_1;
}
 
float TimeRemaining(int dia, int mes, int ano)
{
	time_t rawnow = time(NULL);
	struct tm now; localtime_s(&now, &rawnow);

	int month = now.tm_mon; //0 Janeiro, 1 Fev
	int day = now.tm_mday;
	int year = now.tm_year;

	struct std::tm a = { 0,0,0, day, month, year };
	struct std::tm b = { 0,0,0, dia, mes - 1, ano - 1900 };

	std::time_t x = std::mktime(&a);
	std::time_t y = std::mktime(&b);

	if (x != (std::time_t)(-1) && y != (std::time_t)(-1))
	{
		double difference = (std::difftime(y, x) / (60 * 60 * 24));
		return static_cast<float>(difference);
	}

	return 0;
}

INT32 GetFirstSlot(int clientId, int itemId)
{
	STRUCT_ITEM* item = pMob[clientId].MOB.Carry;
	for (int i = 0; i < 30; i++)
	{
		if (item[i].sIndex == itemId)
			return i;
	}

	if (item[60].sIndex == 3467)
	{
		float remainig = TimeRemaining(item[60].EFV1, item[60].EFV2, item[60].EFV3 + 1900);
		if (remainig > 0.0f)
		{
			for (int i = 30; i < 45; i++)
			{
				if (item[i].sIndex == itemId)
					return i;
			}
		}
		else
		{
			printf("\nBolsa do Andarilho acabou. Slot 60. %02d/%02d/%04d", item[60].EFV1, item[60].EFV2, item[60].EFV3 + 1900);
			printf("\nBolsa do andarilho acabou. Data de finalizaaao: %02d/%02d/%04d", item[60].EFV1, item[60].EFV2, item[60].EFV3 + 1900);

			memset(&item[60], 0, sizeof STRUCT_ITEM);

			// Atualiza o inventario
			SendItem(clientId, ITEM_PLACE_CARRY, 60, &item[60]);
		}
	}

	if (item[61].sIndex == 3467)
	{
		float remainig = TimeRemaining(item[61].EFV1, item[61].EFV2, item[61].EFV3 + 1900);
		if (remainig > 0.0f)
		{
			for (int i = 45; i < 60; i++)
			{
				if (item[i].sIndex == itemId)
					return i;
			}
		}
		else
		{
			printf("\nBolsa do Andarilho acabou. Slot 61. %02d/%02d/%04d", item[61].EFV1, item[61].EFV2, item[61].EFV3 + 1900);
			printf("\nBolsa do andarilho acabou. Data de finalizaaao: %02d/%02d/%04d", item[61].EFV1, item[61].EFV2, item[61].EFV3 + 1900);
			memset(&item[61], 0, sizeof STRUCT_ITEM);

			// Atualiza o inventario
			SendItem(clientId, ITEM_PLACE_CARRY, 61, &item[61]);
		}
	}

	return -1;
}

INT32 GetItemAmount(STRUCT_ITEM* item)
{
	INT32 amount = 1;

	for (INT8 i = 0; i < 3; i++)
	{
		if (item->stEffect[i].cEffect == EF_AMOUNT)
		{
			amount = item->stEffect[i].cValue;
			if (amount == 0)
				amount = 1;

			break;
		}
	}

	return amount;
}

void AmountMinusPlus(STRUCT_ITEM* item, int qtd)
{
	int index = 0;
	int amount = 0;
	for (int i = 0; i < 3; i++)
	{
		if (item->stEffect[i].cEffect == EF_AMOUNT)
		{
			index = i;
			amount = item->stEffect[i].cValue;

			break;
		}
	}

	if (amount <= 1)
		memset(item, 0, sizeof STRUCT_ITEM);
	else
	{
		if (item->stEffect[index].cValue == qtd)
			memset(item, 0, sizeof STRUCT_ITEM);
		else
		{
			if (item->stEffect[index].cValue && item->stEffect[index].cValue < 120)
			{
				item->stEffect[index].cValue = item->stEffect[index].cValue - qtd;
			}
		}
	}
}
 
void SendLeilaoStoreInfos(int clientId, int targetItemType) {
	if (clientId <= MOB_EMPTY || clientId >= MAX_USER || pUser[clientId].Mode != USER_PLAY)
		return;

	MSG_LeilaoStore auctionPage;
	memset(&auctionPage, 0, sizeof(auctionPage));
	auctionPage.Size = sizeof(MSG_LeilaoStore);
	auctionPage.ID = clientId;
	auctionPage.Type = 0x397B;

	int itemCount = 0;
	int pageIndex = 0;

	for (int i = 0; i < MAX_SLOT_LEILAO_AUTOTRADE; ++i) {
		// Verifica se o slot tem um item válido
		if (pMob[clientId].AutoTrade.List[i].Item.sIndex <= 0)
		{
			continue;
		}

		// Filtra itens por tipo, se necessário
		if (targetItemType != 0 && pMob[clientId].AutoTrade.List[i].Categoria != targetItemType)
			continue;

		// Cópia dos dados para a estrutura de envio
		memcpy(&auctionPage.List[itemCount], &pMob[clientId].AutoTrade.List[i], sizeof(LeilaoStoreAux));
		itemCount++;

		// Verifica se é necessário enviar uma nova página
		if (itemCount >= MAX_SLOT_LEILAO_AUTOTRADE) {
			auctionPage.TotalPages = ++pageIndex;
			auctionPage.CurrentPage = pageIndex;
			if (!pUser[clientId].cSock.AddMessage((char*)&auctionPage, sizeof(MSG_LeilaoStore)))
				CloseUser(clientId);

			memset(&auctionPage, 0, sizeof(auctionPage));
			auctionPage.Size = sizeof(MSG_LeilaoStore);
			auctionPage.ID = clientId;
			auctionPage.Type = 0x397B;
			itemCount = 0;
		}
	}

	// Enviar a última página, se houver itens
	if (itemCount > 0) {
		auctionPage.TotalPages = ++pageIndex;
		auctionPage.CurrentPage = pageIndex;
		if (!pUser[clientId].cSock.AddMessage((char*)&auctionPage, sizeof(MSG_LeilaoStore)))
			CloseUser(clientId);
	}
}

void SendLeilaoStoreMyInfos(int clientId)
{
	if (clientId <= MOB_EMPTY || clientId >= MAX_USER || pUser[clientId].Mode != USER_PLAY)
		return;
	 

	int itemCount = 0;
	MSG_LeilaoStore auctionPage;
	memset(&auctionPage, 0, sizeof(auctionPage));
	auctionPage.Size = sizeof(MSG_LeilaoStore);
	auctionPage.Type = 0x397B;
	auctionPage.ID = clientId;
	auctionPage.TotalPages = 1;
	auctionPage.CurrentPage = 1;


	for (int i = 0; i < MAX_SLOT_LEILAO_AUTOTRADE; i++)
	{
		if (itemCount >= MAX_SLOT_LEILAO_AUTOTRADE)
			break;

		auctionPage.List[itemCount].OwnerId = clientId;
		strncpy_s(auctionPage.List[itemCount].Name, pMob[clientId].AutoTrade.List[i].Name, sizeof(auctionPage.List[itemCount].Name) - 1);
		auctionPage.List[itemCount].TaxRate = pMob[clientId].AutoTrade.List[i].TaxRate;
		auctionPage.List[itemCount].Item = pMob[clientId].AutoTrade.List[i].Item;
		auctionPage.List[itemCount].Price = pMob[clientId].AutoTrade.List[i].Price;
		auctionPage.List[itemCount].SlotBank = pMob[clientId].AutoTrade.List[i].SlotBank;
		auctionPage.List[itemCount].Categoria = pMob[clientId].AutoTrade.List[i].Categoria;

		itemCount++;
	}

	auctionPage.Size = sizeof(MSG_LeilaoStore) + itemCount * sizeof(LeilaoStoreAux);

	if (!pUser[clientId].cSock.AddMessage((char*)&auctionPage, auctionPage.Size))
		CloseUser(clientId);
	 
}

void SendLeilaoStoreAlvoInfos(int clientId, int Dono) {
	if (clientId <= MOB_EMPTY || clientId >= MAX_USER || pUser[clientId].Mode != USER_PLAY)
		return;

	int itemCount = 0;
	MSG_LeilaoStore auctionPage;
	memset(&auctionPage, 0, sizeof(auctionPage));
	auctionPage.Size = sizeof(MSG_LeilaoStore);
	auctionPage.Type = 0x397B;
	auctionPage.ID = clientId;
	auctionPage.TotalPages = 1;
	auctionPage.CurrentPage = 1;


	for (int i = 0; i < MAX_SLOT_LEILAO_AUTOTRADE; i++)
	{
		if (itemCount >= MAX_SLOT_LEILAO_AUTOTRADE)
			break;

		auctionPage.List[itemCount].OwnerId = Dono;
		strncpy_s(auctionPage.List[itemCount].Name, pMob[Dono].AutoTrade.List[i].Name, sizeof(auctionPage.List[itemCount].Name) - 1);
		auctionPage.List[itemCount].TaxRate = pMob[Dono].AutoTrade.List[i].TaxRate;
		auctionPage.List[itemCount].Item = pMob[Dono].AutoTrade.List[i].Item;
		auctionPage.List[itemCount].Price = pMob[Dono].AutoTrade.List[i].Price;
		auctionPage.List[itemCount].SlotBank = pMob[Dono].AutoTrade.List[i].SlotBank;
		auctionPage.List[itemCount].Categoria = pMob[Dono].AutoTrade.List[i].Categoria;

		itemCount++;
	}

	auctionPage.Size = sizeof(MSG_LeilaoStore) + itemCount * sizeof(LeilaoStoreAux);

	if (!pUser[clientId].cSock.AddMessage((char*)&auctionPage, auctionPage.Size))
		CloseUser(clientId);
}
 
void SendLeilaoStoreAllInfos(int clientId, int type, int requestedPage)
{
	if (clientId <= MOB_EMPTY || clientId >= MAX_USER || pUser[clientId].Mode != USER_PLAY)
		return;

	std::vector<LeilaoStoreAux> allItems;

	// Coletando os itens de todos os jogadores que estão em AutoTrade
	for (int player = 0; player < MAX_USER; ++player)
	{
		if (pUser[player].Mode != USER_PLAY)
			continue;

		if (!pMob[player].IsAutoTrading)
			continue;

		for (int i = 0; i < MAX_SLOT_LEILAO_AUTOTRADE; i++)
		{
			if (pMob[player].AutoTrade.List[i].Item.sIndex == 0)
				continue;

			if (type != 0 && type != pMob[player].AutoTrade.List[i].Categoria)
				continue;

			LeilaoStoreAux itemInfo;
			itemInfo.OwnerId = player;

			// Copia as informações do item sem alterar sua posição original
			strncpy_s(itemInfo.Name, pMob[player].AutoTrade.List[i].Name, sizeof(itemInfo.Name) - 1);
			itemInfo.TaxRate = pMob[player].AutoTrade.List[i].TaxRate;
			itemInfo.Item = pMob[player].AutoTrade.List[i].Item;
			itemInfo.Price = pMob[player].AutoTrade.List[i].Price;
			itemInfo.SlotBank = pMob[player].AutoTrade.List[i].SlotBank;
			itemInfo.Categoria = pMob[player].AutoTrade.List[i].Categoria;

			allItems.push_back(itemInfo);
		}
	}

	// Calculando o total de itens e páginas
	int totalItems = allItems.size();
	int itemsPerPage = MAX_SLOT_LEILAO_AUTOTRADE;  // Quantidade de itens por página
	int totalPages = (totalItems + itemsPerPage - 1) / itemsPerPage;

	// Verificando se a página solicitada é válida
	if (requestedPage < 1 || requestedPage > totalPages)
		requestedPage = 1;  // Caso a página solicitada seja inválida, voltamos para a página 1

	// Preparando o pacote para a página solicitada
	MSG_LeilaoStore auctionPage;
	memset(&auctionPage, 0, sizeof(auctionPage));
	auctionPage.Size = sizeof(MSG_LeilaoStore);
	auctionPage.Type = 0x397B;
	auctionPage.ID = clientId;
	auctionPage.TotalPages = totalPages;
	auctionPage.CurrentPage = requestedPage;

	int startIdx = (requestedPage - 1) * itemsPerPage;
	int endIdx = min(startIdx + itemsPerPage, totalItems);
	int itemCount = 0;

	for (int i = startIdx; i < endIdx; ++i)
	{
		auctionPage.List[itemCount++] = allItems[i];
	}

	auctionPage.Size = sizeof(MSG_LeilaoStore) + itemCount * sizeof(LeilaoStoreAux);

	// Enviando os dados para o cliente
	if (!pUser[clientId].cSock.AddMessage((char*)&auctionPage, auctionPage.Size))
	{
		CloseUser(clientId);
		return;
	}
}

/*Recupera informações*/
void Exec_MSG_LeilaoStore(int clientId, char* pMsg)
{ 
	MSG_GetLeilaoStores* p = (MSG_GetLeilaoStores*)pMsg;

	if (p->Size > sizeof(MSG_GetLeilaoStores))
	{
		printf("Pacote: 0x%X - Tamanho: %d - Index: %d\n",p->Type, p->Size, p->ID);
		return;
	} 

	if (clientId <= 0 || clientId >= MAX_USER)
	{
		AddCrackError(clientId, 10, 803);
		return;
	}

	if (pUser[clientId].Mode != USER_PLAY)
	{
		AddCrackError(clientId, 10, 804);
		return;
	}

	//// Verifica se o tempo de atraso permite a nova busca
	if (pUser[clientId].sxCountSerch != 0)
	{
		int isTime = GetTickCount64() - pUser[clientId].sxCountSerch; // ATRASO PACOTE DE LOGIN

		if (isTime < 500)
		{ 
			return;
		} 
	}

	// Atualiza o tempo de atraso para evitar spam
	pUser[clientId].sxCountSerch = GetTickCount64();

	if (pMob[clientId].MOB.CurrentScore.Hp == 0)
	{
		AddCrackError(clientId, 10, 805);
		return;
	}

	// Define o tipo de item com base no comando
	int tipo = p->itemType;

	if (tipo == -1)//somente minhas informações
	{    
		if (!pMob[clientId].IsAutoTrading)
		{ 
			return;
		}  
		 SendLeilaoStoreMyInfos(clientId);  
	} 
	else
	{ 
		SendLeilaoStoreAllInfos(clientId, tipo, p->currentpage); 
	}

	UpdateLeilaoSaldo(clientId);
}

/*Cria Mob e da permissao para anunciar itens*/
void Exec_MSG_CreateMobLeilao(int clientId, char* pMsg)
{
	std::cout << "Informações dos itens da loja\n";
	MSG_LeilaoStore* p = (MSG_LeilaoStore*)(pMsg);

	if (p->Size > sizeof(MSG_LeilaoStore))
	{
		printf("Pacote: 0x%X - Tamanho: %d - Index: %d\n", p->Type, p->Size, p->ID);
		return;
	}


	// Verificar se o usuário já tem uma loja ativa
	for (int i = 1; i < MAX_USER; i++)
	{
	    auto& user = pUser[i];
	    if (user.Mode != USER_PLAY || !pMob[i].IsAutoTrading)
	        continue;

	    // Comparar endereços MACCheckLojaTime
	    if (memcmp(pUser[clientId].MacAddress, user.MacAddress, 6) == 0)
	    {
	        // Se já tiver uma loja ativa com o mesmo endereço MAC, retornar falso
	        SendClientMessage(clientId, "Você tem loja ativa!!!");
	      //  return;
	    }
	}


	goResetLeilao(clientId);

	if (!pMob[clientId].MOB.CurrentScore.Hp)
	{ 
		AddCrackError(clientId, 10, 800);
		return;
	}
	if (pUser[clientId ].Mode != USER_PLAY)
	{
		SendHpMode(clientId);
		AddCrackError(clientId, 10, 801);
		RemoveTrade(clientId);
		return;
	}

	if (pUser[clientId].Trade.OpponentID)
	{
		RemoveTrade(clientId);
		return;
	}

	RemoveTrade(clientId);

	INT32 posX = pMob[clientId].TargetX;
	INT32 posY = pMob[clientId].TargetY;
	INT32 villageId = BASE_GetVillage(posX, posY);
	if (villageId < 0 || villageId >= 5)
	{
		SendClientMessage(clientId, g_pMessageStringTable[_NN_OnlyVillage]);
		return;
	}

	if (clientId <= 0 || clientId >= MAX_USER)
		return;



	int mobid = CreateMobLeilaoStore(posX, posY, clientId);
	if (mobid <= 0)
	{
		SendClientMessage(clientId, "Não foi possivel abrir a loja.");
		return;
	}

	const char* tiposDeVenda[] = { "Desconhecido", "Donate", "Gold", "Bis" };
	 

	for (int i = 0; i < MAX_SLOT_LEILAO_AUTOTRADE; i++)
	{
		p->List[i].Name[23] = '\0';
		p->List[i].Name[22] = '\0';

		int tipoIndex = (pMob[clientId].AutoTrade.List[i].Categoria >= 1 && pMob[clientId].AutoTrade.List[i].Categoria <= 3) ? pMob[clientId].AutoTrade.List[i].Categoria : 0;
		int itemIndice = pMob[clientId].AutoTrade.List[i].Item.sIndex;

		memcpy(&pMob[clientId].AutoTrade.List[i].Name, &p->List[i].Name, 24);
		pMob[clientId].IsAutoTrading = true;
		pMob[mobid].IsAutoTrading = true;
		pMob[clientId].AutoTrade.List[i].OwnerId = clientId;

		std::cout << "Informações dos itens da loja\n";
		std::cout << "OwnerId da loja: " << pMob[clientId].AutoTrade.List[i].OwnerId << "\n";
		std::cout << "Nome da loja: " << pMob[clientId].AutoTrade.List[i].Name << "\n";
		std::cout << "Posição criada: " << pMob[clientId].TargetX << "x " << pMob[clientId].TargetY << "\n";
		std::cout << "[ITENS]" << "\n";
		std::cout << "SlotBank do Item da Loja: " << (int)pMob[clientId].AutoTrade.List[i].SlotBank << "\n";
		std::cout << "Tipo de Venda: " << tiposDeVenda[tipoIndex] << "\n";
		std::cout << "Slot [" << std::to_string(pMob[clientId].AutoTrade.List[i].Categoria) << "] - " << g_pItemList[itemIndice].Name << " " << ". Preço de " << pMob[clientId].AutoTrade.List[i].Price << "\n";
	}

	memcpy(&pMob[mobid].AutoTrade, &pMob[clientId].AutoTrade, sizeof pMob[clientId].AutoTrade);
	pMob[mobid].IsAutoTrading = true; 

	MSG_CreateMobTrade sm_tb;
	memset(&sm_tb, 0, sizeof(MSG_CreateMobTrade));
	GetCreateMobTrade(mobid, &sm_tb); 
	GridMulticast(pMob[clientId].TargetX, pMob[clientId].TargetY, (MSG_STANDARD*)&sm_tb, 0);
	 
	SendClientSignalParm(clientId, 0x7530, pLeilaoStatus, 1);
	SendLeilaoStoreMyInfos(clientId);
	SendClientMessage(clientId, "Sua lojinha foi criada com sucesso."); 
	Log(temp, "-system", 0);
	return;

}

/*Abre Mob e envia informações itens*/
void Exec_MSG_OpenMobLeilao(int clientId, char* pMsg)
{ 
	MSG_STANDARDPARM* p = (MSG_STANDARDPARM*)(pMsg);

	INT32 idx = p->Parm;
	INT32 Dono = 0;

	if (pMob[clientId].MOB.CurrentScore.Hp == 0 || pUser[clientId].Mode != USER_PLAY)
	{
		AddCrackError(clientId, 10, 804);
		return ;
	}

	if (pMob[idx].MOB.CurrentScore.Hp == 0)
	{
		AddCrackError(clientId, 10, 805);
		return;
	}

	if (!pMob[idx].IsAutoTrading)
		return;

	Dono = pMob[idx].AutoTrade.List->OwnerId;


	if (Dono <= 0 || Dono >= MAX_USER)
	{
		AddCrackError(clientId, 10, 803);
		return;
	}

	if (pUser[Dono].Mode != USER_PLAY)
	{
		AddCrackError(clientId, 10, 804);
		return;
	}

	SendLeilaoStoreAlvoInfos(clientId, Dono);
	return;

}

/*Cria anuncio de itens no Sistema de leilão*/
void Exec_MSG_AddItemLeilaoStore(int clientId, char* pMsg)
{ 
	pAddItemLeilaoStore* p = (pAddItemLeilaoStore*)(pMsg);

	if (p->Size > sizeof(pAddItemLeilaoStore))
	{
		printf("Pacote: 0x%X - Tamanho: %d - Index: %d\n", p->Type, p->Size, p->ID);
		return;
	} 

	int itemType = p->itemType;
	int SlotBank = p->SlotBank;
	int itemPrice = p->itemPrice;
	STRUCT_ITEM newItem = p->item;

	bool itemAdded = false;

	// Log inicial: recepção do pacote
	// printf("\n Recebido pacote 0x397C - Tentativa de adicionar item ao AutoTrade. Tipo: %d, SlotBank: %d, Preço: %d", itemType, SlotBank, itemPrice);
	INT32 itemId = p->item.sIndex;
	INT32 i = 0;
	char strSexy[128]{};

	int sTepPacket = 0;

	if (itemId == 0)
		return;

	if (itemPrice < 0 || itemPrice > 1999999999)
		return;


	if (itemType == 3 && itemPrice > 100)//BIs
	{
		SendClientMessage(clientId, "Limite de 100 bi para cada 1 item!");
		SendLeilaoStoreInfos(clientId, 0);
		return;
	}


	if (itemId == 508 || itemId == 509 || itemId == 522 || (itemId >= 526 && itemId <= 531) || itemId == 446
		|| itemId == 3993 || itemId == 3994)
		return;

	if (BASE_GetItemAbility(&p->item, EF_NOTRADE))
	{
		SendClientMessage(clientId, "Este item não é negociavel.");
		SendLeilaoStoreInfos(clientId, 0);

		SendItem(clientId, ITEM_PLACE_CARGO, SlotBank, &pUser[clientId].Cargo[SlotBank]);
		return;
	}

	if (!pMob[clientId].IsAutoTrading)
	{
		SendClientMessage(clientId, "Você precisa criar uma lojinha para anunciar itens!");
		SendLeilaoStoreInfos(clientId, 0);

		SendItem(clientId, ITEM_PLACE_CARGO, SlotBank, &pUser[clientId].Cargo[SlotBank]);
		return;
	}

	if (SlotBank < 0 || SlotBank >= 168)
		return;

	INT32 verify = memcmp(&pUser[clientId].Cargo[SlotBank], &p->item, 8);

	if (verify != 0)
	{
		return;
	}

	if (!itemType)
	{
		snprintf(strSexy, sizeof strSexy, "%s esta sem definição de valor. Processo reiniciado!", g_pItemList[itemId].Name);
		SendClientMessage(clientId, strSexy);
		SendLeilaoStoreInfos(clientId, 0);

		SendItem(clientId, ITEM_PLACE_CARGO, SlotBank, &pUser[clientId].Cargo[SlotBank]);
		return;
	}


	p->Name[23] = '\0';
	p->Name[22] = '\0';

	INT32 posX = pMob[clientId].TargetX;
	INT32 posY = pMob[clientId].TargetY;
	INT32 villageId = BASE_GetVillage(posX, posY);

	if (villageId < 0 || villageId >= 5)
	{
		SendClientMessage(clientId, g_pMessageStringTable[_NN_OnlyVillage]);
		SendLeilaoStoreInfos(clientId, 0);

		SendItem(clientId, ITEM_PLACE_CARGO, SlotBank, &pUser[clientId].Cargo[SlotBank]);
		return;
	}

	int CityTax = g_pGuildZone[villageId].CityTax;

	for (int i = 0; i < MAX_SLOT_LEILAO_AUTOTRADE; i++)
	{
		if (pMob[clientId].AutoTrade.List[i].Item.sIndex == 0)
		{
			// Vaga disponível encontrada, adicionar o item
			strncpy_s(pMob[clientId].AutoTrade.List[i].Name, pMob[clientId].AutoTrade.List[i].Name, sizeof(pMob[clientId].AutoTrade.List[i].Name) - 1);
			pMob[clientId].AutoTrade.List[i].OwnerId = clientId;
			pMob[clientId].AutoTrade.List[i].TaxRate = CityTax;
			pMob[clientId].AutoTrade.List[i].Item = newItem;
			pMob[clientId].AutoTrade.List[i].Categoria = itemType;
			pMob[clientId].AutoTrade.List[i].SlotBank = SlotBank;
			pMob[clientId].AutoTrade.List[i].Price = itemPrice;
			itemAdded = true;

			// Log de sucesso: item adicionado
		printf("\nItem adicionado ao AutoTrade. Tipo: %d, SlotBank: %d, Preço: %d, Posição no AutoTrade: %d", itemType, SlotBank, itemPrice, i);
			break;
		}
	}

	if (itemAdded)
	{

		// Declara uma variável para armazenar o tipo de item como string
		const char* itemTypeName = "";

		// Verifica o tipo de item e define a variável itemTypeName apropriada
		switch (itemType)
		{
		case 1: // donate
			itemTypeName = "donate";
			break;
		case 2: // gold
			itemTypeName = "gold";
			break;
		case 3: // barras de 1b
			itemTypeName = "barras de 1b";
			break;
		default:
			itemTypeName = "NA";
			break;
		}

		snprintf(strSexy, sizeof(strSexy), "Item '%s' anunciado por %d em %s.", g_pItemList[itemId].Name, itemPrice, itemTypeName);


		// Envia a mensagem para o cliente e atualiza a loja de leilão
		SendClientMessage(clientId, strSexy);
		SendLeilaoStoreInfos(clientId, 0);
	}
	else
	{
		// Log de falha: não há vagas disponíveis
		printf("\nFalha ao adicionar item ao AutoTrade: Não há vagas disponíveis. Tipo: %d, SlotBank: %d, Preço: %d", itemType, SlotBank, itemPrice);

		// Enviar uma mensagem ao cliente indicando que não há vagas disponíveis
		SendClientMessage(clientId, "Não há vagas disponíveis no AutoTrade.");
	}
	return;
}

/*Negociação de itens no Sistema de leilão*/
void Exec_MSG_BuyItemLeilaoStore(int clientId, char* pMsg)
{
	pStartNegotiation* p = (pStartNegotiation*)(pMsg);

	if (p->Size > sizeof(pStartNegotiation))
	{
		printf(" Maior Pacote: 0x%X - Tamanho: %d - Index: %d\n", p->Type, p->Size, p->ID);
		return;
	}

	STRUCT_MOB* player = (STRUCT_MOB*)(&pMob[clientId].MOB);


	int itemType = p->itemType;
	int slotBank = p->SlotBank;
	int itemSlot = p->itemSlot;
	int itemPrice = p->itemPrice;
	int itemTax = p->itemTax;
	int mobId = p->targetPlayerId;
	STRUCT_ITEM newItem = p->item;

	INT32 DonoLoja = mobId;


	if (!player->CurrentScore.Hp || pUser[clientId].Mode != USER_PLAY)
		return;


	if (DonoLoja <= 0 || DonoLoja >= MAX_USER)
	{
		SendClientMessage(clientId, "indice do lider fora do indice");
		return;
	}

	/*if (DonoLoja == pMob[DonoLoja].AutoTrade.List->OwnerId)
	{
		SendClientMessage(clientId, "Ação não permitida");
		return false;
	}*/

	if (!pMob[DonoLoja].MOB.CurrentScore.Hp || pUser[DonoLoja].Mode != USER_PLAY)
		return;


	if (pUser[clientId].Trade.OpponentID != 0)
	{
		RemoveTrade(clientId);

		AddCrackError(clientId, 1, 810);
		return;
	}


	/*

	// bloqueio distancia

	if (pMob[clientId].Target.X < pMob[mobId].Target.X - VIEWGRIDX || pMob[clientId].Target.X > pMob[mobId].Target.X + VIEWGRIDX || pMob[clientId].Target.Y < pMob[mobId].Target.Y - VIEWGRIDY || pMob[clientId].Target.Y > pMob[mobId].Target.Y + VIEWGRIDY)
   {
	   SendClientMessage(clientId, g_pMessageStringTable[_NN_SoFar_BuyShop]);
	   return;
   }

   */


	if (itemSlot < 0 || itemSlot >= MAX_SLOT_LEILAO_AUTOTRADE)
	{
		return;
	}



	INT32 SellTipy = 0;

	SellTipy = pMob[DonoLoja].AutoTrade.List[itemSlot].Categoria;
	int MyCash = 0;
	int MyGold = player->Coin;
	int MyBis = 0;

	auto& pc = cSQL::instance();


	sprintf(hQuery, "SELECT * FROM `accounts` WHERE `username` = '%s'", pUser[clientId].AccountName);
	MYSQL_ROW row;
	MYSQL* wSQL = pc.wStart();
	MYSQL_RES* result = pc.wRes(wSQL, hQuery);

	if (result == NULL)
		return;

	while ((row = mysql_fetch_row(result)) != NULL)
	{
		MyCash = atoi(row[6]);
	}
	INT8 MyBisSlot = GetFirstSlot(clientId, 4011);

	if (MyBisSlot != -1)
	{
		MyBis = GetItemAmount(&pMob[clientId].MOB.Carry[MyBisSlot]);
	}

	if (slotBank < 0 || slotBank >= 128)
	{

		return;
	}

	if (itemTax != pMob[DonoLoja].AutoTrade.List[itemSlot].TaxRate)
	{
		return;
	}

	printf(" fluxo Pacote:   %d %d \n", itemPrice, pMob[DonoLoja].AutoTrade.List[itemSlot].Price);

	if (itemPrice != pMob[DonoLoja].AutoTrade.List[itemSlot].Price)
	{
		return;
	}

	if (pMob[DonoLoja].AutoTrade.List[itemSlot].Item.sIndex == 0)
	{
		return;
	}

	INT32 itemCheck = memcmp(&p->item, &pMob[DonoLoja].AutoTrade.List[itemSlot].Item, 8);


	if (itemCheck != 0)
	{
		return;
	}

	itemCheck = memcmp(&pUser[DonoLoja].Cargo[slotBank], &pMob[DonoLoja].AutoTrade.List[itemSlot].Item, 8);

	if (itemCheck != 0)
	{
		return;
	}

	if (SellTipy == 1) // o preço do item é em donate
	{

		if (MyCash < itemPrice)
		{
			SendClientMessage(clientId, "Não possui a quantia de cash!");
			return;
		}
	}
	else if (SellTipy == 2) // o preço do item é em gold
	{
		if (MyGold < itemPrice)
		{
			SendClientMessage(clientId, "Não possui a quantia de gold!");
			return;
		}
	}
	else if (SellTipy == 3) // o preço do item é em biss
	{
		if (MyBis < itemPrice)
		{
			SendClientMessage(clientId, "Não possui a quantia de bis!");
			return;
		}
	}
	else
	{
		if (player->Coin < itemPrice)
		{
			SendClientMessage(clientId, "Não possui a quantia de gold!");
			return;
		}
	}




	if (itemPrice <= 1000 && SellTipy == 2)// o preço do item é em gold
	{
		SendClientMessage(clientId, "Este item esta em modo demonstração");

		return;
	}

	STRUCT_ITEM* item = (STRUCT_ITEM*)&p->item;

	INT32 nullSlot = GetFirstSlot(clientId, 0);
	if (nullSlot < 0 || nullSlot >= MAX_CARRY)
	{
		SendClientMessage(clientId, g_pMessageStringTable[_NN_You_Have_No_Space_To_Trade]);
		return;
	}

	INT32 impost = 0;
	INT32 totalPrice = itemPrice; // local1190

	INT32 mobTargetX = pMob[mobId].TargetX; // local1178
	INT32 mobTargetY = pMob[mobId].TargetY; // local1179
	INT32 villageId = BASE_GetVillage(mobTargetX, mobTargetY); // local1180

	if (villageId < 0 || villageId >= 5)
	{ // Permitido somente dentro da cidade
		SendClientMessage(clientId, g_pMessageStringTable[_NN_OnlyVillage]);
		return;
	}

	INT32 tax = g_pGuildZone[villageId].CityTax;

	if (SellTipy == 2 && itemPrice >= 100000)
	{
		impost = itemPrice / 100 * tax;

		totalPrice = itemPrice - impost;
	}

	UINT64 total = pUser[DonoLoja].Coin + totalPrice;
	if (total > 2000000000)
	{
		SendClientMessage(clientId, g_pMessageStringTable[_NN_Cant_get_more_than_2G]);

		return;
	}


	memcpy(&player->Carry[nullSlot], item, 8);

	SendItem(clientId, ITEM_PLACE_CARRY, nullSlot, &player->Carry[nullSlot]);

	pMob[DonoLoja].AutoTrade.List[itemSlot].SlotBank = -1; // -1;

	memset(&pMob[DonoLoja].AutoTrade.List[itemSlot].Item, 0, 8);

	pMob[DonoLoja].AutoTrade.List[itemSlot].Price = 0;
	memset(&pUser[DonoLoja].Cargo[slotBank], 0, 8);


	SendItem(DonoLoja, ITEM_PLACE_CARGO, slotBank, &pUser[DonoLoja].Cargo[slotBank]);


	if (SellTipy == 1) // o preço do item é em donate
	{
		auto& pc = cSQL::instance();
		int Donate = 0;
		sprintf(hQuery, "SELECT * FROM `accounts` WHERE `username` = '%s'", pUser[clientId].AccountName);
		MYSQL_ROW row;
		MYSQL* wSQL = pc.wStart();
		MYSQL_RES* result = pc.wRes(wSQL, hQuery);

		if (result == NULL) {
			return;
		}


		while ((row = mysql_fetch_row(result)) != NULL)
		{
			Donate = atoi(row[6]) - itemPrice;
		}

		sprintf(xQuery, "UPDATE accounts SET donate = '%d' WHERE username = '%s' ", (Donate), pUser[clientId].AccountName);
		pc.wQuery(xQuery);


		UpdateDonate(clientId);
		SaveUser(clientId, 0);


		auto& pc2 = cSQL::instance();
		int SellDonate = 0;
		sprintf(hQuery, "SELECT * FROM `accounts` WHERE `username` = '%s'", pUser[DonoLoja].AccountName);
		MYSQL_ROW row2;
		MYSQL* wSQL2 = pc2.wStart();
		MYSQL_RES* result2 = pc2.wRes(wSQL2, hQuery);

		if (result2 == NULL) {
			return;
		}


		while ((row2 = mysql_fetch_row(result2)) != NULL)
		{
			SellDonate = atoi(row2[6]) + itemPrice;
		}

		sprintf(xQuery, "UPDATE accounts SET donate = '%d' WHERE username = '%s' ", (SellDonate), pUser[DonoLoja].AccountName);
		pc2.wQuery(xQuery);

		UpdateDonate(DonoLoja);
		SaveUser(DonoLoja, 0); 

	}
	else if (SellTipy == 2) // o preço do item é em gold
	{
		player->Coin = player->Coin - itemPrice;
		SendCarry(clientId);

		if (pUser[DonoLoja].Coin < 2000000000)
		{
			pUser[DonoLoja].Coin += totalPrice;
			SendCargoCoin(DonoLoja);
		}

	}
	else if (SellTipy == 3) // o preço do item é em biss
	{
		if (MyBisSlot == -1)//não tem bis
		{
			return;
		}

		AmountMinusPlus(&pMob[clientId].MOB.Carry[MyBisSlot], itemPrice);
		SendItem(clientId, ITEM_PLACE_CARRY, MyBisSlot, &pMob[clientId].MOB.Carry[MyBisSlot]);

		for (int i = 0; i < MAX_CARGO; i++)
		{
			if (pUser[DonoLoja].Cargo[i].sIndex != 0)
				continue;

			pUser[DonoLoja].Cargo[i].sIndex = 4011;
			pUser[DonoLoja].Cargo[i].stEffect[0].cEffect = 61;
			pUser[DonoLoja].Cargo[i].stEffect[0].cValue = itemPrice;
			SendItem(DonoLoja, ITEM_PLACE_CARGO, i, &pUser[DonoLoja].Cargo[i]);
			break;
		}

	}
	else
	{
		SendClientMessage(clientId, "Invalido!");
		return;
	}


	struct p39B
	{
		_MSG;
		INT32 MobID;
		INT32 SlotID;
	};

	char strtemp[128]{};
	snprintf(strtemp, 128, "!O personagem [%s] comprou o item %s por %d", player->MobName, g_pItemList[p->item.sIndex].Name, p->itemPrice);

	SendClientMessage(p->targetPlayerId, strtemp);

	printf("\nComprou o item %s [%d] [%d %d %d %d %d %d] de %s (%s) por %d. Gold sobrando: %d - Impostos pago: %d", g_pItemList[item->sIndex].Name, item->sIndex, item->stEffect[0].cEffect,
		item->stEffect[0].cValue, item->stEffect[1].cEffect, item->stEffect[1].cValue, item->stEffect[2].cEffect, item->stEffect[2].cValue, pMob[DonoLoja].MOB.MobName, pUser[DonoLoja].AccountName, p->itemPrice,
		player->Coin, impost);

	printf("\nVendeu o item %s [%d] [%d %d %d %d %d %d] para %s (%s) por %d. Gold banco: %d - Impostos: %d", g_pItemList[item->sIndex].Name, item->sIndex, item->stEffect[0].cEffect,
		item->stEffect[0].cValue, item->stEffect[1].cEffect, item->stEffect[1].cValue, item->stEffect[2].cEffect, item->stEffect[2].cValue, player->MobName, pUser[clientId].AccountName, p->itemPrice, pUser[DonoLoja].Coin,
		impost);

	printf("\nComprou o item %s da loja de %s por %d", g_pItemList[item->sIndex].Name, pMob[p->targetPlayerId].MOB.MobName, p->itemPrice);
	printf("\nVendeu o item %s de sua loja para %s por %d. %d foram pagos de impostos", g_pItemList[item->sIndex].Name, pMob[clientId].MOB.MobName, p->itemPrice, impost);


	snprintf(strtemp, 128, "Comprou o item %s de %s por %d", g_pItemList[item->sIndex].Name, pMob[DonoLoja].MOB.MobName, p->itemPrice);
	SendClientMessage(clientId, strtemp);

	snprintf(strtemp, 128, "Vendeu o item %s de %s por %d. %d de impostos", g_pItemList[item->sIndex].Name, pMob[clientId].MOB.MobName, p->itemPrice, impost);
	SendClientMessage(DonoLoja, strtemp);


	if (impost > 50000000)
	{
		printf("\nPagos um total de %d de impostos... Valor maior que 50 milhões.", impost);
		printf("\n[%s] Vendeu o item %s [%d] [%d %d %d %d %d %d] para %s (%s) por %d. Gold banco: %d - Impostos: %d", pUser[p->targetPlayerId].AccountName, g_pItemList[item->sIndex].Name, item->sIndex, item->stEffect[0].cEffect,
			item->stEffect[0].cValue, item->stEffect[1].cEffect, item->stEffect[1].cValue, item->stEffect[2].cEffect, item->stEffect[2].cValue, player->MobName, pUser[clientId].AccountName, p->itemPrice, pUser[DonoLoja].Coin,
			impost);
	}


	UpdateLeilaoSaldo(mobId);
	UpdateLeilaoSaldo(clientId);

	snprintf(strtemp, 128, "Comprou %s de %s($:%d)", g_pItemList[p->item.sIndex].Name, pMob[mobId].MOB.MobName, p->itemPrice);
	SendClientMessage(clientId, strtemp);

	snprintf(strtemp, 128, "Vendeu %s de %s($:%d) %d de impostos", g_pItemList[p->item.sIndex].Name, pMob[clientId].MOB.MobName, p->itemPrice, itemTax);
	SendClientMessage(mobId, strtemp);
	SaveUser(clientId, 0);
	SaveUser(mobId, 0);
	SendLeilaoStoreAlvoInfos(clientId, mobId);
	SendLeilaoStoreMyInfos(mobId);


	return;

}















///*Negociação de itens no Sistema de leilão*/
//void Exec_MSG_BuyItemLeilaoStore(int clientId, char* pMsg)
//{
//	pStartNegotiation* p = (pStartNegotiation*)(pMsg);
//
//	// Valida o tamanho do pacote
//	if (p->Size != sizeof(pStartNegotiation))
//	{
//		printf("Pacote inválido: 0x%X - Tamanho: %d - Index: %d\n", p->Type, p->Size, p->ID);
//		return;
//	}
//
//	STRUCT_MOB* player = (STRUCT_MOB*)(&pMob[clientId].MOB);
//
//	int itemType = p->itemType;
//	int slotBank = p->SlotBank;
//	int itemSlot = p->itemSlot;
//	int itemPrice = p->itemPrice;
//	int itemTax = p->itemTax;
//	int mobId = p->targetPlayerId;
//	STRUCT_ITEM newItem = p->item;
//
//
//	std::cout << "  *******************  " << "  \n  ";
//	std::cout << "\n  Compra recebida :: itemSlot " << itemSlot;
//	std::cout << "  mobId " << mobId;
//	std::cout << "  Price " << static_cast<int>(itemPrice);
//	std::cout << "  Categoria " << static_cast<int>(itemType);
//	std::cout << "  TaxRate " << static_cast<int>(itemTax);
//	std::cout << "  SlotBank  " << static_cast<int>(slotBank) << "  \n  ";
//	std::cout << "  *******************  "  << "  \n  ";
//
//	// Verifica se o jogador está ativo e possui permissão para comprar
//	if (!player->CurrentScore.Hp || pUser[clientId].Mode != USER_PLAY)
//	{
//		SendClientMessage(clientId, "Você não está em um estado válido para realizar a compra.");
//		return;
//	}
//
//	// Verifica se o ID do dono da loja é válido
//	if (mobId <= 0 || mobId >= MAX_USER)
//	{
//		std::cout << "ID do dono da loja inválido.\n";
//		return;
//	}
//
//	// Verifica se o dono da loja está ativo
//	if (!pMob[mobId].MOB.CurrentScore.Hp || pUser[mobId].Mode != USER_PLAY)
//	{
//		std::cout << "O dono da loja não está ativo.\n" ;
//		return;
//	}
//
//
//	// Verifica se o dono da loja está comprando o proprio item
//	if (mobId == clientId)
//	{
//		std::cout << "O dono da loja comprando os proprios itens.\n";
//		return;
//	}
//
//
//	// Verifica a validade do slot e do item
//	if (itemSlot < 0 || itemSlot >= MAX_SLOT_LEILAO_AUTOTRADE)
//	{
//		std::cout << "Slot do item inválido.\n" ;
//		return;
//	}
//
//	INT32 verify = memcmp(&pUser[mobId].Cargo[slotBank], &newItem, 8);
//
//	if (verify != 0)
//	{
//		std::cout << "verify do item inválido.\n"  << slotBank;
//		return;
//	}
//
//	// Verifica se o slot contém um item e se as informações estão corretas
//	auto& itemList = pMob[mobId].AutoTrade.List[itemSlot];
//
//
//	std::cout << "\n  *******************  ";
//
//	std::cout << "  Item.sIndex " << static_cast<int>(pMob[mobId].AutoTrade.List[itemSlot].Item.sIndex);
//	std::cout << "\n  OwnerId recebida :: itemSlot " << itemSlot;
//	std::cout << "  mobId " << pMob[mobId].AutoTrade.List[itemSlot].OwnerId;
//	std::cout << "  Price " << static_cast<int>(pMob[mobId].AutoTrade.List[itemSlot].Price);
//	std::cout << "  Categoria " << static_cast<int>(pMob[mobId].AutoTrade.List[itemSlot].Categoria);
//	std::cout << "  TaxRate " << static_cast<int>(pMob[mobId].AutoTrade.List[itemSlot].TaxRate);
//	std::cout << "  SlotBank  " << static_cast<int>(pMob[mobId].AutoTrade.List[itemSlot].SlotBank) << "  \n  ";
//
//	std::cout << "  *******************  " << "  \n  ";
//
//	if (itemList.Item.sIndex == 0 || itemList.Categoria != itemType)
//	{
//		std::cout << "Item não encontrado ou categoria inválida.\n" ; 
//		return;
//	}
//
//	// Verifica se o preço e taxa correspondem
//	if (itemList.Price != itemPrice || itemList.TaxRate != itemTax)
//	{
//		std::cout << "Preço ou taxa do item não correspondem.\n" ;
//		return;
//	}
//
//	
//	/*Sistema de imposto se quiser usar*/
//	/*
//	
//	int imposto = 0;
//   	int PriceEnd = itemPrice;
//
//	if (itemType == 2)
//	{ 
//		if (itemPrice >= 100000)
//		{
//			imposto = (itemPrice / 100) * itemTax;
//			PriceEnd = itemPrice - imposto;
//		}
//	}
//	if(PriceEnd > 0)
//	{
//		itemPrice = PriceEnd;
//	}
//
//	*/
//
//	// Verifica se o item no banco corresponde
//	if (memcmp(&newItem, &itemList.Item, sizeof(STRUCT_ITEM)) != 0)
//	{
//		std::cout << "O item selecionado não corresponde ao item listado.\n";
//		return;
//	}
//
//	// Verifica se o jogador tem fundos suficientes
//	int playerFunds = 0;
//	if (itemType == 1) // Donate
//	{  
//		ProcessarBuyLeilaoStore(clientId, mobId, itemPrice);  
//	}
//	else if (itemType == 2) // Gold
//	{
//		if (player->Coin < itemPrice)
//		{
//			SendClientMessage(clientId, "Não há fundos suficientes de gold.");
//			return;
//		}
//	}
//	else if (itemType == 3) // Biss
//	{
//		// Verificar fundos de biss
//		int bissSlot = GetFirstSlot(clientId, 4011);
//		if (bissSlot == -1 || GetItemAmount(&pMob[clientId].MOB.Carry[bissSlot]) < itemPrice)
//		{
//			SendClientMessage(clientId, "Não há fundos suficientes de biss.");
//			return;
//		}
//	}
//
//	// Processar a compra 
//	// Exemplo de transferência e atualização de fundos:
//	int nullSlot = GetFirstSlot(clientId, 0);
//	if (nullSlot < 0 || nullSlot >= MAX_CARRY)
//	{
//		SendClientMessage(clientId, "Você não tem espaço suficiente para a compra.");
//		return;
//	}
//	 
//	STRUCT_ITEM* item = (STRUCT_ITEM*)&p->item;
//	 
//	memcpy(&player->Carry[nullSlot], item, 8);
//	SendItem(clientId, ITEM_PLACE_CARRY, nullSlot, &player->Carry[nullSlot]);
//
//
//	memset(&pMob[mobId].AutoTrade.List[itemSlot].Item, 0, 8);
//	pMob[mobId].AutoTrade.List[itemSlot].Price = 0;
//	pMob[mobId].AutoTrade.List[itemSlot].TaxRate = 0;
//	pMob[mobId].AutoTrade.List[itemSlot].Categoria = 0;
//	pMob[mobId].AutoTrade.List[itemSlot].OwnerId = 0;
//	pMob[mobId].AutoTrade.List[itemSlot].SlotBank = -1; // -1;
//
//	memset(&pUser[mobId].Cargo[slotBank], 0, 8);
//
//
//	SendItem(mobId, ITEM_PLACE_CARGO, slotBank, &pUser[mobId].Cargo[slotBank]);
//	 
//
//	// Atualizar saldo do jogador e do dono da loja
//	if (itemType == 1) // Donate
//	{
//		auto& pc = cSQL::instance(); 
//		int debitCash = playerFunds - itemPrice;
//		snprintf(xQuery, sizeof(xQuery), "UPDATE accounts SET donate = '%d' WHERE username = '%s'", debitCash, pUser[clientId].AccountName);
//		pc.wQuery(xQuery);
//		UpdateDonate(clientId);
//
//		snprintf(xQuery, sizeof(xQuery), "UPDATE accounts SET donate = '%d' WHERE username = '%s'", playerFunds + itemPrice, pUser[mobId].AccountName);
//		pc.wQuery(xQuery);
//		UpdateDonate(mobId);
//		 
//	}
//	else if (itemType == 2) // Gold
//	{
//		player->Coin -= itemPrice;
//		pUser[mobId].Coin += itemPrice; 
//	}
//	else if (itemType == 3) // Biss
//	{ 
//		AmountMinusPlus(&pMob[clientId].MOB.Carry[GetFirstSlot(clientId, 4011)], itemPrice);
//		SendItem(clientId, ITEM_PLACE_CARRY, GetFirstSlot(clientId, 4011), &pMob[clientId].MOB.Carry[GetFirstSlot(clientId, 4011)]);
//		for (int i = 0; i < MAX_CARGO; i++)
//		{
//			if (pUser[mobId].Cargo[i].sIndex == 0)
//			{
//				pUser[mobId].Cargo[i].sIndex = 4011;
//				pUser[mobId].Cargo[i].stEffect[0].cEffect = 61;
//				pUser[mobId].Cargo[i].stEffect[0].cValue = itemPrice;
//				SendItem(mobId, ITEM_PLACE_CARGO, i, &pUser[mobId].Cargo[i]);
//				break;
//			}
//		}
//	} 
//
//	UpdateLeilaoSaldo(mobId);
//	UpdateLeilaoSaldo(clientId);
//
//	char strtemp[128]{}; 
//	 
//	snprintf(strtemp, 128, "Comprou %s de %s($:%d)", g_pItemList[p->item.sIndex].Name, pMob[mobId].MOB.MobName, p->itemPrice);
//	SendClientMessage(clientId, strtemp);
//
//	snprintf(strtemp, 128, "Vendeu %s de %s($:%d) %d de impostos", g_pItemList[p->item.sIndex].Name, pMob[clientId].MOB.MobName, p->itemPrice, itemTax);
//	SendClientMessage(mobId, strtemp);
//	SaveUser(clientId, 0);
//	SaveUser(mobId, 0); 
//	SendLeilaoStoreMyInfos(clientId);
//	SendLeilaoStoreMyInfos(mobId);
//	return;
//}
//void ProcessarBuyLeilaoStore(int clientId, int mobId, int itemPrice)
//{
//	auto& pc = cSQL::instance();
//
//	// Variáveis para consulta e resultado
//	int donate = 0;
//	MYSQL_ROW row;
//	MYSQL* wSQL = pc.wStart();
//	MYSQL_RES* result = nullptr;
//	MYSQL_STMT* stmt = nullptr;
//	MYSQL_BIND bind[2];
//
//	// Consulta ao saldo atual usando prepared statements para evitar SQL injection
//	const char* query = "SELECT donate FROM accounts WHERE username = ?";
//
//	stmt = mysql_stmt_init(wSQL);
//	if (!stmt) {
//		fprintf(stderr, "mysql_stmt_init() failed\n");
//		return;
//	}
//
//	if (mysql_stmt_prepare(stmt, query, strlen(query))) {
//		fprintf(stderr, "mysql_stmt_prepare() failed: %s\n", mysql_stmt_error(stmt));
//		mysql_stmt_close(stmt);
//		return;
//	}
//
//	memset(bind, 0, sizeof(bind));
//
//	bind[0].buffer_type = MYSQL_TYPE_STRING;
//	bind[0].buffer = (char*)pUser[clientId].AccountName;
//	bind[0].buffer_length = strlen(pUser[clientId].AccountName);
//
//	if (mysql_stmt_bind_param(stmt, bind)) {
//		fprintf(stderr, "mysql_stmt_bind_param() failed: %s\n", mysql_stmt_error(stmt));
//		mysql_stmt_close(stmt);
//		return;
//	}
//
//	if (mysql_stmt_execute(stmt)) {
//		fprintf(stderr, "mysql_stmt_execute() failed: %s\n", mysql_stmt_error(stmt));
//		mysql_stmt_close(stmt);
//		return;
//	}
//
//	result = mysql_stmt_result_metadata(stmt);
//	if (!result) {
//		fprintf(stderr, "mysql_stmt_result_metadata() failed: %s\n", mysql_stmt_error(stmt));
//		mysql_stmt_close(stmt);
//		return;
//	}
//
//	MYSQL_BIND resultBind[1];
//	memset(resultBind, 0, sizeof(resultBind));
//	resultBind[0].buffer_type = MYSQL_TYPE_LONG;
//	resultBind[0].buffer = &donate;
//
//	if (mysql_stmt_bind_result(stmt, resultBind)) {
//		fprintf(stderr, "mysql_stmt_bind_result() failed: %s\n", mysql_stmt_error(stmt));
//		mysql_stmt_close(stmt);
//		return;
//	}
//
//	if (mysql_stmt_fetch(stmt) != 0 && mysql_stmt_fetch(stmt) != MYSQL_NO_DATA) {
//		fprintf(stderr, "mysql_stmt_fetch() failed: %s\n", mysql_stmt_error(stmt));
//		mysql_stmt_close(stmt);
//		return;
//	}
//
//	mysql_stmt_close(stmt);
//
//	int saldoAtual = donate + itemPrice;
//
//	// Atualizando o saldo no banco de dados
//	const char* updateQuery = "UPDATE accounts SET donate = ? WHERE username = ?";
//
//	stmt = mysql_stmt_init(wSQL);
//	if (!stmt) {
//		fprintf(stderr, "mysql_stmt_init() failed\n");
//		return;
//	}
//
//	if (mysql_stmt_prepare(stmt, updateQuery, strlen(updateQuery))) {
//		fprintf(stderr, "mysql_stmt_prepare() failed: %s\n", mysql_stmt_error(stmt));
//		mysql_stmt_close(stmt);
//		return;
//	}
//
//	memset(bind, 0, sizeof(bind));
//
//	bind[0].buffer_type = MYSQL_TYPE_LONG;
//	bind[0].buffer = &saldoAtual;
//
//	bind[1].buffer_type = MYSQL_TYPE_STRING;
//	bind[1].buffer = (char*)pUser[clientId].AccountName;
//	bind[1].buffer_length = strlen(pUser[clientId].AccountName);
//
//	if (mysql_stmt_bind_param(stmt, bind)) {
//		fprintf(stderr, "mysql_stmt_bind_param() failed: %s\n", mysql_stmt_error(stmt));
//		mysql_stmt_close(stmt);
//		return;
//	}
//
//	if (mysql_stmt_execute(stmt)) {
//		fprintf(stderr, "mysql_stmt_execute() failed: %s\n", mysql_stmt_error(stmt));
//		mysql_stmt_close(stmt);
//		return;
//	}
//
//	mysql_stmt_close(stmt);
//
//	// Atualizando o cliente no jogo
//	UpdateDonate(clientId);
//	SaveUser(clientId, 0);
//
//	// Debugging
//	printf("\nsaldoAtual %d Donate %d itemPrice %d", saldoAtual, donate, itemPrice);
//}




# -------------------- FiltroDrop.cpp --------------------

#pragma once

#include "ProcessClientMessage.h"
#include <iostream>
#include <cstdlib>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <random>
#include <ctime>
#include "SendFunc.h"
#include "Functions.h"

void FiltroDrop(int conn, int Index) {

	if (conn <= 0 || conn >= MAX_USER)
		return;

	if (pUser[conn].Mode != USER_PLAY)
		return;

	if (pUser[conn].cSock.Sock == 0)
		return;

	if (Index <= 0 || Index > MAX_ITEMLIST)
		return;

	if (pUser[conn].FiltroDelay != 0)
	{
		int isTime = GetTickCount64() - pUser[conn].FiltroDelay;

		if (isTime < 600)
			return;

	}
	pUser[conn].FiltroDelay = GetTickCount64();

	if (pMob[conn].FiltroState == 0) {
		SendClientMessage(conn, "Ative o filtro para adicionar itens");
		return;
	}

	if (pMob[conn].MOB.Equip[13].sIndex != 3901 && pMob[conn].MOB.Equip[13].sIndex != 3902) {
		SendClientMessage(conn, "Precisa de uma Fada Azul ou Vermelha para usar essa função!");
		return;
	}

	int Lista = Index - 5720;

	if (pMob[conn].FiltroID[Lista] == 1) {
		SendClientMessage(conn, strFmt("Categoria [%s] Desativada", g_pItemList[Index].Name));
		pMob[conn].FiltroID[Lista] = 0;
		return;
	}
	int x = 0;
	for (int i = 0; i < 50; i++) {
		if (pMob[conn].FiltroID[i] == 1)
			x++;

		if (x == 10) {
			SendClientMessage(conn, "Limite de categorias ativas é 10");
			return;
		}
	}
	pMob[conn].FiltroID[Lista] = 1;
	SendClientMessage(conn, strFmt("Categoria [%s] Ativada", g_pItemList[Index].Name));
	return;
}

# -------------------- Freeze.cpp --------------------

#pragma once

#include "ProcessClientMessage.h"
#include <iostream>
#include <cstdlib>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <random>
#include <ctime>
#include "SendFunc.h"
#include "Functions.h"
#include "wMySQL.h"

void Freeze() {

	for (int i = MAX_USER; i < MAX_MOB; i++)
	{
		if (pMob[i].Mode != MOB_EMPTY)
		{
			MSG_UpdateScore Update;
			memset(&Update, 0, sizeof(MSG_UpdateScore));
			GridMulticast(pMob[i].TargetX, pMob[i].TargetY, (MSG_STANDARD*)&Update, 0);
		}
		else {
			MSG_RemoveMob sm;
			memset(&sm, 0, sizeof(MSG_RemoveMob));

			sm.Type = _MSG_RemoveMob;
			sm.Size = sizeof(MSG_RemoveMob);
			sm.ID = i;
			sm.RemoveType = 0;

			GridMulticast(pMob[i].TargetX, pMob[i].TargetY, (MSG_STANDARD*)&sm, i);
		}
	}
}

# -------------------- Functions.h --------------------

#pragma once

#include <stdio.h>
#include "..\Basedef.h"

void UpdateDropList(int conn, const char* mobname, int region);
void FiltroDrop(int conn, int Index);
void ReqDropList(int conn, char* pMsg);
void ReqdListNames(int conn, char* pMsg);
void ReqTeleport(int conn, char* pMsg);
void ReqDonateShop(int conn, char* pMsg);
void EventoClick(int conn, int npc);
void Jephi(int conn, char* pMsg);
void ItemLevel(int conn, char* pMsg);
void TradeDonate(int conn, char* pMsg);
void UpdateShopDonate1();
void UpdateShopDonate2();
void UpdateShopDonate3();
void SendShopDonate(int conn);
void RequestAlias(int conn, char* pMsg);
void MailItem(int conn);
void SendMailItem(int conn);
void doRanking(int conn);
void sendRanking(int conn, int state);
void GerarPix(int conn);
void GerarRecaptcha();
void VerificarRecaptcha(int conn, int word);
void SendRecaptcha(int conn, int territorio);

void attMountTraje(int conn, char* pMsg);
void SetMountTraje(int conn, int slot);
void RemoveMountTraje(int conn);
bool MountTrajeBuy(int conn, int Index);
void RequestTraje(int conn);

int NumbGen(int Initial, int Final);
void LoadEvent();
void ReadServerConfigs();
void ReadExpTableN();
void ReadExpTableM();
//void ReadExpTableA();

int ControleDropGold(int conn, int target, int DropedGold);
STRUCT_ITEM* ControleDropItem(int conn, int target, int bonus, int PosX, int PosY, STRUCT_ITEM* Item);
void LanDrop(int conn, int target);
void CartaDrop(int conn, int target, int type);
bool AutoDrop(int conn, int itemId);
bool AgroupList(int conn, int itemId);
bool LogList(int itemId);
void Freeze();
void BlockAdd(STRUCT_ITEM* item, int Type, int min, int max);
bool DropItemControl(int sIndex);
void MacroNextSala(int conn, int Type, int Sala);

# -------------------- GeradorPix.cpp --------------------

#pragma once

#include "ProcessClientMessage.h"
#include <iostream>
#include <string>
#include <cstdlib>
#include <ctime>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <random>
#include <ctime>
#include "SendFunc.h"
#include "Functions.h"
#include "wMySQL.h"

using namespace std;

string gerar_senha() {
    const string caracteres = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
    const int TAMANHO_SENHA = 5;
    string senha;

    // Inicializa o gerador de números aleatórios
    //srand(time(nullptr));

    // Gera a senha com caracteres aleatórios
    for (int i = 0; i < TAMANHO_SENHA; i++) {
        int indice_aleatorio = rand() % caracteres.length();
        senha += caracteres[indice_aleatorio];
    }

    return senha;
}

void GerarPix(int conn) {

    if (conn < 0 || conn > MAX_USER)
        return;

    auto& pc = cSQL::instance();
    std::string Senha = gerar_senha();
    std::string Pix;

    sprintf(hQuery, "SELECT * FROM `accounts` WHERE `pix` = '%s'", Senha.c_str());
    MYSQL_ROW row;
    MYSQL* wSQL = pc.wStart();
    MYSQL_RES* result = pc.wRes(wSQL, hQuery);

    if (result == NULL)
        return;

    while ((row = mysql_fetch_row(result)) != NULL)
    {
        Pix = row[20];
    }

    if (Pix == "") {
        sprintf(xQuery, "UPDATE `accounts` SET pix = '%s' WHERE `username` = '%s' ", Senha.c_str(), pUser[conn].AccountName);
        pc.wQuery(xQuery);
    }
    else {
        SendClientMessage(conn, "Um erro ocorreu ao gerar sua chave pix");
        CloseUser(conn);
    }
}



# -------------------- GetFunc.cpp --------------------


#include <Windows.h>

#include "..\Basedef.h"
#include "..\ItemEffect.h"
#include "Language.h"

#include "Server.h"
#include "GetFunc.h"
#include "CMob.h"
#include "SendFunc.h"
#include "CCubo.h"

extern STRUCT_ITEMLIST g_pItemList[MAX_ITEMLIST];


int ReadAdminList(char* macAddress)
{
	FILE* arq = NULL;
	fopen_s(&arq, "../../Common/AdminList.txt", "r");

	if (!arq)
	{
		MessageBoxA(0, "Arquivo não encontrado", "../../Common/AdminList.txt", 0);
		ExitProcess(1);
	}

	char line[100];
	memset(&line, 0, 100);

	char mac[25];
	memset(&mac, 0, 25);

	while ((fscanf(arq, "%[^\n]", line)) != EOF)
	{
		fgetc(arq);
		sscanf(line, "%s", &mac);

		if (!strcmp(mac, macAddress))
		{
			fclose(arq);
			return 1;
		}
	}

	fclose(arq);
	return -1;
}

int GetMatchCombine(STRUCT_ITEM* item)
{
	int target = item[0].sIndex;

	for (int i = 0; i < MAX_COMBINE; i++)
	{
		if (item[i].sIndex == 747)
			return 0;
	}

	if (target <= 0 || target >= MAX_ITEMLIST)
		return 0;

	int	stone = item[1].sIndex;

	if (stone <= 0 || stone >= MAX_ITEMLIST)
		return 0;

	if (g_pItemList[target].nUnique < 41 || g_pItemList[target].nUnique > 49)
		return 0;

	if (g_pItemList[target].Extra <= 0)
		return 0;

	if (BASE_GetItemAbility(&item[0], EF_MOBTYPE) == 3)
		return 0;

	if ((item[1].sIndex >= 2441 && item[1].sIndex <= 2444) && item[1].stEffect[0].cEffect == 61 && item[1].stEffect[0].cValue > 1)
		return 0;

	int rate = 0;
	for (int j = 2; j < MAX_COMBINE; j++)
	{
		int idx = item[j].sIndex;

		if (idx <= 0 || idx >= MAX_ITEMLIST)
			continue;

		int eq = BASE_GetItemAbility(&item[j], EF_POS);

		if (eq == 0)
			return 0;

		int ItemGrade = g_pItemList[item[j].sIndex].Grade;
		int ItemLevel = BASE_GetItemAbility(&item[j], EF_ITEMLEVEL);

		if (ItemLevel == 5 && ItemGrade == 1) {
			ItemGrade = 3;
		}

		if (ItemGrade == 0) {
			ItemGrade = 3;
		}

		int il1 = BASE_GetItemAbility(&item[0], EF_ITEMLEVEL);
		int il2 = (BASE_GetItemAbility(&item[j], EF_ITEMLEVEL));

		if (il2 <= 3 || il1 <= 3)
			return 0;

		int	sa = BASE_GetItemSanc(&item[j]);

		if (ItemLevel == 4) {
			if (ItemGrade == 1)
			{
				if (sa == 7)
					rate = rate + 4;
				if (sa == 8)
					rate = rate + 5;
				if (sa == 9)
					rate = rate + 6;

				continue;
			}
			if (ItemGrade == 2)
			{
				if (sa == 7)
					rate = rate + 5;
				if (sa == 8)
					rate = rate + 6;
				if (sa == 9)
					rate = rate + 7;

				continue;
			}
			if (ItemGrade == 3)
			{
				if (sa == 7)
					rate = rate + 6;
				if (sa == 8)
					rate = rate + 7;
				if (sa == 9)
					rate = rate + 8;

				continue;
			}
			if (ItemGrade == 4)
			{
				if (sa == 7)
					rate = rate + 8;
				if (sa == 8)
					rate = rate + 9;
				if (sa == 9)
					rate = rate + 10;

				continue;
			}
		}
		if (ItemLevel == 5) {
			if (ItemGrade == 1)
			{
				if (sa == 7)
					rate = rate + 6;
				if (sa == 8)
					rate = rate + 7;
				if (sa == 9)
					rate = rate + 8;

				continue;
			}
			if (ItemGrade == 2)
			{
				if (sa == 7)
					rate = rate + 7;
				if (sa == 8)
					rate = rate + 8;
				if (sa == 9)
					rate = rate + 9;

				continue;
			}
			if (ItemGrade == 3)
			{
				if (sa == 7)
					rate = rate + 8;
				if (sa == 8)
					rate = rate + 9;
				if (sa == 9)
					rate = rate + 10;

				continue;
			}
			if (ItemGrade == 4)
			{
				if (sa == 7)
					rate = rate + 10;
				if (sa == 8)
					rate = rate + 11;
				if (sa == 9)
					rate = rate + 12;

				continue;
			}
		}

		return 0;
	}

	return rate;
}

int GetMatchCombineDedekinto(STRUCT_ITEM* Item)
{
	int rate = 0;

	for (int i = 0; i < MAX_COMBINE; i++)
	{
		if (Item[i].sIndex == 747)
			return 0;
	}

	if (Item[0].sIndex < 0 || Item[0].sIndex >= MAX_ITEMLIST)
		return 0;

	if (Item[1].sIndex < 0 || Item[1].sIndex >= MAX_ITEMLIST)
		return 0;

	if (Item[2].sIndex < 0 || Item[2].sIndex >= MAX_ITEMLIST)
		return 0;

	if (Item[3].sIndex < 0 || Item[3].sIndex >= MAX_ITEMLIST)
		return 0;

	if (Item[4].sIndex < 0 || Item[4].sIndex >= MAX_ITEMLIST)
		return 0;

	if (Item[5].sIndex < 0 || Item[5].sIndex >= MAX_ITEMLIST)
		return 0;

	if (Item[6].sIndex < 0 || Item[6].sIndex >= MAX_ITEMLIST)
		return 0;

	if (Item[7].sIndex < 0 || Item[7].sIndex >= MAX_ITEMLIST)
		return 0;

	if (Item[0].sIndex == 673 && Item[1].sIndex == 674 && Item[2].sIndex == 675 && Item[3].sIndex == 676 && Item[4].sIndex == 677 && Item[5].sIndex == 770)
		rate = 1; //Criação de Pedra Amunra

	else if (Item[0].sIndex == 677 && Item[1].sIndex == 677 && Item[2].sIndex == 678 && Item[3].sIndex == 678)
		rate = 2; //Proteção Divina



	return rate;
}

int GetMatchCombineEhre(STRUCT_ITEM* Item)
{
	int rate = 0;

	for (int i = 0; i < MAX_COMBINE; i++)
	{
		if (Item[i].sIndex == 747)
			return 0;
	}

	if (Item[0].sIndex < 0 || Item[0].sIndex >= MAX_ITEMLIST)
		return 0;

	if (Item[1].sIndex < 0 || Item[1].sIndex >= MAX_ITEMLIST)
		return 0;

	if (Item[2].sIndex < 0 || Item[2].sIndex >= MAX_ITEMLIST)
		return 0;

	if (Item[3].sIndex < 0 || Item[3].sIndex >= MAX_ITEMLIST)
		return 0;

	if (Item[4].sIndex < 0 || Item[4].sIndex >= MAX_ITEMLIST)
		return 0;

	if (Item[5].sIndex < 0 || Item[5].sIndex >= MAX_ITEMLIST)
		return 0;

	if (Item[6].sIndex < 0 || Item[6].sIndex >= MAX_ITEMLIST)
		return 0;

	if (Item[7].sIndex < 0 || Item[7].sIndex >= MAX_ITEMLIST)
		return 0;

	if (Item[0].sIndex == 697 && Item[1].sIndex == 697 && BASE_GetItemSanc(&Item[2]) >= 9 && Item[2].sIndex != 3338)
		rate = 1;//Pacote Oriharucon

	else if (Item[0].sIndex >= 5110 && Item[0].sIndex <= 5133 && Item[1].sIndex >= 5110 && Item[1].sIndex <= 5133 && Item[2].sIndex == 413 && BASE_GetItemAmount(&Item[2]) >= 10)
		rate = 2;//Pedra Misteriosa

	else if (Item[0].sIndex >= 661 && Item[0].sIndex <= 663 && Item[1].sIndex >= 661 && Item[1].sIndex <= 663 && Item[2].sIndex == 633 && BASE_GetItemSanc(&Item[2]) >= 9)
		rate = 3;//Pedra espiritual

	else if (Item[0].sIndex >= 661 && Item[0].sIndex <= 663 && Item[1].sIndex >= 661 && Item[1].sIndex <= 663 && Item[2].sIndex == 3464 && BASE_GetItemSanc(&Item[2]) >= 9)
		rate = 4;//Pedra Amunrá

	else if (Item[0].sIndex == 697 && Item[1].sIndex == 697 && Item[2].sIndex == 3338 && BASE_GetItemSanc(&Item[2]) <= 8)
		rate = 5;//Refinação abençoada Purificada

	else if (Item[0].sIndex >= 2360 && Item[0].sIndex <= 2389 && Item[1].sIndex >= 4190 && Item[1].sIndex <= 4199)
		rate = 6;//Traje montaria

	else if (Item[0].sIndex >= 2360 && Item[0].sIndex <= 2389 && Item[1].sIndex == 4899)
		rate = 7;//Restaurar Traje montaria

	else if (Item[0].sIndex >= 2441 && Item[0].sIndex <= 2444 && Item[1].sIndex >= 2441 && Item[1].sIndex <= 2444 && Item[2].sIndex >= 2441 && Item[2].sIndex <= 2444)
		rate = 8;//Soul

	else if (Item[0].sIndex == 5643 && Item[1].sIndex == 5643 && Item[2].sIndex == 5643 && Item[3].sIndex == 5643)
		rate = 9; //brinco

	else if (Item[0].sIndex == 5643 && Item[1].sIndex == 5643 && Item[2].sIndex == 5643 && Item[3].sIndex == 5643)
		rate = 10; //brinco

	else if (Item[0].sIndex == 5643 && Item[1].sIndex == 5643 && Item[2].sIndex == 5643 && Item[3].sIndex == 5643)
		rate = 11; //brinco

	else if (Item[0].sIndex == 5643 && Item[1].sIndex == 5643 && Item[2].sIndex == 5643 && Item[3].sIndex == 5643)
		rate = 12; //brinco

	else if (Item[0].sIndex == 5643 && Item[1].sIndex == 5643 && Item[2].sIndex == 5643 && Item[3].sIndex == 5643 && Item[4].sIndex == 5643 && Item[5].sIndex == 5643 && Item[6].sIndex == 5643 && Item[7].sIndex == 5643)
		rate = 13; //brinco

	return rate;
}

int GetMatchCombineTiny(STRUCT_ITEM* Item)
{
	for (int i = 0; i < MAX_COMBINE; i++)
	{
		if (Item[i].sIndex == 747)
			return 0;
	}

	if (Item[0].sIndex <= 0 || Item[0].sIndex >= MAX_ITEMLIST)
		return 0;

	if (Item[1].sIndex <= 0 || Item[1].sIndex >= MAX_ITEMLIST)
		return 0;

	if (Item[2].sIndex <= 0 || Item[2].sIndex >= MAX_ITEMLIST)
		return 0;

	if (BASE_GetItemAbility(&Item[0], EF_MOBTYPE) != ARCH)
		return 0;

	if (g_pItemList[Item[0].sIndex].Grade < 5 || g_pItemList[Item[0].sIndex].Grade > 8)
		return 0;

	//if (BASE_GetItemAbility(&Item[1], EF_ITEMTYPE) == 1)
	//	return 0;

	// block armas C
	if (Item[1].sIndex >= 2511 && Item[1].sIndex <= 2542
		|| Item[1].sIndex >= 2571 && Item[1].sIndex <= 2602
		|| Item[1].sIndex >= 2811 && Item[1].sIndex <= 2842
		|| Item[1].sIndex >= 2851 && Item[1].sIndex <= 2854
		|| Item[1].sIndex >= 2631 && Item[1].sIndex <= 2662
		|| Item[1].sIndex >= 2691 && Item[1].sIndex <= 2722
		|| Item[1].sIndex >= 2871 && Item[1].sIndex <= 2886
		|| Item[1].sIndex >= 2471 && Item[1].sIndex <= 2482
		|| Item[1].sIndex >= 2911 && Item[1].sIndex <= 2926
		|| Item[1].sIndex >= 2751 && Item[1].sIndex <= 2782)
		return 0;

	if (g_pItemList[Item[1].sIndex].Grade < 5 || g_pItemList[Item[1].sIndex].Grade > 8)
		return 0;

	if (BASE_GetItemAbility(&Item[2], EF_ITEMTYPE) == 1)
		return 0;

	if (g_pItemList[Item[0].sIndex].nPos != g_pItemList[Item[1].sIndex].nPos)
		return 0;

	if (g_pItemList[Item[0].sIndex].nPos != 64 && g_pItemList[Item[0].sIndex].nPos != 192)
		return 0;

	if (BASE_GetItemSanc(&Item[0]) < 9)
		return 0;

	if (BASE_GetItemSanc(&Item[1]) > 237)
		return 0;

	if (BASE_GetItemSanc(&Item[2]) < 9)
		return 0;

	return g_pTinyBase + (BASE_GetItemAbility(&Item[1], EF_ITEMLEVEL) * 5);
}

int GetMatchNovoCompositor(STRUCT_ITEM* Item)
{
	for (int i = 0; i < MAX_COMBINE; i++)
	{
		if (Item[i].sIndex == 747)
			return 0;
	}

	if (Item[0].sIndex < 0 || Item[0].sIndex >= MAX_ITEMLIST)
		return 0;

	if (Item[1].sIndex < 0 || Item[1].sIndex >= MAX_ITEMLIST)
		return 0;

	if (Item[2].sIndex < 0 || Item[2].sIndex >= MAX_ITEMLIST)
		return 0;

	if (Item[3].sIndex < 0 || Item[3].sIndex >= MAX_ITEMLIST)
		return 0;

	if (Item[4].sIndex < 0 || Item[4].sIndex >= MAX_ITEMLIST)
		return 0;

	if (Item[5].sIndex < 0 || Item[5].sIndex >= MAX_ITEMLIST)
		return 0;

	if (Item[6].sIndex < 0 || Item[6].sIndex >= MAX_ITEMLIST)
		return 0;

	int rate = 0;

	for (int i = 0; i < 3; i++) {
		if (Item[0].stEffect[i].cEffect == 69) {
			if (Item[2].sIndex != 662 || Item[3].sIndex != 662 || Item[4].sIndex != 662 || Item[5].sIndex != 662)
				return 0;
		}
		if (Item[0].stEffect[i].cEffect == 70) {
			if (Item[2].sIndex != 661 || Item[3].sIndex != 661 || Item[4].sIndex != 661 || Item[5].sIndex != 661)
				return 0;
		}
	}

	if (Item[2].sIndex != Item[3].sIndex ||
		Item[2].sIndex != Item[4].sIndex ||
		Item[2].sIndex != Item[5].sIndex ||
		Item[3].sIndex != Item[4].sIndex ||
		Item[3].sIndex != Item[5].sIndex ||
		Item[4].sIndex != Item[5].sIndex)
		return 0;

	if (((Item[0].sIndex >= 591 && Item[0].sIndex <= 595) && BASE_GetItemSanc(&Item[0]) >= 9) && Item[1].sIndex == 5718 &&
		((Item[2].sIndex == 661 || Item[2].sIndex == 662) && BASE_GetItemSanc(&Item[0]) >= 9) &&
		((Item[3].sIndex == 661 || Item[3].sIndex == 662) && BASE_GetItemSanc(&Item[0]) >= 9) &&
		((Item[4].sIndex == 661 || Item[4].sIndex == 662) && BASE_GetItemSanc(&Item[0]) >= 9) &&
		((Item[5].sIndex == 661 || Item[5].sIndex == 662) && BASE_GetItemSanc(&Item[0]) >= 9))
		rate = 1;

	return rate;
}

int GetMatchCombineShany(STRUCT_ITEM* Item)
{
	int rate = 0;
	for (int i = 0; i < MAX_COMBINE; i++)
	{
		if (Item[i].sIndex == 747)
			return 0;
	}

	if (Item[0].sIndex <= 0 || Item[0].sIndex >= MAX_ITEMLIST)
		return 0;

	if (Item[1].sIndex <= 0 || Item[1].sIndex >= MAX_ITEMLIST)
		return 0;

	if (Item[2].sIndex <= 0 || Item[2].sIndex >= MAX_ITEMLIST)
		return 0;

	if (Item[3].sIndex <= 0 || Item[3].sIndex >= MAX_ITEMLIST)
		return 0;

	if (Item[4].sIndex <= 0 || Item[4].sIndex >= MAX_ITEMLIST)
		return 0;

	if (Item[5].sIndex <= 0 || Item[5].sIndex >= MAX_ITEMLIST)
		return 0;

	if (Item[6].sIndex <= 0 || Item[6].sIndex >= MAX_ITEMLIST)
		return 0;

	if (Item[0].sIndex != 540 && Item[0].sIndex != 541 || BASE_GetItemSanc(&Item[0]) < 9)
		return 0;

	if (Item[1].sIndex != 540 && Item[1].sIndex != 541 || BASE_GetItemSanc(&Item[1]) < 9)
		return 0;

	if (Item[2].sIndex != 540 && Item[2].sIndex != 541 && Item[2].sIndex != 633)
		return 0;

	if (Item[3].sIndex != 413 || Item[4].sIndex != 413 || Item[5].sIndex != 413 || Item[6].sIndex != 413)
		return 0;

	return 1;
}

int GetMatchCombineAilyn(STRUCT_ITEM* Item)
{
	for (int i = 0; i < MAX_COMBINE; i++)
	{
		if (Item[i].sIndex == 747)
			return 0;

		if ((Item[i].sIndex >= 2441 && Item[i].sIndex <= 2444) && Item[i].stEffect[0].cEffect == 61 && Item[i].stEffect[0].cValue > 1)
			return 0;
	}

	if (Item[0].sIndex <= 0 || Item[0].sIndex >= MAX_ITEMLIST)
		return 0;

	if (Item[1].sIndex <= 0 || Item[1].sIndex >= MAX_ITEMLIST)
		return 0;

	if (Item[2].sIndex <= 0 || Item[2].sIndex >= MAX_ITEMLIST)
		return 0;

	if (Item[3].sIndex <= 0 || Item[3].sIndex >= MAX_ITEMLIST)
		return 0;

	if (Item[4].sIndex <= 0 || Item[4].sIndex >= MAX_ITEMLIST)
		return 0;

	if (Item[5].sIndex <= 0 || Item[5].sIndex >= MAX_ITEMLIST)
		return 0;

	if (Item[6].sIndex <= 0 || Item[6].sIndex >= MAX_ITEMLIST)
		return 0;

	if (Item[0].sIndex != Item[1].sIndex)
		return 0;

	if (g_pItemList[Item[0].sIndex].Grade != g_pItemList[Item[1].sIndex].Grade)
		return 0;

	if (Item[2].sIndex != 1774)
		return 0;

	if (Item[2].sIndex == 1774 && Item[2].stEffect[0].cEffect == 61 && Item[2].stEffect[0].cValue > 1)
		return 77;
	int rate = 1;
		
	if ((g_pItemList[Item[0].sIndex].nPos != 2 && g_pItemList[Item[0].sIndex].nPos != 4 && g_pItemList[Item[0].sIndex].nPos != 8 && g_pItemList[Item[0].sIndex].nPos != 16 && g_pItemList[Item[0].sIndex].nPos != 32 && g_pItemList[Item[0].sIndex].nPos != 64 && g_pItemList[Item[0].sIndex].nPos != 192 && g_pItemList[Item[0].sIndex].nPos != 128))
		return 0;


	for (int i = 3; i < 7; i++)
	{
		if (Item[i].sIndex == 0)
			continue;

		if (Item[3].sIndex != Item[i].sIndex)
			return 0;

		rate += g_pAilynBase;
	}

	return rate;
}

int GetMatchCombineAgatha(STRUCT_ITEM* Item)
{
	if (Item[0].sIndex <= 0 || Item[0].sIndex >= MAX_ITEMLIST)
		return 0;

	if (Item[1].sIndex <= 0 || Item[1].sIndex >= MAX_ITEMLIST)
		return 0;

	if (Item[2].sIndex <= 0 || Item[2].sIndex >= MAX_ITEMLIST)
		return 0;

	if (Item[3].sIndex <= 0 || Item[3].sIndex >= MAX_ITEMLIST)
		return 0;

	if (Item[4].sIndex <= 0 || Item[4].sIndex >= MAX_ITEMLIST)
		return 0;

	if (Item[5].sIndex <= 0 || Item[5].sIndex >= MAX_ITEMLIST)
		return 0;

	int ItemArchPos = g_pItemList[Item[0].sIndex].nPos;
	int ItemMortalPos = g_pItemList[Item[1].sIndex].nPos;

	if (ItemArchPos < 2 || ItemArchPos > 32)
		return 0;

	if (ItemMortalPos < 2 || ItemMortalPos > 32)
		return 0;

	if (BASE_GetItemAbility(&Item[0], EF_MOBTYPE) != ARCH)
		return 0;

	if (BASE_GetItemAbility(&Item[1], EF_ITEMTYPE) != MORTAL && BASE_GetItemAbility(&Item[1], EF_ITEMTYPE) != 0)
		return 0;

	if (BASE_GetItemAbility(&Item[1], EF_ITEMLEVEL) < 4)
		return 0;

	if (g_pItemList[Item[0].sIndex].nPos != g_pItemList[Item[1].sIndex].nPos)
		return 0;

	if (BASE_GetItemSanc(&Item[0]) < 9)
		return 0;

	if (BASE_GetItemSanc(&Item[1]) < 9)
		return 0;

	if (Item[2].sIndex != 3140 || Item[3].sIndex != 3140 || Item[4].sIndex != 3140 || Item[5].sIndex != 3140)
		return 0;

	if (Item[2].sIndex == 3140 && Item[2].stEffect[0].cEffect == 61 && Item[2].stEffect[0].cValue > 1
		|| Item[3].sIndex == 3140 && Item[3].stEffect[0].cEffect == 61 && Item[3].stEffect[0].cValue > 1
		|| Item[4].sIndex == 3140 && Item[4].stEffect[0].cEffect == 61 && Item[4].stEffect[0].cValue > 1
		|| Item[5].sIndex == 3140 && Item[5].stEffect[0].cEffect == 61 && Item[5].stEffect[0].cValue > 1)
		return 77;

	int ItemGrade = g_pItemList[Item[1].sIndex].Grade;
	int ItemLevel = BASE_GetItemAbility(&Item[1], EF_ITEMLEVEL);

	if (ItemLevel == 5 && ItemGrade == 1) {
		ItemGrade = 3;
	}

	return g_pAgathaBase + (ItemGrade * 5) + (ItemLevel == 5 ? 6 : 1);
}

int GetMatchCombineEvent(STRUCT_ITEM* Item)
{
	for (int i = 0; i < MAX_COMBINE; i++)
	{
		if (Item[i].sIndex == 747)
			return 0;
	}

	if (Item[0].sIndex == 480 && Item[1].sIndex == 480 && Item[2].sIndex == 4052)
		return 1;

	if (Item[0].sIndex == 480 && Item[1].sIndex == 480 && Item[2].sIndex == 4054)
		return 2;

	if (Item[0].sIndex == 480 && Item[1].sIndex == 480 && Item[2].sIndex == 480 && Item[3].sIndex == 0)
		return 3;

	if (Item[0].sIndex == 480 && Item[1].sIndex == 480 && Item[2].sIndex == 4051)
		return 4;

	if (Item[0].sIndex == 4052 && Item[1].sIndex == 4051)
		return 5;

	if (Item[0].sIndex == 480 && Item[1].sIndex == 480 && Item[2].sIndex == 480 && Item[3].sIndex == 4053 && (Item[4].sIndex >= 762 && Item[4].sIndex <= 768 && BASE_GetItemSanc(&Item[4]) == 9))
		return 6;

	if (Item[0].sIndex == 480 && Item[1].sIndex == 480 && Item[2].sIndex == 480 && Item[3].sIndex == 4055 && (Item[4].sIndex >= 762 && Item[4].sIndex <= 768 && BASE_GetItemSanc(&Item[4]) == 9))
		return 7;

	if (Item[0].sIndex == 480 && Item[1].sIndex == 480 && Item[2].sIndex == 480 && Item[3].sIndex == 4055)
		return 8;

	return 0;
}

int GetMatchCombineOdin(STRUCT_ITEM* Item)
{
	for (int i = 0; i < MAX_COMBINE; i++)
	{
		if (Item[i].sIndex == 747)
			return 0;
	}

	if (Item[0].sIndex < 0 || Item[0].sIndex >= MAX_ITEMLIST)
		return 0;

	if (Item[1].sIndex < 0 || Item[1].sIndex >= MAX_ITEMLIST)
		return 0;

	if (Item[2].sIndex < 0 || Item[2].sIndex >= MAX_ITEMLIST)
		return 0;

	if (Item[3].sIndex < 0 || Item[3].sIndex >= MAX_ITEMLIST)
		return 0;

	if (Item[4].sIndex < 0 || Item[4].sIndex >= MAX_ITEMLIST)
		return 0;

	if (Item[5].sIndex < 0 || Item[5].sIndex >= MAX_ITEMLIST)
		return 0;

	if (Item[6].sIndex < 0 || Item[6].sIndex >= MAX_ITEMLIST)
		return 0;

	if (Item[7].sIndex < 0 || Item[7].sIndex >= MAX_ITEMLIST)
		return 0;

	if (Item[0].sIndex == g_pItemList[Item[1].sIndex].Extra && BASE_GetItemSanc(&Item[0]) >= 9 && BASE_GetItemSanc(&Item[1]) == REF_15
		&& (Item[2].sIndex == 542 || Item[2].sIndex == 772) && Item[3].sIndex == 5334 && Item[4].sIndex == 5335 && Item[5].sIndex == 5336 && Item[6].sIndex == 5337)
		return 1;//Item celestial

	else if ((Item[0].sIndex == 413 && BASE_GetItemAmount(&Item[0]) >= 10 && Item[1].sIndex == 413 && BASE_GetItemAmount(&Item[1]) >= 10 || Item[0].sIndex == 4043 && Item[1].sIndex == 4043)
		&& BASE_GetItemSanc(&Item[2]) > REF_10 && BASE_GetItemSanc(&Item[2]) <= REF_15 && (Item[3].sIndex >= 5334 && Item[3].sIndex <= 5337 || Item[3].sIndex == 3338) && (Item[4].sIndex >= 5334 && Item[4].sIndex <= 5337 || Item[4].sIndex == 3338)
		&& (Item[5].sIndex >= 5334 && Item[5].sIndex <= 5337 || Item[5].sIndex == 3338) && (Item[6].sIndex >= 5334 && Item[6].sIndex <= 5337 || Item[6].sIndex == 3338) && (g_pItemList[Item[2].sIndex].nPos == 2 || g_pItemList[Item[2].sIndex].nPos == 4 || g_pItemList[Item[2].sIndex].nPos == 8 || g_pItemList[Item[2].sIndex].nPos == 16 || g_pItemList[Item[2].sIndex].nPos == 32 || g_pItemList[Item[2].sIndex].nPos == 64 || g_pItemList[Item[2].sIndex].nPos == 192 || g_pItemList[Item[2].sIndex].nPos == 128))
		return 2;//Ref+12+

	else if (Item[0].sIndex == 413 && Item[1].sIndex == 413 && Item[2].sIndex == 413 && Item[3].sIndex == 413 && Item[4].sIndex == 413 && Item[5].sIndex == 413 && Item[6].sIndex == 413)
		return 3;//Pista de runas

	else if (Item[0].sIndex == 4127 && Item[1].sIndex == 4127 && Item[2].sIndex == 5135 && Item[3].sIndex == 5113 && Item[4].sIndex == 5129 && Item[5].sIndex == 5112 && Item[6].sIndex == 5110)
		return 4;//Level40 Celestial

	else if (Item[0].sIndex == 5125 && Item[1].sIndex == 5115 && Item[2].sIndex == 5111 && Item[3].sIndex == 5112 && Item[4].sIndex == 5120 && Item[5].sIndex == 5128 && Item[6].sIndex == 5119)
		return 5;//Pedra da fúria

	else if (Item[0].sIndex == 5126 && Item[1].sIndex == 5127 && Item[2].sIndex == 5121 && Item[3].sIndex == 5114 && Item[4].sIndex == 5125 && Item[5].sIndex == 5111 && Item[6].sIndex == 5118)
		return 6;//Secreta da Agua

	else if (Item[0].sIndex == 5131 && Item[1].sIndex == 5113 && Item[2].sIndex == 5115 && Item[3].sIndex == 5116 && Item[4].sIndex == 5125 && Item[5].sIndex == 5112 && Item[6].sIndex == 5114)
		return 7;//Secreta da Terra

	else if (Item[0].sIndex == 5110 && Item[1].sIndex == 5124 && Item[2].sIndex == 5117 && Item[3].sIndex == 5129 && Item[4].sIndex == 5114 && Item[5].sIndex == 5125 && Item[6].sIndex == 5128)
		return 8;//Secreta do Sol

	else if (Item[0].sIndex == 5122 && Item[1].sIndex == 5119 && Item[2].sIndex == 5132 && Item[3].sIndex == 5120 && Item[4].sIndex == 5130 && Item[5].sIndex == 5133 && Item[6].sIndex == 5123)
		return 9;//Secreta do Vento

	else if (Item[0].sIndex == 421 && Item[1].sIndex == 422 && Item[2].sIndex == 423 && Item[3].sIndex == 424 && Item[4].sIndex == 425 && Item[5].sIndex == 426 && Item[6].sIndex == 427)
		return 10;//Semente de cristal

	else if (Item[0].sIndex == 4127 && Item[1].sIndex == 4127 && Item[2].sIndex == 5135 && Item[3].sIndex == 413 && Item[4].sIndex == 413 && Item[5].sIndex == 413 && Item[6].sIndex == 413)
		return 11;//Capa

	return 0;
}

int GetMatchCombineAlquimia(STRUCT_ITEM* Item)
{
	for (int i = 0; i < MAX_COMBINE; i++)
	{
		if (Item[i].sIndex == 747)
			return 0;

		if (Item[i].stEffect[0].cEffect == 61 && Item[i].stEffect[0].cValue > 1)
			return 0;

	}
	if (Item[0].sIndex < 0 || Item[0].sIndex >= MAX_ITEMLIST)
		return -1;

	if (Item[1].sIndex < 0 || Item[1].sIndex >= MAX_ITEMLIST)
		return -1;

	if (Item[2].sIndex < 0 || Item[2].sIndex >= MAX_ITEMLIST)
		return -1;

	if (Item[3].sIndex < 0 || Item[3].sIndex >= MAX_ITEMLIST)
		return -1;

	if (Item[4].sIndex < 0 || Item[4].sIndex >= MAX_ITEMLIST)
		return -1;

	if (Item[5].sIndex < 0 || Item[5].sIndex >= MAX_ITEMLIST)
		return -1;

	if (Item[6].sIndex < 0 || Item[6].sIndex >= MAX_ITEMLIST)
		return -1;

	if (Item[7].sIndex < 0 || Item[7].sIndex >= MAX_ITEMLIST)
		return -1;

	if (Item[0].sIndex == 413 && Item[1].sIndex == 2441 && Item[2].sIndex == 2442)
		return 0;//Sagacidade

	if (Item[0].sIndex == 413 && Item[1].sIndex == 2443 && Item[2].sIndex == 2442)
		return 1;//Resistencia

	if (Item[0].sIndex == 4127 && Item[1].sIndex == 4127 && Item[2].sIndex == 4127)
		return 2;//Revelação

	if (Item[0].sIndex == 4127 && Item[1].sIndex == 4127 && Item[2].sIndex == 697)
		return 3;//Recuperação

	if (Item[0].sIndex == 412 && Item[1].sIndex == 2441 && Item[2].sIndex == 2444)
		return 4;//Absorção

	if (Item[0].sIndex == 412 && Item[1].sIndex == 2444 && Item[2].sIndex == 2443)
		return 5;//Proteção	

	if (Item[0].sIndex == 612 && BASE_GetItemSanc(&Item[0]) >= 9 && Item[1].sIndex == 2441 && Item[2].sIndex == 2442)
		return 6;//Poder

	if (Item[0].sIndex == 612 && Item[1].sIndex == 613 && Item[2].sIndex == 614 && Item[3].sIndex == 615)
		return 7;//Armazenagem

	if (Item[0].sIndex == 614 && BASE_GetItemSanc(&Item[0]) >= 9 && Item[1].sIndex == 2443 && Item[2].sIndex == 2444)
		return 8;//Precisão

	if (Item[0].sIndex == 615 && BASE_GetItemSanc(&Item[0]) >= 9 && Item[1].sIndex == 697 && Item[2].sIndex == 697 && Item[3].sIndex == 697)
		return 9;//Magia

	return -1;
}

int GetParryRate(STRUCT_MOB* conn, int attackerdex, int attackerrsv, int attackerparry, int defensordex, int defensorrsv, int defensorparry) // Parry que realmente usa no PVP
{
	int ParryChance = 0, Parry1 = 0, Parry2 = 0, PD = 0, PDFM = 0, ParryFM1 = 0, ParryFM2 = 0;

	if (defensordex >= 5000)
		defensordex = 5000;

	if (attackerdex >= 5000)
		attackerdex = 5000;

	//Destrezas iguais
	if (attackerdex == defensordex || defensordex == attackerdex)
	{
		Parry1 = (attackerdex - defensordex);
		Parry2 = (attackerdex - defensordex);
	}
	else
	{
		//Destreza do attacker e maior do que o do defensor
		if (attackerdex > defensordex) // 10000 x 10 // 5000 x 4000 // 15000 x 4000 // 2000 x 2000
		{
			if (defensordex <= 0)
				defensordex = 1;

			if (attackerdex <= 0)
				attackerdex = 1;

			PD = (attackerdex - defensordex) / 10; // 999 // 100 // 1100 // 

			if (PD <= 0)
				PD = 1; // 999 // 100 // 1100 // 1

			Parry1 = (PD / 100); // 9.99 // 10 // 11 // 1

			if (Parry1 <= 0)
				Parry1 = 1;

			if (defensordex <= 0)
				defensordex = 1;
			// 18
			Parry2 = (PD * 100) / attackerdex;  // 9.99 // 20 // 7,3 // 
			// soma = 19.98 // 30 // 18.3

			if (Parry2 <= 0)
				Parry2 = 1;
		}
		else
		{
			if (attackerdex + 600 > defensordex)
			{
				if (defensordex <= 0)
					defensordex = 1;

				if (attackerdex <= 0)
					attackerdex = 1;

				PD = (attackerdex - defensordex) / 10; // 999 // 100 // 1100 // 

				if (PD <= 0)
					PD = 1; // 999 // 100 // 1100 // 1

				Parry1 = (PD / 100); // 9.99 // 10 // 11 // 1

				if (Parry1 <= 0)
					Parry1 = 1;

				if (defensordex <= 0)
					defensordex = 1;
				// 18
				Parry2 = (PD * 100) / attackerdex;  // 9.99 // 20 // 7,3 // 
				// soma = 19.98 // 30 // 18.3

				if (Parry2 <= 0)
					Parry2 = 1;
			}
			else {
				if (defensordex <= 0) // defensor = 5000 / atk = 1000 
					defensordex = 1;

				if (attackerdex <= 0)
					attackerdex = 1;

				PD = (defensordex - attackerdex); // 4000

				if (PD <= 0)
					PD = 1; // 1

				Parry1 = (PD * 10) / 200; // 200 

				if (Parry1 <= 0)
					Parry1 = 0;

				Parry2 = (140 * defensordex) / attackerdex; // 

				if (Parry2 <= 0)
					Parry2 = 0;
			}
		}
	}

	ParryChance = (Parry1 + Parry2);

	if (attackerrsv & 0x20)
		ParryChance += 50;

	if (attackerrsv & 0x200) //Skill da ht Ligação espectral
		ParryChance -= 20;

	if (defensorrsv & 0x20)
		ParryChance -= 50;

	if (defensorrsv & 0x40)
		ParryChance -= 15;

	if (ParryChance <= 0)
		ParryChance = 1;

	if (ParryChance >= 657)
		ParryChance = 657;

	//SendNotice(strFmt("Chance atual [%d]", ParryChance));  //balanceio de pvp

	return ParryChance;
}

// Original 7556 descompilado
int CGetParryRate(int attackerdex, int attackerrsv, int attackerparry, int defensordex, int defensorrsv, int defensorparry)
{
	int ParryChance = 0, Parry1 = 0, Parry2 = 0, PD = 0, PDFM = 0, ParryFM1 = 0, ParryFM2 = 0;

	//Destrezas iguais
	if (attackerdex == defensordex || defensordex == attackerdex)
	{
		Parry1 = (attackerdex - defensordex);
		Parry2 = (attackerdex - defensordex);
	}
	else
	{
		//Destreza do attacker e maior do que o do defensor
		if (attackerdex > defensordex) // 10000 x 10 // 5000 x 4000 // 15000 x 4000 // 2000 x 2000
		{
			if (defensordex <= 0)
				defensordex = 1;

			if (attackerdex <= 0)
				attackerdex = 1;

			PD = (attackerdex - defensordex) / 10; // 999 // 100 // 1100 // 

			if (PD <= 0)
				PD = 1; // 999 // 100 // 1100 // 1

			Parry1 = (PD / 100); // 9.99 // 10 // 11 // 1

			if (Parry1 <= 0)
				Parry1 = 1;

			if (defensordex <= 0)
				defensordex = 1;
			// 18
			Parry2 = (PD * 100) / attackerdex;  // 9.99 // 20 // 7,3 // 
			// soma = 19.98 // 30 // 18.3

			if (Parry2 <= 0)
				Parry2 = 1;
		}
		else
		{
			if (defensordex <= 0) // defensor = 5000 / atk = 1000 
				defensordex = 1;

			if (attackerdex <= 0)
				attackerdex = 1;

			PD = (defensordex - attackerdex); // 4000

			if (PD <= 0)
				PD = 1; // 1

			Parry1 = (PD * 10) / 200; // 200 

			if (Parry1 <= 0)
				Parry1 = 0;

			Parry2 = (100 * defensordex) / attackerdex; // 

			if (Parry2 <= 0)
				Parry2 = 0;

		}
	}

	if (pMob[attackerdex].MOB.Class != 1)
		ParryChance = (Parry1 + Parry2);

	if (pMob[attackerdex].MOB.Class == 1 || pMob[attackerdex].MOB.Class == 2)
	{
		PDFM = (defensordex - attackerdex);

		if (PDFM <= 0)
			PDFM = 3;

		ParryFM1 = (PDFM * 100) / attackerdex; //33

		if (ParryFM1 <= 0)
			ParryFM1 = 0;

		ParryFM2 = (PDFM / 40); // 33

		ParryChance = (ParryFM1 + ParryFM2);

		if (ParryChance <= 0)
			ParryChance = 1;

		if (ParryChance > 800)
			ParryChance = 800;
	}

	if (attackerrsv & 0x20)
		ParryChance += 50;
	if (attackerrsv & 0x80)
		ParryChance += 50;
	if (attackerrsv & 0x200)
		ParryChance += 50;
	if (defensorrsv & 0x20)
		ParryChance -= 50;
	if (defensorrsv & 0x40)
		ParryChance -= 15;
	if (defensorrsv & 0x80)
		ParryChance -= 50;
	if (defensorrsv & 0x200)
		ParryChance -= 50;

	ParryChance -= attackerparry;
	ParryChance += defensorparry;

	if (attackerdex >= 9000)
		ParryChance = 1;

	if (ParryChance <= 0)
		ParryChance = 1;

	if (ParryChance > 800)
		ParryChance = 800;

	return ParryChance;
}

// W2PP Original
int WGetParryRate(STRUCT_MOB *mob, int add, int attackerdex, int attackrsv)
{
	if (add > 100)
		add = 100;

	if (add < 0)
		add = 0;

	int	targetdex = mob->CurrentScore.Dex;

	if (targetdex > 1000)
		targetdex = 1000;

	int parryrate1 = mob->CurrentScore.Dex - 1000;

	if (parryrate1 < 0)
		parryrate1 = 0;

	if (parryrate1 >= 2000)
		parryrate1 = 2000;

	int parryrate2 = mob->CurrentScore.Dex - 3000;

	if (parryrate2 < 0)
		parryrate2 = 0;

	int parryrate = targetdex / 2 + add + parryrate1 / 4 + parryrate2 / 8 - attackerdex;

	int rsv = attackrsv;

	if (rsv & 0x20)
		parryrate += 100;

	if (rsv & 0x80)
		parryrate += 50;

	if (rsv & 0x200)
		parryrate += 50;

	if (parryrate >= 650)
		parryrate = 650;

	if (parryrate < 1)
		parryrate = 1;

	return parryrate;
}


int GetEmptyAffect(int mob, int type)
{
	for (int i = 1; i < MAX_AFFECT; i++)
	{
		if (pMob[mob].Affect[i].Type == type)
			return i;
	}

	for (int i = 1; i < MAX_AFFECT; i++)
	{
		if (pMob[mob].Affect[i].Type == 0)
			return i;
	}

	return -1;
}

int GetHide(int mob)
{
	if (mob <= 0 || mob >= MAX_USER)
		return FALSE;

	for (int i = 1; i < MAX_AFFECT; i++)
	{
		if (pMob[mob].Affect[i].Type == 28)
			return TRUE;
	}
	return FALSE;
}
int GetInView(int a, int b)
{
	if (pMob[a].TargetX < pMob[b].TargetX - VIEWGRIDX || pMob[a].TargetX > pMob[b].TargetX + VIEWGRIDX ||
		pMob[a].TargetY < pMob[b].TargetY - VIEWGRIDY || pMob[a].TargetY > pMob[b].TargetY + VIEWGRIDY)
		return FALSE;

	return TRUE;
}

int GetInHalf(int a, int b)
{
	if (pMob[a].TargetX < pMob[b].TargetX - HALFGRIDX || pMob[a].TargetX > pMob[b].TargetX + HALFGRIDX ||
		pMob[a].TargetY < pMob[b].TargetY - HALFGRIDY || pMob[a].TargetY > pMob[b].TargetY + HALFGRIDY)
		return FALSE;

	return TRUE;
}

bool GetCuboTeleportPositionN(int conn, int room)
{
	if (conn > MAX_USER)
		return FALSE;

	int Question = CuboN.CurrentQuestion[room];
	bool Answer = CuboN.Answer[Question];

	if (Answer)
	{
		if (pMob[conn].TargetX >= (CuboN.O[room].PosX - 3) && pMob[conn].TargetX <= CuboN.O[room].PosX && pMob[conn].TargetY >= (CuboN.O[room].PosY - 3) && pMob[conn].TargetY <= CuboN.O[room].PosY)
			return TRUE;
		else
			return FALSE;
	}
	else
	{
		if (pMob[conn].TargetX >= (CuboN.X[room].PosX - 3) && pMob[conn].TargetX <= CuboN.X[room].PosX && pMob[conn].TargetY >= (CuboN.X[room].PosY - 3) && pMob[conn].TargetY <= CuboN.X[room].PosY)
			return TRUE;
		else
			return FALSE;
	}

	return FALSE;
}

bool GetCuboTeleportPositionM(int conn, int room)
{
	if (conn > MAX_USER)
		return FALSE;

	int Question = CuboM.CurrentQuestion[room];
	bool Answer = CuboM.Answer[Question];

	if (Answer)
	{
		if (pMob[conn].TargetX >= (CuboM.O[room].PosX - 3) && pMob[conn].TargetX <= CuboM.O[room].PosX && pMob[conn].TargetY >= (CuboM.O[room].PosY - 3) && pMob[conn].TargetY <= CuboM.O[room].PosY)
			return TRUE;
		else
			return FALSE;
	}
	else
	{
		if (pMob[conn].TargetX >= (CuboM.X[room].PosX - 3) && pMob[conn].TargetX <= CuboM.X[room].PosX && pMob[conn].TargetY >= (CuboM.X[room].PosY - 3) && pMob[conn].TargetY <= CuboM.X[room].PosY)
			return TRUE;
		else
			return FALSE;
	}

	return FALSE;
}

bool GetCuboTeleportPositionA(int conn, int room)
{
	if (conn > MAX_USER)
		return FALSE;

	int Question = CuboA.CurrentQuestion[room];
	bool Answer = CuboA.Answer[Question];

	if (Answer)
	{
		if (pMob[conn].TargetX >= (CuboA.O[room].PosX - 3) && pMob[conn].TargetX <= CuboA.O[room].PosX && pMob[conn].TargetY >= (CuboA.O[room].PosY - 3) && pMob[conn].TargetY <= CuboA.O[room].PosY)
			return TRUE;
		else
			return FALSE;
	}
	else
	{
		if (pMob[conn].TargetX >= (CuboA.X[room].PosX - 3) && pMob[conn].TargetX <= CuboA.X[room].PosX && pMob[conn].TargetY >= (CuboA.X[room].PosY - 3) && pMob[conn].TargetY <= CuboA.X[room].PosY)
			return TRUE;
		else
			return FALSE;
	}

	return FALSE;
}

int GetTeleportPosition(int conn, int *x, int *y)
{
	int xv = (*x) & 0xFFFC;
	int yv = (*y) & 0xFFFC;

	int Charge = 0;

	if (xv == 2116 && yv == 2100) // Armia to Noatum	
	{
		*x = 1044 + rand() % 3;
		*y = 1724 + rand() % 3;
		SendMsgExp(conn, "Bem vindo a [Noatum]", TNColor::Default, false);
		Charge = 700;
	}
	else if (xv == 2480 && yv == 1716) // Azran to Noatum
	{
		*x = 1044 + rand() % 3;
		*y = 1716 + rand() % 3;
		SendMsgExp(conn, "Bem vindo a [Noatum]", TNColor::Default, false);
		Charge = 700;
	}
	else if (xv == 2456 && yv == 2016) // Erion to Noatum
	{
		*x = 1044 + rand() % 3;
		*y = 1708 + rand() % 3;
		SendMsgExp(conn, "Bem vindo a [Noatum]", TNColor::Default, false);
		Charge = 700;
	}
	else if (xv == 1044 && yv == 1724) // Noatum to Armia
	{
		*x = 2116 + rand() % 3;
		*y = 2100 + rand() % 3;
		SendMsgExp(conn, "Bem vindo a [Armia]", TNColor::Default, false);
	}
	else if (xv == 1044 && yv == 1716) // Noatum to Azran
	{
		*x = 2480 + rand() % 3;
		*y = 1716 + rand() % 3;
		SendMsgExp(conn, "Bem vindo a [Azran]", TNColor::Default, false);
	}
	else if (xv == 1044 && yv == 1708) // Noatum to Erion
	{
		*x = 2456 + rand() % 3;
		*y = 2016 + rand() % 3;
		SendMsgExp(conn, "Bem vindo a [Erion]", TNColor::Default, false);
	}
	else if (xv == 1048 && yv == 1764) // Noatum guild area to Noatum siege war area
	{
		*x = 1100 + rand() % 3;
		*y = 1712 + rand() % 3;
		SendMsgExp(conn, "Bem vindo a [Noatun War]", TNColor::Default, false);
	}
	else if (xv == 1052 && yv == 1708) // Noatum to Karden
	{
		*x = 3650 + rand() % 3;
		*y = 3110 + rand() % 3;
		SendMsgExp(conn, "Bem vindo a [Karden]", TNColor::Default, false);
	}
	else if (xv == 2140 && yv == 2068) // Armia to Armia Field
	{
		*x = 2588 + rand() % 3;
		*y = 2096 + rand() % 3;
		SendMsgExp(conn, "Bem vindo ao [Campo de Armia]", TNColor::Default, false);
	}
	else if (xv == 2468 && yv == 1716) // Azran to Azran Field, near cape quest
	{
		*x = 2248 + rand() % 3;
		*y = 1556 + rand() % 3;
		SendMsgExp(conn, "Bem vindo ao [Campo de Azran]", TNColor::Default, false);
	}
	else if (xv == 2364 && yv == 2284) // Armia Field to Dungeon 1st Floor
	{
		*x = 144 + rand() % 3;
		*y = 3788 + rand() % 3;
		SendMsgExp(conn, "Bem vindo ao [Dungeon 1 Andar]", TNColor::Default, false);
	}
	else if (xv == 144 && yv == 3788) // Dungeon 1st floor to Armia Field
	{
		*x = 2364 + rand() % 3;
		*y = 2284 + rand() % 3;
		SendMsgExp(conn, "Bem vindo ao [Campo de Armia]", TNColor::Default, false);
	}
	else if (xv == 2668 && yv == 2156) // Armia Field to Dungeon 1st Floor (other locations)
	{
		*x = 148 + rand() % 2;
		*y = 3774 + rand() % 2;
		SendMsgExp(conn, "Bem vindo ao [Dungeon 1 Andar]", TNColor::Default, false);
	}
	else if (xv == 144 && yv == 3772) // Dungeon 1st floor to Armia Field (other locations)
	{
		*x = 2668 + rand() % 3;
		*y = 2156 + rand() % 3;
		SendMsgExp(conn, "Bem vindo ao [Dungeon 1 Andar]", TNColor::Default, false);
	}
	else if (xv == 148 && yv == 3780) // Dungeon 1st floor to Dungeon 2nd floor
	{
		*x = 1004 + rand() % 3;
		*y = 4028 + rand() % 3;
		SendMsgExp(conn, "Bem vindo ao [Dungeon 2 Andar]", TNColor::Default, false);
	}
	else if (xv == 144 && yv == 3780) // Dungeon 1st floor to Dungeon 2nd floor
	{
		*x = 1004 + rand() % 3;
		*y = 4028 + rand() % 3;
		SendMsgExp(conn, "Bem vindo ao [Dungeon 2 Andar]", TNColor::Default, false);
	}
	else if (xv == 1004 && yv == 4028) // Dungeon 2nd floor to Dungeon 1st Floor
	{
		*x = 148 + rand() % 3;
		*y = 3780 + rand() % 3;
		SendMsgExp(conn, "Bem vindo ao [Dungeon 1 Andar]", TNColor::Default, false);
	}
	else if (xv == 408 && yv == 4072) // Dungeon 1st floor to Dungeon 2nd floor
	{
		*x = 1004 + rand() % 3;
		*y = 4064 + rand() % 3;
		SendMsgExp(conn, "Bem vindo ao [Dungeon 2 Andar]", TNColor::Default, false);
	}
	else if (xv == 1004 && yv == 4064) // Dungeon 2nd floor to Dungeon 1st floor
	{
		*x = 408 + rand() % 3;
		*y = 4072 + rand() % 3;
		SendMsgExp(conn, "Bem vindo ao [Dungeon 1 Andar]", TNColor::Default, false);
	}
	else if (xv > 743 && xv < 750 && yv < 3820 && yv > 3815) // Dungeon 1st floor to Dungeon 3rd floor
	{
		*x = 1004 + rand() % 3;
		*y = 3992 + rand() % 3;
		SendMsgExp(conn, "Bem vindo ao [Dungeon 3 Andar]", TNColor::Default, false);
	}
	else if (xv == 1004 && yv == 3992) // Dungeon 3rd floor to Dugeon 1st floor
	{
		*x = 744 + rand() % 3;
		*y = 3820 + rand() % 3;
		SendMsgExp(conn, "Bem vindo ao [Dungeon 1 Andar]", TNColor::Default, false);
	}
	else if (xv == 680 && yv == 4076) // Dungeon 2nd floor to Dungeon 3rd floor
	{
		*x = 916 + rand() % 3;
		*y = 3820 + rand() % 3;
		SendMsgExp(conn, "Bem vindo ao [Dungeon 3 Andar]", TNColor::Default, false);
	}
	else if (xv == 916 && yv == 3820) // Dungeon 3rd floor to Dungeon 2nd floor
	{
		*x = 680 + rand() % 3;
		*y = 4076 + rand() % 3;
		SendMsgExp(conn, "Bem vindo ao [Dungeon 2 Andar]", TNColor::Default, false);
	}
	else if (xv == 876 && yv == 3872) // Dungeon 2nd floor to Dungeon 3rd floor
	{
		*x = 932 + rand() % 3;
		*y = 3820 + rand() % 3;
		SendMsgExp(conn, "Bem vindo ao [Dungeon 3 Andar]", TNColor::Default, false);
	}
	else if (xv == 932 && yv == 3820) // Dungeon 3rd floor to Dungeon 2nd floor	
	{
		*x = 876 + rand() % 3;
		*y = 3872 + rand() % 3;
		SendMsgExp(conn, "Bem vindo ao [Dungeon 2 Andar]", TNColor::Default, false);
	}
	else if (xv == 188 && yv == 188) // War area to Azran
	{
		*x = 2548 + rand() % 3;
		*y = 1740 + rand() % 3;
		SendMsgExp(conn, "Bem vindo a [Azran]", TNColor::Default, false);
	}
	else if (xv == 2548 && yv == 1740) // Azran to vale
	{
		if (pMob[conn].MOB.Equip[13].sIndex == 3916) {
			*x = 2281 + rand() % 3;
			*y = 3688 + rand() % 3;
			SendClientMessage(conn, "Bem vindo ao [Vale]");
		}
		else {
			SendClientMessage(conn, "Equipe uma Fada do Vale para ir ao Vale");
		}
	}
	else if (xv == 1824 && yv == 1772) // Azran Field to Underworld
	{
		*x = 1172 + rand() % 3;
		*y = 4080 + rand() % 3;
		SendMsgExp(conn, "Bem vindo ao [Submundo]", TNColor::Default, false);
	}
	else if (xv == 1172 && yv == 4080) // Underworld to Azran Field
	{
		*x = 1824 + rand() % 3;
		*y = 1772 + rand() % 3;
		SendMsgExp(conn, "Bem vindo a [Azran]", TNColor::Default, false);
	}
	else if (xv == 1516 && yv == 3996) // Underworld 1st floor to Underworld 2nd floor
	{
		*x = 1304 + rand() % 3;
		*y = 3816 + rand() % 3;
		SendMsgExp(conn, "Bem vindo ao [Submundo 2 Andar]", TNColor::Default, false);
	}
	else if (xv == 1304 && yv == 3816) // Underworld 2nd floor to Underworld 1st floor
	{
		*x = 1516 + rand() % 3;
		*y = 3996 + rand() % 3;
		SendMsgExp(conn, "Bem vindo ao [Submundo 1 Andar]", TNColor::Default, false);
	}
	else if (xv == 2452 && yv == 1716) // Azran 2nd teleport to Azran field
	{
		*x = 1969 + rand() % 3;
		*y = 1711 + rand() % 3;
		SendMsgExp(conn, "Bem vindo ao [Campo de Azran]", TNColor::Default, false);
	}
	else if (xv == 2452 && yv == 1988) // Erion teleport to Azran field
	{
		*x = 1989 + rand() % 3;
		*y = 1755 + rand() % 3;
		SendMsgExp(conn, "Bem vindo ao [Campo de Azran]", TNColor::Default, false);
	}

	else if (xv == 3648 && yv == 3108) // Karden teleport to Noatum
	{
		*x = 1054 + rand() % 3;
		*y = 1710 + rand() % 3;
		SendMsgExp(conn, "Bem vindo a [Noatum]", TNColor::Default, false);
	}

	else if (xv == 1056 && yv == 1724) // Noatum to RvR - Deserto
	{
		if (RvRState == 2)
		{
			if (pMob[conn].MOB.Clan == 7)//BLUE
			{
				*x = 1060 + rand() % 3;
				*y = 2098 + rand() % 3;
				SendMsgExp(conn, "Bem vindo ao [RVR BLUE]", TNColor::Default, false);
				Charge = 700;
			}
			else if (pMob[conn].MOB.Clan == 8)//RED
			{
				*x = 1238 + rand() % 3;
				*y = 1997 + rand() % 3;
				SendMsgExp(conn, "Bem vindo ao [RVR RED]", TNColor::Default, false);
				Charge = 700;
			}
		}

		/*else
		{
			*x = 1164 + rand() % 3;
			*y = 1720 + rand() % 3;
			SendMsgExp(conn, "Bem vindo ao [Pilar]", TNColor::Default, false);
		}*/

	}
	/*else if (xv == 2364 && yv == 3892 && pMob[conn].extra.KefraTicket > 0)
	{
		pMob[conn].extra.KefraTicket--;

		*x = 2364 + rand() % 3;
		*y = 3906 + rand() % 3;


		sprintf(temp, g_pMessageStringTable[_DN_CHANGE_COUNT], pMob[conn].extra.KefraTicket);
	 
		SendMsgExp(conn, temp, TNColor::NewWhite, false);
	}*/

	else if (xv == 2364 && yv == 3892 && pMob[conn].extra.KefraTicket > 0)
	{
		pMob[conn].extra.KefraTicket--;
		*x = 2364 + rand() % 3;
		*y = 3906 + rand() % 3;
		SendMsgExp(conn, "Bem vindo ao Boss [Kefra]", TNColor::Default, false);
	}

	//Deserto - Kefra
	else if (xv == 2364 && yv == 3924 && KefraLive != 0)
	{
		*x = 3250 + rand() % 3;
		*y = 1703 + rand() % 3;
		SendMsgExp(conn, "Bem vindo a [Kefra]", TNColor::Default, false);
	}

	//Kefra - Deserto
	else if (xv == 1312 && yv == 1900)
	{
		*x = 2366 + rand() % 2;
		*y = 4073 + rand() % 2;
		SendMsgExp(conn, "Bem vindo a [Noatun Deserto]", TNColor::Default, false);
	}

	else if (xv == 2364 && yv == 4072)
	{
		*x = 1314 + rand() % 2;
		*y = 1900 + rand() % 2;
	}

	// Portal1 (Portão Infernal) - Zona 2
	else if (xv == 1756 && yv == 3672 && TarantulaKilled == TRUE)
	{
		*x = 1772 + rand() % 3;
		*y = 3648 + rand() % 3;
	}
	else if (xv == 1756 && yv == 3672 && TarantulaKilled == FALSE)
	 
		SendMsgExp(conn, "Por favor derrote os monstros.", TNColor::Default, false);

	// Portal2 (Portão Infernal) - Zona 2
	else if (xv == 1756 && yv == 3644 && TarantulaKilled == TRUE)
	{
		*x = 1772 + rand() % 3;
		*y = 3648 + rand() % 3;
	}
	else if (xv == 1756 && yv == 3644 && TarantulaKilled == FALSE)
		 
		SendMsgExp(conn, "Por favor derrote os monstros.", TNColor::Default, false);

	// Portal3 (Portão Infernal) - Zona 2
	else if (xv == 1756 && yv == 3616 && TarantulaKilled == TRUE)
	{
		*x = 1772 + rand() % 3;
		*y = 3648 + rand() % 3;
	}
	else if (xv == 1756 && yv == 3616 && TarantulaKilled == FALSE)
	 
		SendMsgExp(conn, "Por favor derrote os monstros.", TNColor::Default, false);

	return Charge;
}


int	GetExpApply(STRUCT_MOBEXTRA extra, int exp, int attacker, int target)//exp cele //exp arch
{
	if ((extra.ClassMaster == MORTAL || extra.ClassMaster == ARCH || extra.ClassMaster == CELESTIAL || extra.ClassMaster == SCELESTIAL || extra.ClassMaster == CELESTIALCS ||
		extra.ClassMaster == HARDCORE || extra.ClassMaster == HARDCOREA || extra.ClassMaster == HARDCORECS ||
		extra.ClassMaster == SHARDCORE) && exp > 0)
	{
		if (attacker >= MAX_LEVEL)
			return 0;
	}

	if (extra.ClassMaster == ARCH && exp > 0)
	{
		if (attacker >= 354 && extra.QuestInfo.Arch.Level355 == 0)
			return 0;

		if (attacker >= 369 && extra.QuestInfo.Arch.Level370 == 0)
			return 0;
	}
	else if (extra.ClassMaster == CELESTIAL && exp > 0)
	{
		if (attacker >= 39 && extra.QuestInfo.Celestial.Lv40 == 0)
			return 0;

		if (attacker >= 89 && extra.QuestInfo.Celestial.Lv90 == 0)
			return 0;
	}

	else if (extra.ClassMaster == CELESTIALCS && exp > 0)
	{
		if (attacker >= 239 && extra.QuestInfo.Celestial.Lv240 == 0)
			return 0;

		if (attacker >= 279 && extra.QuestInfo.Celestial.Lv280 == 0)
			return 0;

		if (attacker >= 319 && extra.QuestInfo.Celestial.Lv320 == 0)
			return 0;

		if (attacker >= 359 && extra.QuestInfo.Celestial.Lv360 == 0)
			return 0;
	}

	if (target > MAX_LEVEL + 1 || attacker < 0 || target < 0)
		return exp;

	attacker++;
	target++;

	long long int ExpTotal = 0;
	int Multiply = 100;


	if (extra.ClassMaster == MORTAL) {
		if (attacker > 398)
			ExpTotal = (exp * 100) / ExpBaseN[11];

		else if (attacker > 395)
			ExpTotal = (exp * 100) / ExpBaseN[10];

		else if (attacker > 390)
			ExpTotal = (exp * 100) / ExpBaseN[9];

		else if (attacker > 380)
			ExpTotal = (exp * 100) / ExpBaseN[8];

		else if (attacker > 370)
			ExpTotal = (exp * 100) / ExpBaseN[7];

		else if (attacker > 360)
			ExpTotal = (exp * 100) / ExpBaseN[6];

		else if (attacker > 350)
			ExpTotal = (exp * 100) / ExpBaseN[5];

		else if (attacker > 340)
			ExpTotal = (exp * 100) / ExpBaseN[4];

		else if (attacker > 320)
			ExpTotal = (exp * 100) / ExpBaseN[3];

		else if (attacker > 300)
			ExpTotal = (exp * 100) / ExpBaseN[2];

		else if (attacker > 280)
			ExpTotal = (exp * 100) / ExpBaseN[1];

		else if (attacker > 255)
			ExpTotal = (exp * 100) / ExpBaseN[0];

		else if (attacker < 256) {
			if (attacker < 5)
				Multiply += 0;
			else
				Multiply += (attacker / 5);

			ExpTotal = (exp * 100) / Multiply;
		}
		else
			ExpTotal = exp;
	}

	if (extra.ClassMaster == ARCH) {
		if (attacker > 398)
			ExpTotal = (exp * 100) / ExpBaseM[11];

		else if (attacker > 395)
			ExpTotal = (exp * 100) / ExpBaseM[10];

		else if (attacker > 390)
			ExpTotal = (exp * 100) / ExpBaseM[9];

		else if (attacker > 380)
			ExpTotal = (exp * 100) / ExpBaseM[8];

		else if (attacker > 370)
			ExpTotal = (exp * 100) / ExpBaseM[7];

		else if (attacker > 360)
			ExpTotal = (exp * 100) / ExpBaseM[6];

		else if (attacker > 350)
			ExpTotal = (exp * 100) / ExpBaseM[5];

		else if (attacker > 340)
			ExpTotal = (exp * 100) / ExpBaseM[4];

		else if (attacker > 320)
			ExpTotal = (exp * 100) / ExpBaseM[3];

		else if (attacker > 300)
			ExpTotal = (exp * 100) / ExpBaseM[2];

		else if (attacker > 280)
			ExpTotal = (exp * 100) / ExpBaseM[1];

		else if (attacker > 255)
			ExpTotal = (exp * 100) / ExpBaseM[0];

		else if (attacker < 256) {
			if (attacker < 5)
				Multiply += 0;
			else
				Multiply += (attacker / 5);

			ExpTotal = (exp * 100) / Multiply;
		}
		else
			ExpTotal = exp;		
	}

	if (extra.ClassMaster >= CELESTIAL) {
		if (attacker > 398)
			ExpTotal = (exp * 100) / 18000;

		else if (attacker > 395)
			ExpTotal = (exp * 100) / 17000;

		else if (attacker > 390)
			ExpTotal = (exp * 100) / 16000;

		else if (attacker > 385)
			ExpTotal = (exp * 100) / 15000;

		else if (attacker > 380)
			ExpTotal = (exp * 100) / 14000;

		else if (attacker > 375)
			ExpTotal = (exp * 100) / 13000;

		else if (attacker > 370)
			ExpTotal = (exp * 100) / 12000;

		else if (attacker > 365)
			ExpTotal = (exp * 100) / 11000;

		else if (attacker > 360)
			ExpTotal = (exp * 100) / 10000;

		else if (attacker > 355)
			ExpTotal = (exp * 100) / 9500;

		else if (attacker > 350)
			ExpTotal = (exp * 100) / 9300;

		else if (attacker > 340)
			ExpTotal = (exp * 100) / 9100;

		else if (attacker > 320)
			ExpTotal = (exp * 100) / 9000;

		else if (attacker > 300)
			ExpTotal = (exp * 100) / 8900;

		else if (attacker > 280)
			ExpTotal = (exp * 100) / 8800;

		else if (attacker > 255)
			ExpTotal = (exp * 100) / 8500;

		else if (attacker > 230)
			ExpTotal = (exp * 100) / 8000;

		else if (attacker > 210)
			ExpTotal = (exp * 100) / 7500;

		else if (attacker > 190)
			ExpTotal = (exp * 100) / 7000;

		else if (attacker > 150)
			ExpTotal = (exp * 100) / 6500;

		else if (attacker > 100)
			ExpTotal = (exp * 100) / 6000;

		else if (attacker > 80)
			ExpTotal = (exp * 100) / 5500;

		else if (attacker > 40)
			ExpTotal = (exp * 100) / 5000;

		else
			ExpTotal = (exp * 100) / 4000;
	}

	return ExpTotal;
}

void TiroDireto(int Attacker, int Attacked)
{
	if (pMob[Attacker].MOB.Class == 3)
	{
		for (int i = 0; i < MAX_AFFECT; i++)
		{
			int Type = pMob[Attacker].Affect[i].Type;

			if (Type == 28)
			{
		 
				SendMsgExp(Attacker, "Oba", TNColor::Default, false);
				return;
			}
		}
	}
}

int GetCreateMob(int mob, MSG_CreateMob *sm)
{
	memset(sm, 0, sizeof(MSG_CreateMob));

	sm->Type = _MSG_CreateMob;

	strncpy(sm->MobName, pMob[mob].MOB.MobName, NAME_LENGTH);

	if (mob < MAX_USER)
	{
		int ck = GetCurKill(mob);
		int tk = GetTotKill(mob);

		unsigned char cv = ck;
		unsigned char cv1 = tk % 256;
		unsigned char cv2 = tk / 256;

		sm->MobName[13] = cv;
		sm->MobName[14] = cv1;
		sm->MobName[15] = cv2;

		int chaos = GetPKPoint(mob);
		int gv = GetGuilty(mob);

		if (gv > 0)
			chaos = 0;

		cv = chaos;
		sm->MobName[12] = chaos;
	}

	sm->PosX = pMob[mob].TargetX;
	sm->PosY = pMob[mob].TargetY;
	sm->Size = sizeof(MSG_CreateMob);
	sm->ID = ESCENE_FIELD;
	sm->MobID = mob;
	sm->ClientTick = CurrentTime;

	sm->Score = pMob[mob].MOB.CurrentScore;

	sm->Guild = pMob[mob].MOB.Guild;
	sm->GuildMemberType = pMob[mob].MOB.GuildLevel;

	if (pMob[mob].GuildDisable == 1)
	{
		sm->Guild = 0;
		sm->GuildMemberType = 0;
	}
	if (mob >= MAX_USER)
	{
		if (pMob[mob].MOB.Clan == 4)
			sm->Score.Ac = 0;

		else
			sm->Score.Ac = 1;
	}

	sm->CreateType = 0;

	if (pMob[mob].MOB.GuildLevel == 9)
		sm->CreateType = sm->CreateType | 0x80;

	else if (pMob[mob].MOB.GuildLevel >= 6)
		sm->CreateType = sm->CreateType | 0x40;


	sm->Hold = pMob[mob].extra.Hold;

	strncpy(sm->Tab, pMob[mob].Tab, 26);

	int selfdead = 0;

	int xx = pMob[mob].TargetX;
	int yy = pMob[mob].TargetY;

	for (int i = 0; i < MAX_EQUIP; i++)
	{
		STRUCT_ITEM *item = &pMob[mob].MOB.Equip[i];

		sm->Equip[i] = BASE_VisualItemCode(item, i);

		sm->AnctCode[i] = BASE_VisualAnctCode(item);

		if (i == 14 && sm->Equip[i] >= 2360 && sm->Equip[i] < 2390 && pMob[mob].MOB.Equip[i].stEffect[0].sValue <= 0)
		{
			sm->Equip[i] = 0;

			selfdead = 1;

			continue;
		}

		if (i == 14 && sm->Equip[i] >= 2360 && sm->Equip[i] < 2390)
		{
			int sanc = pMob[mob].MOB.Equip[i].stEffect[1].cEffect;
			sanc = sanc / 10;

			if (sanc > 13)
				sanc = 13;

			if (sanc < 0)
				sanc = 0;

			sanc = sanc << 12;

			sm->Equip[i] = sm->Equip[i] + sanc;

			continue;
		}
	}

	if (strcmp((char*)sm->MobName, "Balmus") == 0)
		strncpy(sm->Tab, "Informações da Guild", sizeof(sm->Tab));

	else if (strcmp((char*)sm->MobName, "Judith") == 0)
		strncpy(sm->Tab, "Informações da Guild", sizeof(sm->Tab));

	else if (strcmp((char*)sm->MobName, "Kara") == 0)
		strncpy(sm->Tab, "Informações da Guild", sizeof(sm->Tab));

	else if (strcmp((char*)sm->MobName, "Empis") == 0)
		strncpy(sm->Tab, "Informações da Guild", sizeof(sm->Tab));

	else if (strcmp((char*)sm->MobName, "Bruce") == 0)
		strncpy(sm->Tab, "Informações da Guild", sizeof(sm->Tab));

	else if (strcmp((char*)sm->MobName, "Kibita") == 0)
		strncpy(sm->Tab, "Torne-se Cidadão", sizeof(sm->Tab));

	else if (strcmp((char*)sm->MobName, "Carbuncle Wind") == 0)
		strncpy(sm->Tab, "Ajudante Mágico", sizeof(sm->Tab));

	else if (strcmp((char*)sm->MobName, "Aylin") == 0)
		strncpy(sm->Tab, "Compositor +10", sizeof(sm->Tab));

	else if (strcmp((char*)sm->MobName, "Agatha") == 0)
		strncpy(sm->Tab, "Passar Add Armadura Arch", sizeof(sm->Tab));

	else if (strcmp((char*)sm->MobName, "Compositor") == 0)
		strncpy(sm->Tab, "Compositor Anct", sizeof(sm->Tab));

	else if (strcmp((char*)sm->MobName, "Sobrevivente") == 0)
		strncpy(sm->Tab, "Fale comigo para entrar!", sizeof(sm->Tab));

	else if (strcmp((char*)sm->MobName, "Jephi") == 0)
		strncpy(sm->Tab, "Compor Poeiras e Círculos", sizeof(sm->Tab));

	else if (strcmp((char*)sm->MobName, "Perzen Mistico") == 0)
		strncpy(sm->Tab, "Esfera M", sizeof(sm->Tab));

	else if (strcmp((char*)sm->MobName, "Perzen Arcano") == 0)
		strncpy(sm->Tab, "Esfera A", sizeof(sm->Tab));

	else if (strcmp((char*)sm->MobName, "Perzen Normal") == 0)
		strncpy(sm->Tab, "Esfera N", sizeof(sm->Tab));

	else if (strcmp((char*)sm->MobName, "Guarda Carga") == 0 ||
		strcmp((char*)sm->MobName, "Hera") == 0 ||
		strcmp((char*)sm->MobName, "Angela") == 0)
		strncpy(sm->Tab, "Baú", sizeof(sm->Tab));

	else if (strcmp((char*)sm->MobName, "Xama") == 0)
		strncpy(sm->Tab, "Entrada Coliseu", sizeof(sm->Tab));

	else if (strcmp((char*)sm->MobName, "Shaman") == 0)
		strncpy(sm->Tab, "Reset Skill", sizeof(sm->Tab));

	else if (strcmp((char*)sm->MobName, "Juli") == 0)
		strncpy(sm->Tab, "Teleport", sizeof(sm->Tab));

	else if (strcmp((char*)sm->MobName, "Aki") == 0 ||
		strcmp((char*)sm->MobName, "Ferreiro") == 0 ||
		strcmp((char*)sm->MobName, "Rainy") == 0 ||
		strcmp((char*)sm->MobName, "Rapien") == 0 ||
		strcmp((char*)sm->MobName, "Arnod") == 0 ||
		strcmp((char*)sm->MobName, "Arnold") == 0 ||
		strcmp((char*)sm->MobName, "Ruti") == 0 ||
		strcmp((char*)sm->MobName, "Lucy") == 0 ||
		strcmp((char*)sm->MobName, "C. de Montaria") == 0 ||
		strcmp((char*)sm->MobName, "Rophelion") == 0 ||
		strcmp((char*)sm->MobName, "Reimers") == 0 ||
		strcmp((char*)sm->MobName, "Lubien") == 0 ||
		strcmp((char*)sm->MobName, "Reiners") == 0 ||
		strcmp((char*)sm->MobName, "Hestia") == 0 ||
		strcmp((char*)sm->MobName, "Berlund") == 0 ||
		strcmp((char*)sm->MobName, "Parche") == 0 ||
		strcmp((char*)sm->MobName, "Martin ") == 0)
		strncpy(sm->Tab, "Comerciante", sizeof(sm->Tab));

	else if (strcmp((char*)sm->MobName, "Shany") == 0)
		strncpy(sm->Tab, "Compor Pedra Espiritual", sizeof(sm->Tab));

	else if (strcmp((char*)sm->MobName, "Sr Ygg") == 0)
		strncpy(sm->Tab, "Loja Honra", sizeof(sm->Tab));

	else if (strcmp((char*)sm->MobName, "Tiny") == 0)
		strncpy(sm->Tab, "Add Arma Arch", sizeof(sm->Tab));

	else if (strcmp((char*)sm->MobName, "Ehre") == 0)
		strncpy(sm->Tab, "Compositor Diverso", sizeof(sm->Tab));

	else if (strcmp((char*)sm->MobName, "M. de Montaria") == 0)
		strncpy(sm->Tab, "Reviver Montarias", sizeof(sm->Tab));

	else if (strcmp((char*)sm->MobName, "Cap.Mercenario") == 0)
		strncpy(sm->Tab, "Quest Amuleto", sizeof(sm->Tab));

	else if (strcmp((char*)sm->MobName, "Mestre Archi") == 0 ||
		strcmp((char*)sm->MobName, "Foema Ancian") == 0 ||
		strcmp((char*)sm->MobName, "Cap.Cavaleiros") == 0 ||
		strcmp((char*)sm->MobName, "ForeLearner") == 0)
		strncpy(sm->Tab, "Aprender Skill", sizeof(sm->Tab));
		
	GetAffect(sm->Affect, pMob[mob].Affect);

	if (BrState != 0 && xx >= 2604 && yy >= 1708 && xx <= 2648 && yy <= 1744)
	{
		memset(sm->MobName, 0, NAME_LENGTH); // MOBNAME_LEGNTH = 16
		strncpy(sm->MobName, "??????", 6);

		sm->Equip[15] = 0;
		sm->Guild = 0;
	}

	return selfdead;
}

int GetCreateMobTrade(int mob, MSG_CreateMobTrade *sm)
{
	sm->Type = _MSG_CreateMobTrade;

	strncpy(sm->MobName, pMob[mob].MOB.MobName, NAME_LENGTH);
	 
	if (mob < MAX_USER)
	{
		int ck = GetCurKill(mob);
		int tk = GetTotKill(mob);

		unsigned char cv = ck;
		unsigned char cv1 = tk % 256;
		unsigned char cv2 = tk / 256;

		sm->MobName[13] = cv;
		sm->MobName[14] = cv1;
		sm->MobName[15] = cv2;

		int chaos = GetPKPoint(mob);

		cv = chaos;
		sm->MobName[12] = cv;
	}

	sm->PosX = pMob[mob].TargetX;
	sm->PosY = pMob[mob].TargetY;
	sm->Size = sizeof(MSG_CreateMobTrade);
	sm->ID = ESCENE_FIELD;
	sm->MobID = mob;
	sm->ClientTick = CurrentTime;

	memcpy(&sm->Score, &pMob[mob].MOB.CurrentScore, sizeof(STRUCT_SCORE));

	sm->Guild = pMob[mob].MOB.Guild;

	if (pMob[mob].GuildDisable == 1)
		sm->Guild = 0;

	if (mob >= MAX_USER)
		sm->Score.Ac = pMob[mob].MOB.Clan != 4;

	sm->CreateType = 0;

	if (pMob[mob].MOB.GuildLevel == 9)
		sm->CreateType = sm->CreateType | 0x80;

	if (pMob[mob].MOB.GuildLevel != 0)
		sm->CreateType = sm->CreateType | 0x40;

	int selfdead = 0;

	for (int i = 0; i < MAX_EQUIP; i++)
	{
		STRUCT_ITEM *item = &pMob[mob].MOB.Equip[i];

		sm->Equip[i] = BASE_VisualItemCode(item, i);

		sm->AnctCode[i] = BASE_VisualAnctCode(item);

		if (i == 14 && sm->Equip[i] >= 2360 && sm->Equip[i] < 2390 && pMob[mob].MOB.Equip[i].stEffect[0].sValue <= 0)
		{
			sm->Equip[i] = 0;

			selfdead = 1;

			continue;
		}

		if (i == 14 && sm->Equip[i] >= 2360 && sm->Equip[i] < 2390)
		{
			int sanc = pMob[mob].MOB.Equip[i].stEffect[1].cEffect;
			sanc = sanc / 10;

			if (sanc > 13)
				sanc = 13;

			if (sanc < 0)
				sanc = 0;

			sanc = sanc << 12;

			sm->Equip[i] = sm->Equip[i] + sanc;

			continue;
		}
	}

	strncpy(sm->Tab, pMob[mob].Tab, 26);  
	strncpy(sm->Desc, pMob[mob].AutoTrade.List->Name, 24); 
	GetAffect(sm->Affect, pMob[mob].Affect);

	return selfdead;
}

void GetAffect(unsigned short *out, STRUCT_AFFECT *affect)
{
	for (int i = 0; i < MAX_AFFECT; i++) // i = 0;
	{
		int type = affect[i].Type;
		int value = affect[i].Time;

		//if(type == 0)
		//	continue;

		value = value;

		if (value > 2550000)
			value = 2550000;

		unsigned short tout = (type << 8) + (value & 0xFF);

		out[i] = tout;
	}
}

void GetCreateItem(int idx, MSG_CreateItem *sm)
{
	sm->ID = ESCENE_FIELD;
	sm->Size = sizeof(MSG_CreateItem);
	sm->Type = _MSG_CreateItem;


	sm->GridX = pItem[idx].PosX;
	sm->GridY = pItem[idx].PosY;

	sm->ItemID = idx + 10000;

	sm->Rotate = pItem[idx].Rotate;

	sm->Item = pItem[idx].ITEM;

	sm->State = pItem[idx].State;

	sm->Height = -204;

	if (pItem[idx].ITEM.sIndex == 3145)
	{
		int zone = BASE_GetVillage(pItem[idx].PosX, pItem[idx].PosY);
		sm->Item.sIndex = 3145 + g_pGuildZone[zone].Victory;

		sm->State = STATE_CLOSED;

		sm->Item.stEffect[0].cEffect = 56;
		sm->Item.stEffect[1].cEffect = 57;

		sm->Item.stEffect[0].cValue = (g_pGuildZone[zone].ChargeGuild + (ServerIndex << 12)) >> 8;
		sm->Item.stEffect[1].cValue = g_pGuildZone[zone].ChargeGuild;
	}

	if (pItem[idx].ITEM.sIndex == 5700)
		return;

	if (sm->State == STATE_OPEN)
	{
		sm->Height = pItem[idx].Height;
		sm->Create = 0;
	}
}

void GetAction(int mob, int targetx, int targety, MSG_Action *sm)
{
	sm->ID = mob;
	sm->ClientTick = CurrentTime;
	sm->Size = sizeof(MSG_Action);
	sm->Type = _MSG_Action;

	sm->TargetX = targetx;
	sm->TargetY = targety;
	sm->Route[0] = 0;

	sm->Speed = 2;
	sm->Effect = 1;
	sm->PosX = pMob[mob].TargetX;
	sm->PosY = pMob[mob].TargetY;
}

unsigned char GetAttribute(int x, int y)
{
	if (x < 0 || x > MAX_GRIDX || y < 0 || y > MAX_GRIDY)
		return 0;

	int xx = x / 4;

	xx = xx & 0x3FF;

	int yy = y / 4;

	yy = yy & 0x3FF;

	unsigned char ret = g_pAttribute[yy][xx];

	return ret;
}

union MapAttribute
{
	struct
	{
		UINT8 Village : 1; // 1
		UINT8 CantGo : 1; // 2
		UINT8 CantSummon : 1; // 4
		UINT8 House : 1; // 8
		UINT8 Teleport : 1; // 16
		UINT8 Guild : 1; // 32
		UINT8 PvP : 1; // 64
		UINT8 Newbie : 1; // 128
	};
	UINT8 Value;
};

void GetAttack(int clientId, int mobId, p39D* p)
{
	memset(p, 0, sizeof p39D);

	p->ID = 0x7531;
	p->attackerId = clientId;
	p->ClientTick = clock();

	p->attackerPos.PosX = pMob[clientId].TargetX;
	p->attackerPos.PosY = pMob[clientId].TargetY;

	p->targetPos.PosX = pMob[mobId].TargetX;
	p->targetPos.PosY = pMob[mobId].TargetY;

	//0041D27A
	p->Size = sizeof p39D;
	p->Type = 0x39D;

	p->doubleCritical = 0;
	p->currentMp = -1;
	p->currentExp = -1;

	p->Target.Damage = 0;

	//p->unknow_2 = -2;
	p->Target.TargetID = mobId;

	INT32 LOCAL_1 = -1;
	p->skillParm = 0;
	p->skillId = -1;

	p->Motion = rand() % 3 + 4;

	if (clientId >= MAX_USER)
	{
		INT32 LOCAL_2 = BASE_GetDistance(pMob[clientId].TargetX, pMob[clientId].TargetY, pMob[mobId].TargetX, pMob[mobId].TargetY);

		INT16 LOCAL_3;
		INT32 LOCAL_4;
		if (LOCAL_2 < 3)
		{
			LOCAL_3 = (char)pMob[clientId].MOB.CurrentScore.Special[0];
			LOCAL_4 = (char)pMob[clientId].MOB.CurrentScore.Special[1];
		}
		else
		{
			LOCAL_3 = (char)pMob[clientId].MOB.CurrentScore.Special[2];
			LOCAL_4 = (char)pMob[clientId].MOB.CurrentScore.Special[3];
		}

		p->Motion = 0;

		/*if ((LOCAL_3 & 0xFF) == 0xFF)
			LOCAL_3 = 0xFF;*/

			// 0041D3B1
			//LOCAL_3 &= 0xFF;

		if (LOCAL_3 == 0x79)
		{
			p->skillId = 103;
			p->skillParm = 5;
		}
		else if (LOCAL_3 == 0x7A)
		{
			p->skillId = 0x69;
			p->skillParm = 1;
		}
		else if (LOCAL_3 == 0x7B)
		{
			p->skillId = 0x65;
			p->skillParm = 1;
		}
		else if (LOCAL_3 == 0x7C)
		{
			p->skillId = 0x65;
			p->skillParm = 2;
		}
		else if (LOCAL_3 == 0x7D)
		{
			p->skillId = 0x28;
			p->skillParm = 1;
		}
		else if (LOCAL_3 == 0x7E)
		{
			p->skillId = 0x28;
			p->skillParm = 2;
		}

		else if (LOCAL_3 == 0x7F)
		{
			p->skillId = 0x28;
			p->skillParm = 3;
		}
		else if (LOCAL_3 == 0x80)
		{
			p->skillId = 0x21;
			p->skillParm = 0xFC;
			p->Motion = 0xFC;
		}
		else
			p->skillId = LOCAL_3;

		if (LOCAL_4 != 0)
		{
			p->Motion = 4;

			INT32 LOCAL_5 = rand() & 0x80000003;
			if (LOCAL_4 == 3)
			{
				if (LOCAL_5 <= 1)
					p->Motion++;
			}
			else if (LOCAL_4 == 6)
			{
				if (LOCAL_5 <= 1)
					p->Motion++;
				else
					p->Motion += 2;
			}
			else if (LOCAL_4 == 7)
			{
				if (LOCAL_5 == 1)
					p->Motion++;
				else
					p->Motion += 2;
			}
			else if (LOCAL_4 == 15)
			{
				if (LOCAL_5 == 1)
					p->Motion++;
				else if (LOCAL_5 == 2)
					p->Motion += 2;
				else if (LOCAL_5 == 3)
					p->Motion += 3;
			}
			else if (LOCAL_4 == 0x18)
			{
				if (LOCAL_5 <= 1)
					p->Motion += 3;
				else
					p->Motion += 4;
			}
			else if (LOCAL_4 == 0x1B)
			{
				if (LOCAL_5 == 1)
					p->Motion++;
				else if (LOCAL_5 == 2)
					p->Motion += 3;
				else if (LOCAL_5 == 3)
					p->Motion += 4;
			}
			else if (LOCAL_4 == 0x17)
			{
				if (LOCAL_5 == 1)
					p->Motion++;
				else if (LOCAL_5 == 2)
					p->Motion += 2;
				else if (LOCAL_5 == 3)
					p->Motion += 4;
			}
		}

		INT32 LOCAL_6 = rand() % 100;
		if (pMob[clientId].MOB.SkillBar[3] != -1 && LOCAL_6 >= 0x19 && LOCAL_6 <= 40)
		{// skillData base = 7DCDD8
			INT32 LOCAL_7 = pMob[clientId].MOB.SkillBar[3];
			INT32 LOCAL_8 = g_pSpell[LOCAL_7].InstanceType;
			INT32 LOCAL_9 = pMob[clientId].Leader;

			if (LOCAL_9 <= 0)
				LOCAL_9 = clientId;

			INT32 LOCAL_10 = pMob[clientId].MOB.CurrentScore.Hp;
			LOCAL_10 = LOCAL_10 * 10;
			LOCAL_10 = LOCAL_10 / pMob[clientId].MOB.CurrentScore.MaxHp;
			INT32 LOCAL_11 = pMob[LOCAL_9].MOB.CurrentScore.Hp;
			LOCAL_11 = LOCAL_11 * 10;
			LOCAL_11 = LOCAL_11 / pMob[clientId].MOB.CurrentScore.MaxHp;

			if (LOCAL_8 == 6 && LOCAL_10 <= 8 && LOCAL_11 <= 8)
			{
				p->skillId = LOCAL_7;

				INT32 LOCAL_12 = clientId;
				if (LOCAL_10 > LOCAL_11)
					LOCAL_12 = LOCAL_9;

				INT32 LOCAL_13 = pMob[LOCAL_12].MOB.CurrentScore.Hp / 10;

				p->Target.TargetID = LOCAL_12;
				p->Target.Damage = -LOCAL_13;

				return;
			}
		}

		if (pMob[clientId].MOB.SkillBar[0] != -1 && LOCAL_6 >= 0 && LOCAL_6 <= 49)
		{
			INT32 LOCAL_14 = pMob[clientId].MOB.SkillBar[0];
			INT32 LOCAL_15 = g_pSpell[LOCAL_14].InstanceType;

			LOCAL_1 = LOCAL_15 - 2;

			p->skillId = LOCAL_14;
		}
		else if (pMob[clientId].MOB.SkillBar[1] != -1 && LOCAL_6 >= 50 && LOCAL_6 <= 84)
		{
			INT32 LOCAL_16 = pMob[clientId].MOB.SkillBar[1];
			INT32 LOCAL_17 = g_pSpell[LOCAL_16].InstanceType;

			LOCAL_1 = LOCAL_17 - 2;

			p->skillId = LOCAL_16;
		}
		else if (pMob[clientId].MOB.SkillBar[2] != -1 && LOCAL_6 >= 85 && LOCAL_6 <= 99)
		{
			INT32 LOCAL_16 = pMob[clientId].MOB.SkillBar[1];
			INT32 LOCAL_17 = g_pSpell[LOCAL_16].InstanceType;

			LOCAL_1 = LOCAL_17 - 2;

			p->skillId = LOCAL_16;
		}
	}

	INT32 LOCAL_20 = pMob[clientId].MOB.CurrentScore.Damage;

	LOCAL_20 = BASE_GetDamage(LOCAL_20, pMob[mobId].MOB.CurrentScore.Ac, 0);



	if (LOCAL_1 >= 0 && LOCAL_1 <= 3)
		LOCAL_20 = LOCAL_20 * (100 - *(BYTE*)(&pMob[mobId].MOB.Resist + LOCAL_1)) / 100;

	if (LOCAL_20 > 0 && mobId < MAX_USER && pMob[mobId].ReflectDamage > 0)
	{
		LOCAL_20 -= pMob[mobId].ReflectDamage;

		if (LOCAL_20 < 0)
			LOCAL_20 = 0;
	}

	if (LOCAL_20 > 0)
	{
		if (clientId < MAX_USER || pMob[clientId].MOB.Clan == 4)
		{
			if (mobId < MAX_USER || pMob[mobId].MOB.Clan == 4)
			{
				LOCAL_20 = LOCAL_20 * 3 / 10;

				MapAttribute LOCAL_21{};
				auto att1 = GetAttribute(pMob[mobId].TargetX, pMob[mobId].TargetY);
				memcpy(&LOCAL_21, &att1, sizeof(MapAttribute));
				auto att2 = GetAttribute(pMob[clientId].TargetX, pMob[clientId].TargetY);
				MapAttribute LOCAL_22{};
				memcpy(&LOCAL_22, &att2, sizeof(MapAttribute));
				if (LOCAL_21.Village || !LOCAL_21.PvP)
					LOCAL_20 = 0;

				if (LOCAL_22.Village || !LOCAL_22.PvP)
					LOCAL_20 = 0;
			}
		}

		INT32 LOCAL_23 = pMob[clientId].Leader;
		if (LOCAL_23 == 0)
			LOCAL_23 = clientId;

		INT32 LOCAL_24 = pMob[mobId].Leader;
		if (LOCAL_24 == 0)
			LOCAL_24 = mobId;

		INT32 LOCAL_25 = pMob[clientId].MOB.Guild;
		INT32 LOCAL_26 = pMob[mobId].MOB.Guild;    // quem está sendo atacado
		INT32 ally = g_pGuildAlly[LOCAL_25];
		if (ally == 0)
			ally = -1;

		if (LOCAL_25 == 0 && LOCAL_26 == 0)
			LOCAL_25 = -1;

		if (mobId < MAX_USER && pMob[mobId].GuildDisable)
			LOCAL_26 = -2;


		if (LOCAL_23 == LOCAL_24 || LOCAL_25 == LOCAL_26 || ally == LOCAL_26)
		{
			LOCAL_20 = 0;
			pMob[clientId].CurrentTarget = 0;
		}
	}
	int damage = LOCAL_20;
	p->Target.Damage = damage;
	if (mobId < MAX_USER && LOCAL_20 > 0)
	{
		UINT32 LOCAL_180 = GetParryRate(&pMob[clientId].MOB, pMob[clientId].MOB.CurrentScore.Dex, pMob[clientId].MOB.Rsv, pMob[clientId].Parry, pMob[mobId].MOB.CurrentScore.Dex, pMob[mobId].MOB.Rsv, pMob[mobId].Parry);

		INT32 LOCAL_181 = (rand() % 1000) + 1;
		if (LOCAL_181 < LOCAL_180 && pMob[clientId].GenerateIndex != KEFRA_BOSS)
		{
			p->Target.Damage = -3;
			if ((pMob[mobId].MOB.Rsv & 128) && LOCAL_181 < MAX_USER)
				p->Target.Damage = -4;
		}

		if (pMob[mobId].MOB.Clan == 4)
			p->Target.Damage = (p->Target.Damage << 1) / 5;


		INT32 auxDam = p->Target.Damage;
		if (pMob[mobId].MOB.Class == 1)//controle de mana foema
		{
			for (int c = 0; c < MAX_AFFECT; c++) // Controle de Mana ( PVP )
			{
				if (pMob[mobId].Affect[c].Type == 18)
				{
					INT32 tmpDamage = auxDam / 2;
					if ((pUser[mobId].ReqMp - tmpDamage) >= 300)
					{
						pMob[mobId].MOB.CurrentScore.Mp -= tmpDamage;
						pUser[mobId].ReqMp -= tmpDamage;

						SetReqMp(mobId);
						SendScore(mobId);

						auxDam = tmpDamage;
					}
					else
						SendSetHpMp(mobId);
				}
			}
		}

		/*INT32 auxDam = p->Target.Damage;
		for (int i = 0; i < 32; i++)
		{
			if (pMob[mobId].Affect[i].Type == 18)
			{
				INT32 tmpDamage = auxDam / 2;
				if ((pUser[mobId].ReqMp - tmpDamage) >= 300)
				{
					pMob[mobId].MOB.CurrentScore.Mp -= tmpDamage;
					pUser[mobId].ReqMp -= tmpDamage;

					SetReqMp(mobId);
					SendScore(mobId);

					auxDam = tmpDamage;
				}
				else
					SendSetHpMp(mobId);

				break;
			}
		}*/

		damage = auxDam;
	}

	p->Target.Damage = damage;
}

//void GetAttack(int mob, int target, MSG_AttackOne *sm)
//{
//	memset(sm, 0, sizeof(MSG_AttackOne));
//
//	sm->ID = ESCENE_FIELD;
//	sm->AttackerID = mob;
//	sm->ClientTick = CurrentTime;
//	sm->PosX = pMob[mob].TargetX;
//	sm->PosY = pMob[mob].TargetY;
//	sm->TargetX = pMob[target].TargetX;
//	sm->TargetY = pMob[target].TargetY;
//	sm->Size = sizeof(MSG_AttackOne);
//	sm->Type = _MSG_AttackOne;
//
//	sm->DoubleCritical = 0;
//	sm->CurrentMp = -1;
//	sm->ReqMp = -1;
//
//	sm->Dam[0].TargetID = 0;
//	sm->Dam[0].Damage = 0;
//
//	sm->Dam[0].TargetID = target;
//
//	int Resist = -1;
//
//	sm->SkillParm = 0;
//	sm->SkillIndex = -1;
//	sm->Motion = rand() % 3 + 4;
//
//	int special = 0;
//	int special2 = 0;
//
//	if (mob >= MAX_USER)
//	{
//		int dis = BASE_GetDistance(pMob[mob].TargetX, pMob[mob].TargetY, pMob[target].TargetX, pMob[target].TargetY);
//		if (dis >= 3)
//		{
//			special = pMob[mob].MOB.BaseScore.Special[2];//pMob[mob].MOB.SkillBar[2];
//			special2 = pMob[mob].MOB.BaseScore.Special[3]; // pMob[mob].MOB.SkillBar[3];
//		}
//		else
//		{
//			special = pMob[mob].MOB.BaseScore.Special[0];//pMob[mob].MOB.SkillBar[0];
//			special2 = pMob[mob].MOB.BaseScore.Special[1];//pMob[mob].MOB.SkillBar[1];
//		}
//
//		sm->Motion = 0;
//
//		if (special == 255)
//			special = -1;
//
//		switch (special)
//		{
//		case 121:
//			sm->SkillIndex = 103;
//			sm->SkillParm = 5;
//			break;
//		case 122:
//			sm->SkillIndex = 105;
//			sm->SkillParm = 1;
//			break;
//		case 123:
//			sm->SkillIndex = 101;
//			sm->SkillParm = 1;
//			break;
//		case 124:
//			sm->SkillIndex = 101;
//			sm->SkillParm = 2;
//			break;
//		case 125:
//			sm->SkillIndex = 40;
//			sm->SkillParm = 1;
//			break;
//		case 126:
//			sm->SkillIndex = 40;
//			sm->SkillParm = 2;
//			break;
//		case 127:
//			sm->SkillIndex = 40;
//			sm->SkillParm = 3;
//			break;
//		case 128:
//			sm->SkillIndex = 33;
//			sm->SkillParm = -4;
//			sm->Motion = -4;
//			break;
//		default:
//			sm->SkillIndex = special;
//			sm->SkillParm = 1;
//			break;
//		}
//		if (special2)
//		{
//			sm->Motion = 4;
//			int _rand = rand() % 4;
//
//			switch (special2)
//			{
//			case 3:
//				if (_rand <= 1)
//					sm->Motion++;
//				break;
//			case 6:
//				if (_rand > 1)
//					sm->Motion += 2;
//				else
//					sm->Motion++;
//				break;
//			case 7:
//				if (_rand == 1)
//					sm->Motion++;
//				else
//					sm->Motion += 2;
//				break;
//			case 15:
//				switch (_rand)
//				{
//				case 1:
//					sm->Motion++;
//					break;
//				case 2:
//					sm->Motion += 2;
//					break;
//				case 3:
//					sm->Motion += 3;
//					break;
//				}
//				break;
//			case 24:
//				if (_rand > 1)
//					sm->Motion += 4;
//				else
//					sm->Motion += 3;
//				break;
//			case 27:
//				switch (_rand)
//				{
//				case 1:
//					sm->Motion++;
//					break;
//				case 2:
//					sm->Motion += 3;
//					break;
//				case 3:
//					sm->Motion += 4;
//					break;
//				}
//				break;
//			case 23:
//				switch (_rand)
//				{
//				case 1:
//					sm->Motion++;
//					break;
//				case 2:
//					sm->Motion += 2;
//					break;
//				case 3:
//					sm->Motion += 4;
//					break;
//				}
//				break;
//
//			default:
//				sm->SkillParm = 1;
//				break;
//			}
//		}
//		int rand_ = rand() % 100;
//		if (pMob[mob].MOB.SkillBar[3] != 255 && rand_ >= 25 && rand_ <= 64)
//		{
//			int skillb3 = pMob[mob].MOB.SkillBar[3];
//
//			int insttype = g_pSpell[skillb3].InstanceType;
//
//			int leader = pMob[mob].Leader;
//			if (leader <= 0)
//				leader = mob;
//
//			int hp = pMob[mob].MOB.CurrentScore.Hp;
//			hp *= 10;
//			hp /= pMob[mob].MOB.CurrentScore.MaxHp + 1;
//
//			int lhp = pMob[leader].MOB.CurrentScore.Hp;
//			lhp *= 10;
//			lhp /= pMob[leader].MOB.CurrentScore.MaxHp + 1;
//
//			if (insttype == 6)
//			{
//				if (hp <= 8 || lhp <= 8)
//				{
//					int _mob = 0;
//
//					sm->SkillIndex = insttype;
//
//					_mob = mob;
//					if (hp > lhp)
//						_mob = leader;
//
//
//					sm->Dam[0].TargetID = _mob;
//					sm->Dam[0].Damage = pMob[_mob].MOB.CurrentScore.MaxHp / 10;
//
//					return;
//				}
//			}
//		}
//		if (pMob[mob].MOB.SkillBar[0] == 255 || rand_ < 0 || rand_ > 49)
//		{
//			if (pMob[mob].MOB.SkillBar[1] == 255 || rand_ < 50 || rand_ > 84)
//			{
//				if (pMob[mob].MOB.SkillBar[2] != 255 && rand_ >= 85 && rand_ <= 99)
//				{
//					Resist = g_pSpell[pMob[mob].MOB.SkillBar[2]].InstanceType - 2;
//					sm->SkillIndex = pMob[mob].MOB.SkillBar[2];
//				}
//			}
//			else
//			{
//				Resist = g_pSpell[pMob[mob].MOB.SkillBar[1]].InstanceType - 2;
//				sm->SkillIndex = pMob[mob].MOB.SkillBar[1];
//			}
//		}
//		else
//		{
//			Resist = g_pSpell[pMob[mob].MOB.SkillBar[0]].InstanceType - 2;
//			sm->SkillIndex = pMob[mob].MOB.SkillBar[0];
//		}
//	}
//
//	int fisdam = pMob[mob].MOB.CurrentScore.Damage;
//	fisdam = BASE_GetDamage(fisdam, pMob[target].MOB.CurrentScore.Ac, 0);
//
//	if (Resist >= 0 && Resist <= 3)
//		fisdam = (200 - pMob[target].MOB.Resist[Resist]) * fisdam / 100;
//
//	if (fisdam > 0 && target < MAX_USER)
//	{
//		if (pMob[target].ReflectDamage > 0)
//		{
//			fisdam -= pMob[target].ReflectDamage;
//			if (fisdam <= 0)
//				fisdam = 1;
//		}
//	}
//
//	if (fisdam > 0)
//	{
//		if ((mob < MAX_USER || pMob[mob].MOB.Clan == 4) && (target < MAX_USER || pMob[target].MOB.Clan == 4))
//		{
//			fisdam = 3 * fisdam / 10;
//
//			if (GetAttribute(pMob[target].TargetX, pMob[target].TargetY) & 1 || !(GetAttribute(pMob[target].TargetX, pMob[target].TargetY) & 0x40))
//				fisdam = 0;
//			if (GetAttribute(pMob[mob].TargetX, pMob[mob].TargetY) & 1 || !(GetAttribute(pMob[mob].TargetX, pMob[mob].TargetY) & 0x40))
//				fisdam = 0;
//		}
//
//		int mob_leader = pMob[mob].Leader;
//		if (!mob_leader)
//			mob_leader = mob;
//
//		int target_leader = pMob[target].Leader;
//		if (!target_leader)
//			target_leader = target;
//
//		int mob_guild = pMob[mob].MOB.Guild;
//		int target_guild = pMob[target].MOB.Guild;
//
//		if (!mob_guild && !target_guild)
//			mob_guild = -1;
//
//		if (target < MAX_USER)
//		{
//			if (pMob[target].GuildDisable)
//				target_guild = -2;
//		}
//		if (mob_leader == target_leader || mob_guild == target_guild)
//		{
//			pMob[mob].CurrentTarget = 0;
//			fisdam = 0;
//		}
//	}
//
//	sm->CurrentHp = -1;
//	sm->Progress = 52428;
//	sm->Dam[0].Damage = fisdam;
//}

void GetAttackArea(int mob, MSG_Attack *sm)
{
	sm->ID = ESCENE_FIELD;
	sm->AttackerID = mob;
	sm->ClientTick = CurrentTime;
	sm->PosX = pMob[mob].TargetX;
	sm->PosY = pMob[mob].TargetY;
	sm->Size = sizeof(MSG_Attack);
	sm->Type = _MSG_Attack;

	sm->DoubleCritical = 0;
	sm->CurrentMp = -1;
	sm->ReqMp = -1;

	for (int i = 0; i < MAX_TARGET; i++)
	{
		sm->Dam[i].TargetID = 0;
		sm->Dam[i].Damage = 0;

		sm->Dam[i].TargetID = pMob[mob].EnemyList[i];

		if (sm->Dam[i].TargetID < 0 || sm->Dam[i].TargetID >= MAX_MOB)
			sm->Dam[i].TargetID = 0;
	}
	int Resist = -1;

	sm->SkillParm = 0;
	sm->SkillIndex = -1;
	sm->Motion = rand() % 3 + 4;

	for (int i = 0; i < MAX_TARGET; i++)
	{
		if (sm->Dam[i].TargetID == 0)
			continue;

		sm->TargetX = pMob[sm->Dam[i].TargetID].TargetX;
		sm->TargetY = pMob[sm->Dam[i].TargetID].TargetY;

		int special = 0;
		int special2 = 0;

		if (mob >= MAX_USER)
		{
			int dis = BASE_GetDistance(pMob[mob].TargetX, pMob[mob].TargetY, pMob[sm->Dam[i].TargetID].TargetX, pMob[sm->Dam[i].TargetID].TargetY);
			if (dis >= 3)
			{
				special = pMob[mob].MOB.BaseScore.Special[2];//pMob[mob].MOB.SkillBar[2];
				special2 = pMob[mob].MOB.BaseScore.Special[3]; //pMob[mob].MOB.SkillBar[3];
			}
			else
			{
				special = pMob[mob].MOB.BaseScore.Special[0];//pMob[mob].MOB.SkillBar[0];
				special2 = pMob[mob].MOB.BaseScore.Special[1];//pMob[mob].MOB.SkillBar[1];
			}

			sm->Motion = 0;

			if (special == 255)
				special = -1;

			switch (special)
			{
			case 121:
				sm->SkillIndex = 103;
				sm->SkillParm = 5;
				break;
			case 122:
				sm->SkillIndex = 105;
				sm->SkillParm = 1;
				break;
			case 123:
				sm->SkillIndex = 101;
				sm->SkillParm = 1;
				break;
			case 124:
				sm->SkillIndex = 101;
				sm->SkillParm = 2;
				break;
			case 125:
				sm->SkillIndex = 40;
				sm->SkillParm = 1;
				break;
			case 126:
				sm->SkillIndex = 40;
				sm->SkillParm = 2;
				break;
			case 127:
				sm->SkillIndex = 40;
				sm->SkillParm = 3;
				break;
			case 128:
				sm->SkillIndex = 33;
				sm->SkillParm = -4;
				sm->Motion = -4;
				break;
			default:
				sm->SkillIndex = special;
				sm->SkillParm = 1;
				break;
			}
			if (special2)
			{
				sm->Motion = 4;
				int _rand = rand() % 4;

				switch (special2)
				{
				case 3:
					if (_rand <= 1)
						sm->Motion++;
					break;
				case 6:
					if (_rand > 1)
						sm->Motion += 2;
					else
						sm->Motion++;
					break;
				case 7:
					if (_rand == 1)
						sm->Motion++;
					else
						sm->Motion += 2;
					break;
				case 15:
					switch (_rand)
					{
					case 1:
						sm->Motion++;
						break;
					case 2:
						sm->Motion += 2;
						break;
					case 3:
						sm->Motion += 3;
						break;
					}
					break;
				case 24:
					if (_rand > 1)
						sm->Motion += 4;
					else
						sm->Motion += 3;
					break;
				case 27:
					switch (_rand)
					{
					case 1:
						sm->Motion++;
						break;
					case 2:
						sm->Motion += 3;
						break;
					case 3:
						sm->Motion += 4;
						break;
					}
					break;
				case 23:
					switch (_rand)
					{
					case 1:
						sm->Motion++;
						break;
					case 2:
						sm->Motion += 2;
						break;
					case 3:
						sm->Motion += 4;
						break;
					}
					break;

				default:
					sm->SkillParm = 1;
					break;
				}
			}
			int rand_ = rand() % 100;
			if (pMob[mob].MOB.SkillBar[3] != 255 && rand_ >= 25 && rand_ <= 64)
			{
				int skillb3 = pMob[mob].MOB.SkillBar[3];

				int insttype = g_pSpell[skillb3].InstanceType;

				int leader = pMob[mob].Leader;
				if (leader <= 0)
					leader = mob;

				int hp = pMob[mob].MOB.CurrentScore.Hp;
				hp *= 10;
				hp /= pMob[mob].MOB.CurrentScore.MaxHp + 1;

				int lhp = pMob[leader].MOB.CurrentScore.Hp;
				lhp *= 10;
				lhp /= pMob[leader].MOB.CurrentScore.MaxHp + 1;

				if (insttype == 6)
				{
					if (hp <= 8 || lhp <= 8)
					{
						int _mob = 0;

						sm->SkillIndex = insttype;

						_mob = mob;
						if (hp > lhp)
							_mob = leader;


						sm->Dam[0].TargetID = _mob;
						sm->Dam[0].Damage = pMob[_mob].MOB.CurrentScore.MaxHp / 10;

						return;
					}
				}
			}
			if (pMob[mob].MOB.SkillBar[0] == 255 || rand_ < 0 || rand_ > 49)
			{
				if (pMob[mob].MOB.SkillBar[1] == 255 || rand_ < 50 || rand_ > 84)
				{
					if (pMob[mob].MOB.SkillBar[2] != 255 && rand_ >= 85 && rand_ <= 99)
					{
						Resist = g_pSpell[pMob[mob].MOB.SkillBar[2]].InstanceType - 2;
						sm->SkillIndex = pMob[mob].MOB.SkillBar[2];
					}
				}
				else
				{
					Resist = g_pSpell[pMob[mob].MOB.SkillBar[1]].InstanceType - 2;
					sm->SkillIndex = pMob[mob].MOB.SkillBar[1];
				}
			}
			else
			{
				Resist = g_pSpell[pMob[mob].MOB.SkillBar[0]].InstanceType - 2;
				sm->SkillIndex = pMob[mob].MOB.SkillBar[0];
			}
		}

		int fisdam = pMob[mob].MOB.CurrentScore.Damage;
		fisdam = BASE_GetDamage(fisdam, pMob[sm->Dam[i].TargetID].MOB.CurrentScore.Ac, 0);

		if (Resist >= 0 && Resist <= 3)
			fisdam = (200 - pMob[sm->Dam[i].TargetID].MOB.Resist[Resist]) * fisdam / 100;

		if (fisdam > 0 && sm->Dam[i].TargetID < MAX_USER)
		{
			if (pMob[sm->Dam[i].TargetID].ReflectDamage > 0)
			{
				fisdam -= pMob[sm->Dam[i].TargetID].ReflectDamage;
				if (fisdam < 0)
					fisdam = 0;
			}
		}

		if (fisdam > 0)
		{
			if ((mob < MAX_USER || pMob[mob].MOB.Clan == 4) && (sm->Dam[i].TargetID < MAX_USER || pMob[sm->Dam[i].TargetID].MOB.Clan == 4))
			{
				fisdam = 3 * fisdam / 10;

				if (GetAttribute(pMob[sm->Dam[i].TargetID].TargetX, pMob[sm->Dam[i].TargetID].TargetY) & 1 || !(GetAttribute(pMob[sm->Dam[i].TargetID].TargetX, pMob[sm->Dam[i].TargetID].TargetY) & 0x40))
					fisdam = 0;
				if (GetAttribute(pMob[mob].TargetX, pMob[mob].TargetY) & 1 || !(GetAttribute(pMob[mob].TargetX, pMob[mob].TargetY) & 0x40))
					fisdam = 0;
			}

			int mob_leader = pMob[mob].Leader;
			if (!mob_leader)
				mob_leader = mob;

			int target_leader = pMob[sm->Dam[i].TargetID].Leader;
			if (!target_leader)
				target_leader = sm->Dam[i].TargetID;

			int mob_guild = pMob[mob].MOB.Guild;
			int target_guild = pMob[sm->Dam[i].TargetID].MOB.Guild;

			if (!mob_guild && !target_guild)
				mob_guild = -1;

			if (sm->Dam[i].TargetID < MAX_USER)
			{
				if (pMob[sm->Dam[i].TargetID].GuildDisable)
					target_guild = -2;
			}
			if (mob_leader == target_leader || mob_guild == target_guild)
			{
				pMob[mob].CurrentTarget = 0;
				fisdam = 0;
			}
		}

		sm->Dam[i].Damage = fisdam;
	}
}


void GetGuild(int conn)
{
	STRUCT_ITEM *item = &pMob[conn].MOB.Equip[12];

	int guild = pMob[conn].MOB.Guild;
}

int GetGuild(STRUCT_ITEM *item)
{
	int guild = BASE_GetGuild(item);

	return guild;
}

BOOL GetEmptyItemGrid(int *gridx, int *gridy)
{
	if ((pItemGrid[*gridy][*gridx] == 0) && (pHeightGrid[*gridy][*gridx] != 127))
		return TRUE;

	for (int y = (*gridy) - 1; y <= (*gridy) + 1; y++)
	{
		for (int x = (*gridx) - 1; x <= (*gridx) + 1; x++)
		{
			if (x < 0 || y < 0 || x >= MAX_GRIDX || y >= MAX_GRIDY)
				continue;

			if (pItemGrid[y][x] == 0 && pHeightGrid[y][x] != 127)
			{
				*gridy = y;
				*gridx = x;

				return TRUE;
			}
		}
	}

	return FALSE;
}
//mob yoko
BOOL GetEmptyMobGrid(int mob, int* tx, int* ty)
{
	//int Index, unsigned int* posX, unsigned int* posY
	if (*tx < 0 || *tx >= 4096 || *ty < 0 || *ty >= 4096)
		return false;

	if (pMobGrid[*ty][*tx] == mob)
		return true;

	int LOCAL1 = pMobGrid[*ty][*tx];

	if (LOCAL1 < 0 || LOCAL1 >= MAX_MOB)
	{
		pMobGrid[*ty][*tx] = 0;
		LOCAL1 = 0;
	}

	if (pMob[LOCAL1].Mode == 0)
	{
		pMobGrid[*ty][*tx] = 0;
		LOCAL1 = 0;
	}

	if (LOCAL1 == 0)
	{
		if (pHeightGrid[*ty][*tx] != 127)
			return true;
	}

	for (unsigned int nY = (*ty - 1); nY <= (*ty + 1); nY++)
	{
		for (unsigned int nX = (*tx - 1); nX <= (*tx + 1); nX++)
		{
			if (nX >= 4096 || nY >= 4096)
				continue;

			if (pMobGrid[nY][nX] == 0)
			{
				if (pHeightGrid[nY][nX] != 127)
				{
					*tx = nX;
					*ty = nY;
					return true;
				}
			}
		}
	}

	for (unsigned int nY = (*ty - 2); nY <= (*ty + 2); nY++)
	{
		for (unsigned int nX = (*tx - 2); nX <= (*tx + 2); nX++)
		{
			if (nX >= 4096 || nY >= 4096)
				continue;

			if (pMobGrid[nY][nX] == 0)
			{
				if (pHeightGrid[nY][nX] != 127)
				{
					*tx = nX;
					*ty = nY;
					return true;
				}
			}
		}
	}

	for (unsigned int nY = (*ty - 3); nY <= (*ty + 3); nY++)
	{
		for (unsigned int nX = (*tx - 3); nX <= (*tx + 3); nX++)
		{
			if (nX < 0 || nY < 0 || nX >= 4096 || nY >= 4096)
				continue;

			if (pMobGrid[nY][nX] == 0)
			{
				if (pHeightGrid[nY][nX] != 127)
				{
					*tx = nX;
					*ty = nY;
					return true;
				}
			}
		}
	}

	for (unsigned int nY = (*ty - 4); nY <= (*ty + 4); nY++)
	{
		for (unsigned int nX = (*tx - 4); nX <= (*tx + 4); nX++)
		{
			if (nX < 0 || nY < 0 || nX >= 4096 || nY >= 4096)
				continue;

			if (pMobGrid[nY][nX] == 0)
			{
				if (pHeightGrid[nY][nX] != 127)
				{
					*tx = nX;
					*ty = nY;
					return true;
				}
			}
		}
	}

	for (unsigned int nY = (*ty - 5); nY <= (*ty + 5); nY++)
	{
		for (unsigned int nX = (*tx - 5); nX <= (*tx + 5); nX++)
		{
			if (nX < 0 || nY < 0 || nX >= 4096 || nY >= 4096)
				continue;

			if (pMobGrid[nY][nX] == 0)
			{
				if (pHeightGrid[nY][nX] != 127)
				{
					*tx = nX;
					*ty = nY;
					return true;
				}
			}
		}
	}

	return false;
}

//BOOL GetEmptyMobGrid(int mob, int *tx, int *ty)
//{
//	if (*tx < 0 || *ty < 0 || *tx >= MAX_GRIDX || *ty >= MAX_GRIDY)
//	{
//		Log("GetEmptyMobGridOut of range", "-system", 0);
//
//		return FALSE;
//	}
//
//	if (pMobGrid[*ty][*tx] == mob)
//		return TRUE;
//
//	if (pMobGrid[*ty][*tx] == 0 && pHeightGrid[*ty][*tx] != 127)
//		return TRUE;
//
//	int y = 0;
//	int x = 0;
//
//	for (y = (*ty) - 1; y <= (*ty) + 1; y++)
//	{
//		for (x = (*tx) - 1; x <= (*tx) + 1; x++)
//		{
//			if (x < 0 || y < 0 || x >= MAX_GRIDX || y >= MAX_GRIDY)
//				continue;
//
//			if (pMobGrid[y][x] != 0)
//				continue;
//
//			if (pHeightGrid[*ty][*tx] == 127)
//				continue;
//
//			*ty = y;
//			*tx = x;
//
//			return TRUE;
//		}
//	}
//
//	for (y = (*ty) - 2; y <= (*ty) + 2; y++)
//	{
//		for (x = (*tx) - 2; x <= (*tx) + 2; x++)
//		{
//			if (x < 0 || y < 0 || x >= MAX_GRIDX || y >= MAX_GRIDY)
//				continue;
//
//			if (pMobGrid[y][x] != 0)
//				continue;
//
//			if (pHeightGrid[*ty][*tx] == 127)
//				continue;
//
//			*ty = y;
//			*tx = x;
//
//			return TRUE;
//		}
//	}
//
//	for (y = (*ty) - 3; y <= (*ty) + 3; y++)
//	{
//		for (int x = (*tx) - 3; x <= (*tx) + 3; x++)
//		{
//			if (x < 0 || y < 0 || x >= MAX_GRIDX || y >= MAX_GRIDY)
//				continue;
//
//			if (pMobGrid[y][x] != 0)
//				continue;
//
//			if (pHeightGrid[*ty][*tx] == 127)
//				continue;
//
//			*ty = y;
//			*tx = x;
//
//			return TRUE;
//		}
//	}
//
//	for (y = (*ty) - 4; y <= (*ty) + 4; y++)
//	{
//		for (int x = (*tx) - 4; x <= (*tx) + 4; x++)
//		{
//			if (x < 0 || y < 0 || x >= MAX_GRIDX || y >= MAX_GRIDY)
//				continue;
//
//			if (pMobGrid[y][x] != 0)
//				continue;
//
//			if (pHeightGrid[*ty][*tx] == 127)
//				continue;
//
//			*ty = y;
//			*tx = x;
//
//			return TRUE;
//		}
//	}
//
//	for (y = (*ty) - 5; y <= (*ty) + 5; y++)
//	{
//		for (int x = (*tx) - 5; x <= (*tx) + 5; x++)
//		{
//			if (x < 0 || y < 0 || x >= MAX_GRIDX || y >= MAX_GRIDY)
//				continue;
//
//			if (pMobGrid[y][x] != 0)
//				continue;
//
//			if (pHeightGrid[*ty][*tx] == 127)
//				continue;
//
//			*ty = y;
//			*tx = x;
//
//			return TRUE;
//		}
//	}
//
//	return FALSE;
//}

BOOL GetEmptyMobGridGreat(int mob, int *tx, int *ty)
{
	if (*tx < 0 || *ty < 0 || *tx >= MAX_GRIDX || *ty >= MAX_GRIDY)
	{
		Log("GetEmptyMobGridOut of range", "-system", 0);

		return FALSE;
	}

	if (pMobGrid[*ty][*tx] == mob)
		return TRUE;

	if (pMobGrid[*ty][*tx] == 0 && pHeightGrid[*ty][*tx] != 127)
		return TRUE;

	int y = 0;
	int x = 0;

	for (int k = 0; k < 30; k++)
	{
		for (y = (*ty) - k; y <= (*ty) + k; y++)
		{
			for (x = (*tx) - k; x <= (*tx) + k; x++)
			{
				if (x < 0 || y < 0 || x >= MAX_GRIDX || y >= MAX_GRIDY)
					continue;

				if (pMobGrid[y][x] != 0)
					continue;

				if (pHeightGrid[*ty][*tx] == 127)
					continue;

				*ty = y;
				*tx = x;

				return TRUE;
			}
		}
	}
	return FALSE;
}

int GetCurKill(int conn)
{
	if (conn <= 0 || conn >= MAX_USER)
		return 0;

	unsigned char cv = pMob[conn].MOB.Carry[KILL_MARK].stEffect[0].cValue;

	int ret = cv;

	return ret;
}

int GetTotKill(int conn)
{
	if (conn <= 0 || conn >= MAX_USER)
		return 0;

	unsigned char cv1 = pMob[conn].MOB.Carry[KILL_MARK].stEffect[1].cValue;
	unsigned char cv2 = pMob[conn].MOB.Carry[KILL_MARK].stEffect[2].cValue;

	int ret = cv1 + cv2 * 256;

	return ret;
}

void SetCurKill(int conn, int value)
{
	if (conn <= 0 || conn >= MAX_USER)
		return;

	if (value < 0)
		value = 0;

	if (value > 200)
		value = 200;

	unsigned char cv = value;

	pMob[conn].MOB.Carry[KILL_MARK].stEffect[0].cValue = cv;
}

void SetTotKill(int conn, int value)
{
	if (conn <= 0 || conn >= MAX_USER)
		return;

	if (value < 0)
		value = 0;

	if (value > 32767)
		value = 32767;

	unsigned char cv1 = value % 256;
	unsigned char cv2 = value / 256;

	pMob[conn].MOB.Carry[KILL_MARK].stEffect[1].cValue = cv1;
	pMob[conn].MOB.Carry[KILL_MARK].stEffect[2].cValue = cv2;
}

int	GetPKPoint(int conn)
{
	unsigned char cv = pMob[conn].MOB.Carry[KILL_MARK].stEffect[0].cEffect;

	int ret = cv;

	return ret;
}

int GetGuilty(int conn)
{
	unsigned char cv = pMob[conn].MOB.Carry[KILL_MARK].stEffect[1].cEffect;

	int ret = cv;

	if (ret > 50)
	{
		pMob[conn].MOB.Carry[KILL_MARK].stEffect[1].cEffect = 0;
		ret = 0;
	}

	return ret;
}

void SetGuilty(int conn, int value)
{
	if (conn <= 0 || conn >= MAX_USER)
		return;

	if (value < 0)
		value = 0;

	if (value > 50)
		value = 50;

	unsigned char cv = value;

	pMob[conn].MOB.Carry[KILL_MARK].stEffect[1].cEffect = cv;
}

void SetPKPoint(int conn, int value)
{
	if (conn <= 0 || conn >= MAX_USER)
		return;

	if (value < 1)
		value = 1;

	if (value > 150)
		value = 150;

	unsigned char cv = value;

	pMob[conn].MOB.Carry[KILL_MARK].stEffect[0].cEffect = cv;
}

int GetRecycleBin(int conn, STRUCT_ITEM* kItem, int Price)
{
	if (conn <= 0 || conn >= MAX_USER)
		return 0;

	if (pUser[conn].Mode != USER_PLAY)
		return 0;

	int i = -1;

	for (int k = 0; k < MAX_ITEM_REBUY; k++)
	{
		auto My = pMob[conn].Rebuy[k];

		if (My.Item.sIndex <= 0 || My.Item.sIndex >= MAX_ITEMLIST)
		{
			i = k;

			break;
		}
	}

	if (i == -1)
	{
		for (int k = 0; k < MAX_ITEM_REBUY - 1; k++)
		{
			pMob[conn].Rebuy[k] = pMob[conn].Rebuy[k + 1];
		}

		i = 9;

		pMob[conn].Rebuy[i].Price = Price;
		memcpy(&pMob[conn].Rebuy[i].Item, kItem, sizeof(STRUCT_ITEM));
		pMob[conn].Rebuy[i].Ticks = rand() % 100000;

		return 1;
	}

	pMob[conn].Rebuy[i].Price = Price;
	memcpy(&pMob[conn].Rebuy[i].Item, kItem, sizeof(STRUCT_ITEM));
	pMob[conn].Rebuy[i].Ticks = rand() % 100000;

	return 1;
}

BOOL GetEmptyMobGridShort(int mob, int *tx, int *ty)
{
	if (*tx < 0 || *ty < 0 || *tx >= MAX_GRIDX || *ty >= MAX_GRIDY)
	{
		Log("GetEmptyMobGridOut of range", "-system", 0);

		return FALSE;
	}

	if (pMobGrid[*ty][*tx] == mob)
		return TRUE;

	if (pMobGrid[*ty][*tx] == 0 && pHeightGrid[*ty][*tx] != 127)
		return TRUE;

	int y = 0;
	int x = 0;

	for (y = (*ty) - 4; y <= (*ty) + 4; y++)
	{
		for (x = (*tx) - 4; x <= (*tx) + 4; x++)
		{
			if (x < 0 || y < 0 || x >= MAX_GRIDX || y >= MAX_GRIDY)
				continue;

			if (pMobGrid[y][x] != 0)
				continue;

			if (pHeightGrid[*ty][*tx] == 127)
				continue;

			*ty = y;
			*tx = x;

			return TRUE;
		}
	}
	/*
	for (y = (*ty) - 2; y <= (*ty) + 2; y++)
	{
	for (x = (*tx) - 2; x <= (*tx) + 2; x++)
	{
	if (x < 0 || y < 0 || x >= MAX_GRIDX || y >= MAX_GRIDY)
	continue;

	if (pMobGrid[y][x] != 0)
	continue;

	if (pHeightGrid[*ty][*tx] == 127)
	continue;

	*ty = y;
	*tx = x;

	return TRUE;
	}
	}

	for (y = (*ty) - 3; y <= (*ty) + 3; y++)
	{
	for (int x = (*tx) - 3; x <= (*tx) + 3; x++)
	{
	if (x < 0 || y < 0 || x >= MAX_GRIDX || y >= MAX_GRIDY)
	continue;

	if (pMobGrid[y][x] != 0)
	continue;

	if (pHeightGrid[*ty][*tx] == 127)
	continue;

	*ty = y;
	*tx = x;

	return TRUE;
	}
	}

	for (y = (*ty) - 4; y <= (*ty) + 4; y++)
	{
	for (int x = (*tx) - 4; x <= (*tx) + 4; x++)
	{
	if (x < 0 || y < 0 || x >= MAX_GRIDX || y >= MAX_GRIDY)
	continue;

	if (pMobGrid[y][x] != 0)
	continue;

	if (pHeightGrid[*ty][*tx] == 127)
	continue;

	*ty = y;
	*tx = x;

	return TRUE;
	}
	}
	*/
	return FALSE;
}

int ReadMacList(char* macAddress)
{
	FILE* arq = NULL;
	fopen_s(&arq, "../../Common/MacList.txt", "r");

	if (!arq)
	{
		MessageBoxA(0, "Arquivo não encontrado", "../../Common/MacList.txt", 0);
		ExitProcess(1);
	}

	char line[100];
	memset(&line, 0, 100);

	char mac[25];
	memset(&mac, 0, 25);

	while ((fscanf(arq, "%[^\n]", line)) != EOF)
	{
		fgetc(arq);
		sscanf(line, "%s", &mac);

		if (!strcmp(mac, macAddress))
		{
			fclose(arq);
			return 1;
		}
	}

	fclose(arq);
	return -1;
}

void MacBan(int conn)
{
	if (conn <= NULL || conn >= MAX_USER)
		return;

	FILE* Arquivo;

	fopen_s(&Arquivo, "../../Common/MacList.txt", "a+");

	if (!Arquivo)
	{
		MessageBoxA(0, "Arquivo não encontrado", "../../Common/MacList.txt", 0);
		ExitProcess(1);
		false;
	}

	char update[20];
	memset(update, 0, 20);
	sprintf_s(update, "%s \n", pUser[conn].MacAddress);
	fputs(update, Arquivo);
	fclose(Arquivo);

	CloseUser(conn);
	return;
}

void GetPlayerON()
{
	for (int i = 0; i < MAX_USER; i++)
	{
		if (pUser[i].Mode != USER_PLAY)
			continue; 
	}
}


# -------------------- GetFunc.h --------------------

/*
*   Copyright (C) {2015}  {Victor Klafke, Charles TheHouse}
*
*   This program is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program.  If not, see [http://www.gnu.org/licenses/].
*
*   Contact at: victor.klafke@ecomp.ufsm.br
*/
#ifndef __GETFUNC__
#define __GETFUNC__

#include "..\Basedef.h"
#include <Windows.h>
void MacBan(int conn);
void GetPlayerON();
int ReadMacList(char* macAddress);
int	 GetMatchCombine			(STRUCT_ITEM *item);
int  GetMatchCombineDedekinto	(STRUCT_ITEM *Item);
int  GetMatchCombineEhre		(STRUCT_ITEM *Item);
int  GetMatchCombineTiny		(STRUCT_ITEM *Item);
int  GetMatchCombineShany		(STRUCT_ITEM *Item);
int  GetMatchCombineAilyn		(STRUCT_ITEM *Item);
int  GetMatchCombineAgatha		(STRUCT_ITEM *Item);
int  GetMatchCombineOdin		(STRUCT_ITEM *Item);
int  GetMatchCombineAlquimia	(STRUCT_ITEM *Item);
int  GetMatchCombineEvent		(STRUCT_ITEM* Item);
int  WGetParryRate				(STRUCT_MOB *mob, int add, int attackerdex, int attackrsv);
int  GetParryRate				(STRUCT_MOB *conn, int attackerdex, int attackerrsv, int attackerparry, int defensordex, int defensorrsv, int defensorparry);
int	 GetEmptyAffect				(int mob, int type);  // return value -1 if it's full.
int	 GetHide					(int mob);
int	 GetInView					(int a, int b);
int  GetInHalf					(int a, int b);
int	 GetTeleportPosition		(int conn, int *x, int * y); // returns the cost of the teleport
int	 GetExpApply				(STRUCT_MOBEXTRA extra, int exp, int attacker, int target);
int	 GetCreateMob				(int mob, MSG_CreateMob *sm);
int	 GetCreateMobTrade			(int mob, MSG_CreateMobTrade* sm);
void GetAffect					(unsigned short *out, STRUCT_AFFECT *affect);
void GetCreateItem				(int idx, MSG_CreateItem* sm);
void GetAction					(int mob, int targetx, int targety, MSG_Action* sm);
unsigned char GetAttribute		(int x, int y);
//void GetAttack					(int mob, int target, MSG_AttackOne *sm);
void GetAttack(int mob, int target, p39D* sm);
void GetAttackArea				(int mob, MSG_Attack *sm);
void GetGuild					(int conn);
int  GetGuild					(STRUCT_ITEM *item);
int  GetEmptyItemGrid			(int *gridx, int *gridy);
int	 GetEmptyMobGrid			(int conn, int  *tx, int *ty);
int  GetCurKill					(int conn);
int	 GetTotKill					(int conn);
void SetCurKill					(int conn, int value);
void SetTotKill					(int conn, int value);
int  GetPKPoint					(int conn);
int	 GetGuilty					(int conn);
void SetGuilty					(int conn, int value);
void SetPKPoint					(int conn, int value);
BOOL GetEmptyMobGridGreat		(int mob, int *tx, int *ty);
void TiroDireto					(int Attacker, int Attacked);
int  GetRecycleBin				(int conn, STRUCT_ITEM* kItem, int Price);
BOOL GetEmptyMobGridShort		(int mob, int *tx, int *ty);
bool GetCuboTeleportPositionN	(int conn, int room);
bool GetCuboTeleportPositionM	(int conn, int room);
bool GetCuboTeleportPositionA	(int conn, int room);
int ReadAdminList(char* macAddress);

#endif




# -------------------- IPControl.cpp --------------------

#include "IPControl.h"

std::unique_ptr<IPControl> g_pIPControl;
std::unique_ptr<IPControl> g_pEventoControl;

//g_pIPControl.get()->Initialize();
void IPControl::Initialize()
{
	if (isInitialized)
		return;

	m_pList = std::vector<std::string>{};

	m_pList.clear();

	isInitialized = true;
}

//g_pIPControl.get()->Clear();
void IPControl::Clear()
{
	if (m_pList.size() != 0)
		m_pList.clear();
}

//g_pIPControl.get()->Add(pUser[conn].IP);
void IPControl::Add(unsigned int IP)
{
	if (!isInitialized)
		Initialize();

	char tmp[32] = { 0, };
	sprintf_s(tmp, "%d.%d.%d.%d",
		IP & 0xFF,
		(IP >> 8) & 0xFF,
		(IP >> 16) & 0xFF,
		(IP >> 24) & 0xFF);

	m_pList.push_back(std::string(tmp));
}

void IPControl::Remove(unsigned int IP)
{
	if (!isInitialized)
		Initialize();

	char tmp[32] = { 0, };
	sprintf_s(tmp, "%d.%d.%d.%d",
		IP & 0xFF,
		(IP >> 8) & 0xFF,
		(IP >> 16) & 0xFF,
		(IP >> 24) & 0xFF);

	std::string currentIp = std::string(tmp);

	int i = 0;

	for (auto el : m_pList)
	{
		if (el == currentIp)
		{
			m_pList.erase(m_pList.begin() + i);
			break;
		}

		i++;
	}

	return;
}

//g_pIPControl.get()->Contains(pUser[conn].IP);
bool IPControl::Contains(unsigned int IP)
{
	if (!isInitialized)
		Initialize();

	if (m_pList.size() == 0)
		return false;

	char tmp[32] = { 0, };
	sprintf_s(tmp, "%d.%d.%d.%d",
		IP & 0xFF,
		(IP >> 8) & 0xFF,
		(IP >> 16) & 0xFF,
		(IP >> 24) & 0xFF);

	std::string currentIp = std::string(tmp);

	for (auto i : m_pList)
	{
		if (i == currentIp)
			return true;
	}

	return false;
}

# -------------------- IPControl.h --------------------

#pragma once

#include <string>
#include <vector>
#include <memory>

class IPControl
{
private:
	//List with all IPs registered
	std::vector<std::string> m_pList;

public:
	bool isInitialized;

	//Start the class to clear all unecessary infos
	void Initialize();

	//Add a new IP to the list
	void Add(unsigned int IP);

	//Remove element from vector array
	void Remove(unsigned int IP);

	//Clear the IP List
	void Clear();

	//Check if is in the list
	bool Contains(unsigned int IP);

};

extern std::unique_ptr<IPControl> g_pIPControl;
extern std::unique_ptr<IPControl> g_pEventoControl;

# -------------------- ItemLevel.cpp --------------------

#pragma once

#include "ProcessClientMessage.h"
#include <iostream>
#include <cstdlib>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <random>
#include <ctime>
#include "SendFunc.h"
#include "Functions.h"

void ItemLevel(int conn, char* pMsg)
{
	if (conn <= 0 || conn >= MAX_USER)
		return;

	if (pUser[conn].Mode != USER_PLAY)
		return;

	if (pUser[conn].cSock.Sock == 0)
		return;

	MSG_SendItemLevel* m = (MSG_SendItemLevel*)pMsg;

	int Size = m->Size;

	if (Size > sizeof(MSG_SendItemLevel)) //CONTROLE DE SIZE
	{
		SendClientMessage(conn, "Impossível executar ação, tente mais tarde.");
		return;
	}

	if (m->Qnt <= 0 || m->Qnt > 120)
		return;

	if (m->Item <= 0 || m->Item >= MAX_ITEMLIST)
		return;

	if (pMob[conn].extra.ClassMaster != 2) {
		pUser[conn].chave1 = 99;
		return;
	}
		

	if (pUser[conn].chave1 == 0 && pMob[conn].MOB.BaseScore.Level >= 0) {
		if (m->Item < 938 || m->Item > 945)
			return;

		if ((m->Item == 938 || m->Item == 939) && m->Qnt != 2)
			return;

		int Qnt = m->Qnt;

		if (m->Item != 938 && m->Item != 939)
			Qnt = 1;

		int SlotId = 0;
		for (int i = 0; i < pMob[conn].MaxCarry; i++)
		{
			if (pMob[conn].MOB.Carry[i].sIndex == 0)
			{
				SlotId++;
			}
		}
		if (SlotId < 2) {
			SendClientMessage(conn, "Você não possuí espaço para receber");
			return;
		}

		pUser[conn].chave1 = 1;

		STRUCT_ITEM item;
		memset(&item, 0, sizeof(STRUCT_ITEM));
		item.sIndex = m->Item;
		item.stEffect[0].cEffect = 43;
		item.stEffect[0].cValue = 0;
		item.stEffect[1].cEffect = 0;
		item.stEffect[1].cValue = 0;
		item.stEffect[2].cEffect = 0;
		item.stEffect[2].cValue = 0;

		while (Qnt >= 1) {
			PutItem(conn, &item);
			Qnt--;
		}
		SendEtc(conn);
		SendCarry(conn);
		SaveUser(conn, 0);
		return;
	}
	if (pUser[conn].chave1 == 1 && pMob[conn].MOB.BaseScore.Level >= 0)
	{
		if (m->Item != 3980 || m->Qnt != 1)
			return;

		int Qnt = m->Qnt;

		int SlotId = 0;
		for (int i = 0; i < pMob[conn].MaxCarry; i++)
		{
			if (pMob[conn].MOB.Carry[i].sIndex == 0)
			{
				SlotId++;
			}
		}
		if (SlotId < 2) {
			SendClientMessage(conn, "Você não possuí espaço para receber");
			return;
		}

		STRUCT_ITEM item;
		memset(&item, 0, sizeof(STRUCT_ITEM));
		item.sIndex = m->Item;
		item.stEffect[0].cEffect = 0;
		item.stEffect[0].cValue = 0;
		item.stEffect[1].cEffect = 0;
		item.stEffect[1].cValue = 0;
		item.stEffect[2].cEffect = 0;
		item.stEffect[2].cValue = 0;


		while (Qnt >= 1) {
			PutItem(conn, &item);
			Qnt--;
		}
		pUser[conn].chave1 = 2;

		// Buff de Bau de XP e Frango Novato
		/*int sAffect = GetEmptyAffect(conn, 30);

		pMob[conn].Affect[sAffect].Type = 30;
		pMob[conn].Affect[sAffect].Level = 2000;
		pMob[conn].Affect[sAffect].Value = 0;
		pMob[conn].Affect[sAffect].Time += AFFECT_1H * 4;

		if (pMob[conn].Affect[sAffect].Time >= 324000)
			pMob[conn].Affect[sAffect].Time = 324000;

		int sAffect2 = GetEmptyAffect(conn, 39);

		pMob[conn].Affect[sAffect2].Type = 39;
		pMob[conn].Affect[sAffect2].Level = 0;
		pMob[conn].Affect[sAffect2].Value = 0;
		pMob[conn].Affect[sAffect2].Time += AFFECT_1H * 4;

		pMob[conn].GetCurrentScore(conn);*/


		SendScore(conn);
		SendEtc(conn);
		SendCarry(conn);				
		SaveUser(conn, 0);
		return;
	}
	if (pUser[conn].chave1 == 2 && pMob[conn].MOB.BaseScore.Level >= 113)
	{
		if (m->Item != 2373 && m->Item != 2368)
			return;

		STRUCT_ITEM Item1, Item2;
		memset(&Item1, 0, sizeof(STRUCT_ITEM));

		int x = 0;
		int invfree = 0;

		for (x = 0; x < pMob[conn].MaxCarry; x++)
		{
			if (pMob[conn].MOB.Carry[x].sIndex == 0)
				invfree++;
		}
		if (invfree < 3)
		{
			SendClientMessage(conn, "Não há espaço suficiente no inventário");
			return;
		}

		//level b
		Item1.sIndex = m->Item;
		Item1.stEffect[0].cEffect = 10;
		Item1.stEffect[0].cValue = 10;
		Item1.stEffect[1].cEffect = 10;
		Item1.stEffect[1].cValue = 10;
		Item1.stEffect[2].cEffect = 100;
		Item1.stEffect[2].cValue = 0;

		pUser[conn].chave1 = 3;
		PutItem(conn, &Item1);
		SendEtc(conn);
		SendCarry(conn);		
		SaveUser(conn, 0);
		return;
	}
	if (pUser[conn].chave1 == 3 && pMob[conn].MOB.BaseScore.Level >= 124)
	{
		if (m->Item < 1207 && m->Item > 1654)
			return;

		STRUCT_ITEM Item[5];
		memset(&Item[0], 0, sizeof(STRUCT_ITEM));
		memset(&Item[1], 0, sizeof(STRUCT_ITEM));
		memset(&Item[2], 0, sizeof(STRUCT_ITEM));
		memset(&Item[3], 0, sizeof(STRUCT_ITEM));
		memset(&Item[4], 0, sizeof(STRUCT_ITEM));

		int x = 0;
		int invfree = 0;

		for (x = 0; x < pMob[conn].MaxCarry; x++)
		{
			if (pMob[conn].MOB.Carry[x].sIndex == 0)
				invfree++;
		}
		if (invfree < 6)
		{
			SendClientMessage(conn, "Não há espaço suficiente no inventário");
			return;
		}
		//CLASSES: 0=TK, 1=FM, 2=BM, 3=HT
		if (pMob[conn].MOB.Class == 0) {
			Item[0].sIndex = 1216;
			Item[1].sIndex = 1219;
			Item[2].sIndex = 1207;
			Item[3].sIndex = 1213;
			Item[4].sIndex = 1210;
			for (int i = 0; i < 5; i++) {
				Item[i].stEffect[0].cEffect = 43;
				Item[i].stEffect[0].cValue = 3;
				Item[i].stEffect[1].cEffect = 0;
				Item[i].stEffect[1].cValue = 0;
				Item[i].stEffect[2].cEffect = 0;
				Item[i].stEffect[2].cValue = 0;
				PutItem(conn, &Item[i]);
			}
		}
		if (pMob[conn].MOB.Class == 1) {
			Item[0].sIndex = 1351;
			Item[1].sIndex = 1354;
			Item[2].sIndex = 1342;
			Item[3].sIndex = 1348;
			Item[4].sIndex = 1345;
			for (int i = 0; i < 5; i++) {
				Item[i].stEffect[0].cEffect = 43;
				Item[i].stEffect[0].cValue = 3;
				Item[i].stEffect[1].cEffect = 0;
				Item[i].stEffect[1].cValue = 0;
				Item[i].stEffect[2].cEffect = 0;
				Item[i].stEffect[2].cValue = 0;
				PutItem(conn, &Item[i]);
			}
		}
		if (pMob[conn].MOB.Class == 2) {
			Item[0].sIndex = 1501;
			Item[1].sIndex = 1504;
			Item[2].sIndex = 1492;
			Item[3].sIndex = 1498;
			Item[4].sIndex = 1495;
			for (int i = 0; i < 5; i++) {
				Item[i].stEffect[0].cEffect = 43;
				Item[i].stEffect[0].cValue = 3;
				Item[i].stEffect[1].cEffect = 0;
				Item[i].stEffect[1].cValue = 0;
				Item[i].stEffect[2].cEffect = 0;
				Item[i].stEffect[2].cValue = 0;
				PutItem(conn, &Item[i]);
			}
		}
		if (pMob[conn].MOB.Class == 3) {
			Item[0].sIndex = 1651;
			Item[1].sIndex = 1654;
			Item[2].sIndex = 1642;
			Item[3].sIndex = 1648;
			Item[4].sIndex = 1645;
			for (int i = 0; i < 5; i++) {
				Item[i].stEffect[0].cEffect = 43;
				Item[i].stEffect[0].cValue = 3;
				Item[i].stEffect[1].cEffect = 0;
				Item[i].stEffect[1].cValue = 0;
				Item[i].stEffect[2].cEffect = 0;
				Item[i].stEffect[2].cValue = 0;
				PutItem(conn, &Item[i]);
			}
		}
		pUser[conn].chave1 = 4;
		SendEtc(conn);
		SendCarry(conn);
		SaveUser(conn, 0);
		return;
	}
	if (pUser[conn].chave1 == 4 && pMob[conn].MOB.BaseScore.Level >= 143)
	{
		if (m->Item != 854 && m->Item != 809 && m->Item != 2127 && m->Item != 2122)
			return;

		STRUCT_ITEM Item[2];
		memset(&Item[0], 0, sizeof(STRUCT_ITEM));
		memset(&Item[1], 0, sizeof(STRUCT_ITEM));

		int x = 0;
		int invfree = 0;

		for (x = 0; x < pMob[conn].MaxCarry; x++)
		{
			if (pMob[conn].MOB.Carry[x].sIndex == 0)
				invfree++;
		}
		if (invfree < 3)
		{
			SendClientMessage(conn, "Não há espaço suficiente no inventário");
			return;
		}
		//CLASSES: 0=TK, 1=FM, 2=BM, 3=HT
		if (pMob[conn].MOB.Class == 0) {

			//MAGO
			if (pMob[conn].MOB.BaseScore.Int > (pMob[conn].MOB.BaseScore.Dex + pMob[conn].MOB.BaseScore.Str)) {
				Item[0].sIndex = 854;
				Item[0].stEffect[0].cEffect = 43;
				Item[0].stEffect[0].cValue = 5;
				Item[0].stEffect[1].cEffect = 60;
				Item[0].stEffect[1].cValue = 16;
				Item[0].stEffect[2].cEffect = 0;
				Item[0].stEffect[2].cValue = 0;
				PutItem(conn, &Item[0]);
			}
			//DANO
			if (pMob[conn].MOB.BaseScore.Int < (pMob[conn].MOB.BaseScore.Dex + pMob[conn].MOB.BaseScore.Str)) {
				Item[0].sIndex = 809;
				Item[1].sIndex = 809;

				for (int i = 0; i < 2; i++) {
					Item[i].stEffect[0].cEffect = 43;
					Item[i].stEffect[0].cValue = 5;
					Item[i].stEffect[1].cEffect = 2;
					Item[i].stEffect[1].cValue = 36;
					Item[i].stEffect[2].cEffect = 0;
					Item[i].stEffect[2].cValue = 0;
					PutItem(conn, &Item[i]);
				}
			}
		}
		if (pMob[conn].MOB.Class == 1) {
			//MAGO
			if (pMob[conn].MOB.BaseScore.Int > (pMob[conn].MOB.BaseScore.Dex + pMob[conn].MOB.BaseScore.Str)) {
				Item[0].sIndex = 2127;
				Item[0].stEffect[0].cEffect = 43;
				Item[0].stEffect[0].cValue = 5;
				Item[0].stEffect[1].cEffect = 60;
				Item[0].stEffect[1].cValue = 16;
				Item[0].stEffect[2].cEffect = 0;
				Item[0].stEffect[2].cValue = 0;
				PutItem(conn, &Item[0]);
			}
			//DANO
			if (pMob[conn].MOB.BaseScore.Int < (pMob[conn].MOB.BaseScore.Dex + pMob[conn].MOB.BaseScore.Str)) {
				Item[0].sIndex = 2122;
				Item[0].stEffect[0].cEffect = 43;
				Item[0].stEffect[0].cValue = 5;
				Item[0].stEffect[1].cEffect = 2;
				Item[0].stEffect[1].cValue = 36;
				Item[0].stEffect[2].cEffect = 0;
				Item[0].stEffect[2].cValue = 0;
				PutItem(conn, &Item[0]);
			}
		}
		if (pMob[conn].MOB.Class == 2) {
			//MAGO
			if (pMob[conn].MOB.BaseScore.Int > (pMob[conn].MOB.BaseScore.Dex + pMob[conn].MOB.BaseScore.Str)) {
				Item[0].sIndex = 854;
				Item[0].stEffect[0].cEffect = 43;
				Item[0].stEffect[0].cValue = 5;
				Item[0].stEffect[1].cEffect = 60;
				Item[0].stEffect[1].cValue = 16;
				Item[0].stEffect[2].cEffect = 0;
				Item[0].stEffect[2].cValue = 0;
				PutItem(conn, &Item[0]);
			}
			//DANO
			if (pMob[conn].MOB.BaseScore.Int < (pMob[conn].MOB.BaseScore.Dex + pMob[conn].MOB.BaseScore.Str)) {
				Item[0].sIndex = 809;
				Item[1].sIndex = 809;

				for (int i = 0; i < 2; i++) {
					Item[i].stEffect[0].cEffect = 43;
					Item[i].stEffect[0].cValue = 5;
					Item[i].stEffect[1].cEffect = 2;
					Item[i].stEffect[1].cValue = 36;
					Item[i].stEffect[2].cEffect = 0;
					Item[i].stEffect[2].cValue = 0;
					PutItem(conn, &Item[i]);
				}
			}
		}
		if (pMob[conn].MOB.Class == 3) {
			Item[0].sIndex = 2122;
			Item[0].stEffect[0].cEffect = 43;
			Item[0].stEffect[0].cValue = 5;
			Item[0].stEffect[1].cEffect = 2;
			Item[0].stEffect[1].cValue = 36;
			Item[0].stEffect[2].cEffect = 0;
			Item[0].stEffect[2].cValue = 0;
			PutItem(conn, &Item[0]);
		}
		pUser[conn].chave1 = 5;
		SendEtc(conn);
		SaveUser(conn, 0);
		return;
	}
	if (pUser[conn].chave1 == 5 && pMob[conn].MOB.BaseScore.Level >= 255)
	{
		STRUCT_ITEM Item[5];
		memset(&Item[0], 0, sizeof(STRUCT_ITEM));
		memset(&Item[1], 0, sizeof(STRUCT_ITEM));
		memset(&Item[2], 0, sizeof(STRUCT_ITEM));

		int x = 0;
		int invfree = 0;

		for (x = 0; x < pMob[conn].MaxCarry; x++)
		{
			if (pMob[conn].MOB.Carry[x].sIndex == 0)
				invfree++;
		}
		if (invfree < 6)
		{
			SendClientMessage(conn, "Não há espaço suficiente no inventário");
			return;
		}
		//CLASSES: 0=TK, 1=FM, 2=BM, 3=HT
		if (pMob[conn].MOB.Class == 0) {

			//MAGO
			if (pMob[conn].MOB.BaseScore.Int > (pMob[conn].MOB.BaseScore.Dex + pMob[conn].MOB.BaseScore.Str)) {
				Item[0].sIndex = 3566;
				Item[0].stEffect[0].cEffect = 43;
				Item[0].stEffect[0].cValue = 5;
				Item[0].stEffect[1].cEffect = 60;
				Item[0].stEffect[1].cValue = 16;
				Item[0].stEffect[2].cEffect = 0;
				Item[0].stEffect[2].cValue = 0;
				PutItem(conn, &Item[0]);
			}
			//DANO
			if (pMob[conn].MOB.BaseScore.Int < (pMob[conn].MOB.BaseScore.Dex + pMob[conn].MOB.BaseScore.Str)) {
				Item[0].sIndex = 3551;
				Item[1].sIndex = 3551;

				for (int i = 0; i < 2; i++) {
					Item[i].stEffect[0].cEffect = 43;
					Item[i].stEffect[0].cValue = 5;
					Item[i].stEffect[1].cEffect = 2;
					Item[i].stEffect[1].cValue = 36;
					Item[i].stEffect[2].cEffect = 0;
					Item[i].stEffect[2].cValue = 0;
					PutItem(conn, &Item[i]);
				}
			}
		}
		if (pMob[conn].MOB.Class == 1) {
			//MAGO
			if (pMob[conn].MOB.BaseScore.Int > (pMob[conn].MOB.BaseScore.Dex + pMob[conn].MOB.BaseScore.Str)) {
				Item[0].sIndex = 3582;
				Item[0].stEffect[0].cEffect = 43;
				Item[0].stEffect[0].cValue = 5;
				Item[0].stEffect[1].cEffect = 60;
				Item[0].stEffect[1].cValue = 16;
				Item[0].stEffect[2].cEffect = 0;
				Item[0].stEffect[2].cValue = 0;
				PutItem(conn, &Item[0]);
			}
			//DANO
			if (pMob[conn].MOB.BaseScore.Int < (pMob[conn].MOB.BaseScore.Dex + pMob[conn].MOB.BaseScore.Str)) {
				Item[0].sIndex = 3556;
				Item[0].stEffect[0].cEffect = 43;
				Item[0].stEffect[0].cValue = 5;
				Item[0].stEffect[1].cEffect = 2;
				Item[0].stEffect[1].cValue = 36;
				Item[0].stEffect[2].cEffect = 0;
				Item[0].stEffect[2].cValue = 0;
				PutItem(conn, &Item[0]);
			}
		}
		if (pMob[conn].MOB.Class == 2) {
			//MAGO
			if (pMob[conn].MOB.BaseScore.Int > (pMob[conn].MOB.BaseScore.Dex + pMob[conn].MOB.BaseScore.Str)) {
				Item[0].sIndex = 3566;
				Item[0].stEffect[0].cEffect = 43;
				Item[0].stEffect[0].cValue = 5;
				Item[0].stEffect[1].cEffect = 60;
				Item[0].stEffect[1].cValue = 16;
				Item[0].stEffect[2].cEffect = 0;
				Item[0].stEffect[2].cValue = 0;
				PutItem(conn, &Item[0]);
			}
			//DANO
			if (pMob[conn].MOB.BaseScore.Int < (pMob[conn].MOB.BaseScore.Dex + pMob[conn].MOB.BaseScore.Str)) {
				Item[0].sIndex = 3551;
				Item[1].sIndex = 3551;

				for (int i = 0; i < 2; i++) {
					Item[i].stEffect[0].cEffect = 43;
					Item[i].stEffect[0].cValue = 5;
					Item[i].stEffect[1].cEffect = 2;
					Item[i].stEffect[1].cValue = 36;
					Item[i].stEffect[2].cEffect = 0;
					Item[i].stEffect[2].cValue = 0;
					PutItem(conn, &Item[i]);
				}
			}
		}
		if (pMob[conn].MOB.Class == 3) {
			Item[0].sIndex = 3556;
			Item[0].stEffect[0].cEffect = 43;
			Item[0].stEffect[0].cValue = 5;
			Item[0].stEffect[1].cEffect = 2;
			Item[0].stEffect[1].cValue = 36;
			Item[0].stEffect[2].cEffect = 0;
			Item[0].stEffect[2].cValue = 0;
			PutItem(conn, &Item[0]);
		}
		pUser[conn].chave1 = 6;
		SendEtc(conn);
		SaveUser(conn, 0);
		return;
	}
}


# -------------------- Language.h --------------------

/*
*   Copyright (C) {2015}  {Victor Klafke, Charles TheHouse}
*
*   This program is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program.  If not, see [http://www.gnu.org/licenses/].
*
*   Contact at: victor.klafke@ecomp.ufsm.br
*/
#pragma once

#define _NN_Get_Skill_Point 1
#define _NN_Weapon_Enchanted 2
#define _NN_Get_Watching_Town_Mission 3
#define _NN_Watching_Town_Success 4
#define _NN_Watching_Town_Awarded 5
#define _NN_Qest06Complete 6
#define _NN_Qest07Complete 7
#define _NN_Qest08Complete 8
#define _NN_Qest09Complete 9
#define _NN_Qest10Complete 10
#define _NN_Qest11Complete 11
#define _NN_Qest12Complete 12
#define _NN_Qest13Complete 13
#define _NN_Qest14Complete 14
#define _NN_Qest15Complete 15
#define _NN_Qest16Complete 16
#define _NN_ServerRebootAfter_1minute 17
#define _NN_Rerun_Game_For_Auto_Patch 18
#define _NN_ServerReboot_After_30Sec 19
#define _NN_ServerReboot_Takes_10min 20
#define _NN_ServerReboot_After_10Sec 21
#define _NN_ServerReboot_Now 22
#define _NN_Bad_Network_Packets 23
#define _NN_Only_Guild_Master_can 24
#define _NN_Champions_Cant_Challange 25
#define _NN_Last_Challange_Cant 26
#define _NN_Allready_Challanged 27
#define _NN_Cant_Get_More_Challanger 28
#define _NN_Need_Sign_Of_Challanger 29
#define _NN_Challanged 30
#define _NN_Cant_Create_More_Summons 31
#define _NN_1_Kind_Summon_in_1_Party 32
#define _NN_Party_Full_Cant_Summon 33
#define _NN_SelectCharacter 34
#define _NN_ServerReboot_Cant_Connect 35
#define _NN_Version_Not_Match_Rerun 36
#define _NN_3_Tims_Wrong_Pass 37
#define _NN_Wait_Checking_Billing 38
#define _DN_Not_Allowed_Account 39
#define _NN_Using_Other_Server_Group 40
#define _NN_Wait_Checking_Billing_t 41
#define _NN_Not_Allowed_Account_t 42
#define _NN_Using_Other_Server_Group_t 43
#define _NN_Cant_Deposit_That_Much 44
#define _NN_Cant_Withdraw_That_Much 45
#define _NN_Newbie_zone 46
#define _NN_Only_Guild_Members 47
#define _NN_Cant_Summon_Dead_Person 48
#define _NN_Summon_Not_Allowed_Here 49
#define _NN_Too_High_Level_To_Summon 50
#define _NN_Not_Enough_Mana 51
#define _SN_Summoned_By_S 52
#define _NN_Level_Up 53
#define _NN_3_Quarters_Bonus 54
#define _NN_2_Quarters_Bonus 55
#define _NN_1_Quarters_Bonus 56
#define _SS_Champion_And_Challanger 57
#define _SN_No_Challanger 58
#define _SN_Winner_Is 59
#define _NN_Teleport_Gate_Requir 60
#define _SN_I_Wwill_Enchant_Your_Weapon 61
#define _NN_Gather_7_Clistals 62
#define _NN_Equip_Weapon_To_Enchant 63
#define _NN_Only_Nomal_Weapons 64
#define _SN_Now_I_Will_Enchant_Your 65
#define _SN_All_Villagers_Thanks_Your 66
#define _NN_Give_You_Some_Reward 67
#define _NN_Guard_This_Village 68
#define _NN_Monster_Attaking_Us_Help 69
#define _NN_Thanks_for_Helping_us 70
#define _NN_Youve_Done_It_Already 71
#define _NN_Cant_Drop_Here 72
#define _NN_Guild_Medal_Cant_Be_Droped 73
#define _NN_Only_To_Equips 74
#define _NN_Cant_Refine_More 75
#define _NN_Fail_To_Refine 76
#define _NN_Fail_To_Level_Up 77
#define _NN_No_Return_Point 78
#define _NN_No_Key 79
#define _NN_Wrong_Trade_Packet1 80
#define _NN_Only_With_Guild_Master 81
#define _NN_Already_Trading 82
#define _NN_Havent_Money_So_Much 83
#define _NN_Opponent_Havent_Money 84
#define _NN_Each_Of_You_Havent_Space 85
#define _NN_You_Have_No_Space_To_Trade 86
#define _NN_Opponent_Have_No_Space_To 87
#define _NN_Wrong_Trade_Packet2 88
#define _NN_Summon 89
#define _NN_Cant_Use_Killed 90
#define _NN_Not_Connected 91
#define _NN_Cant_Use_To_Yourself 92
#define _NN_Cant_Use_To_Killed 93
#define _NN_Only_To_Party_Or_Guild 94
#define _NN_Didnt_Learn_Summon_Skill 95
#define _NN_Cant_Use_That_Here 96
#define _NN_Too_High_Level 97
#define _SN_Summoned_By_S2 98
#define _NN_Relocate 99
#define _SN_S_Relocate_To_You 100
#define _NN_Reply 101
#define _NN_No_One_To_Reply 102
#define _SN_S_is_Connected 103
#define _NN_Only_Guild_Member_Can 104
#define _NN_Maximum_Point_Now 105
#define _NN_Maximum_Point_200_Now 106
#define _NN_Cant_Learn_Other_Class_Skill 107
#define _NN_Not_Enough_Skill_Point 108
#define _NN_Already_Learned_It 109
#define _NN_Need_More_Level_To_Learn 110
#define _NN_Need_More_Mastery_To_Learn 111
#define _NN_Only_Merchant_Sells 112
#define _NN_Not_Enough_Money 113
#define _NN_Only_Guild_Master_Can_Buy_It 114
#define _NN_He_Is_Not_Merchant 115
#define _NN_Only_Merchant_Buy_Yours 116
#define _NN_Dropped_Current_Party_First2 117
#define _NN_Not_Connected2 118
#define _NN_Other_Partys_Member 119
#define _NN_Have_Own_Party_Already 120
#define _NN_Dropped_Current_Party_First 121
#define _NN_Partys_Full 122
#define _DN_Billing_Code 123
#define _DN_Billing_Notice1 124
#define _DD_Billing_Notice2 125
#define _NN_Billing_Notice3 126
#define _NN_Billing_Notice4 127
#define _NN_Billing_Notice5 128
#define _NN_Billing_Notice6 129
#define _NN_Try_Reconnect 130
#define _NN_No_Account_With_That_Name 131
#define _SN_Blocked_Account 132
#define _NN_Wrong_Password 133
#define _NN_Your_Account_From_Others 134
#define _NN_Guild_Battle_Notice1 135
#define _NN_Guild_Battle_Notice2 136
#define _NN_Guild_Battle_Notice3 137
#define _NN_Guild_Battle_Notice4 138
#define _NN_Guild_Battle_Notice5 139
#define _NN_Guild_Battle_Notice6 140
#define _NN_Below_lv20_No_Exp_Loss 141
#define _DN_lose_D_exp 142
#define _NN_In_Arena_No_Exp_Loss 143
#define _NN_Only_Guild_Master_Can 144
#define _NN_Disqualified_By_Guild_Master 145
#define _NN_Disqualify 146
#define _NN_Haven_Guild_Medal 147
#define _NN_Deprivate 148
#define _NN_CarryFull 149
#define _NN_Equip_Particle 150
#define _NN_Purify_Particle 151
#define _NN_Need_1000000_Gold 152
#define _NN_Hurry_Helping_them 153
#define _NN_Party_Only 154
#define _NN_Need_Pure_Divine 155
#define _NN_Initialize_Skill 156
#define _NN_Need_10_Particle 157
#define _NN_Processing_Complete 158
#define _DD_Billing_Notice7 159
#define _DN_Billing_Notice8 160
#define _NN_Disabled_Account 161
#define _NN_No_Guild_Members 162
#define _SN_CastleQuest_Killed 163
#define _NN_CastleQuest_Initialize 164
#define _NN_Deny_Whisper 165
#define _NN_Need_5000000_Gold 166
#define _NN_Cant_Sell_Potion 167
#define _NN_Guild_Tax_0_to_30 168
#define _DD_Set_Guild_Tax 169
#define _NN_CantWhenAutoTrade 170
#define _NN_ItemSold 171
#define _NN_OnlyVillage 172
#define _NN_Only_Named_Guild 173
#define _NN_Only_Once_Per_Day 174
#define _SSD_S_get_S_D 175
#define _NN_Refine_Success 176
#define _DN_Need_D_Sapphire 177
#define _NN_My_King_Bless1 178
#define _NN_My_King_Bless2 179
#define _NN_Need_Level 180
#define _NN_King1_Killed 181
#define _NN_King2_Killed 182
#define _DN_get_D_exp 183
#define _NN_Kingdom 184
#define _NN_King 185
#define _NN_Set_Warp 186
#define _DS_S_Challanged 187
#define _NN_Need_Master 188
#define _DN_Need_D_Sapphire2 189
#define _NN_Need_Guild_Medal 190
#define _NN_Reconnect 191
#define _DN_Need_1000000_For_Challange 192
#define _NN_Battle_In_Progress 193
#define _NN_Battle_Started 194
#define _SS_S_Killed_By_S 195
#define _SS_S_WinBy_S 196
#define _SS_S_S_Draw 197
#define _SSD_S_get_S 198
#define _NN_Leaving_kingdom 199
#define _NN_Next_Chance 200
#define _NN_Congratulations 201
#define _NN_Stat_Initialized 202
#define _DN_Want_Stat_Init 203
#define _DN_D_Cost 204
#define _NN_Cant_with_armor 205
#define _NN_Child_Pay 206
#define _DD_PKPointPlus 207
#define _DD_PKPointMinus 208
#define _DN_CantKillUser 209
#define _SS_War_Declared 210
#define _SS_War_Started 211
#define _SS_War_Canceled 212
#define _NN_War_Stop 213
#define _NN_Cant_Declare_War 214
#define _NN_Party_Level_Limit 215
#define _NN_Summon_Guild 216
#define _NN_Only_Village 217
#define _SN_Your_are_at_war 218
#define _SN_War_to_S 219
#define _SN_War_from_S 220
#define _SS_War_declare_canceled 221
#define _SD_Zakum_Quest_by_S_N 222
#define _NN_Zakum_Quest_empty 223
#define _NN_Only_Level1_Armor 224
#define _NN_Only_Level2_Armor 225
#define _NN_Only_Level3_Armor 226
#define _NN_Only_Level4_Armor 227
#define _NN_Only_By_Water_Scroll 228
#define _NN_Party_Leader_Only 229
#define _NN_NewbieQuest_Already1 230
#define _NN_NewbieQuest_Cheerup1 231
#define _NN_NewbieQuest_Complete1 232
#define _NN_NewbieQuest_Reward1 233
#define _NN_NewbieQuest_Already2 234
#define _NN_NewbieQuest_Cheerup2 235
#define _NN_NewbieQuest_Complete2 236
#define _NN_NewbieQuest_Reward2 237
#define _NN_NewbieQuest_Already3 238
#define _NN_NewbieQuest_Cheerup3 239
#define _NN_NewbieQuest_Complete3 240
#define _NN_NewbieQuest_Reward3 241
#define _NN_NewbieQuest_Already4 242
#define _NN_NewbieQuest_Cheerup4 243
#define _NN_NewbieQuest_Complete4 244
#define _NN_NewbieQuest_Reward4 245
#define _NN_BR_Start1 246
#define _NN_BR_Start2 247
#define _NN_BR_Start3 248
#define _NN_BR_Rewarded 249
#define _NN_BR_Ready1 250
#define _NN_BR_Ready2 251
#define _NN_BR_Ready3 252
#define _NN_INCUBATED 253
#define _NN_Cant_Upgrade_More 254
#define _NN_Mount_Growth 255
#define _NN_Mount_Not_Match 256
#define _NN_Cure_animals 257
#define _DS_S_cure_price_D 258
#define _NN_Cured 259
#define _NN_Cure_failed 260
#define _NN_Incu_Wait_More 261
#define _NN_Incu_Proceed 262
#define _NN_Mount_Level 263
#define _NN_Mount_died 264
#define _NN_3rd_village_limit 265
#define _NN_Only_Sunday 266
#define _NN_Treasure_Map 267
#define _NN_TicketUsed 268
#define _NN_CombineFailed 269
#define _SS_CombineSucceed 270
#define _NN_Wrong_Combination 271
#define _NN_Item_Arrived 272
#define _NN_Cant_get_more_than_2G 273
#define _SN_Learn_Sephera 274
#define _DN_Castle_will_be_open 275
#define _DN_Castle_opened 276
#define _DN_Castle_will_be_closed 277
#define _DN_Castle_closed 278
#define _NN_Only_when_castle_war 279
#define _SN_S_is_charging_castle 280
#define _SN_S_charge_castle 281
#define _NN_Only_same_kingdom 282
#define _SN_Ally_to_S 283
#define _SN_Ally_from_S 284
#define _NN_Ally_Stop 285
#define _SS_Ally_Canceled 286
#define _SS_Ally_Declared 287
#define _NN_Cant_Declare_Ally 289
#define _SSNN_GuildWarResult 290
#define _NN_Need_5_materials 291
#define _NN_snowimp_create_success 292
#define _NN_snowimp_need_2MGold 293
#define _DN_receive_D_gold 294
#define _NN_Someone_is_on_quest 295
#define _NN_Only_at_tor_alter 296
#define _NN_Only_quiz_time 297
#define _NN_Level_limit 298
#define _NN_Message_Sent 299
#define _NN_New_Class_quest 300
#define _NN_New_Class_quest_Lv 301
#define _NN_Set_Soul 302
#define _NN_Soul_Merged 303
#define _NN_Go_to_skill_master 304
#define _NN_Sepherot_created 305
#define _NN_VS_Server 306
#define _NN_NoEmptySlot 307
#define _NN_NewCharacter 308
#define _NN_Soul_n_8_Sephera 309
#define _NN_Congratulations_Trans 310
#define _NN_Need_8_Sephera 311
#define _NN_Cant_in_castle_war 312
#define _NN_SameCharAlready 313
#define _NN_NeedMoreExp 314
#define _NN_BelongToS 315
#define _NN_You_get_the_Apple 316
#define _NN_Already_you_have 317
#define _DD_Correct_answer 318
#define _DD_Incorrect_answer 319
#define _NN_YouNeedTicket 320
#define _NN_Incorrect_kicked 321
#define _NN_Quiz_Cleared 322
#define _NN_Only_By_Quiz_Scroll 323
#define _NN_Only_at_south_of 324
#define _NN_VS_Battle 325
#define _NN_Party_Battle1 326
#define _NN_Party_Battle2 327
#define _NN_Party_Battle3 328
#define _NN_Guild_Battle 329
#define _NN_You_need_feeding_mount 330
#define _NN_Cant_trade_pkmode 331
#define _NN_No_Lotto_Result_Yet 332
#define _NN_Lotto_No_0 333
#define _NN_Lotto_No_1 334
#define _NN_Lotto_No_2 335
#define _NN_Lotto_No_3 336
#define _DN_Lotto_No_4 337
#define _NN_Lotto_No_5 338
#define _NN_FromMonday 339
#define _NN_Level_Limit2 340
#define _DN_LottoResult 341
#define _NN_HitNumber 342
#define _NN_SelectedNumber 343
#define _SD_NoticeLotto 344
#define _NN_CantEatMore 345
#define _NN_SameLevelOnly 346
#define _NN_Need_Elixer 347
#define _NN_Quiz2_Cleared 348
#define _NN_Night_Limited 349
#define _NN_Night_Already 350
#define _NN_Water_Cleared 351
#define _NN_Chat_Prohibition 352
#define _NN_No_Speak 353
#define _NN_Chat_Free 354
#define _DN_Event_Limit 355
#define _NN_Event_Stop 356
#define _NN_Hell_Clear 357
#define _NN_Not_KillBoss 358
#define _NN_Not_Teleport 359
#define _NN_Not_NeedUp 360
#define _NN_Killed_Boss 361
#define _NN_Used_Chao 362
#define _DN_Show_Chao 363
#define _NN_Not_StatInit 364
#define _NN_Another_Server 365
#define _NN_Not_SellItem 366
#define _DD_D_Show_Time 367
#define _DN_Show_Date 368
#define _NN_End_Service 369
#define _NN_Name_Khepra 370
#define _NN_CantGetItem 371
#define _NN_CantAdultUsed 372
#define _DN_Level_Limit 373
#define _NN_Only_when_castle_start 374
#define _NN_Castle_Can_charge 375
#define _NN_Stop_Service 376
#define _DS_Notice_Jackpot 377
#define _SN_End_Khepra 378
#define _NN_Cant_MoveItem 379
#define _NN_Need_ExpMore 380
#define _NN_Need_Trans 381
#define _NN_Need_BeforeQuest 382
#define _DN_Play_Quest 383
#define _NN_NoHave_Quest 384
#define _NN_SND_MESSAGE 385
#define _UN_JACKPOT_MESSAGE 386
#define _NN_NOT_TRANSITEM 387
#define _NN_ITEM_DESTROY 388
#define _SN_Item_BelongToS 389
#define _NN_NotEquip_Saturday 390
#define _DD_Lotto_No_6 391
#define _NN_Need_Kingdom 392
#define _SSDD_HeavenWarResult 393
#define _NN_NeedOverSapp 394
#define _NN_Complete_Quest 395
#define _SSDD_HeavenWarResult2 396
#define _SSDD_HeavenWarResult3 397
#define _NN_GAMEROOM_ITEM 398
#define _NN_PLUS_POINT 399
#define _DN_PLUS_CPPOINT 400
#define _DN_SUB_CPPOINT 401
#define _NN_Only_OneSkillLearn 402
#define _NN_Befor_LearnSkill 403
#define _NN_Cash_ChargeOk 404
#define _NN_Cash_ChargeErr 405
#define _NN_NOTUSE_TRANS 406
#define _NN_NOTUSE_YET 407
#define _NN_Maximum_Point_255_Now 408
#define _NN_EquipArmor_Refine 409
#define _DN_Recovery_Life 410
#define _DN_CanUse_Time 411
#define _NN_Crack_Block 412
#define _SN_Use_Item 413
#define _I64D_TOWN_TAX 414
#define _DD_QUIZ 415
#define _DD_NOT_QUIZ 416
#define _NN_GIVE_TOWN_TAX 417
#define _NN_CANT_USE_NIGHTMARE 418
#define _NN_CHANGE_PASSWORD 419
#define _DN_CHANGE_COUNT 420
#define _SN_CREATEGUILD 421
#define _SN_JOINGUILD 422
#define _DN_TOWNSPEOPLE 423
#define _DN_BASEWORRESULT 424
#define _DN_BASEWORSTART 425
#define _DD_SERVERWAR 426
#define _DD_JOINTOWNPEP 427
#define _DN_DOSERVERWAR 428
#define _NN_GSTRING_ERR 429
#define _NN_CANT_USE_ID 430
#define _NN_OPEN_HELLGATE 431
#define _DN_TOWNBOUNS 432
#define _DD_KINGDOMWAR_START 433
#define _DD_KINGDOMWAR_END 434
#define _NN_Check_User_Info 435
#define _NN_LockSetMessage 436
#define _NN_CanelMessage 437
#define _NN_LockCheckMessage 438
#define _NN_LockPsSetMessage 439
#define _NN_LockPsChangeMessage 440
#define _DN_ServerWarTo 441
#define _DN_ServerWarFrom 442
#define _NN_LockPsWrongPassMessage 443
#define _ND_GenDarkShadow 444
#define _NN_Refine_Down 445
#define _NN_CantCreateGOD2 446
#define _NN_CantUseIt 447
#define _NN_AlreadyClosing 448
#define _NN_NotMatchMission 449
#define _NN_ClearMission 450
#define _NN_NOT_TRANS3ITEM 451
#define _NN_FUll_CARRY 452
#define _NN_APPLY_EVENT 453
#define _NN_CANT_APPLY_EVENT 454
#define _NN_KINGDOM_BLUE 455
#define _NN_KINGDOM_RED 456
#define _NN_SWAR_AHEAD 457
#define _NN_SWAR_TRUCE 458
#define _NN_GIVEUP_SERVERWAR 459
#define _ND_SERVERCLAN 460
#define _NN_Charm_Stone 461
#define _SS_Combin_12Succ 462
#define _SS_Guild_to_drop 463
#define _NN_PARTY_TEL 464
#define _DN_LIMITWARNING 465
#define _DN_LIMITTIME 466
#define _DN_GUILDMESSAGE 467
#define _DN_CHARSELECTMESSAGE 468
#define _NN_WAITFORDELCHAR 469
#define _NN_WAITFORLOGIN 470
#define _NN_PASSWORDERROR 471
#define _NN_ISNOTALLOWEDACCOUNT 472
#define _NS_GETEXP 473
#define _NN_GETJEWALITEM 474
#define _SS_PLUSMILEAGEPOINT 475
#define _NN_FAILURE 476
#define _SN_WANTEQUIPITEM 477
#define _SN_Item_Arrived 478
#define _DN_Mileage_Point 479
#define _DN_BeforLearnSkill 480
#define _SN_Learn_Skill 481
#define _NN_Maximum_Point_320_Now 482
#define _NN_NOT_SUBJECT_TO_EVENT 483
#define _DN_LIMITDURING_3HOUR 484
#define _NN_LIMITDURING_OVER 485
#define _SN_AUCTION_START 486
#define _NN_AUCTION_END 487
#define _DS_AUCTION_PERIOD 488
#define _SSD_AUCTION_SUC 489
#define _SN_AUCTION_BID 490
#define _NN_AUCTION_PLACE 491
#define _NN_NEWBIEEVENTSERVER 492
#define _NN_LIMIT_FAME 493
#define _SN_APPEAR_MOB 494
#define _SN_JOINRESTRICTED 495
#define _SD_RAID_BONUS 496
#define _DD_KILLSCORE 497
#define _NN_GOD2CHARONLY_ 498
#define _NN_MOREKILLPOINT 499
#define _DD_KINGDOMWAR_BEGIN 500
#define _DN_CHANNELWAR_BEGIN 501
#define _NN_CHANNELWAR_ZONE 502
#define _SN_GUILDZONE_NPC_1_ 503
#define _SN_GUILDZONE_NPC_2_ 504
#define _SN_CHANNELWAR_DROP_ 505
#define _SN_KINGDOMWAR_DROP_ 506
#define _DN_NO_TOWNSPEOPLE 513
#define _DN_ANOTHER_TOWNSPEOPLE 514
#define _DN_WAR_JOIN_TOWNSPEOPLE 515
#define _DN_TOWN_SOUL_BUFF 516
#define _DN_TOWN_SOUL_NOBUFF 517
#define _DN_TOWN_SORRY 518
#define _SN_BRINGITEM 519
#define _DN_SANCREQ 520
#define _DN_NeedDonate 521
#define _NN_MAC_Block 522
#define _DN_NEEDFAME 523
#define _SN_NEEDCLASS 524
#define _NN_MAX_ACCOUNTMAC 525
#define _NN_ONLYTRADE 526
#define _NN_NOSTOCK 527
#define _SN_BOXSTATE 528
#define	_NN_PINCODE_INVALID	529
#define _NN_PINCODE_3TIMES 530
#define _NN_MAX_BAG 531
#define _DD_NightmareTime 532
#define _DN_REMAINDONATE 533
#define _SN_CARBUNCLEMSG 534
#define _NN_GUILDCREATECLAN 535
#define _SS_BASEWORKILLTOWER 536
#define _NN_ENCAMPMENTBORN 537
#define _NN_Check_User_Info_Guild 538
#define _NN_Chat_Desmute 539 
#define _DD_AutoNotice1 540
#define _DD_AutoNotice2 541 

# -------------------- LogControl.cpp --------------------

#include "LogControl.h"

using namespace std;

LogControl::LogControl()
{
	m_sDir = std::string();
	m_pStream = std::make_unique<std::ofstream>();
}

LogControl::~LogControl()
{
	if (!m_sDir.empty())
		m_sDir.clear();

	if (m_pStream.get()->is_open()) {
		m_pStream.get()->close();
		m_pStream.release();
	}
}

void LogControl::Initialize(std::string LogName)
{
	if (this == nullptr) {
		printf("Error in Initialize: this was nullptr");
		return;
	}

	//If filename is empty we can't continue
	if (LogName.empty())
		return;

	//Clear old string
	m_sDir.clear();

	//Set the new directory name as LogName variable
	m_sDir = std::string(LogName);

	//Update the stream to a new one
	if (m_pStream.get()->is_open()) {
		m_pStream.get()->close();
		m_pStream.get()->clear();
		m_pStream.reset();
	}

	m_pStream.get()->open(m_sDir.c_str(), std::ios_base::app);

	return;
}

void LogControl::Reset(std::string LogName)
{
	Initialize(LogName);
	return;
}

void LogControl::WriteLog(std::string Message, std::string MacAddress, std::string IP, std::string Account)
{
	if (this == nullptr) {
		printf("Error in WriteLog::std: this was nullptr");
		return;
	}

	if (m_pStream.get()->is_open())
	{
		struct tm when;
		time_t now;
		time(&now);
		when = *localtime(&now);

		char tmp_msg[1024] = { 0, };

		sprintf_s(tmp_msg, "(%02d/%02d/%04d|%02d:%02d:%02d) [%s|%s|%s] : %s\n",
			when.tm_mday, when.tm_mon + 1, when.tm_year + 1900, when.tm_hour, when.tm_min, when.tm_sec,
			Account.c_str(), MacAddress.c_str(), IP.c_str(), Message.c_str());

		*(m_pStream.get()) << std::string(tmp_msg);
	}
}


# -------------------- LogControl.h --------------------

#pragma once

#include <memory>
#include <string>
#include <fstream>
#include <stdexcept>

class LogControl
{
public:
	//Directory for current log
	std::string m_sDir;

	//File stream pointer
	std::unique_ptr <std::ofstream> m_pStream;

public:
	//Constructor - Clear all pointers to start with the Log system
	LogControl();

	//Destructor - Leave all info when class terminates
	~LogControl();

	//Initialize the log system
	void Initialize(std::string LogName);

	//Write to the log using std::string
	void WriteLog(std::string Message, std::string MacAddress, std::string IP, std::string Account);

	//Reset the log to a new file
	void Reset(std::string LogName);
	

};

template<typename ... Args>
std::string string_format(const std::string& format, Args ... args)
{
	int size = snprintf(nullptr, 0, format.c_str(), args ...) + 1; // Extra space for '\0'
	if (size <= 0) { throw std::runtime_error("Error during formatting."); }
	std::unique_ptr<char[]> buf(new char[size]);
	snprintf(buf.get(), size, format.c_str(), args ...);
	return std::string(buf.get(), buf.get() + size - 1); // We don't want the '\0' inside
}

# -------------------- MacroPerga.cpp --------------------

#pragma once

#include "ProcessClientMessage.h"
#include <iostream>
#include <cstdlib>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <random>
#include <ctime>
#include "SendFunc.h"
#include "Functions.h"

void MacroNextSala(int conn, int Type, int Sala) {
	//PERGA N
	if (Type == 1) {
		STRUCT_ITEM Perga;
		memset(&Perga, 0, sizeof(STRUCT_ITEM));

		Perga.sIndex = 3173 + Sala;

		int TargetX = pMob[conn].TargetX;
		int TargetY = pMob[conn].TargetY;

		pUser[conn].Ingame.MacroSala = Sala;
		pUser[conn].Ingame.MacroType = 1;

		if (pUser[conn].Ingame.MacroState == 2 || Perga.sIndex == 3173) {
			pUser[conn].Ingame.MacroState = 1;

			if (RemoveItem(conn, Perga.sIndex, 1) == FALSE) {
				SendClientMessage(conn, "Item não encontrado. Macro desativado");
				pUser[conn].Ingame.MacroState = 0;
				return;
			}
		}

		if ((pMob[conn].extra.ClassMaster == CELESTIAL || pMob[conn].extra.ClassMaster == CELESTIALCS || pMob[conn].extra.ClassMaster == SCELESTIAL) && pMob[conn].MOB.CurrentScore.Level > -1)
		{
			PutItem(conn, &Perga);
			SendClientMessage(conn, "Apenas Personagens Mortais e Arch");
			pUser[conn].Ingame.MacroState = 2;
			return;
		}

		char UserName[128];
		int UserArea = Sala <= 7 ? GetUserInArea(WaterScrollPosition[0][Sala][0] - 8, WaterScrollPosition[0][Sala][1] - 8, WaterScrollPosition[0][Sala][0] + 8, WaterScrollPosition[0][Sala][1] + 8, UserName) : GetUserInArea(WaterScrollPosition[0][Sala][0] - 12, WaterScrollPosition[0][Sala][1] - 12, WaterScrollPosition[0][Sala][0] + 12, WaterScrollPosition[0][Sala][1] + 12, UserName);

		if (UserArea >= 1)
		{
			SendMsgExp(conn, strFmt("O jogador [%s] Já se encontra na sala", UserName), TNColor::Default, false);
			PutItem(conn, &Perga);
			pUser[conn].Ingame.MacroState = 2;
			return;
		}

		WaterClear1[0][Sala] = 30;

		DoTeleport(conn, WaterScrollPosition[0][Sala][0], WaterScrollPosition[0][Sala][1]);
		SendClientSignalParm(conn, ESCENE_FIELD, _MSG_StartTime, WaterClear1[0][Sala] * 2);

		for (int i = 0; i < MAX_PARTY; i++)
		{
			int partyconn = pMob[conn].PartyList[i];

			if ((pMob[partyconn].extra.ClassMaster == CELESTIAL || pMob[partyconn].extra.ClassMaster == CELESTIALCS || pMob[partyconn].extra.ClassMaster == SCELESTIAL) && pMob[partyconn].MOB.CurrentScore.Level >= -1) {
				SendClientMessage(partyconn, "Apenas Personagens Mortais e Arch");
				continue;
			}

			if (partyconn > 0 && partyconn < MAX_USER && partyconn != conn && pUser[partyconn].Mode == USER_PLAY)
			{
				DoTeleport(partyconn, WaterScrollPosition[0][Sala][0], WaterScrollPosition[0][Sala][1]);
				SendClientSignalParm(partyconn, ESCENE_FIELD, _MSG_StartTime, WaterClear1[0][Sala] * 2);
			}
		}

		if (Sala <= 7)
		{
			GenerateMob(Sala + WATER_N_INITIAL, 0, 0);
			GenerateMob(Sala + WATER_N_INITIAL, 0, 0);
			RebuildGenerator();
		}
		else if (Sala == 8)
		{
			int _rand = rand() % 10;

			if (_rand < 4)
				GenerateMob(WATER_N_INITIAL + 8, 0, 0);

			else if (_rand < 5)
				GenerateMob(WATER_N_INITIAL + 9, 0, 0);

			else if (_rand < 6)
				GenerateMob(WATER_N_INITIAL + 10, 0, 0);

			else
				GenerateMob(WATER_N_INITIAL + 11, 0, 0);
		}
	}
	//PERGA M
	if (Type == 2) {
		STRUCT_ITEM Perga;
		memset(&Perga, 0, sizeof(STRUCT_ITEM));

		Perga.sIndex = 777 + Sala;

		int TargetX = pMob[conn].TargetX;
		int TargetY = pMob[conn].TargetY;

		pUser[conn].Ingame.MacroSala = Sala;
		pUser[conn].Ingame.MacroType = 2;

		if (pUser[conn].Ingame.MacroState == 2 || Perga.sIndex == 777) {
			pUser[conn].Ingame.MacroState = 1;

			if (RemoveItem(conn, Perga.sIndex, 1) == FALSE) {
				SendClientMessage(conn, "Item não encontrado. Macro desativado");
				pUser[conn].Ingame.MacroState = 0;
				return;
			}
		}

		if ((pMob[conn].extra.ClassMaster == CELESTIAL || pMob[conn].extra.ClassMaster == CELESTIALCS || pMob[conn].extra.ClassMaster == SCELESTIAL) && pMob[conn].MOB.CurrentScore.Level > -1)
		{
			PutItem(conn, &Perga);
			SendClientMessage(conn, "Apenas Personagens Mortais e Arch");
			pUser[conn].Ingame.MacroState = 2;
			return;
		}

		char UserName[128];
		int UserArea = Sala <= 7 ? GetUserInArea(WaterScrollPosition[1][Sala][0] - 8, WaterScrollPosition[1][Sala][1] - 8, WaterScrollPosition[1][Sala][0] + 8, WaterScrollPosition[1][Sala][1] + 8, UserName) : GetUserInArea(WaterScrollPosition[1][Sala][0] - 12, WaterScrollPosition[1][Sala][1] - 12, WaterScrollPosition[1][Sala][0] + 12, WaterScrollPosition[1][Sala][1] + 12, UserName);

		if (UserArea >= 1)
		{
			SendMsgExp(conn, strFmt("O jogador [%s] Já se encontra na sala", UserName), TNColor::Default, false);
			PutItem(conn, &Perga);
			pUser[conn].Ingame.MacroState = 2;
			return;
		}

		WaterClear1[1][Sala] = 30;

		DoTeleport(conn, WaterScrollPosition[1][Sala][0], WaterScrollPosition[1][Sala][1]);
		SendClientSignalParm(conn, ESCENE_FIELD, _MSG_StartTime, WaterClear1[1][Sala] * 2);

		for (int i = 0; i < MAX_PARTY; i++)
		{
			int partyconn = pMob[conn].PartyList[i];

			if ((pMob[partyconn].extra.ClassMaster == CELESTIAL || pMob[partyconn].extra.ClassMaster == CELESTIALCS || pMob[partyconn].extra.ClassMaster == SCELESTIAL) && pMob[partyconn].MOB.CurrentScore.Level >= -1) {
				SendClientMessage(partyconn, "Apenas Personagens Mortais e Arch");
				continue;
			}

			if (partyconn > 0 && partyconn < MAX_USER && partyconn != conn && pUser[partyconn].Mode == USER_PLAY)
			{
				DoTeleport(partyconn, WaterScrollPosition[1][Sala][0], WaterScrollPosition[1][Sala][1]);
				SendClientSignalParm(partyconn, ESCENE_FIELD, _MSG_StartTime, WaterClear1[1][Sala] * 2);
			}
		}

		if (Sala <= 7)
		{
			GenerateMob(Sala + WATER_M_INITIAL, 0, 0);
			GenerateMob(Sala + WATER_M_INITIAL, 0, 0);
			RebuildGenerator();
		}
		else if (Sala == 8)
		{
			int _rand = rand() % 10;

			if (_rand < 4)
				GenerateMob(WATER_M_INITIAL + 8, 0, 0);

			else if (_rand < 5)
				GenerateMob(WATER_M_INITIAL + 9, 0, 0);

			else if (_rand < 6)
				GenerateMob(WATER_M_INITIAL + 10, 0, 0);

			else
				GenerateMob(WATER_M_INITIAL + 11, 0, 0);
		}
	}
	//PERGA A
	if (Type == 3) {
		STRUCT_ITEM Perga;
		memset(&Perga, 0, sizeof(STRUCT_ITEM));

		Perga.sIndex = 3182 + Sala;

		int TargetX = pMob[conn].TargetX;
		int TargetY = pMob[conn].TargetY;

		pUser[conn].Ingame.MacroSala = Sala;
		pUser[conn].Ingame.MacroType = 3;

		if (pUser[conn].Ingame.MacroState == 2 || Perga.sIndex == 3182) {
			pUser[conn].Ingame.MacroState = 1;

			if (RemoveItem(conn, Perga.sIndex, 1) == FALSE) {
				SendClientMessage(conn, "Item não encontrado. Macro desativado");
				pUser[conn].Ingame.MacroState = 0;
				return;
			}
		}

		char UserName[128];
		int UserArea = Sala <= 7 ? GetUserInArea(WaterScrollPosition[2][Sala][0] - 8, WaterScrollPosition[2][Sala][1] - 8, WaterScrollPosition[2][Sala][0] + 8, WaterScrollPosition[2][Sala][1] + 8, UserName) : GetUserInArea(WaterScrollPosition[2][Sala][0] - 12, WaterScrollPosition[2][Sala][1] - 12, WaterScrollPosition[2][Sala][0] + 12, WaterScrollPosition[2][Sala][1] + 12, UserName);

		if (UserArea >= 1)
		{
			SendMsgExp(conn, strFmt("O jogador [%s] Já se encontra na sala", UserName), TNColor::Default, false);
			PutItem(conn, &Perga);
			pUser[conn].Ingame.MacroState = 2;
			return;
		}

		WaterClear1[2][Sala] = 30;

		DoTeleport(conn, WaterScrollPosition[2][Sala][0], WaterScrollPosition[2][Sala][1]);
		SendClientSignalParm(conn, ESCENE_FIELD, _MSG_StartTime, WaterClear1[2][Sala] * 2);

		for (int i = 0; i < MAX_PARTY; i++)
		{
			int partyconn = pMob[conn].PartyList[i];

			if (partyconn > 0 && partyconn < MAX_USER && partyconn != conn && pUser[partyconn].Mode == USER_PLAY)
			{
				DoTeleport(partyconn, WaterScrollPosition[2][Sala][0], WaterScrollPosition[2][Sala][1]);
				SendClientSignalParm(partyconn, ESCENE_FIELD, _MSG_StartTime, WaterClear1[2][Sala] * 2);
			}
		}

		if (Sala <= 7)
		{
			GenerateMob(Sala + WATER_A_INITIAL, 0, 0);
			GenerateMob(Sala + WATER_A_INITIAL, 0, 0);
			RebuildGenerator();
		}
		else if (Sala == 8)
		{
			int _rand = rand() % 10;

			if (_rand < 4)
				GenerateMob(WATER_A_INITIAL + 8, 0, 0);

			else if (_rand < 5)
				GenerateMob(WATER_A_INITIAL + 9, 0, 0);

			else if (_rand < 6)
				GenerateMob(WATER_A_INITIAL + 10, 0, 0);

			else
				GenerateMob(WATER_A_INITIAL + 11, 0, 0);
		}
	}
}

# -------------------- MailItem.cpp --------------------

#pragma once

#include "ProcessClientMessage.h"
#include <iostream>
#include <cstdlib>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <random>
#include <ctime>
#include "SendFunc.h"
#include "Functions.h"
#include "wMySQL.h"

void MailItem(int conn)
{
	if (conn <= 0 || conn >= MAX_USER)
		return;

	if (pUser[conn].Mode != USER_PLAY)
		return;

	if (pUser[conn].cSock.Sock == 0)
		return;

	if (pUser[conn].MailItemDelay != 0)
	{
		int isTime = GetTickCount64() - pUser[conn].MailItemDelay; // ATRASO PACOTE

		if (isTime < 200)
		{
			//SendClientMessage(conn, "Aguarde 1 segundo para uma nova Tentativa.");
			return;
		}

	}
	pUser[conn].MailItemDelay = GetTickCount64();

	auto& pc = cSQL::instance();

	int Index = 0;
	int sEffect[3];
	int sValue[3];

	for (int i = 0; i < 3; i++) {
		sEffect[i] = 0;
		sValue[i] = 0;
	}

	sprintf(hQuery, "SELECT * FROM `mailitem` WHERE `account` = '%s' AND `delivered` = '%d' LIMIT 1", pUser[conn].AccountName, 0);
	MYSQL_ROW row;
	MYSQL* wSQL = pc.wStart();
	MYSQL_RES* result = pc.wRes(wSQL, hQuery);

	if (result == NULL)
		return;

	while ((row = mysql_fetch_row(result)) != NULL)
	{
		Index = atoi(row[3]);
		sEffect[0] = atoi(row[4]);
		sValue[0] = atoi(row[5]);
		sEffect[1] = atoi(row[6]);
		sValue[1] = atoi(row[7]);
		sEffect[2] = atoi(row[8]);
		sValue[2] = atoi(row[9]);
	}

	MSG_MailItem sm;
	memset(&sm, 0, sizeof(MSG_MailItem));
	sm.Type = _MSG_MailItem;
	sm.Size = sizeof(MSG_MailItem);
	sm.ID = conn;

	sm.Index = Index;
	sm.sEffect[0] = sEffect[0];
	sm.sValue[0] = sValue[0];
	sm.sEffect[1] = sEffect[1];
	sm.sValue[1] = sValue[1];
	sm.sEffect[2] = sEffect[2];
	sm.sValue[2] = sValue[2];

	int Size = sm.Size;

	if (Size > sizeof(MSG_MailItem))
	{
		sm.Size = sizeof(MSG_MailItem);
		return;
	}
	if (!pUser[conn].cSock.AddMessage((char*)&sm, sizeof(MSG_MailItem)))
		CloseUser(conn);
}

void SendMailItem(int conn)
{
	if (conn <= 0 || conn >= MAX_USER)
		return;

	if (pUser[conn].Mode != USER_PLAY)
		return;

	if (pUser[conn].cSock.Sock == 0)
		return;

	if (pUser[conn].SendMailItemDelay != 0)
	{
		int isTime = GetTickCount64() - pUser[conn].SendMailItemDelay; // ATRASO PACOTE

		if (isTime < 200)
		{
			//SendClientMessage(conn, "Aguarde 1 segundo para uma nova Tentativa.");
			return;
		}

	}
	pUser[conn].SendMailItemDelay = GetTickCount64();

	int FreeSlot = 0;
	int slotsInv = 30;

	if (pMob[conn].MOB.Carry[60].sIndex == 3467)
		slotsInv += 15;
	if (pMob[conn].MOB.Carry[61].sIndex == 3467)
		slotsInv += 15;

	for (int i = 0; i < slotsInv; i++) {
		if (pMob[conn].MOB.Carry[i].sIndex == 0)
			FreeSlot += 1;
	}
	if (FreeSlot < 2) {
		SendClientMessage(conn, "Não há espaço disponível no Inventário");
		return;
	}

	auto& pc = cSQL::instance();

	int Delivered = 0;
	int RowIndex = 0;
	int Index = 0;
	int sEffect[3];
	int sValue[3];

	for (int i = 0; i < 3; i++) {
		sEffect[i] = 0;
		sValue[i] = 0;
	}

	sprintf(hQuery, "SELECT * FROM `mailitem` WHERE `account` = '%s' AND `delivered` = '%d' LIMIT 1", pUser[conn].AccountName, 0);
	MYSQL_ROW row;
	MYSQL* wSQL = pc.wStart();
	MYSQL_RES* result = pc.wRes(wSQL, hQuery);

	if (result == NULL)
		return;

	while ((row = mysql_fetch_row(result)) != NULL)
	{
		RowIndex = atoi(row[0]);
		Index = atoi(row[3]);
		sEffect[0] = atoi(row[4]);
		sValue[0] = atoi(row[5]);
		sEffect[1] = atoi(row[6]);
		sValue[1] = atoi(row[7]);
		sEffect[2] = atoi(row[8]);
		sValue[2] = atoi(row[9]);
	}

	if (Index == 0) {
		SendClientMessage(conn, "Não há itens a serem recebidos");
		return;
	}

	STRUCT_ITEM item;
	memset(&item, 0, sizeof(STRUCT_ITEM));
	item.sIndex = Index;
	item.stEffect[0].cEffect = sEffect[0];
	item.stEffect[0].cValue = sValue[0];
	item.stEffect[1].cEffect = sEffect[1];
	item.stEffect[1].cValue = sValue[1];
	item.stEffect[2].cEffect = sEffect[2];
	item.stEffect[2].cValue = sValue[2];

	PutItem(conn, &item);
	
	Delivered = 1;
	sprintf(xQuery, "UPDATE mailitem SET delivered = '%d' WHERE id = '%d' ", Delivered, RowIndex);
	pc.wQuery(xQuery);

	SendClientMessage(conn, strFmt("O item [%s] foi entregue no seu inventário!", g_pItemList[Index].Name));

	MailItem(conn);
}

# -------------------- MestreGrifo.cpp --------------------

#include "ProcessClientMessage.h"

struct      MSG_MestreGrifo
{
	_MSG;
	int WarpID;
	int Typpe;

};


void Exec_MSG_MestreGrifo(int conn, char *pMsg)
	{
		MSG_MestreGrifo *m = (MSG_MestreGrifo*)pMsg;

		int Size = m->Size;

		if (Size > sizeof(MSG_MestreGrifo)) //CONTROLE DE SIZE
		{
			SendClientMessage(conn, "Impossível executar ação1, tente mais tarde.");
			return;
		}

		if (m->Typpe == 1)
		{
			SendClientMessage(conn, "Obrigado por viajar comigo!");
			return;
		}
		switch (m->WarpID)
		{
		case 0:
			DoTeleport(conn, 2112, 2051);
			break;

		case 1:
			DoTeleport(conn, 2372, 2099);
			break;

		case 2:
			DoTeleport(conn, 2220, 1714);
			break;

		case 3:
			DoTeleport(conn, 2365, 2249);
			break;

		case 4:
			DoTeleport(conn, 1826, 1771);
			break;
		}

	}


# -------------------- MobKilled.cpp --------------------


#include <Windows.h>
#include <stdio.h>
#include <fcntl.h>
#include <time.h>
#include <math.h>
#include <io.h>
#include <errno.h>

#include "..\Basedef.h"
#include "..\CPSock.h"
#include "..\ItemEffect.h"
#include "Language.h"

#include "CItem.h"
#include "Server.h"
#include "GetFunc.h"
#include "SendFunc.h"
#include "ProcessClientMessage.h"
#include "ProcessDBMessage.h"
#include "CCastleZakum.h"
#include "CWarTower.h"
#include "CCubo.h" 
#include "Functions.h"
#include "wMySQL.h"

void MobKilled(int target, int conn, int PosX, int PosY)
{
	if (conn <= 0 || conn >= MAX_MOB || target <= 0 || target >= MAX_MOB || pMob[target].Mode == USER_EMPTY)
		return;

	STRUCT_ITEM* FairySlot = &pMob[target].MOB.Equip[13];

	MSG_CreateMob sCreateMob;

	if (pMob[target].MOB.CurrentScore.Level >= 1000)
	{
		pMob[target].MOB.CurrentScore.Hp = pMob[target].MOB.CurrentScore.MaxHp;

		if (target < MAX_USER)
			SetReqHp(target);

		GetCreateMob(target, &sCreateMob);
		GridMulticast(pMob[target].TargetX, pMob[target].TargetY, (MSG_STANDARD*)&sCreateMob, 0);

		SendScore(conn);

		return;
	}

	if (pMob[target].MOB.Equip[13].sIndex == 769 && RvRState == 0 && GTorreState == 0 && CastleState == 0) // Nyerds
	{
		int sanc = BASE_GetItemSanc(FairySlot);

		if (sanc > 0)
		{
			sanc--;

			if (FairySlot->stEffect[0].cEffect == 43)
				FairySlot->stEffect[0].cValue = sanc;

			else if (FairySlot->stEffect[1].cEffect == 43)
				FairySlot->stEffect[1].cValue = sanc;

			else if (FairySlot->stEffect[2].cEffect == 43)
				FairySlot->stEffect[2].cValue = sanc;
		}
		else
			BASE_ClearItem(FairySlot);

		if (target > 0 && target <= MAX_USER)
		{
			SendItem(target, ITEM_PLACE_EQUIP, 13, &pMob[target].MOB.Equip[13]);
			SendEmotion(target, 14, 2);
		}

		SendEquip(target, 0);

		pMob[target].MOB.CurrentScore.Hp = pMob[target].MOB.CurrentScore.MaxHp;

		if (target < MAX_USER)
			SetReqHp(target);

		GetCreateMob(target, &sCreateMob);
		GridMulticast(pMob[target].TargetX, pMob[target].TargetY, (MSG_STANDARD*)&sCreateMob, 0);

		SendScore(conn);

		return;
	}
	if (CastleState > 1 && pMob[target].TargetX == 1046 && pMob[target].TargetY == 1690 && target > 0 && target < MAX_USER)
	{
		DoTeleport(target, 1066, 1717);
		return;
	}
	#pragma region >> Batalha Real func
		if (BrState >= 1)
		{
	#pragma region >> Func para quem morreu
			if (p_BatalhaReal.start == true)
			{		
				if ((conn > 0 && conn < MAX_USER) && (target > 0 && target < MAX_USER)) {
	
					if (pMob[target].TargetX >= 140 && pMob[target].TargetY >= 4000 && pMob[target].TargetX <= 200 && pMob[target].TargetY <= 4100)
					{
						//p_BatalhaReal.Members[target].Id -= 1;
						p_BatalhaReal.NumMembers -= 1;
						if (pUser[target].Vidas >= 1)
						{
							pUser[target].Vidas -= 1;
							int rand_ = rand() % 100;
							if (rand_ <= 10)
								DoTeleport(target, 148 + rand() % 2, 4010 + rand() % 2);
							else if (rand_ <= 20)
								DoTeleport(target, 148 + rand() % 2, 4044 + rand() % 2);
							else if (rand_ <= 30)
								DoTeleport(target, 148 + rand() % 2, 4077 + rand() % 2);
							else if (rand_ <= 40)
								DoTeleport(target, 168 + rand() % 2, 4061 + rand() % 2);
							else if (rand_ <= 50)
								DoTeleport(target, 168 + rand() % 2, 4028 + rand() % 2);
							else if (rand_ <= 60)
								DoTeleport(target, 191 + rand() % 2, 4080 + rand() % 2);
							else if (rand_ <= 70)
								DoTeleport(target, 191 + rand() % 2, 4063 + rand() % 2);
							else if (rand_ <= 80)
								DoTeleport(target, 191 + rand() % 2, 4044 + rand() % 2);
							else if (rand_ <= 90)
								DoTeleport(target, 191 + rand() % 2, 4027 + rand() % 2);
							else
								DoTeleport(target, 191 + rand() % 2, 4010 + rand() % 2);
							pMob[target].MOB.CurrentScore.Hp = pMob[target].MOB.CurrentScore.MaxHp;
							pMob[target].MOB.CurrentScore.Mp = pMob[target].MOB.CurrentScore.MaxMp;
							SendScore(target);
							SendSetHpMp(target);
							return;
						}
	
	
						STRUCT_ITEM presente = { 476, 0, 0, 0 };
						PutItem(target, &presente);
						//pUser[conn].Honra += 5;
						SendClientMessage(target, "Recebeu um prêmio de consolo da Arena Real.");
						DoRecall(target);
						pMob[target].MOB.CurrentScore.Hp = pMob[target].MOB.CurrentScore.MaxHp;
						pMob[target].MOB.CurrentScore.Mp = pMob[target].MOB.CurrentScore.MaxMp;
						pMob[target].GetCurrentScore(target);
						SendScore(target);
						SendSetHpMp(target);
						DoTeleport(target, 2132 + rand() % 5, 2147 + rand() % 5);
						return;
					}
				}
			}
	#pragma endregion
			
		}


#pragma region Morte nas quests
	//Coveiro
	if (pMob[conn].TargetX > 2379 && pMob[conn].TargetY > 2076 && pMob[conn].TargetX < 2426 && pMob[conn].TargetY < 2133)
		pMob[conn].extra.CheckTimeKersef = 0;

	//Jardin
	if (pMob[conn].TargetX > 2228 && pMob[conn].TargetY > 1700 && pMob[conn].TargetX < 2257 && pMob[conn].TargetY < 1728)
		pMob[conn].extra.CheckTimeKersef = 0;

	//Kaizen
	if (pMob[conn].TargetX > 459 && pMob[conn].TargetY > 3887 && pMob[conn].TargetX < 497 && pMob[conn].TargetY < 3916)
		pMob[conn].extra.CheckTimeKersef = 0;

	//Hidra
	if (pMob[conn].TargetX > 658 && pMob[conn].TargetY > 3728 && pMob[conn].TargetX < 703 && pMob[conn].TargetY < 3762)
		pMob[conn].extra.CheckTimeKersef = 0;

	//Elfos
	if (pMob[conn].TargetX > 1312 && pMob[conn].TargetY > 4027 && pMob[conn].TargetX < 1348 && pMob[conn].TargetY < 4055)
		pMob[conn].extra.CheckTimeKersef = 0;
#pragma endregion	

#pragma region Morte nas Lans
	//LAN N	 
	if (pMob[conn].TargetX > 3604 && pMob[conn].TargetY > 3604 && pMob[conn].TargetX < 3691 && pMob[conn].TargetY < 3690)
		pMob[conn].extra.CheckTimeKersef = 0;

	//LAN M 
	if (pMob[conn].TargetX > 3732 && pMob[conn].TargetY > 3476 && pMob[conn].TargetX < 3819 && pMob[conn].TargetY < 3563)
		pMob[conn].extra.CheckTimeKersef = 0;

	//LAN A
	if (pMob[conn].TargetX > 3860 && pMob[conn].TargetY > 3604 && pMob[conn].TargetX < 3946 && pMob[conn].TargetY < 3690)
		pMob[conn].extra.CheckTimeKersef = 0;

#pragma endregion	 

	int Face = pMob[conn].MOB.Equip[0].sIndex;

#pragma region Crias EXP
	if (conn >= MAX_USER && pMob[conn].MOB.Clan == 4 && Face >= 315 && Face <= 345 && target > MAX_USER && pMob[target].MOB.Clan != 4)
	{
		int summoner = pMob[conn].Summoner;

		if (summoner > 0 && summoner < MAX_USER && pUser[summoner].Mode && pMob[summoner].Mode)
		{
			STRUCT_ITEM* Mount = &pMob[summoner].MOB.Equip[14];

			if (pMob[summoner].MOB.Equip[14].sIndex >= 2330 && pMob[summoner].MOB.Equip[14].sIndex < 2390)
			{
				unsigned char XP = Mount->stEffect[1].cEffect;
				unsigned char Crescimento = Mount->stEffect[2].cValue;

				unsigned char exp = XP + 100;

				if (Mount->sIndex == 2330)
					exp = XP + 25;

				else if (Mount->sIndex == 2331)
					exp = XP + 35;

				else if (Mount->sIndex == 2332)
					exp = XP + 45;

				else if (Mount->sIndex == 2333)
					exp = XP + 55;

				else if (Mount->sIndex == 2334)
					exp = XP + 65;

				else if (Mount->sIndex == 2335)
					exp = XP + 75;

				if (XP < pMob[target].MOB.CurrentScore.Level && XP < 100)
				{
					Crescimento = Crescimento + 1;

					if (Crescimento < exp)
					{
						Mount->stEffect[2].cValue = Crescimento;
						SendItem(summoner, ITEM_PLACE_EQUIP, 14, &pMob[summoner].MOB.Equip[14]);
					}
					else
					{
						Crescimento = 1;
						XP = XP + 1;
						Mount->stEffect[2].cValue = 1;
						Mount->stEffect[1].cEffect = XP;

						SendMsgExp(summoner, g_pMessageStringTable[_NN_Mount_Level], TNColor::Default, false);
						SendItem(summoner, ITEM_PLACE_EQUIP, 14, &pMob[summoner].MOB.Equip[14]);
						MountProcess(summoner, &pMob[conn].MOB.Equip[14]);
					}
				}
			}
		}
	}

#pragma endregion

#pragma region Invocações
	MSG_CNFMobKill sm;
	memset(&sm, 0, sizeof(MSG_CNFMobKill));

	sm.Type = _MSG_CNFMobKill;
	sm.Size = sizeof(MSG_CNFMobKill);
	sm.ID = ESCENE_FIELD;

	sm.KilledMob = target;
	sm.Killer = conn;

	pMob[target].MOB.CurrentScore.Hp = 0;

	int Leader = pMob[conn].Leader;

	if (Leader == 0)
		Leader = conn;

	if (conn >= MAX_USER && pMob[conn].MOB.Clan == 4)
	{
		int Summoner = pMob[conn].Summoner;

		if (Summoner <= 0 || Summoner >= MAX_USER || pUser[Summoner].Mode != USER_PLAY)
		{
			GridMulticast(pMob[target].TargetX, pMob[target].TargetY, (MSG_STANDARD*)&sm, 0);

			if (target > MAX_USER)
				DeleteMob(target, 1);

			return;
		}

		conn = Summoner;
	}
#pragma endregion 
#pragma region PvE
	if (target >= MAX_USER || pMob[target].MOB.BaseScore.Level > MAX_LEVEL + 5)
	{
		if (target >= MAX_USER || pMob[target].MOB.BaseScore.Level <= MAX_LEVEL)
		{
			if (conn < MAX_USER && pMob[target].MOB.Clan != 4)
			{
#pragma region Distribuição da EXP
				int MobExp = GetExpApply(pMob[conn].extra, (int)pMob[target].MOB.Exp, pMob[conn].MOB.CurrentScore.Level, pMob[target].MOB.CurrentScore.Level);
				int FinalExp = 0;

				// TODO: Change this UNK_s to something else.
				int UNK_1 = 30;
				int UNK_2 = 0;
				int UNK_3 = pMob[conn].extra.ClassMaster;

				int tx = pMob[conn].TargetX;
				int ty = pMob[conn].TargetY;

				int party = 0;

				if (UNK_3 > 0 && UNK_3 <= MAX_PARTY)
				{
					int NumMob = g_EmptyMob + UNK_3;

					if (UNK_3 > 1)
						NumMob = NumMob + PARTYBONUS - 100;

					int eMob = MobExp;
					int isExp = NumMob * MobExp / 100;

					struct tm when;
					time_t now;
					time(&now);
					when = *localtime(&now);

					for (int i = 0; i < MAX_PARTY + 1; ++i)
					{
						party = 0;

						if (Leader && i < MAX_PARTY)
							party = pMob[Leader].PartyList[i];
						else
							party = Leader;
#pragma region Pesa A
						if (party > 0 && party < MAX_USER && pMob[party].MOB.CurrentScore.Hp > 0 && (tx / 128) == 9 && (pMob[party].TargetX / 128) == 9
							&& (ty / 128) == 1 && (pMob[party].TargetY / 128) == 1)
						{
							isExp = GetExpApply(pMob[party].extra, (int)pMob[target].MOB.Exp, pMob[party].MOB.CurrentScore.Level, pMob[target].MOB.CurrentScore.Level);

							int myLevel = pMob[party].MOB.CurrentScore.Level;

							//if (pMob[party].extra.ClassMaster != MORTAL && pMob[party].extra.ClassMaster != ARCH)
							//	myLevel += MAX_LEVEL + 1;

							long long int exp = (UNK_1 + myLevel) * isExp / (UNK_1 + myLevel);
							if (exp > 0 && exp <= 10000000)
							{
								if (pMob[conn].ExpBonus > 0 && pMob[conn].ExpBonus < 500)
									exp += exp * pMob[conn].ExpBonus / 100;

								if (RvRBonus && RvRBonus == pMob[party].MOB.Clan)
									exp += (exp * 20) / 100;

								if (NewbieEventServer && pMob[party].MOB.CurrentScore.Level < 100 && pMob[party].extra.ClassMaster != CELESTIAL && pMob[party].extra.ClassMaster != CELESTIALCS && pMob[party].extra.ClassMaster != SCELESTIAL)
									exp += exp / 4;

								if (DOUBLEMODE)
									exp *= 2;

								if (NewbieEventServer)
									exp += (exp * 15) / 100;
								else
									exp -= (exp * 15) / 100;

								int ESCURIDAO = mNPCGen.pList[Escuridao].CurrentNumMob;
								int ERIN = mNPCGen.pList[Erin].CurrentNumMob;
								int FENIX = mNPCGen.pList[Fenix].CurrentNumMob;
								int KARA = mNPCGen.pList[Kara].CurrentNumMob;
								int KEI = mNPCGen.pList[Kei].CurrentNumMob;
								int KEMI = mNPCGen.pList[Kemi].CurrentNumMob;
								int LEAO = mNPCGen.pList[Leao].CurrentNumMob;
								int UIE = mNPCGen.pList[Yue].CurrentNumMob;

								if (ESCURIDAO == 0)
									exp -= (exp * 10) / 100;

								if (ERIN == 0)
									exp -= (exp * 10) / 100;

								if (FENIX == 0)
									exp -= (exp * 10) / 100;

								if (KARA == 0)
									exp -= (exp * 10) / 100;

								if (KEI == 0)
									exp -= (exp * 10) / 100;

								if (KEMI == 0)
									exp -= (exp * 10) / 100;

								if (LEAO == 0)
									exp -= (exp * 10) / 100;

								if (UIE == 0)
									exp -= (exp * 10) / 100;


#pragma region Log de Experiência diário
								if (when.tm_yday != pMob[party].extra.DayLog.YearDay)
									pMob[party].extra.DayLog.Exp = 0;

								pMob[party].extra.DayLog.YearDay = when.tm_yday;
								pMob[party].extra.DayLog.Exp += exp;
#pragma endregion

								if (pMob[party].extra.Hold > 0 && (unsigned int)exp >= pMob[party].extra.Hold)
								{
									int nhold = pMob[party].extra.Hold - exp;

									if (nhold < 0)
										nhold = 0;

									exp -= pMob[party].extra.Hold;
									pMob[party].extra.Hold = nhold;
								}

								else if (pMob[party].extra.Hold > 0 && (unsigned int)exp < pMob[party].extra.Hold)
								{
									pMob[party].extra.Hold -= exp;
									continue;
								}

								pMob[party].MOB.Exp += exp;

#pragma region RankingUpdateExp
								STRUCT_RANKING rankInfo = STRUCT_RANKING(pMob[party].MOB.MobName, pMob[party].MOB.Exp, pMob[party].extra.ClassMaster, pMob[party].MOB.CurrentScore.Level, pMob[party].MOB.Class, pMob[party].MOB.Guild, pMob[party].MOB.Clan);
								//doRanking(party);
								MSG_UpdateExpRanking expRankingPacket = MSG_UpdateExpRanking(party, rankInfo);
								DBServerSocket.SendOneMessage((char*)&expRankingPacket, sizeof(expRankingPacket));
#pragma endregion
							}
						}
#pragma endregion

#pragma region Pesa M
						else if (party > 0 && party < MAX_USER && pMob[party].MOB.CurrentScore.Hp > 0 && (tx / 128) == 8 && (pMob[party].TargetX / 128) == 8 && (ty / 128) == 2 && (pMob[party].TargetY / 128) == 2)

						{
							isExp = GetExpApply(pMob[party].extra, (int)pMob[target].MOB.Exp, pMob[party].MOB.CurrentScore.Level, pMob[target].MOB.CurrentScore.Level);

							int myLevel = pMob[party].MOB.CurrentScore.Level;

							//if (pMob[party].extra.ClassMaster != MORTAL && pMob[party].extra.ClassMaster != ARCH)
							//	myLevel += MAX_LEVEL + 1;

							long long int exp = (UNK_1 + myLevel) * isExp / (UNK_1 + myLevel);
							if (exp > 0 && exp <= 10000000)
							{
								if (pMob[party].extra.ClassMaster != MORTAL && pMob[party].extra.ClassMaster != ARCH)
									exp = 0;

								if (pMob[conn].ExpBonus > 0 && pMob[conn].ExpBonus < 500)
									exp += exp * pMob[conn].ExpBonus / 100;

								if (RvRBonus && RvRBonus == pMob[party].MOB.Clan)
									exp += (exp * 20) / 100;

								if (NewbieEventServer && pMob[party].MOB.CurrentScore.Level < 100 && pMob[party].extra.ClassMaster != CELESTIAL && pMob[party].extra.ClassMaster != CELESTIALCS && pMob[party].extra.ClassMaster != SCELESTIAL)
									exp += exp / 4;

								if (DOUBLEMODE)
									exp *= 2;

								if (NewbieEventServer)
									exp += (exp * 15) / 100;
								else
									exp -= (exp * 15) / 100;

								int ARNOLD_ = mNPCGen.pList[Arnold_].CurrentNumMob;
								int LAINY = mNPCGen.pList[Lainy].CurrentNumMob;
								int REIMERS = mNPCGen.pList[Reimers].CurrentNumMob;
								int ROPERION = mNPCGen.pList[RoPerion].CurrentNumMob;
								int IRENA = mNPCGen.pList[Irena].CurrentNumMob;

								if (ARNOLD_ == 0)
									exp -= (exp * 10) / 100;

								if (LAINY == 0)
									exp -= (exp * 10) / 100;

								if (REIMERS == 0)
									exp -= (exp * 10) / 100;

								if (ROPERION == 0)
									exp -= (exp * 10) / 100;

								if (IRENA == 0)
									exp -= (exp * 10) / 100;



#pragma region Log de Experiência diário
								if (when.tm_yday != pMob[party].extra.DayLog.YearDay)
									pMob[party].extra.DayLog.Exp = 0;

								pMob[party].extra.DayLog.YearDay = when.tm_yday;
								pMob[party].extra.DayLog.Exp += exp;
#pragma endregion

								if (pMob[party].extra.Hold > 0 && (unsigned int)exp >= pMob[party].extra.Hold)
								{
									int nhold = pMob[party].extra.Hold - exp;

									if (nhold < 0)
										nhold = 0;

									exp -= pMob[party].extra.Hold;
									pMob[party].extra.Hold = nhold;
								}

								else if (pMob[party].extra.Hold > 0 && (unsigned int)exp < pMob[party].extra.Hold)
								{
									pMob[party].extra.Hold -= exp;
									continue;
								}

								pMob[party].MOB.Exp += exp;
#pragma region RankingUpdateExp
								STRUCT_RANKING rankInfo = STRUCT_RANKING(pMob[party].MOB.MobName, pMob[party].MOB.Exp, pMob[party].extra.ClassMaster, pMob[party].MOB.CurrentScore.Level, pMob[party].MOB.Class, pMob[party].MOB.Guild, pMob[party].MOB.Clan);
								//doRanking(party);
								MSG_UpdateExpRanking expRankingPacket = MSG_UpdateExpRanking(party, rankInfo);
								DBServerSocket.SendOneMessage((char*)&expRankingPacket, sizeof(expRankingPacket));
#pragma endregion
							}
						}
#pragma endregion
#pragma region Pesa N
						else if (party > 0 && party < MAX_USER && pMob[party].MOB.CurrentScore.Hp > 0 && (tx / 128) == 10 && (pMob[party].TargetX / 128) == 10 && (ty / 128) == 2 && (pMob[party].TargetY / 128) == 2)
						{
							isExp = GetExpApply(pMob[party].extra, (int)pMob[target].MOB.Exp, pMob[party].MOB.CurrentScore.Level, pMob[target].MOB.CurrentScore.Level);

							int myLevel = pMob[party].MOB.CurrentScore.Level;

							//if (pMob[party].extra.ClassMaster != MORTAL && pMob[party].extra.ClassMaster != ARCH)
							//	myLevel += MAX_LEVEL + 1;

							long long int exp = (UNK_1 + myLevel) * isExp / (UNK_1 + myLevel);
							if (exp > 0 && exp <= 10000000)
							{
								if (pMob[party].extra.ClassMaster != MORTAL && pMob[party].extra.ClassMaster != ARCH)
									exp = 0;

								if (pMob[conn].ExpBonus > 0 && pMob[conn].ExpBonus < 500)
									exp += exp * pMob[conn].ExpBonus / 100;

								if (RvRBonus && RvRBonus == pMob[party].MOB.Clan)
									exp += (exp * 20) / 100;

								if (NewbieEventServer && pMob[party].MOB.CurrentScore.Level < 100 && pMob[party].extra.ClassMaster != CELESTIAL && pMob[party].extra.ClassMaster != CELESTIALCS && pMob[party].extra.ClassMaster != SCELESTIAL)
									exp += exp / 4;

								if (DOUBLEMODE)
									exp *= 2;

								if (NewbieEventServer)
									exp += (exp * 15) / 100;
								else
									exp -= (exp * 15) / 100;

								int MARTIN = mNPCGen.pList[Martin].CurrentNumMob;
								int BALMERS = mNPCGen.pList[Balmers].CurrentNumMob;
								int RUBYEN = mNPCGen.pList[Rubyen].CurrentNumMob;
								int NAOMI = mNPCGen.pList[Naomi].CurrentNumMob;
								int ARNOLD = mNPCGen.pList[Arnold].CurrentNumMob;

								if (MARTIN == 0)
									exp -= (exp * 10) / 100;

								if (BALMERS == 0)
									exp -= (exp * 10) / 100;

								if (RUBYEN == 0)
									exp -= (exp * 10) / 100;

								if (NAOMI == 0)
									exp -= (exp * 10) / 100;

								if (ARNOLD == 0)
									exp -= (exp * 10) / 100;

#pragma region Log de Experiência diário
								if (when.tm_yday != pMob[party].extra.DayLog.YearDay)
									pMob[party].extra.DayLog.Exp = 0;

								pMob[party].extra.DayLog.YearDay = when.tm_yday;
								pMob[party].extra.DayLog.Exp += exp;


								if (pMob[party].extra.Hold > 0 && (unsigned int)exp >= pMob[party].extra.Hold)
								{
									int nhold = pMob[party].extra.Hold - exp;

									if (nhold < 0)
										nhold = 0;

									exp -= pMob[party].extra.Hold;
									pMob[party].extra.Hold = nhold;
								}

								else if (pMob[party].extra.Hold > 0 && (unsigned int)exp < pMob[party].extra.Hold)
								{
									pMob[party].extra.Hold -= exp;
									continue;
								}

								pMob[party].MOB.Exp += exp;
#pragma region RankingUpdateExp
								STRUCT_RANKING rankInfo = STRUCT_RANKING(pMob[party].MOB.MobName, pMob[party].MOB.Exp, pMob[party].extra.ClassMaster, pMob[party].MOB.CurrentScore.Level, pMob[party].MOB.Class, pMob[party].MOB.Guild, pMob[party].MOB.Clan);
								//doRanking(party);
								MSG_UpdateExpRanking expRankingPacket = MSG_UpdateExpRanking(party, rankInfo);
								DBServerSocket.SendOneMessage((char*)&expRankingPacket, sizeof(expRankingPacket));

							}
						}
#pragma endregion
#pragma region >> EXP GERAL
						else if (party > 0 && party < MAX_USER && pMob[party].MOB.CurrentScore.Hp > 0 && tx >= pMob[party].TargetX - HALFGRIDX
							&& tx <= pMob[party].TargetX + HALFGRIDX && ty >= pMob[party].TargetY - HALFGRIDY && ty <= pMob[party].TargetY + HALFGRIDY)
						{
							isExp = GetExpApply(pMob[party].extra, (int)pMob[target].MOB.Exp, pMob[party].MOB.CurrentScore.Level, pMob[target].MOB.CurrentScore.Level);

							int myLevel = pMob[party].MOB.CurrentScore.Level;

							/*if (pMob[party].extra.ClassMaster != MORTAL && pMob[party].extra.ClassMaster != ARCH)
								myLevel += MAX_LEVEL + 1;*/

							long long int exp = isExp;

							if (exp > 0 && exp <= 10000000)
							{
								/*if (pMob[party].extra.ClassMaster == ARCH)
									exp /= 2;

								if (pMob[party].extra.ClassMaster != MORTAL && pMob[party].extra.ClassMaster != ARCH)
									exp /= 5;*/

								if (pMob[conn].ExpBonus > 0 && pMob[conn].ExpBonus < 500)
									exp += exp * pMob[conn].ExpBonus / 100;

								if (RvRBonus == pMob[party].MOB.Clan)
									exp += (exp * 10) / 100;

								if (DOUBLEMODE)
									exp *= 2;

								/*if (NewbieEventServer)
									exp += (exp * 15) / 100;
								else
									exp -= (exp * 15) / 100;*/

#pragma region Log de Experiência diário
								if (when.tm_yday != pMob[party].extra.DayLog.YearDay)
									pMob[party].extra.DayLog.Exp = 0;

								pMob[party].extra.DayLog.YearDay = when.tm_yday;
								pMob[party].extra.DayLog.Exp += exp;
#pragma endregion

								if (pMob[party].extra.Hold > 0 && (unsigned int)exp >= pMob[party].extra.Hold)
								{
									int nhold = pMob[party].extra.Hold - exp;

									if (nhold < 0)
										nhold = 0;

									exp -= pMob[party].extra.Hold;
									pMob[party].extra.Hold = nhold;
								}

								else if (pMob[party].extra.Hold > 0 && (unsigned int)exp < pMob[party].extra.Hold)
								{
									pMob[party].extra.Hold -= exp;
									continue;
								}

								pMob[party].MOB.Exp += exp;
#pragma region RankingUpdateExp
								STRUCT_RANKING rankInfo = STRUCT_RANKING(pMob[party].MOB.MobName, pMob[party].MOB.Exp, pMob[party].extra.ClassMaster, pMob[party].MOB.CurrentScore.Level, pMob[party].MOB.Class, pMob[party].MOB.Guild, pMob[party].MOB.Clan);
								//doRanking(party);
								MSG_UpdateExpRanking expRankingPacket = MSG_UpdateExpRanking(party, rankInfo);
								DBServerSocket.SendOneMessage((char*)&expRankingPacket, sizeof(expRankingPacket));
#pragma endregion
							}
						}
					}

#pragma endregion

#pragma region Targets Monstros
					int GenerateIndex = pMob[target].GenerateIndex;
					int DieSay = rand() % 4;

					if (GenerateIndex >= 0 && mNPCGen.pList[GenerateIndex].DieAction[DieSay][0] && pMob[target].Leader == 0)
						SendChat(target, mNPCGen.pList[GenerateIndex].DieAction[DieSay]);

					GridMulticast(pMob[target].TargetX, pMob[target].TargetY, (MSG_STANDARD*)&sm, 0);

					if (pMob[conn].MOB.Clan && pMob[conn].MOB.Clan != 4 && pMob[conn].MOB.Clan != 7 && pMob[conn].MOB.Clan != 8)
						DeleteMob(target, 1);

					else
					{
						int AlvoX = PosX;
						if (!PosX)
							AlvoX = pMob[target].TargetX;

						int AlvoY = PosY;
						if (!PosY)
							AlvoY = pMob[target].TargetY;

						if (pMob[target].GenerateIndex == CARONTE)
						{
							GenerateMob(SICARIO, 1124, 1471);
						}

						if (pMob[target].GenerateIndex == SICARIO)
						{

							int partyleader = pMob[conn].Leader;

							if (partyleader <= 0)
								partyleader = conn;

							STRUCT_ITEM gift;
							memset(&gift, 0, sizeof(STRUCT_ITEM));

							int _rand = rand() % 6;

							int Gift[6][7] = {
							{ 1773, 0, 0, 0, 0, 0, 0 },
							{ 1773, 0, 0, 0, 0, 0, 0 },
							{ 1773, 0, 0, 0, 0, 0, 0 },
							{ 1773, 0, 0, 0, 0, 0, 0 },
							{ 1773, 0, 0, 0, 0, 0, 0 },
							{ 1773, 0, 0, 0, 0, 0, 0 },
							};

							gift.sIndex = Gift[rand() % 6][0];
							gift.stEffect[0].cEffect = Gift[_rand][1];
							gift.stEffect[0].cValue = Gift[_rand][2];
							gift.stEffect[1].cEffect = Gift[_rand][3];
							gift.stEffect[1].cValue = Gift[_rand][4];
							gift.stEffect[2].cEffect = Gift[_rand][5];
							gift.stEffect[2].cValue = Gift[_rand][6];

							if (partyleader > 0 && partyleader < MAX_USER);
							DoTeleport(partyleader, 2100, 2100);

							for (int i = 0; i < MAX_PARTY; i++)
							{
								int partymember = pMob[partyleader].PartyList[i];
								if (pUser[partymember].Mode != USER_PLAY)
									continue;
								DoTeleport(partymember, 2100, 2100);
								PutItem(partymember, &gift);
								PutItem(partyleader, &gift);

								pUser[partymember].Honra += 5;
								pUser[partyleader].Honra += 5;
								SendMsgExp(partymember, "+ 5 pontos de Honra", TNColor::NewYellow, false);
								SendMsgExp(partyleader, "+ 5 pontos de Honra", TNColor::NewYellow, false);
							}


						}




#pragma region Sombra Negra
						if (pMob[target].GenerateIndex == SOMBRANEGRA)
						{
							STRUCT_ITEM item;
							memset(&item, 0, sizeof(STRUCT_ITEM));

							item.sIndex = 3172;
							item.stEffect[0].cEffect = 0;
							item.stEffect[0].cValue = 0;
							item.stEffect[1].cEffect = 0;
							item.stEffect[1].cValue = 0;
							item.stEffect[2].cEffect = 0;
							item.stEffect[2].cValue = 0;

							if (PutItem(conn, &item)){
								SendClientMessage(conn, "Você recebeu [01][Carta Duelo N]");
							}
							g_BSombraNegra = FALSE;
						}
#pragma endregion
#pragma region Verid Negro
						if (pMob[target].GenerateIndex == VERIDNEGRO)
						{
							STRUCT_ITEM item;
							memset(&item, 0, sizeof(STRUCT_ITEM));

							item.sIndex = 3172;
							item.stEffect[0].cEffect = 61;
							item.stEffect[0].cValue = 2;
							item.stEffect[1].cEffect = 0;
							item.stEffect[1].cValue = 0;
							item.stEffect[2].cEffect = 0;
							item.stEffect[2].cValue = 0;

							if (PutItem(conn, &item))
								SendClientMessage(conn, "Você recebeu [02][Carta Duelo N]");
							g_BVerid = FALSE;
						}
#pragma endregion
#pragma region Verid Negro
						if (pMob[target].GenerateIndex == ESPELHO_RAINHAG)
						{
							int Group = ServerGroup;
							int Server = pMob[conn].MOB.Guild / MAX_GUILD;
							int usGuild = pMob[conn].MOB.Guild;

							char guildname[256];

							BASE_GetGuildName(Group, usGuild, guildname);

							MSG_GuildInfo sm_gi;
							memset(&sm_gi, 0, sizeof(MSG_GuildInfo));

							sm_gi.Type = _MSG_GuildInfo;
							sm_gi.Size = sizeof(MSG_GuildInfo);
							sm_gi.ID = conn;

							sm_gi.Guild = usGuild;
							GuildInfo[usGuild].Fame += 15;

							auto& pc = cSQL::instance();
							sprintf(xQuery, "UPDATE `guilds` SET fame = '%d' WHERE `guild` = '%d'", GuildInfo[usGuild].Fame + 15, usGuild);
							pc.wQuery(xQuery);

							sm_gi.GuildInfo = GuildInfo[usGuild];

							SendNotice(strFmt("O jogador %s derrotou a Rainha do Gelo! A Guild %s recebeu 15 de Fama !", pMob[conn].MOB.MobName, guildname));

							DBServerSocket.SendOneMessage((char*)&sm_gi, sizeof(MSG_GuildInfo));
							g_RainhaG = FALSE;
						}
#pragma endregion


						//#pragma region Espelho Rainha
						//						if (pMob[target].GenerateIndex == ESPELHO_RAINHAG && EspelhoLive == 1)
						//						{
						//							// BOSS PARTE 1
						//							for (int w = BOSS1_INITIAL; w <= BOSS1_END; w++)
						//								GenerateMob(w, 0, 0);
						//
						//							// BOSS PARTE 2
						//							for (int x = BOSS1_INITIAL2; x <= BOSS1_END2; x++)
						//								GenerateMob(x, 0, 0);
						//
						//							STRUCT_ITEM tItem;
						//							memset(&tItem, 0, sizeof(STRUCT_ITEM));
						//
						//							//tItem.sIndex = 676;
						//
						//							//PutItem(conn, &tItem);
						//
						//							EspelhoLive = 2;
						//						}
						//#pragma endregion
						//#pragma region Sombra Negra
						//						if (pMob[target].GenerateIndex == SOMBRANEGRA)
						//						{
						//							int partyleader = pMob[conn].Leader;
						//
						//							if (partyleader <= 0)
						//								partyleader = conn;
						//							int i = 0;
						//							int partymember = pMob[partyleader].PartyList[i];
						//
						//							if (partyleader > 0 && partyleader < MAX_USER)
						//								DoTeleport(partyleader, 3844, 2879);
						//
						//							for (int i = 0; i < MAX_PARTY; i++)
						//							{
						//								int partymember = pMob[partyleader].PartyList[i];
						//								if (pUser[partymember].Mode != USER_PLAY)
						//									continue;
						//									DoTeleport(partymember, 3844, 2879);
						//							}
						//							
						//							GenerateMob(VERIDRAINHAG, 0, 0);
						//						}
						//#pragma endregion
						//#pragma region VeridRainhaG
						//						if (pMob[target].GenerateIndex == VERIDRAINHAG)
						//						{
						//							// BOSS PARTE 1
						//							for (int w = BOSS1_INITIAL; w <= BOSS1_END; w++)
						//								mNPCGen.pList[w].MinuteGenerate = 3;
						//							// BOSS PARTE 2
						//							for (int x = BOSS1_INITIAL2; x <= BOSS1_END2; x++)
						//								mNPCGen.pList[x].MinuteGenerate = 3;
						//
						//							DoRecall(conn);
						//
						//							SendClientMessage(conn, "Parabéns você concluiu a Quest.");
						//							for (int i = 0; i < MAX_PARTY; i++)
						//							{
						//								int partyconn = pMob[conn].PartyList[i];
						//
						//								if (partyconn > 0 && partyconn < MAX_USER && partyconn != conn && pUser[partyconn].Mode == USER_PLAY)
						//								{
						//									DoRecall(partyconn);
						//									EspelhoLive = 0;
						//									SendMsgExp(partyconn, "Parabéns vocês concluiram a Quest.", TNColor::Default, false);
						//								}
						//							}
						//						}
						//#pragma endregion
#pragma region Tarantula
						if (pMob[target].GenerateIndex == CTARANTULA)
						{
							
							TarantulaKilled = TRUE;

							for (int w = PI_INITIAL2; w <= PI_END2; w++)
								GenerateMob(w, 0, 0);

							for (int x = PI_INITIAL3; x <= PI_END3; x++)
								GenerateMob(x, 0, 0);

							for (int y = PI_INITIAL4; y <= PI_END4; y++)
								GenerateMob(y, 0, 0);

							for (int z = PI_INITIAL5; z <= PI_END5; z++)
								GenerateMob(z, 0, 0);

							RandBoss = rand() % 2 + 1;

							Lich_1 = 1;
							Lich_2 = 1;
							Lich_3 = 1;
							Lich_4 = 1;

						}

						if (RandBoss == 1)
						{
							if (pMob[target].GenerateIndex == LICHBOSS1)
								Lich_1 = 0;

							if (pMob[target].GenerateIndex == LICHBOSS2)
								Lich_2 = 2;

							if (pMob[target].GenerateIndex == LICHBOSS3)
								Lich_3 = 0;

							if (pMob[target].GenerateIndex == LICHBOSS4)
								Lich_4 = 2;
						}

						if (RandBoss == 2)
						{
							if (pMob[target].GenerateIndex == LICHBOSS1)
								Lich_2 = 0;

							if (pMob[target].GenerateIndex == LICHBOSS2)
								Lich_1 = 2;

							if (pMob[target].GenerateIndex == LICHBOSS3)
								Lich_4 = 0;

							if (pMob[target].GenerateIndex == LICHBOSS4)
								Lich_3 = 2;
						}
#pragma endregion
#pragma region Kefra
						if (pMob[target].GenerateIndex == KEFRA_BOSS)
						{
							if (pMob[conn].MOB.Guild)
							{
								int Group = ServerGroup;
								int Server = pMob[conn].MOB.Guild / MAX_GUILD;
								int usGuild = pMob[conn].MOB.Guild;

								char guildname[256];

								BASE_GetGuildName(Group, usGuild, guildname);

								KefraLive = usGuild;

								MSG_GuildInfo sm_gi;
								memset(&sm_gi, 0, sizeof(MSG_GuildInfo));

								sm_gi.Type = _MSG_GuildInfo;
								sm_gi.Size = sizeof(MSG_GuildInfo);
								sm_gi.ID = conn;

								sm_gi.Guild = usGuild;
								GuildInfo[usGuild].Fame += 100; // A GUILD QUE MATAR KEFRA GANHA 100 DE FAMA

								sm_gi.GuildInfo = GuildInfo[usGuild];

								auto& pc = cSQL::instance();
								sprintf(xQuery, "UPDATE `guilds` SET fame = '%d' WHERE `guild` = '%d'", GuildInfo[usGuild].Fame + 100, usGuild);
								pc.wQuery(xQuery);

								DBServerSocket.SendOneMessage((char*)&sm_gi, sizeof(MSG_GuildInfo));
								SendNotice(strFmt(g_pMessageStringTable[_SN_End_Khepra], guildname));

								DrawConfig(TRUE);
							}

							else
							{
								KefraLive = 1;
								SendNotice(strFmt(g_pMessageStringTable[_SN_End_Khepra], "FD"));

								DrawConfig(TRUE);
							}

							int DropKefra[] =
							{
								1740, 1741, 1760, 1761, 1762, 1763, 3172, 3172, 671, 670
							};

							for (int i = 0; i < MAX_USER; i++) {

								if (pUser[i].Mode != USER_PLAY)
									continue;

								if (pMob[i].TargetX >= 2335 && pMob[i].TargetX < 2395 && pMob[i].TargetY >= 3896 && pMob[i].TargetY <= 3955) {
									STRUCT_ITEM Item;
									memset(&Item, 0, sizeof(STRUCT_ITEM));
									Item.sIndex = DropKefra[rand() % (sizeof(DropKefra) / 4)];
									PutItem(i, &Item);
									ItemLog(pUser[i].AccountName, pUser[i].MacAddress, pUser[i].IP,
										strFmt("Recebeu o item %s do Kefra", g_pItemList[Item.sIndex].Name));
								}
							}

							SystemLog("-system", "-", 0, strFmt("etc,kefra killed player %d", pMob[conn].MOB.MobName));
						}
#pragma endregion

						if (pHeightGrid[AlvoY][AlvoX] >= -105 && pHeightGrid[AlvoY][AlvoX] < 115)
						{
							int GenerateID = pMob[target].GenerateIndex;

#pragma region Portões de Noatum
							if (pMob[target].MOB.Equip[0].sIndex == 220 && CastleState)
							{
								if (pMob[target].TargetX < 0 || pMob[target].TargetX >= MAX_GRIDX || pMob[target].TargetY < 0 || pMob[target].TargetY >= MAX_GRIDY)
								{
									SystemLog("-system", "-", 0, "err,no castle gate to open pos");
									return;
								}

								int ItemID = pItemGrid[pMob[target].TargetY][pMob[target].TargetX];
								if (ItemID >= 0 && ItemID < MAX_ITEM && pItem[ItemID].Mode)
								{
									int heigth = 0;
									int isUpdate = UpdateItem(ItemID, 1, &heigth);
									if (isUpdate)
									{
										MSG_UpdateItem UpdateIt;

										UpdateIt.ID = ESCENE_FIELD;
										UpdateIt.Type = _MSG_UpdateItem;

										UpdateIt.ItemID = ItemID + 10000;

										UpdateIt.Size = sizeof(MSG_UpdateItem);

										//UpdateIt.Height = heigth;

										UpdateIt.State = pItem[ItemID].State;

										GridMulticast(pItem[ItemID].PosX, pItem[ItemID].PosY, (MSG_STANDARD*)&UpdateIt, 0);

										pItem[ItemID].Delay = 0;
									}
								}

								else
									SystemLog("-system", "-", 0, "err,no castle gate to open pos");
							}
#pragma endregion
#pragma region Drops especiais - IMP - NYERDS - AGUA - REI - ZAKUM
							else
							{
#pragma region Agua M
								//AguaM
								if (GenerateID >= WATER_M_INITIAL && GenerateID <= WATER_M_INITIAL + 7)
								{
									int CurrentNumMob = mNPCGen.pList[GenerateID].CurrentNumMob;

									if (CurrentNumMob == 1)
									{
										int Sala = GenerateID - WATER_M_INITIAL;

										if (WaterClear1[1][Sala] > 15)
											WaterClear1[1][Sala] = 15;

										int partyleader = pMob[conn].Leader;

										if (partyleader <= 0)
											partyleader = conn;

										int slot_free = -1;

										STRUCT_ITEM Perga;
										memset(&Perga, 0, sizeof(STRUCT_ITEM));

										Perga.sIndex = 778 + Sala;

										if (partyleader > 0 && partyleader < MAX_USER) {

											if (pUser[partyleader].Ingame.MacroState == 1 && pMob[partyleader].MOB.Equip[13].sIndex == 3900) {
												MacroNextSala(partyleader, 2, Sala + 1);
											}
											else {
												pUser[partyleader].Ingame.MacroState = 0;
												PutItem(partyleader, &Perga);
											}
										}

										SendClientSignalParm(partyleader, ESCENE_FIELD, _MSG_StartTime, WaterClear1[1][Sala] * 2);

										for (int i = 0; i < MAX_PARTY; i++)
										{
											int partymember = pMob[partyleader].PartyList[i]; // tu não pagou mas vou corrigir, isso acontece na agua tbm

											if (partymember >= MAX_USER) continue;

											if (pUser[partymember].Mode == USER_PLAY)
											{

												SendClientSignalParm(partymember, ESCENE_FIELD, _MSG_StartTime, WaterClear1[1][Sala] * 2);
											}
										}
									}
								}

								else if (GenerateID >= WATER_M_INITIAL + 8 && GenerateID <= WATER_M_INITIAL + 11)
								{
									int CurrentNumMob = mNPCGen.pList[GenerateID].CurrentNumMob;

									if (CurrentNumMob == 1)
									{
										int Sala = 9;

										if (WaterClear1[1][Sala] > 5)
											WaterClear1[1][Sala] = 5;


										int partyleader = pMob[conn].Leader;

										if (partyleader <= 0)
											partyleader = conn;

										SendClientSignalParm(partyleader, ESCENE_FIELD, _MSG_StartTime, WaterClear1[1][Sala] * 2);

										if (partyleader > 0 && partyleader < MAX_USER) {
											if (pUser[partyleader].Ingame.MacroState == 1 && pMob[partyleader].MOB.Equip[13].sIndex == 3900) {
												MacroNextSala(partyleader, 2, 0);
											}
										}

										for (int i = 0; i < MAX_PARTY; i++)
										{
											int partymember = pMob[partyleader].PartyList[i];

											if (partymember >= MAX_USER) continue;

											if (pUser[partymember].Mode == USER_PLAY)
											{

												SendClientSignalParm(partymember, ESCENE_FIELD, _MSG_StartTime, WaterClear1[1][Sala] * 2);
											}
										}
									}
								}
#pragma endregion
#pragma region Agua N
								else if (GenerateID >= WATER_N_INITIAL && GenerateID <= WATER_N_INITIAL + 7)
								{
									int CurrentNumMob = mNPCGen.pList[GenerateID].CurrentNumMob;

									if (CurrentNumMob == 1)
									{
										int Sala = GenerateID - WATER_N_INITIAL;

										if (WaterClear1[0][Sala] > 15)
											WaterClear1[0][Sala] = 15;


										int partyleader = pMob[conn].Leader;

										if (partyleader <= 0)
											partyleader = conn;

										int slot_free = -1;

										STRUCT_ITEM Perga;
										memset(&Perga, 0, sizeof(STRUCT_ITEM));

										Perga.sIndex = 3174 + Sala;

										if (partyleader > 0 && partyleader < MAX_USER) {

											if (pUser[partyleader].Ingame.MacroState == 1 && pMob[partyleader].MOB.Equip[13].sIndex == 3900) {
												MacroNextSala(partyleader, 1, Sala + 1);
											}
											else {
												pUser[partyleader].Ingame.MacroState = 0;
												PutItem(partyleader, &Perga);
											}
										}

										SendClientSignalParm(partyleader, ESCENE_FIELD, _MSG_StartTime, WaterClear1[0][Sala] * 2);

										for (int i = 0; i < MAX_PARTY; i++)
										{
											int partymember = pMob[partyleader].PartyList[i];

											if (partymember >= MAX_USER) continue;

											if (pUser[partymember].Mode == USER_PLAY)
											{

												SendClientSignalParm(partymember, ESCENE_FIELD, _MSG_StartTime, WaterClear1[0][Sala] * 2);
											}
										}
									}
								}

								else if (GenerateID >= WATER_N_INITIAL + 8 && GenerateID <= WATER_N_INITIAL + 11)
								{
									int CurrentNumMob = mNPCGen.pList[GenerateID].CurrentNumMob;

									if (CurrentNumMob == 1)
									{
										int Sala = 9;

										if (WaterClear1[0][Sala] > 5)
											WaterClear1[0][Sala] = 5;


										int partyleader = pMob[conn].Leader;

										if (partyleader <= 0)
											partyleader = conn;

										SendClientSignalParm(partyleader, ESCENE_FIELD, _MSG_StartTime, WaterClear1[0][Sala] * 2);

										if (partyleader > 0 && partyleader < MAX_USER) {
											if (pUser[partyleader].Ingame.MacroState == 1 && pMob[partyleader].MOB.Equip[13].sIndex == 3900) {
												MacroNextSala(partyleader, 1, 0);
											}
										}

										for (int i = 0; i < MAX_PARTY; i++)
										{
											int partymember = pMob[partyleader].PartyList[i];

											if (partymember >= MAX_USER) continue;

											if (pUser[partymember].Mode == USER_PLAY)
											{

												SendClientSignalParm(partymember, ESCENE_FIELD, _MSG_StartTime, WaterClear1[0][Sala] * 2);
											}
										}
									}
								}
#pragma endregion
#pragma region Agua A
								else if (GenerateID >= WATER_A_INITIAL && GenerateID <= WATER_A_INITIAL + 7)
								{
									int CurrentNumMob = mNPCGen.pList[GenerateID].CurrentNumMob;

									if (CurrentNumMob == 1)
									{
										int Sala = GenerateID - WATER_A_INITIAL;

										if (WaterClear1[2][Sala] > 15)
											WaterClear1[2][Sala] = 15;


										int partyleader = pMob[conn].Leader;

										if (partyleader <= 0)
											partyleader = conn;

										int slot_free = -1;

										STRUCT_ITEM Perga;
										memset(&Perga, 0, sizeof(STRUCT_ITEM));

										Perga.sIndex = 3183 + Sala;

										if (partyleader > 0 && partyleader < MAX_USER) {

											if (pUser[partyleader].Ingame.MacroState == 1 && pMob[partyleader].MOB.Equip[13].sIndex == 3900) {
												MacroNextSala(partyleader, 3, Sala + 1);
											}
											else {
												pUser[partyleader].Ingame.MacroState = 0;
												PutItem(partyleader, &Perga);
											}
										}

										SendClientSignalParm(partyleader, ESCENE_FIELD, _MSG_StartTime, WaterClear1[2][Sala] * 2);

										for (int i = 0; i < MAX_PARTY; i++)
										{
											int partymember = pMob[partyleader].PartyList[i];

											if (partymember >= MAX_USER) continue;

											if (pUser[partymember].Mode == USER_PLAY)
											{


												SendClientSignalParm(partymember, ESCENE_FIELD, _MSG_StartTime, WaterClear1[2][Sala] * 2);
											}
										}
									}
								}

								else if (GenerateID >= WATER_A_INITIAL + 8 && GenerateID <= WATER_A_INITIAL + 11)
								{
									int CurrentNumMob = mNPCGen.pList[GenerateID].CurrentNumMob;

									if (CurrentNumMob == 1)
									{
										int Sala = 9;

										if (WaterClear1[2][Sala] > 5)
											WaterClear1[2][Sala] = 5;


										int partyleader = pMob[conn].Leader;

										if (partyleader <= 0)
											partyleader = conn;

										SendClientSignalParm(partyleader, ESCENE_FIELD, _MSG_StartTime, WaterClear1[2][Sala] * 2);

										if (partyleader > 0 && partyleader < MAX_USER) {
											if (pUser[partyleader].Ingame.MacroState == 1 && pMob[partyleader].MOB.Equip[13].sIndex == 3900) {
												MacroNextSala(partyleader, 3, 0);
											}
										}

										for (int i = 0; i < MAX_PARTY; i++)
										{
											int partymember = pMob[partyleader].PartyList[i];

											if (partymember >= MAX_USER) continue;

											if (pUser[partymember].Mode == USER_PLAY)
											{

												SendClientSignalParm(partymember, ESCENE_FIELD, _MSG_StartTime, WaterClear1[2][Sala] * 2);
											}
										}
									}
								}
#pragma endregion
								CCastleZakum::MobKilled(target, conn, PosX, PosY);
								//CCubo::MobKilled(target, conn, PosX, PosY);
								//CEncampment::MobKilled(target, conn, PosX, PosY);



								if (GenerateID >= TORRE_NOATUM1 && GenerateID <= TORRE_NOATUM3)
									LiveTower[GenerateID - TORRE_NOATUM1] = 0;


								else if (GenerateID == REI_HARABARD)
								{
									Kingdom1Clear = 1;
									SendNoticeArea(g_pMessageStringTable[_NN_King1_Killed], 1676, 1556, 1776, 1636);
								}
								else if (GenerateID == REI_GLANTUAR)
								{
									Kingdom2Clear = 1;
									SendNoticeArea(g_pMessageStringTable[_NN_King2_Killed], 1676, 1816, 1776, 1892);
								}
#pragma region Boss R Lac R Ori Circulo divino
								else if (GenerateID == 0 || GenerateID == 1 || GenerateID == 2)
								{
									STRUCT_ITEM item;
									memset(&item, 0, sizeof(STRUCT_ITEM));

									int _rand = rand() % 14;

									if (_rand == 0)
										item.sIndex = 419;

									else if (_rand == 1)
										item.sIndex = 420;

									if (item.sIndex)
									{
										SetItemBonus(&item, 0, 0, 0);

										PutItem(conn, &item);
									}
								}

								else if (GenerateID == 5 || GenerateID == 6 || GenerateID == 7)
								{
									STRUCT_ITEM item;
									memset(&item, 0, sizeof(STRUCT_ITEM));

									int _rand = rand() % 14;

									if (_rand == 0)
										item.sIndex = 421 + (rand() % 7);

									else if (_rand == 1)
										item.sIndex = 419;

									if (item.sIndex)
									{
										SetItemBonus(&item, 0, 0, 0);

										if (pHeightGrid[AlvoY][AlvoX] > -40 && pHeightGrid[AlvoY][AlvoX] < 36)
											PutItem(conn, &item);
										//CreateItem(AlvoX, AlvoY, &item, rand() % 4, 1);
									}
								}
#pragma endregion

								else if (GenerateID == 3)
								{
									STRUCT_ITEM item;
									memset(&item, 0, sizeof(STRUCT_ITEM));

									int _rand = rand() % 7;

									if (_rand == 0)
										item.sIndex = 1106;

									else if (_rand == 1)
										item.sIndex = 1256;

									else if (_rand == 2)
										item.sIndex = 1418;

									else if (_rand == 3)
										item.sIndex = 1568;

									if (item.sIndex)
									{
										SetItemBonus(&item, 75, 1, 0);

										if (pHeightGrid[AlvoY][AlvoX] > -40 && pHeightGrid[AlvoY][AlvoX] < 36)
											PutItem(conn, &item);
										//CreateItem(AlvoX, AlvoY, &item, rand() % 4, 1);
									}
								}
#pragma region Pesas
								else if (GenerateIndex >= NIGHTMARE_M_INITIAL && GenerateIndex <= NIGHTMARE_M_END)
								{
									int ARNOLD_ = mNPCGen.pList[Arnold_].CurrentNumMob;
									int LAINY = mNPCGen.pList[Lainy].CurrentNumMob;
									int REIMERS = mNPCGen.pList[Reimers].CurrentNumMob;
									int ROPERION = mNPCGen.pList[RoPerion].CurrentNumMob;
									int IRENA = mNPCGen.pList[Irena].CurrentNumMob;


									if (ARNOLD_ == 1)
										GenerateMob(GenerateIndex, 0, 0);//Pesa M

									if (LAINY == 1)
										GenerateMob(GenerateIndex, 0, 0);//Pesa M

									if (REIMERS == 1)
										GenerateMob(GenerateIndex, 0, 0);//Pesa M

									if (ROPERION == 1)
										GenerateMob(GenerateIndex, 0, 0);//Pesa M

									if (IRENA == 1)
										GenerateMob(GenerateIndex, 0, 0);//Pesa M

								}
								else if (GenerateIndex >= NIGHTMARE_N_INITIAL && GenerateIndex <= NIGHTMARE_N_END)
								{
									int MARTIN = mNPCGen.pList[Martin].CurrentNumMob;
									int BALMERS = mNPCGen.pList[Balmers].CurrentNumMob;
									int RUBYEN = mNPCGen.pList[Rubyen].CurrentNumMob;
									int NAOMI = mNPCGen.pList[Naomi].CurrentNumMob;
									int ARNOLD = mNPCGen.pList[Arnold].CurrentNumMob;

									if (MARTIN == 1)
										GenerateMob(GenerateIndex, 0, 0);//Pesa N

									if (BALMERS == 1)
										GenerateMob(GenerateIndex, 0, 0);//Pesa N

									if (RUBYEN == 1)
										GenerateMob(GenerateIndex, 0, 0);//Pesa N

									if (NAOMI == 1)
										GenerateMob(GenerateIndex, 0, 0);//Pesa N

									if (ARNOLD == 1)
										GenerateMob(GenerateIndex, 0, 0);//Pesa N
								}
								else if (GenerateIndex >= NIGHTMARE_A_INITIAL && GenerateIndex <= NIGHTMARE_A_END)
								{
									int ESCURIDAO = mNPCGen.pList[Escuridao].CurrentNumMob;
									int ERIN = mNPCGen.pList[Erin].CurrentNumMob;
									int FENIX = mNPCGen.pList[Fenix].CurrentNumMob;
									int KARA = mNPCGen.pList[Kara].CurrentNumMob;
									int KEI = mNPCGen.pList[Kei].CurrentNumMob;
									int KEMI = mNPCGen.pList[Kemi].CurrentNumMob;
									int LEAO = mNPCGen.pList[Leao].CurrentNumMob;
									int UIE = mNPCGen.pList[Yue].CurrentNumMob;

									if (ESCURIDAO == 1)
										GenerateMob(GenerateIndex, 0, 0);//Pesa A

									if (ERIN == 1)
										GenerateMob(GenerateIndex, 0, 0);//Pesa A

									if (FENIX == 1)
										GenerateMob(GenerateIndex, 0, 0);//Pesa A

									if (KARA == 1)
										GenerateMob(GenerateIndex, 0, 0);//Pesa A
									 
									if (KEI == 1)
										GenerateMob(GenerateIndex, 0, 0);//Pesa A

									if (KEMI == 1)
										GenerateMob(GenerateIndex, 0, 0);//Pesa A

									if (LEAO == 1)
										GenerateMob(GenerateIndex, 0, 0);//Pesa A

									if (UIE == 1)
										GenerateMob(GenerateIndex, 0, 0);//Pesa A
								}
#pragma endregion
#pragma region Portão Infernal Parte 1
								else if (GenerateIndex >= PI_INITIAL1 && GenerateIndex <= PI_END1)
								{
									// Portão Infernal Parte 1
									GenerateMob(GenerateIndex, 0, 0);
								}
#pragma endregion
#pragma region Carta de duelo N
								//Carta N
								if (GenerateID >= SECRET_ROOM_N_SALA1_MOB_1 && GenerateID <= SECRET_ROOM_N_SALA1_MOB_2)
								{
									int CurrentNumMob = mNPCGen.pList[SECRET_ROOM_N_SALA1_MOB_1].CurrentNumMob;
									CurrentNumMob += mNPCGen.pList[SECRET_ROOM_N_SALA1_MOB_2].CurrentNumMob;

									if (CurrentNumMob == 1)
									{
										CartaTime = 60;

										ClearAreaTeleport(778, 3652, 832, 3698, CartaPos[1][0], CartaPos[1][1]);

										CartaSala++;

										MSG_STANDARDPARM sm;

										sm.Type = _MSG_StartTime;
										sm.ID = ESCENE_FIELD;
										sm.Size = sizeof(MSG_STANDARDPARM);
										sm.Parm = CartaTime * 2;

										MapaMulticast(6, 28, (MSG_STANDARD*)&sm, 0);
									}
								}

								if (GenerateID >= SECRET_ROOM_N_SALA2_MOB_1 && GenerateID <= SECRET_ROOM_N_SALA2_MOB_2)
								{
									int CurrentNumMob = mNPCGen.pList[SECRET_ROOM_N_SALA2_MOB_1].CurrentNumMob;
									CurrentNumMob += mNPCGen.pList[SECRET_ROOM_N_SALA2_MOB_2].CurrentNumMob;

									if (CurrentNumMob == 1)
									{
										CartaTime = 60;

										ClearAreaTeleport(836, 3652, 890, 3698, CartaPos[2][0], CartaPos[2][1]);

										CartaSala++;

										MSG_STANDARDPARM sm;

										sm.Type = _MSG_StartTime;
										sm.ID = ESCENE_FIELD;
										sm.Size = sizeof(MSG_STANDARDPARM);
										sm.Parm = CartaTime * 2;

										MapaMulticast(6, 28, (MSG_STANDARD*)&sm, 0);
									}
								}

								if (GenerateID >= SECRET_ROOM_N_SALA3_MOB_1 && GenerateID <= SECRET_ROOM_N_SALA3_MOB_2)
								{
									int CurrentNumMob = mNPCGen.pList[SECRET_ROOM_N_SALA3_MOB_1].CurrentNumMob;
									CurrentNumMob += mNPCGen.pList[SECRET_ROOM_N_SALA3_MOB_2].CurrentNumMob;

									if (CurrentNumMob == 1)
									{
										CartaTime = 60;

										ClearAreaTeleport(834, 3595, 889, 3645, CartaPos[3][0], CartaPos[3][1]);

										CartaSala++;

										MSG_STANDARDPARM sm;

										sm.Type = _MSG_StartTime;
										sm.ID = ESCENE_FIELD;
										sm.Size = sizeof(MSG_STANDARDPARM);
										sm.Parm = CartaTime * 2;

										MapaMulticast(6, 28, (MSG_STANDARD*)&sm, 0);
									}
								}

								if (GenerateID >= SECRET_ROOM_N_SALA4_MOB_1 && GenerateID <= SECRET_ROOM_N_SALA4_MOB_4)
								{
									int CurrentNumMob = mNPCGen.pList[SECRET_ROOM_N_SALA4_MOB_1].CurrentNumMob;
									CurrentNumMob += mNPCGen.pList[SECRET_ROOM_N_SALA4_MOB_2].CurrentNumMob;
									CurrentNumMob += mNPCGen.pList[SECRET_ROOM_N_SALA4_MOB_3].CurrentNumMob;
									CurrentNumMob += mNPCGen.pList[SECRET_ROOM_N_SALA4_MOB_4].CurrentNumMob;

									if (CurrentNumMob == 1)
									{
										//ClearArea(776, 3595, 834, 3648);
										CartaTime = 3;
										CartaSala = 4;
									}
								}
#pragma endregion
#pragma region Carta de duelo M
								//Carta M
								if (GenerateID >= SECRET_ROOM_M_SALA1_MOB_1 && GenerateID <= SECRET_ROOM_M_SALA1_MOB_2)
								{
									int CurrentNumMob = mNPCGen.pList[SECRET_ROOM_M_SALA1_MOB_1].CurrentNumMob;
									CurrentNumMob += mNPCGen.pList[SECRET_ROOM_M_SALA1_MOB_2].CurrentNumMob;

									if (CurrentNumMob == 1)
									{
										CartaTime = 60;

										ClearAreaTeleport(778, 3652, 832, 3698, CartaPos[1][0], CartaPos[1][1]);

										CartaSala++;

										MSG_STANDARDPARM sm;

										sm.Type = _MSG_StartTime;
										sm.ID = ESCENE_FIELD;
										sm.Size = sizeof(MSG_STANDARDPARM);
										sm.Parm = CartaTime * 2;

										MapaMulticast(6, 28, (MSG_STANDARD*)&sm, 0);
									}
								}

								if (GenerateID >= SECRET_ROOM_M_SALA2_MOB_1 && GenerateID <= SECRET_ROOM_M_SALA2_MOB_2)
								{
									int CurrentNumMob = mNPCGen.pList[SECRET_ROOM_M_SALA2_MOB_1].CurrentNumMob;
									CurrentNumMob += mNPCGen.pList[SECRET_ROOM_M_SALA2_MOB_2].CurrentNumMob;

									if (CurrentNumMob == 1)
									{
										CartaTime = 60;

										ClearAreaTeleport(836, 3652, 890, 3698, CartaPos[2][0], CartaPos[2][1]);

										CartaSala++;

										MSG_STANDARDPARM sm;

										sm.Type = _MSG_StartTime;
										sm.ID = ESCENE_FIELD;
										sm.Size = sizeof(MSG_STANDARDPARM);
										sm.Parm = CartaTime * 2;

										MapaMulticast(6, 28, (MSG_STANDARD*)&sm, 0);
									}
								}

								if (GenerateID >= SECRET_ROOM_M_SALA3_MOB_1 && GenerateID <= SECRET_ROOM_M_SALA3_MOB_2)
								{
									int CurrentNumMob = mNPCGen.pList[SECRET_ROOM_M_SALA3_MOB_1].CurrentNumMob;
									CurrentNumMob += mNPCGen.pList[SECRET_ROOM_M_SALA3_MOB_2].CurrentNumMob;

									if (CurrentNumMob == 1)
									{
										CartaTime = 60;

										ClearAreaTeleport(834, 3595, 889, 3645, CartaPos[3][0], CartaPos[3][1]);

										CartaSala++;

										MSG_STANDARDPARM sm;

										sm.Type = _MSG_StartTime;
										sm.ID = ESCENE_FIELD;
										sm.Size = sizeof(MSG_STANDARDPARM);
										sm.Parm = CartaTime * 2;

										MapaMulticast(6, 28, (MSG_STANDARD*)&sm, 0);
									}
								}

								if (GenerateID >= SECRET_ROOM_M_SALA4_MOB_1 && GenerateID <= SECRET_ROOM_M_SALA4_MOB_4)
								{
									int CurrentNumMob = mNPCGen.pList[SECRET_ROOM_M_SALA4_MOB_1].CurrentNumMob;
									CurrentNumMob += mNPCGen.pList[SECRET_ROOM_M_SALA4_MOB_2].CurrentNumMob;
									CurrentNumMob += mNPCGen.pList[SECRET_ROOM_M_SALA4_MOB_3].CurrentNumMob;
									CurrentNumMob += mNPCGen.pList[SECRET_ROOM_M_SALA4_MOB_4].CurrentNumMob;

									if (CurrentNumMob == 1)
									{
										//ClearArea(776, 3595, 834, 3648);
										CartaTime = 3;
										CartaSala = 4;
									}
								}
#pragma endregion
#pragma region Carta de duelo A
								//Carta A
								if (GenerateID >= SECRET_ROOM_A_SALA1_MOB_1 && GenerateID <= SECRET_ROOM_A_SALA1_MOB_2)
								{
									int CurrentNumMob = mNPCGen.pList[SECRET_ROOM_A_SALA1_MOB_1].CurrentNumMob;
									CurrentNumMob += mNPCGen.pList[SECRET_ROOM_A_SALA1_MOB_2].CurrentNumMob;

									if (CurrentNumMob == 1)
									{
										CartaTime = 60;

										ClearAreaTeleport(778, 3652, 832, 3698, CartaPos[1][0], CartaPos[1][1]);

										CartaSala++;

										MSG_STANDARDPARM sm;

										sm.Type = _MSG_StartTime;
										sm.ID = ESCENE_FIELD;
										sm.Size = sizeof(MSG_STANDARDPARM);
										sm.Parm = CartaTime * 2;

										MapaMulticast(6, 28, (MSG_STANDARD*)&sm, 0);
									}
								}

								if (GenerateID >= SECRET_ROOM_A_SALA2_MOB_1 && GenerateID <= SECRET_ROOM_A_SALA2_MOB_2)
								{
									int CurrentNumMob = mNPCGen.pList[SECRET_ROOM_A_SALA2_MOB_1].CurrentNumMob;
									CurrentNumMob += mNPCGen.pList[SECRET_ROOM_A_SALA2_MOB_2].CurrentNumMob;

									if (CurrentNumMob == 1)
									{
										CartaTime = 60;

										ClearAreaTeleport(836, 3652, 890, 3698, CartaPos[2][0], CartaPos[2][1]);

										CartaSala++;

										MSG_STANDARDPARM sm;

										sm.Type = _MSG_StartTime;
										sm.ID = ESCENE_FIELD;
										sm.Size = sizeof(MSG_STANDARDPARM);
										sm.Parm = CartaTime * 2;

										MapaMulticast(6, 28, (MSG_STANDARD*)&sm, 0);
									}
								}

								if (GenerateID >= SECRET_ROOM_A_SALA3_MOB_1 && GenerateID <= SECRET_ROOM_A_SALA3_MOB_2)
								{
									int CurrentNumMob = mNPCGen.pList[SECRET_ROOM_A_SALA3_MOB_1].CurrentNumMob;
									CurrentNumMob += mNPCGen.pList[SECRET_ROOM_A_SALA3_MOB_2].CurrentNumMob;

									if (CurrentNumMob == 1)
									{
										CartaTime = 60;

										ClearAreaTeleport(834, 3595, 889, 3645, CartaPos[3][0], CartaPos[3][1]);

										CartaSala++;

										MSG_STANDARDPARM sm;

										sm.Type = _MSG_StartTime;
										sm.ID = ESCENE_FIELD;
										sm.Size = sizeof(MSG_STANDARDPARM);
										sm.Parm = CartaTime * 2;

										MapaMulticast(6, 28, (MSG_STANDARD*)&sm, 0);
									}
								}

								if (GenerateID >= SECRET_ROOM_A_SALA4_MOB_1 && GenerateID <= SECRET_ROOM_A_SALA4_MOB_4)
								{
									int CurrentNumMob = mNPCGen.pList[SECRET_ROOM_A_SALA4_MOB_1].CurrentNumMob;
									CurrentNumMob += mNPCGen.pList[SECRET_ROOM_A_SALA4_MOB_2].CurrentNumMob;
									CurrentNumMob += mNPCGen.pList[SECRET_ROOM_A_SALA4_MOB_3].CurrentNumMob;
									CurrentNumMob += mNPCGen.pList[SECRET_ROOM_A_SALA4_MOB_4].CurrentNumMob;

									if (CurrentNumMob == 1)
									{
										//ClearArea(776, 3595, 834, 3648);
										CartaTime = 3;
										CartaSala = 4;
									}
								}
#pragma endregion
#pragma region Pista de Runas
#pragma region Pista Nv0 Lich_Crunt
								if (GenerateID == RUNEQUEST_LV0_LICH1 || GenerateID == RUNEQUEST_LV0_LICH2)
								{
									int _rand = rand() % 100;

									if (_rand < 20)
									{
										for (int c = MAX_USER; c < MAX_MOB; c++)
										{
											if (pMob[c].Mode == USER_EMPTY)
												continue;

											if (pMob[c].GenerateIndex != RUNEQUEST_LV0_LICH1 && pMob[c].GenerateIndex != RUNEQUEST_LV0_LICH2)
												continue;

											DeleteMob(c, 3);
										}

										int partyleader = pMob[conn].Leader;

										if (partyleader <= 0)
											partyleader = conn;

										STRUCT_ITEM Runa;
										memset(&Runa, 0, sizeof(STRUCT_ITEM));

										Runa.sIndex = PistaRune[0][rand() % 5];

										//correção
										if (checkCord(partyleader, 3330, 1600, 3450, 1660) == TRUE)
										{

											if (partyleader > 0 && partyleader < MAX_USER)
												PutItem(partyleader, &Runa);
										}

										for (int i = 0; i < MAX_PARTY; i++)
										{
											int partymember = pMob[partyleader].PartyList[i];

											if (partymember >= MAX_USER) continue;

											if (pUser[partymember].Mode == USER_PLAY)
											{
												//correção
												if (checkCord(partymember, 3330, 1600, 3450, 1660) == FALSE)
													continue;

												Runa.sIndex = PistaRune[0][rand() % 5];
												PutItem(partymember, &Runa);
											}
										}

										STRUCT_ITEM NextPista;
										memset(&NextPista, 0, sizeof(STRUCT_ITEM));

										NextPista.sIndex = 5134;
										NextPista.stEffect[0].cEffect = 43;
										NextPista.stEffect[0].cValue = 1;

										PutItem(partyleader, &NextPista);
										SystemLog("-system", "-", 0, strFmt("etc,questRune +0 complete leader:%s", pMob[partyleader].MOB.MobName));
									}
									else
									{
										for (int c = MAX_USER; c < MAX_MOB; c++)
										{
											if (pMob[c].Mode == USER_EMPTY)
												continue;

											if (pMob[c].GenerateIndex != RUNEQUEST_LV0_LICH1 && pMob[c].GenerateIndex != RUNEQUEST_LV0_LICH2)
												continue;

											DeleteMob(c, 3);
										}

										GenerateMob(RUNEQUEST_LV0_LICH1, 0, 0);
										GenerateMob(RUNEQUEST_LV0_LICH1, 0, 0);

										GenerateMob(RUNEQUEST_LV0_LICH2, 0, 0);
										GenerateMob(RUNEQUEST_LV0_LICH2, 0, 0);
									}
								}
#pragma endregion
#pragma region Pista Nv1 Torre
								if (GenerateID == RUNEQUEST_LV1_TORRE1 || GenerateID == RUNEQUEST_LV1_TORRE2 || GenerateID == RUNEQUEST_LV1_TORRE3)
								{
									int party = GenerateID - RUNEQUEST_LV1_TORRE1;

									Pista[1].Party[party].MobCount = 0;

									DoTeleport(Pista[1].Party[party].LeaderID, 3294, rand() % 1 == 0 ? 1701 : 1686);

									for (int i = 0; i < MAX_PARTY; i++)
									{
										int partymember = pMob[Pista[1].Party[0].LeaderID].PartyList[i];

										if (partymember >= MAX_USER) continue;

										if (pUser[partymember].Mode != USER_PLAY)
											continue;

										DoTeleport(partymember, 3294, rand() % 1 == 0 ? 1701 : 1686);
									}
								}

								if (GenerateID >= RUNEQUEST_LV1_MOB_INITIAL && GenerateID <= RUNEQUEST_LV1_MOB_END)
								{
									int partyleader = pMob[conn].Leader;

									if (partyleader <= 0)
										partyleader = conn;

									if (Pista[1].Party[0].LeaderID == partyleader)
										Pista[1].Party[0].MobCount++;

									else if (Pista[1].Party[1].LeaderID == partyleader)
										Pista[1].Party[1].MobCount++;

									else if (Pista[1].Party[2].LeaderID == partyleader)
										Pista[1].Party[2].MobCount++;
								}
#pragma endregion
#pragma region Pista Nv2 Amon
								if (GenerateID == RUNEQUEST_LV2_MOB_BOSS)
								{
									int partyleader = pMob[conn].Leader;

									if (partyleader <= 0)
										partyleader = conn;

									STRUCT_ITEM Runa;
									memset(&Runa, 0, sizeof(STRUCT_ITEM));

									Runa.sIndex = PistaRune[2][rand() % 6];

									//correção

									if (checkCord(partyleader, 3340, 1425, 3449, 1463) == TRUE)
									{
										if (partyleader > 0 && partyleader < MAX_USER) {
											PutItem(partyleader, &Runa);

											STRUCT_ITEM NextPista;
											memset(&NextPista, 0, sizeof(STRUCT_ITEM));

											NextPista.sIndex = 5134;
											NextPista.stEffect[0].cEffect = 43;
											NextPista.stEffect[0].cValue = 3;

											PutItem(partyleader, &NextPista);
										}
									}
									for (int i = 0; i < MAX_PARTY; i++)
									{
										int partymember = pMob[partyleader].PartyList[i];

										if (partymember >= MAX_USER) continue;

										if (pUser[partymember].Mode == USER_PLAY)
										{
											//correção
											if (checkCord(partymember, 3340, 1425, 3449, 1463) == FALSE)
												continue;

											Runa.sIndex = PistaRune[2][rand() % 6];
											PutItem(partymember, &Runa);

										}
									}


									SystemLog("-system", "-", 0, strFmt("etc,questRune +2 complete leader:%s", pMob[partyleader].MOB.MobName));
								}
#pragma endregion
#pragma region Pista Nv3 Sulrang
								if (GenerateID >= RUNEQUEST_LV3_MOB_SULRANG_INITIAL && GenerateID <= RUNEQUEST_LV3_MOB_SULRANG_END)
								{
									GenerateMob(RUNEQUEST_LV3_MOB_BOSS_INITIAL + rand() % 7, 0, 0);
								}
								if (GenerateID >= RUNEQUEST_LV3_MOB_BOSS_INITIAL && GenerateID <= RUNEQUEST_LV3_MOB_BOSS_END)
								{
									int partyleader = pMob[conn].Leader;

									if (partyleader <= 0)
										partyleader = conn;

									if (Pista[3].Party[0].LeaderID == partyleader)
										Pista[3].Party[0].MobCount++;

									else if (Pista[3].Party[1].LeaderID == partyleader)
										Pista[3].Party[1].MobCount++;

									else if (Pista[3].Party[2].LeaderID == partyleader)
										Pista[3].Party[2].MobCount++;
								}
#pragma endregion
#pragma region Pista Nv4 Labirinto
								if (GenerateID >= RUNEQUEST_LV4_MOB_INITIAL && GenerateID <= RUNEQUEST_LV4_MOB_END && mNPCGen.pList[GenerateID].CurrentNumMob == 1)
								{
									int leader = pMob[conn].Leader;

									int partyleader = pMob[conn].Leader;

									if (partyleader <= 0)
										partyleader = conn;

									if (partyleader == Pista[4].Party[0].LeaderID && Pista[4].Party[1].MobCount >= 1 && Pista[4].Party[2].MobCount >= 1)
									{									
										if (Pista[4].Party[0].MobCount == 1)
										{
											DoTeleport(partyleader, 3351, 1334);

											for (int i = 0; i < MAX_PARTY; i++)
											{
												int partyconn = pMob[partyleader].PartyList[i];

												if (partyconn > 0 && partyconn < MAX_USER && partyconn != partyleader && pUser[partyconn].Mode == USER_PLAY)
													DoTeleport(partyconn, 3352, 1334);
											}

											GenerateMob(RUNEQUEST_LV4_MOB_BOSS, 3351, 1336);
										}
										if (Pista[4].Party[0].MobCount >= 1)
											Pista[4].Party[0].MobCount--;
									}
									else if (partyleader == Pista[4].Party[1].LeaderID && Pista[4].Party[0].MobCount >= 1 && Pista[4].Party[2].MobCount >= 1)
									{
										if (Pista[4].Party[1].MobCount == 1)
										{
											DoTeleport(partyleader, 3351, 1334);

											for (int i = 0; i < MAX_PARTY; i++)
											{
												int partyconn = pMob[partyleader].PartyList[i];

												if (partyconn > 0 && partyconn < MAX_USER && partyconn != partyleader && pUser[partyconn].Mode == USER_PLAY)
													DoTeleport(partyconn, 3351, 1334);
											}

											GenerateMob(RUNEQUEST_LV4_MOB_BOSS, 3351, 1336);
										}
										if (Pista[4].Party[1].MobCount >= 1)
											Pista[4].Party[1].MobCount--;
									}
									else if (partyleader == Pista[4].Party[2].LeaderID && Pista[4].Party[1].MobCount >= 1 && Pista[4].Party[0].MobCount >= 1)
									{
										if (Pista[4].Party[2].MobCount == 1)
										{
											DoTeleport(partyleader, 3351, 1334);

											for (int i = 0; i < MAX_PARTY; i++)
											{
												int partyconn = pMob[partyleader].PartyList[i];

												if (partyconn >= MAX_USER) continue;

												if (partyconn > 0 && partyconn < MAX_USER && partyconn != partyleader && pUser[partyconn].Mode == USER_PLAY)
													DoTeleport(partyconn, 3351, 1334);
											}

											GenerateMob(RUNEQUEST_LV4_MOB_BOSS, 3351, 1336);
										}
										if (Pista[4].Party[2].MobCount >= 1)
											Pista[4].Party[2].MobCount--;
									}
								}

								if (GenerateID == RUNEQUEST_LV4_MOB_BOSS)
								{
									int partyleader = pMob[conn].Leader;

									if (partyleader <= 0)
										partyleader = conn;

									STRUCT_ITEM Runa;
									memset(&Runa, 0, sizeof(STRUCT_ITEM));

									Runa.sIndex = PistaRune[4][rand() % 4];

									//correção

									if (checkCord(partyleader, 3333, 1320, 3365, 1349) == TRUE)
									{

										if (partyleader > 0 && partyleader < MAX_USER) {
											PutItem(partyleader, &Runa);

											STRUCT_ITEM NextPista;
											memset(&NextPista, 0, sizeof(STRUCT_ITEM));

											NextPista.sIndex = 5134;
											NextPista.stEffect[0].cEffect = 43;
											NextPista.stEffect[0].cValue = 5;

											PutItem(partyleader, &NextPista);
											DoTeleport(partyleader, 3294, rand() % 1 == 0 ? 1701 : 1686);
										}
									}

									for (int i = 0; i < MAX_PARTY; i++)
									{
										int partymember = pMob[partyleader].PartyList[i];

										if (partymember >= MAX_USER) continue;

										if (pUser[partymember].Mode == USER_PLAY)
										{
											//correção
											if (checkCord(partymember, 3333, 1320, 3365, 1349) == TRUE)
											{
												Runa.sIndex = PistaRune[4][rand() % 4];
												PutItem(partymember, &Runa);
												DoTeleport(partymember, 3294, rand() % 1 == 0 ? 1701 : 1686);
											}
										}

									}
									SystemLog("-system", "-", 0, strFmt("etc,questRune +4 complete leader:%s", pMob[partyleader].MOB.MobName));
								}
#pragma endregion
#pragma region Pista Nv5 Balrog
								if (GenerateID == RUNEQUEST_LV5_MOB_BOSS)
								{
									Pista[5].Party[0].MobCount = 1;

									int partyleader = pMob[conn].Leader;

									if (partyleader <= 0)
										partyleader = conn;

									STRUCT_ITEM Runa;
									memset(&Runa, 0, sizeof(STRUCT_ITEM));

									Runa.sIndex = PistaRune[5][rand() % 7];

									//correção

									if (checkCord(partyleader, 3333, 1157, 3448, 1271) == TRUE)
									{

										if (partyleader > 0 && partyleader < MAX_USER) {
											PutItem(partyleader, &Runa);

											STRUCT_ITEM NextPista;
											memset(&NextPista, 0, sizeof(STRUCT_ITEM));

											NextPista.sIndex = 5134;
											NextPista.stEffect[0].cEffect = 43;
											NextPista.stEffect[0].cValue = 6;

											PutItem(partyleader, &NextPista);
											DoTeleport(partyleader, 3294, rand() % 1 == 0 ? 1701 : 1686);
										}
									}

									for (int i = 0; i < MAX_PARTY; i++)
									{
										int partymember = pMob[partyleader].PartyList[i];

										if (partymember >= MAX_USER) continue;

										if (pUser[partymember].Mode == USER_PLAY)
										{
											//correção
											if (checkCord(partymember, 3333, 1157, 3448, 1271) == FALSE)
												continue;
											Runa.sIndex = PistaRune[5][rand() % 7];
											PutItem(partymember, &Runa);
											DoTeleport(partymember, 3294, rand() % 1 == 0 ? 1701 : 1686);
										}

									}

									SystemLog("-system", "-", 0, strFmt("etc,questRune +5 complete leader:%s", pMob[partyleader].MOB.MobName));
								}
#pragma endregion
#pragma region Pista Nv6 Coelho
								if (GenerateID >= RUNEQUEST_LV6_MOB_INITIAL && GenerateID <= RUNEQUEST_LV6_MOB_END)
								{
									if (Pista[6].Party[0].MobCount == 1)
									{
										Pista[6].Party[0].MobCount--;

										GenerateMob(RUNEQUEST_LV6_MOB_BOSS, 0, 0);
									}

									else if (Pista[6].Party[0].MobCount > 0)
										Pista[6].Party[0].MobCount--;
								}

								if (GenerateID == RUNEQUEST_LV6_MOB_BOSS)
								{
									int partyleader = pMob[conn].Leader;

									if (partyleader <= 0)
										partyleader = conn;

									STRUCT_ITEM Runa;
									memset(&Runa, 0, sizeof(STRUCT_ITEM));

									Runa.sIndex = PistaRune[6][rand() % 9];

									//correção
									if (checkCord(partyleader, 3332, 1471, 3449, 1529) == TRUE)
									{

										if (partyleader > 0 && partyleader < MAX_USER)
											PutItem(partyleader, &Runa);
									}


									for (int i = 0; i < MAX_PARTY; i++)
									{
										int partymember = pMob[partyleader].PartyList[i];

										if (partymember >= MAX_USER) continue;

										if (pUser[partymember].Mode == USER_PLAY)
										{
											//correção
											if (checkCord(partymember, 3332, 1471, 3449, 1529) == FALSE)
												continue;

											Runa.sIndex = PistaRune[6][rand() % 9];
											PutItem(partymember, &Runa);
										}
									}
									SystemLog("-system", "-", 0, strFmt("etc,questRune +6 complete leader:%s", pMob[partyleader].MOB.MobName));
								}
#pragma endregion

							}
#pragma region Drop Gold
							int MobCoin = pMob[target].MOB.Coin;
							int UNKGOLD = 18;

							if (pMob[target].MOB.BaseScore.Level < 10)
								UNKGOLD = 2;
							else if (pMob[target].MOB.BaseScore.Level < 20)
								UNKGOLD = 4;
							else if (pMob[target].MOB.BaseScore.Level < 30)
								UNKGOLD = 6;
							else if (pMob[target].MOB.BaseScore.Level < 50)
								UNKGOLD = 9; // aparentementer corrigido man, ta igual ao meu e eu não tenho mais esse b.o se ainda causar, me avisa que a gente vê :) ok

							UNKGOLD = rand() % (UNKGOLD + 1);

							if (MobCoin && UNKGOLD == 0)
							{
								MobCoin = 4 * (rand() % (((MobCoin + 1) / 4) + 1) + (MobCoin + 1) / 4 + MobCoin);

								if (MobCoin > 2000)
									MobCoin = 2000;

								if (MobCoin + pMob[conn].MOB.Coin > 2000000000)

									SendClientMessage(conn, g_pMessageStringTable[_NN_Cant_get_more_than_2G]);

								else
								{
									MobCoin = ControleDropGold(conn, target, MobCoin);
									pMob[conn].MOB.Coin += MobCoin;
									SendEtc(conn);
								}
							}
#pragma endregion
#pragma region Drop Evento em todos os mobs
							if (evOn && evStartIndex && evEndIndex && evItem && evRate && evCurrentIndex < evEndIndex && rand() % evRate == 0)
							{
								STRUCT_ITEM item;
								memset(&item, 0, sizeof(STRUCT_ITEM));

								item.sIndex = evItem;
								
								if (evIndex)
								{
									item.stEffect[0].cEffect = 62;
									item.stEffect[0].cValue = evCurrentIndex / 256;
									item.stEffect[1].cEffect = 63;
									item.stEffect[1].cValue = evCurrentIndex;
									item.stEffect[2].cEffect = 59;
									item.stEffect[2].cValue = rand();

									//snprintf(temp, sizeof(temp), " [%s] Dropou [%s] já foram dropados [%d].", pMob[conn].MOB.MobName, g_pItemList[evItem].Name, evCurrentIndex);
								}
								else {
									//snprintf(temp, sizeof(temp), "[%s] Dropou [%s]", pMob[conn].MOB.MobName, g_pItemList[evItem].Name);
								}

								if (evNotice)
									//SendNotice(temp);

									evCurrentIndex++;

								int bonus = 0;

								if (conn > 0 && conn < MAX_USER)
									bonus = pMob[conn].DropBonus;

								ControleDropItem(conn, target, bonus, PosX, PosY, &item);

								DrawConfig(1);
							}
#pragma endregion

#pragma region DropLanhouse

							if ((pMob[conn].TargetX > 3604 && pMob[conn].TargetY > 3604 && pMob[conn].TargetX < 3691 && pMob[conn].TargetY < 3690) ||
								(pMob[conn].TargetX > 3732 && pMob[conn].TargetY > 3476 && pMob[conn].TargetX < 3819 && pMob[conn].TargetY < 3563) ||
								(pMob[conn].TargetX > 3860 && pMob[conn].TargetY > 3604 && pMob[conn].TargetX < 3946 && pMob[conn].TargetY < 3690)
								)
								LanDrop(conn, target);
#pragma endregion

							int target_level = pMob[target].MOB.CurrentScore.Level;
#pragma region Drop comum
							for (int i = 0; i < MAX_CARRY; i++)
							{
								if (pMob[target].MOB.Carry[i].sIndex == 0)
									continue;

								int droprate = g_pDropRate[i];
								int dropbonus = g_pDropBonus[i] + pMob[conn].DropBonus;

								if (dropbonus != 100)
								{
									dropbonus = 10000 / (dropbonus + 1);
									droprate = dropbonus * droprate / 100;
								}

								int pos = i / 8;

								if (i < 60)
								{
									if (pos == 0 || pos == 1 || pos == 2)
									{
										if (target_level < 10)
											droprate = 4 * droprate / 100;

										else if (target_level < 20)
											droprate = 5 * droprate / 100;

										else if (target_level < 30)
											droprate = 6 * droprate / 100;

										else if (target_level < 40)
											droprate = 7 * droprate / 100;

										else if (target_level < 60)
											droprate = 8 * droprate / 100;

										else
											droprate = 99 * droprate / 100;
									}
								}

								else
								{
									if (target_level < 170)
										droprate = 90 * droprate / 100;

									else if (target_level < 200)
										droprate = 60 * droprate / 100;

									else if (target_level < 230)
										droprate = 50 * droprate / 100;

									else if (target_level < 255)
										droprate = 43 * droprate / 100;

									else if (target_level < 320)
										droprate = 38 * droprate / 100;

									else
										droprate = 50 * droprate / 100;
								}

								if (TESTSERVER)
									droprate /= 2;

								if (LOCALSERVER)
									droprate /= 100;

								if (pMob[conn].MOB.Rsv & 4)
								{
									int special2 = pMob[conn].MOB.CurrentScore.Special[2];
									special2 = special2 / 10 + 10;
									special2 = 100 - special2;
									droprate = special2 * droprate / 100;
								}

								if (i == 8 || i == 9 || i == 10)
									droprate = 4;

								if (i == 11)
									droprate = 1;

								if (droprate >= 32000)
									droprate = 32000;

								if (droprate <= 0)
									droprate = 0;
								else
									droprate = rand() % droprate;

								if (droprate == 0 || i == 11)
								{
									bool isFlag = false;
									STRUCT_ITEM* item = &pMob[target].MOB.Carry[i];

									if (item->sIndex <= 390 || item->sIndex >= MAX_ITEMLIST)
										continue;

									if (item->sIndex == 454)
										continue;

									int reqlv = g_pItemList[item->sIndex].ReqLvl;

									if (reqlv < 140 || (droprate % 2) != 1)
									{
										int bonus = 0;

										if (conn > 0 && conn < MAX_USER)
											bonus = pMob[conn].DropBonus;

										item = ControleDropItem(conn, target, bonus, PosX, PosY, item);

										MSG_STANDARDPARM updateItemDayLog;
										memset(&updateItemDayLog, 0, sizeof(MSG_STANDARDPARM));

										updateItemDayLog.Size = sizeof(MSG_STANDARDPARM);
										updateItemDayLog.Type = _MSG_DBItemDayLog;
										updateItemDayLog.ID = 0;
										updateItemDayLog.Parm = item->sIndex;

										DBServerSocket.SendOneMessage((char*)&updateItemDayLog, sizeof(MSG_STANDARDPARM));


										if (LOCALSERVER)
										{
											int item_index = item->sIndex;

											int reqlv = g_pItemList[item_index].ReqLvl;
											int itempos = g_pItemList[item_index].nPos;

											if (itempos & 0xFE && itempos != 128 && conn < MAX_USER)
											{
												SendSay(conn, strFmt("%-12s - %s(%d:%d) %d(%d:%d)",
													pMob[target].MOB.MobName, g_pItemList[item_index].Name,
													pMob[target].MOB.CurrentScore.Level, reqlv, g_dLevel, g_dLevel1,
													g_dLevel2));
											}
										}

										if (i == 8 || i == 9 || i == 10)
											i = 11;
									}
								}
							}
#pragma endregion
#pragma region Quest Amuleto mistico
							if (conn < MAX_USER && (pMob[target].MOB.Equip[0].sIndex == 239 || pMob[target].MOB.Equip[0].sIndex == 241) && !(rand() % 20))
							{
								if (pMob[conn].extra.QuestInfo.Mortal.TerraMistica == 1)
								{

									SendClientMessage(conn, g_pMessageStringTable[_NN_Watching_Town_Success]);
									pMob[conn].extra.QuestInfo.Mortal.TerraMistica = 2;
								}
							}
#pragma endregion

							//#pragma region Drenagem de HP do mob com skill de HT
							//							if (pMob[conn].MOB.Rsv & 2)
							//							{
							//							int mob_maxhp = pMob[target].MOB.CurrentScore.MaxHp;
							//							int myspecial = pMob[conn].MOB.CurrentScore.Special[3];
							//
							//							mob_maxhp = myspecial + mob_maxhp / 30;
							//							int myhp = pMob[conn].MOB.CurrentScore.Hp;
							//
							//							pMob[conn].MOB.CurrentScore.Hp += mob_maxhp;
							//
							//							if (pMob[conn].MOB.CurrentScore.Hp > pMob[conn].MOB.CurrentScore.MaxHp)
							//							pMob[conn].MOB.CurrentScore.Hp = pMob[conn].MOB.CurrentScore.MaxHp;
							//
							//							if (myhp != pMob[conn].MOB.CurrentScore.Hp)
							//							{
							//							if (conn > 0 && conn < MAX_USER)
							//							{
							//							SetReqHp(conn);
							//							SetReqMp(conn);
							//							}
							//
							//							MSG_SetHpDam hpDam;
							//							MSG_SetHpDam hpDam;
							//
							//							hpDam.Type = _MSG_SetHpDam;
							//							hpDam.Size = sizeof(MSG_SetHpDam);
							//							hpDam.ID = conn;
							//							hpDam.Hp = pMob[conn].MOB.CurrentScore.Hp;
							//							hpDam.Dam = pMob[conn].MOB.CurrentScore.Hp - myhp;
							//
							//							GridMulticast(pMob[conn].TargetX, pMob[conn].TargetY, (MSG_STANDARD*)&hpDam, 0);
							//							}
							//							}
#pragma endregion
							DeleteMob(target, 1);



							if (GenerateID == BARAO_AZUL)
							{
								//char temp[1024];
								//snprintf(temp, sizeof(temp), "O Jogador %s Derrotou o Barao Azul !!!", pMob[conn].MOB.MobName);
								RvRBluePoint += 100;
							}
							if (GenerateID == BARAO_VERMELHO)
							{
								//char temp[1024];
								//snprintf(temp, sizeof(temp), "O Jogador %s Derrotou o Barao Vermelho !!!", pMob[conn].MOB.MobName);
								RvRRedPoint += 100;
							}
							if (GenerateID == ENT_OBSCURO_BLUE)
							{
								//char temp[1024];
								//snprintf(temp, sizeof(temp), "O Jogador %s Derrotou o Ent Obscuro !!!", pMob[conn].MOB.MobName);
								RvRBluePoint += 25;
							}
							if (GenerateID == ENT_OBSCURO_RED)
							{
								//char temp[1024];
								//snprintf(temp, sizeof(temp), "O Jogador %s Derrotou o Ent Obscuro !!!", pMob[conn].MOB.MobName);
								RvRRedPoint += 25;
							}


#pragma region carta (N)
							if (GenerateID >= SECRET_ROOM_N_SALA1_MOB_1 && GenerateID <= SECRET_ROOM_N_SALA1_MOB_2)
								CartaDrop(conn, target, 1);

							if (GenerateID >= SECRET_ROOM_N_SALA2_MOB_1 && GenerateID <= SECRET_ROOM_N_SALA2_MOB_2)
								CartaDrop(conn, target, 2);

							if (GenerateID >= SECRET_ROOM_N_SALA3_MOB_1 && GenerateID <= SECRET_ROOM_N_SALA3_MOB_2)
								CartaDrop(conn, target, 3);

							if (GenerateID >= SECRET_ROOM_N_SALA4_MOB_1 && GenerateID <= SECRET_ROOM_N_SALA4_MOB_2)
								CartaDrop(conn, target, 4);
#pragma endregion

#pragma region carta (M)
							if (GenerateID >= SECRET_ROOM_M_SALA1_MOB_1 && GenerateID <= SECRET_ROOM_M_SALA1_MOB_2)
							{
								STRUCT_ITEM item;
								memset(&item, 0, sizeof(STRUCT_ITEM));

								int _rand = rand() % 10;


								if (_rand == 0)
									item.sIndex = 420;

								else if (_rand == 1)
									item.sIndex = 419;

								/*else if (_rand == 2)
									item.sIndex = 412;

								else if (_rand == 3)
									item.sIndex = 413;*/

								if (item.sIndex)
								{
									SetItemBonus(&item, 0, 0, 0);

									PutItem(conn, &item);
								}
							}
#pragma endregion

#pragma region carta (M)
							if (GenerateID >= SECRET_ROOM_M_SALA2_MOB_1 && GenerateID <= SECRET_ROOM_M_SALA2_MOB_2)
							{
								STRUCT_ITEM item;
								memset(&item, 0, sizeof(STRUCT_ITEM));

								int _rand = rand() % 10;


								if (_rand == 0)
									item.sIndex = 413;

								else if (_rand == 1)
									item.sIndex = 419;

								else if (_rand == 2)
									item.sIndex = 412;

								else if (_rand == 3)
									item.sIndex = 413;

								if (item.sIndex)
								{
									SetItemBonus(&item, 0, 0, 0);

									PutItem(conn, &item);
								}
							}
#pragma endregion

#pragma region carta (M)
							if (GenerateID >= SECRET_ROOM_M_SALA3_MOB_1 && GenerateID <= SECRET_ROOM_M_SALA3_MOB_2)
							{
								STRUCT_ITEM item;
								memset(&item, 0, sizeof(STRUCT_ITEM));

								int _rand = rand() % 10;


								if (_rand == 0)
									item.sIndex = 2444;

								else if (_rand == 1)
									item.sIndex = 2443;

								else if (_rand == 2)
									item.sIndex = 2442;

								else if (_rand == 3)
									item.sIndex = 2441;

								if (item.sIndex)
								{
									SetItemBonus(&item, 0, 0, 0);

									PutItem(conn, &item);
								}
							}
#pragma endregion

#pragma region carta (M)
							if (GenerateID >= SECRET_ROOM_M_SALA4_MOB_1 && GenerateID <= SECRET_ROOM_M_SALA4_MOB_2)
							{
								STRUCT_ITEM item;
								memset(&item, 0, sizeof(STRUCT_ITEM));

								int _rand = rand() % 10;


								if (_rand == 0)
									item.sIndex = 412;

								else if (_rand == 1)
									item.sIndex = 413;

								else if (_rand == 2)
									item.sIndex = 412;

								else if (_rand == 3)
									item.sIndex = 413;

								if (item.sIndex)
								{
									SetItemBonus(&item, 0, 0, 0);

									PutItem(conn, &item);
								}
							}
#pragma endregion
#pragma region carta (A)
							if (GenerateID >= SECRET_ROOM_A_SALA1_MOB_1 && GenerateID <= SECRET_ROOM_A_SALA1_MOB_2)
							{
								STRUCT_ITEM item;
								memset(&item, 0, sizeof(STRUCT_ITEM));

								int _rand = rand() % 5;


								if (_rand == 0)
									item.sIndex = 413;

								else if (_rand == 1)
									item.sIndex = 412;


								if (item.sIndex)
								{
									SetItemBonus(&item, 0, 0, 0);

									PutItem(conn, &item);
								}
							}
#pragma endregion
#pragma region carta (A)
							if (GenerateID >= SECRET_ROOM_A_SALA2_MOB_1 && GenerateID <= SECRET_ROOM_A_SALA2_MOB_2)
							{
								STRUCT_ITEM item;
								memset(&item, 0, sizeof(STRUCT_ITEM));

								int _rand = rand() % 5;


								if (_rand == 0)
									item.sIndex = 413;

								else if (_rand == 1)
									item.sIndex = 412;


								if (item.sIndex)
								{
									SetItemBonus(&item, 0, 0, 0);

									PutItem(conn, &item);
								}
							}
#pragma endregion
#pragma region carta (A)
							if (GenerateID >= SECRET_ROOM_A_SALA3_MOB_1 && GenerateID <= SECRET_ROOM_A_SALA3_MOB_2)
							{
								STRUCT_ITEM item;
								memset(&item, 0, sizeof(STRUCT_ITEM));

								int _rand = rand() % 5;


								if (_rand == 0)
									item.sIndex = 612;

								else if (_rand == 1)
									item.sIndex = 613;

								else if (_rand == 2)
									item.sIndex = 614;

								else if (_rand == 3)
									item.sIndex = 615;


								if (item.sIndex)
								{
									SetItemBonus(&item, 0, 0, 0);

									PutItem(conn, &item);
								}
							}
#pragma endregion

#pragma region carta (A)
							if (GenerateID >= SECRET_ROOM_A_SALA4_MOB_1 && GenerateID <= SECRET_ROOM_A_SALA4_MOB_2)
							{
								STRUCT_ITEM item;
								memset(&item, 0, sizeof(STRUCT_ITEM));

								int _rand = rand() % 5;

								if (_rand == 0)
									item.sIndex = 413;

								else if (_rand == 1)
									item.sIndex = 413;

								else if (_rand == 2)
									item.sIndex = 413;

								else if (_rand == 3)
									item.sIndex = 413;

								if (item.sIndex)
								{
									SetItemBonus(&item, 0, 0, 0);

									PutItem(conn, &item);
								}
							}
#pragma endregion

#pragma region Coliseu (N)
							if (GenerateID >= COLISEU_N_INITIAL && GenerateID <= COLISEU_N_END)
							{
								STRUCT_ITEM item;
								memset(&item, 0, sizeof(STRUCT_ITEM));

								int _rand = rand() % 20;

								if (_rand == 0 || _rand == 1 || _rand == 2 || _rand == 3)
									item.sIndex = 419;

								else if (_rand == 4 || _rand == 5)
									item.sIndex = 420;

								else if (_rand == 6)
									item.sIndex = 4019;

								SetItemBonus(&item, 0, 0, 0);

								if (pMob[conn].MOB.Equip[13].sIndex == 3901 || pMob[conn].MOB.Equip[13].sIndex == 3902) {
									SendItemagrupar(conn, item.sIndex);
								}
								else {
									PutItem(conn, &item);
								}
							}
#pragma endregion

#pragma region Coliseu (M)
							if (GenerateID >= COLISEU_M_INITIAL && GenerateID <= COLISEU_M_END)
							{
								STRUCT_ITEM item;
								memset(&item, 0, sizeof(STRUCT_ITEM));

								int _rand = rand() % 20;

								if (_rand == 0 || _rand == 1 || _rand == 2 || _rand == 3)
									item.sIndex = 419;

								else if (_rand == 4 || _rand == 5)
									item.sIndex = 420;

								else if (_rand == 6)
									item.sIndex = 4020;

								SetItemBonus(&item, 0, 0, 0);

								if (pMob[conn].MOB.Equip[13].sIndex == 3901 || pMob[conn].MOB.Equip[13].sIndex == 3902) {
									SendItemagrupar(conn, item.sIndex);
								}
								else {
									PutItem(conn, &item);
								}
							}
#pragma endregion

#pragma region Coliseu (A)
							if (GenerateID >= COLISEU_A_INITIAL && GenerateID <= COLISEU_A_END)
							{
								STRUCT_ITEM item;
								memset(&item, 0, sizeof(STRUCT_ITEM));

								int _rand = rand() % 20;

								if (_rand == 0 || _rand == 1 || _rand == 2 || _rand == 3)
									item.sIndex = 419;

								else if (_rand == 4 || _rand == 5)
									item.sIndex = 420;

								SetItemBonus(&item, 0, 0, 0);

								if (pMob[conn].MOB.Equip[13].sIndex == 3901 || pMob[conn].MOB.Equip[13].sIndex == 3902) {
									SendItemagrupar(conn, item.sIndex);
								}
								else {
									PutItem(conn, &item);
								}
							}
#pragma endregion

#pragma region Pista +1 - Lugefer_Inf
							if (GenerateID >= RUNEQUEST_LV1_MOB_INITIAL && GenerateID <= RUNEQUEST_LV1_MOB_END)
								GenerateMob(GenerateID, 0, 0);
#pragma endregion
#pragma region Pista +2 - Amon_Inf
							if (GenerateID >= RUNEQUEST_LV2_MOB_INITIAL && GenerateID <= RUNEQUEST_LV2_MOB_END)
								GenerateMob(GenerateID, 0, 0);
#pragma endregion
#pragma region Kefra - Mago_Negro
							if (GenerateIndex >= KEFRA_MOB_INITIAL && GenerateIndex <= KEFRA_MOB_END && KefraLive == 0)
								GenerateMob(GenerateIndex, 0, 0);
#pragma endregion

							CWarTower::MobKilled(target, conn, PosX, PosY);
						}
						else
							DeleteMob(target, 1);
					}
				}

				else
				{
					GridMulticast(pMob[target].TargetX, pMob[target].TargetY, (MSG_STANDARD*)&sm, 0);
					DeleteMob(target, 1);
				}
			}

			else
			{
				GridMulticast(pMob[target].TargetX, pMob[target].TargetY, (MSG_STANDARD*)&sm, 0);
				DeleteMob(target, 1);
			}
		}
		else
		{
			pUser[target].ReqHp = pMob[target].MOB.CurrentScore.MaxHp;
			SetReqHp(target);

			pMob[target].MOB.CurrentScore.Hp = pMob[target].MOB.CurrentScore.MaxHp;
			SendScore(target);
		}
	}
#pragma endregion


#pragma region PvP
	else
	{
		int tlevel = pMob[target].MOB.BaseScore.Level;

		if (tlevel < 0 || tlevel > MAX_LEVEL)
			return;

#pragma region Lose EXP
		unsigned int curexp = (unsigned int)(pMob[target].extra.ClassMaster == MORTAL || pMob[target].extra.ClassMaster == ARCH ? g_pNextLevel[tlevel] : g_pNextLevel_2[tlevel]);
		unsigned int nextexp = (unsigned int)(pMob[target].extra.ClassMaster == MORTAL || pMob[target].extra.ClassMaster == ARCH ? g_pNextLevel[tlevel + 1] : g_pNextLevel_2[tlevel + 1]);
		unsigned int alphaexp = (nextexp - curexp);
		unsigned int deltaexp = (nextexp - curexp) / 20;

		if (tlevel >= 30)
			deltaexp = alphaexp / 22;

		if (tlevel >= 40)
			deltaexp = alphaexp / 25;

		if (tlevel >= 50)
			deltaexp = alphaexp / 30;

		if (tlevel >= 60)
			deltaexp = alphaexp / 35;

		if (tlevel >= 70)
			deltaexp = alphaexp / 40;

		if (tlevel >= 80)
			deltaexp = alphaexp / 45;

		if (tlevel >= 90)
			deltaexp = alphaexp / 50;

		if (tlevel >= 100)
			deltaexp = alphaexp / 55;

		if (tlevel >= 150)
			deltaexp = alphaexp / 70;

		if (tlevel >= 200)
			deltaexp = alphaexp / 85;

		if (tlevel >= 250)
			deltaexp = alphaexp / 100;

		if (deltaexp < 0)
			deltaexp = 0;
		if (deltaexp > 150000)
			deltaexp = 150000;
#pragma endregion

		int killer_curkill = GetCurKill(conn);
		int killer_totkill = GetTotKill(conn);
		int killer_pkpoint = GetPKPoint(conn);
		int killed_pkpoint = GetPKPoint(target);
		int killed_guilty = GetGuilty(target);
		int killed_curkill = GetCurKill(target);
		int killed_clan = pMob[target].MOB.Clan;
		int killer_clan = pMob[conn].MOB.Clan;
		int SameClan = 0;
		int AtWar = 0;

		if (killed_pkpoint > 10 && killed_pkpoint <= 25)
			deltaexp *= 3;
		else
			deltaexp *= 5;

		int killed_x = pMob[target].TargetX / 128;
		int killed_y = pMob[target].TargetY / 128;

#pragma region No lose At war
		if (conn < MAX_USER)
		{
			if (pMob[conn].TargetX >= 128 && pMob[conn].TargetY <= 4000)
			{
				if (killer_pkpoint >= 31 && killer_pkpoint <= 74)// 12
				{

					pMob[conn].extra.EMPTY[0] = 1;
					SendEtc(conn);
					pMob[conn].GetCurrentScore(conn);
					SendScore(conn);
				}
				if (killer_pkpoint <= 30) //-56
				{

					pMob[conn].extra.EMPTY[1] = 1;
					pMob[conn].extra.EMPTY[0] = 0;
					SendEtc(conn);
					pMob[conn].GetCurrentScore(conn);
					SendScore(conn);
				}

			}
			if (TESTSERVER)
				deltaexp /= 3;

			else
				deltaexp /= 6;

			if (killed_clan == 7 && killer_clan == 8 || killed_clan == 8 && killer_clan == 7)
				SameClan = 1;

			if (killed_clan == 7 && killer_clan == 8 || killed_clan == 8 && killer_clan == 7)
				SameClan = 1;

			int killed_guild = pMob[target].MOB.Guild;
			int killer_guild = pMob[conn].MOB.Guild;
			int max_guild = 65536;

			if (killed_guild > 0 && killed_guild < max_guild && killer_guild > 0 && killer_guild < max_guild
				&& g_pGuildWar[killed_guild] == killer_guild && g_pGuildWar[killer_guild] == killed_guild)
				AtWar = 1;

			if (CastleState && killed_x == 8 && killed_y == 13)
				AtWar = 1;

			if (RvRState != 0)
				AtWar = 1;

			if (GTorreState != 0)
				AtWar = 1;

		}
#pragma endregion

		GridMulticast(pMob[target].TargetX, pMob[target].TargetY, (MSG_STANDARD*)&sm, 0);

		int arena = BASE_GetArena(pMob[target].TargetX, pMob[target].TargetY);
		int village = BASE_GetVillage(pMob[target].TargetX, pMob[target].TargetY);
		int ZoneUnk = 0;

		if (killed_x == 1 && killed_y == 31)
			ZoneUnk = 1;

		if (arena != 5 || village != 5 || ZoneUnk || (pMob[target].TargetX > 1078 && pMob[target].TargetY > 1725 && pMob[target].TargetX < 1102 && pMob[target].TargetY < 1737))
		{


			//pMob[conn].extra.EMPTY[3] = 1;
			if (arena == 5 && village != 5)
			{
				FILE* fpp = NULL;

				fpp = fopen("TesteDie.txt", "a+");
				
				printf(temp, "%s %s %d %d %d %d\n", pMob[conn].MOB.MobName, pMob[target].MOB.MobName, conn, target, pMob[target].TargetX, pMob[target].TargetY);

				fclose(fpp);
			}
			/*
						if (arena >= 0 && arena < MAX_GUILDZONE)
						{
							STRUCT_ITEM item;
							memset(&item, 0, sizeof(STRUCT_ITEM));

							item.sIndex = 431;
							SetItemBonus(&item, 0, 0, 0);

							CreateItem(pMob[target].TargetX, pMob[target].TargetY, &item, rand() % 4, 1);
						}*/
		}

		else
		{
			if (TESTSERVER)
				deltaexp /= 4;

			if (SameClan)
				deltaexp += killed_curkill * deltaexp / 4;

			if (deltaexp > 30000)
				deltaexp = 30000;

			if (deltaexp < 0)
				deltaexp = 0;


			if ((tlevel >= 35 || pMob[target].extra.ClassMaster != MORTAL) && NewbieEventServer == 0)
			{
				if (conn >= MAX_USER)
				{
					if (DEADPOINT)
						pMob[target].extra.Hold += (unsigned int)(pMob[target].MOB.Exp > deltaexp ? deltaexp : pMob[target].MOB.Exp);
				}
				else
					pMob[target].extra.Hold += (unsigned int)(pMob[target].MOB.Exp > deltaexp ? deltaexp : pMob[target].MOB.Exp);

				if (DEADPOINT || conn < MAX_USER)
				{
					SendMsgExp(target, strFmt(g_pMessageStringTable[_DN_lose_D_exp], deltaexp), TNColor::Speak, false);
					SendEtc(target);
				}
			}
			else if (pMob[target].MOB.CurrentScore.Level < FREEEXP && pMob[target].extra.ClassMaster == MORTAL && NewbieEventServer == 0) {
				GridMulticast(pMob[target].TargetX, pMob[target].TargetY, (MSG_STANDARD*)&sm, 0);
				SendMsgExp(target, g_pMessageStringTable[_NN_Below_lv20_No_Exp_Loss], TNColor::Default, false);
			}
			if (SameClan)
			{
				SendEtc(conn);

				++killer_curkill;
				SetCurKill(conn, killer_curkill);

				++killer_totkill;
				SetTotKill(conn, killer_totkill);

				if (AtWar == 0 && killed_guilty == 0)
				{
					int Lostpk = 3 * killed_pkpoint / -20;
					if (Lostpk < -3)
						Lostpk = -3;

					if (Lostpk > 0)
						Lostpk = 0;

					if (killed_guilty > 0)
						Lostpk = 0;

					killer_pkpoint += Lostpk;
					SetPKPoint(conn, killer_pkpoint);
					SendClientMessage(conn, strFmt(g_pMessageStringTable[_DD_PKPointMinus], killer_pkpoint - 75, Lostpk));
					GridMulticast(pMob[target].TargetX, pMob[target].TargetY, (MSG_STANDARD*)&sm, 0);
				}

				if (pMob[target].TargetX >= 1017 && pMob[target].TargetX <= 1290 && pMob[target].TargetY >= 1911 && pMob[target].TargetY <= 2183)
				{
					if (pMob[target].MOB.Clan == 7)
					{
						pMob[target].MOB.CurrentScore.Hp = 200;
						pMob[target].GetCurrentScore(target);
						SendScore(target);
						DoTeleport(target, 1072 + rand() % 2, 2140 + rand() % 2);
						RvRRedPoint++;
					}

					else if (pMob[target].MOB.Clan == 8)
					{
						pMob[target].MOB.CurrentScore.Hp = 200;
						pMob[target].GetCurrentScore(target);
						SendScore(target);
						DoTeleport(target, 1237 + rand() % 2, 1971 + rand() % 2);
						RvRBluePoint++;
					}
					GridMulticast(pMob[target].TargetX, pMob[target].TargetY, (MSG_STANDARD*)&sm, 0);
				}
			}
#pragma region Perca de CP
			else
			{
				int AtWarMap = 0;

				//torre
				if (AtWar == 1 && pMob[target].TargetX >= 2445 && pMob[target].TargetX <= 1850 && pMob[target].TargetY >= 1850 && pMob[target].TargetY <= 1920)
					AtWarMap = 1;

				//rvr
				if (AtWar == 1 && pMob[target].TargetX >= 1017 && pMob[target].TargetX <= 1290 && pMob[target].TargetY >= 1911 && pMob[target].TargetY <= 2183)
					AtWarMap = 1;

				//batalha real
				if (pMob[target].TargetX >= 140 && pMob[target].TargetX <= 200 && pMob[target].TargetY >= 4000 && pMob[target].TargetY <= 4100)
					AtWarMap = 1;

				//batalha de castelo
				if (AtWar == 1 && pMob[target].TargetX >= 1024 && pMob[target].TargetY >= 1664 && pMob[target].TargetX <= 1153 && pMob[target].TargetY <= 1793)
					AtWarMap = 1;

				if (AtWarMap != 1) {
					int LostPk = 3 * killed_pkpoint / -25;

					if (LostPk < -3)
						LostPk = -3;

					if (LostPk > 0)
						LostPk = 0;

					if (killed_guilty > 0)
						LostPk = 0;

					//aumenta o pk quando mata mortal
					if (pMob[target].MOB.Equip[15].sIndex == 548 || pMob[target].MOB.Equip[15].sIndex == 549 || pMob[conn].MOB.Equip[15].sIndex == 548 || pMob[conn].MOB.Equip[15].sIndex == 549)
						LostPk *= 1;

					killer_pkpoint += LostPk;

					SetPKPoint(conn, killer_pkpoint);

					if (LostPk)
					{
						SendClientMessage(conn, strFmt(g_pMessageStringTable[_DD_PKPointMinus], killer_pkpoint - 75, -LostPk));
						SendEtc(conn);
					}

#pragma region  Perca de itens, cp negativo
					if (killed_pkpoint >= 31 && killed_pkpoint <= 74)// 12
					{
						pMob[target].extra.EMPTY[0] = 1;
						SendEtc(target);
						pMob[target].GetCurrentScore(target);
						SendScore(target);
					}
					if (killed_pkpoint <= 30) //-56
					{

						pMob[target].extra.EMPTY[1] = 1;
						pMob[target].extra.EMPTY[0] = 0;
						SendEtc(target);
						pMob[target].GetCurrentScore(target);
						SendScore(target);
					}
					GridMulticast(pMob[target].TargetX, pMob[target].TargetY, (MSG_STANDARD*)&sm, 0);
#pragma endregion
				}

			}
			GetCreateMob(conn, &sCreateMob);
			GridMulticast(pMob[conn].TargetX, pMob[conn].TargetY, (MSG_STANDARD*)&sCreateMob, 0);

			if (SameClan)
				SetCurKill(target, 0);

			if (killed_pkpoint < 75 && !AtWar && conn < MAX_USER)
			{
				killed_pkpoint++;
				SetPKPoint(target, killed_pkpoint);
				SendMsgExp(target, strFmt(g_pMessageStringTable[_DD_PKPointPlus], killed_pkpoint - 75, 1), TNColor::Red, false);
			}
			GetCreateMob(target, &sCreateMob);
			GridMulticast(pMob[target].TargetX, pMob[target].TargetY, (MSG_STANDARD*)&sCreateMob, 0);
		}

		if (pMob[target].MOB.Equip[13].sIndex == 753 || pMob[target].MOB.Equip[13].sIndex == 1726)//10X HP MOB  - 20X HP MOB
		{
			int sanc = BASE_GetItemSanc(&pMob[target].MOB.Equip[13]);
			if (sanc > 0)
			{
				sanc--;

				if (pMob[target].MOB.Equip[13].stEffect[0].cEffect == 43)
					pMob[target].MOB.Equip[13].stEffect[0].cValue = sanc;

				else if (pMob[target].MOB.Equip[13].stEffect[1].cEffect == 43)
					pMob[target].MOB.Equip[13].stEffect[1].cValue = sanc;

				else if (pMob[target].MOB.Equip[13].stEffect[2].cEffect == 43)
					pMob[target].MOB.Equip[13].stEffect[2].cValue = sanc;
			}
			else
				BASE_ClearItem(&pMob[target].MOB.Equip[13]);

			SendItem(target, ITEM_PLACE_EQUIP, 13, &pMob[target].MOB.Equip[13]);
		}
		GridMulticast(pMob[target].TargetX, pMob[target].TargetY, (MSG_STANDARD*)&sm, 0);
	}
	//pMob[target].extra.EMPTY[3] = 1;
#pragma endregion
}


# -------------------- NewJephi.cpp --------------------

#pragma once

#include "ProcessClientMessage.h"
#include <iostream>
#include <cstdlib>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <random>
#include <ctime>
#include "SendFunc.h"
#include "Functions.h"


void Jephi(int conn, char* pMsg) {

	if (conn <= 0 || conn >= MAX_USER)
		return;

	if (pUser[conn].Mode != USER_PLAY)
		return;

	if (pUser[conn].cSock.Sock == 0)
		return;

	MSG_SendJephi* m = (MSG_SendJephi*)pMsg;

	int Size = m->Size;

	if (Size > sizeof(MSG_SendJephi)) //CONTROLE DE SIZE
	{
		SendClientMessage(conn, "Impossível executar ação, tente mais tarde.");
		return;
	}

	if (m->Qnt <= 0 || m->Qnt > 120)
		return;

	if (m->Item < 0 || m->Item >= MAX_ITEMLIST)
		return;

	int itemIndex = m->Item;
	int Quantidade = m->Qnt;

	if (itemIndex == 0)
		itemIndex = 413;

	if (itemIndex == 1)
		itemIndex = 412;

	//circulo divino
	if (itemIndex == 447 || itemIndex == 692)
	{
		int price = 0;
		if (pMob[conn].MOB.Equip[13].sIndex != 447 && pMob[conn].MOB.Equip[13].sIndex != 692) {
			SendClientMessage(conn, "Equipe o pedaço do círculo Divino!");
			return;
		}
		if (pMob[conn].MOB.Equip[13].sIndex == 447) {
			price = 1000000;
		}

		if (pMob[conn].MOB.Equip[13].sIndex == 692) {
			price = 5000000;
		}
		if (pMob[conn].MOB.Coin < price) {
			SendClientMessage(conn, "Você não possui gold suficiente!");
			return;
		}
		if (pMob[conn].MOB.Coin >= price)
		{
			if (price == 1000000)
			{
				pMob[conn].MOB.Coin -= 1000000;
				pMob[conn].MOB.Equip[13].sIndex = rand() % 3 + 448;
			}
			else
			{
				pMob[conn].MOB.Coin -= 5000000;
				pMob[conn].MOB.Equip[13].sIndex = rand() % 3 + 693;
			}

			SendItem(conn, ITEM_PLACE_EQUIP, 13, &pMob[conn].MOB.Equip[13]);
			SendEtc(conn);
			SendClientMessage(conn, g_pMessageStringTable[_NN_Processing_Complete]);
			SendScore(conn);
			return;
		}
	}

	//poeira de ori
	if (itemIndex == 412) {

		int Ori = 0;
		for (int i = 0; i < pMob[conn].MaxCarry; i++)
		{
			if (pMob[conn].MOB.Carry[i].sIndex == 419)
				Ori += pMob[conn].MOB.Carry[i].stEffect[0].cEffect == 61 ? pMob[conn].MOB.Carry[i].stEffect[0].cValue : 1;
		}

		int SlotId = 0;
		for (int i = 0; i < pMob[conn].MaxCarry; i++)
		{
			if (pMob[conn].MOB.Carry[i].sIndex == 0)
			{
				SlotId++;
			}
		}
		if (Ori < (Quantidade * 10)) {
			SendClientMessage(conn, "Restos Insuficientes");
			return;
		}

		if (pMob[conn].MOB.Coin > (Quantidade * 100000)) //100k
		{
			if (SlotId > 2)
			{
				RemoveItem(conn, 419, Quantidade * 10);
				pMob[conn].MOB.Coin -= (Quantidade * 100000); //100k

				STRUCT_ITEM item;
				memset(&item, 0, sizeof(STRUCT_ITEM));

				item.sIndex = 412;
				item.stEffect[0].cEffect = 61;
				item.stEffect[0].cValue = Quantidade;
				item.stEffect[1].cEffect = 0;
				item.stEffect[1].cValue = 0;
				item.stEffect[2].cEffect = 0;
				item.stEffect[2].cValue = 0;

				PutItem(conn, &item);
				SendCarry(conn);
				SendScore(conn);
				SendEtc(conn);
				SendClientMessage(conn, strFmt("Criou %d Poeiras de Ori", Quantidade));
				ItemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, strFmt("Criou %d Poeiras de Ori", Quantidade));
				return;
			}
			else
			{
				SendClientMessage(conn, g_pMessageStringTable[_NN_You_Have_No_Space_To_Trade]);
				return;
			}
		}
		SendClientMessage(conn, "Gold Insuficiente");
		return;
	}

	//poeira de lac
	if (itemIndex == 413) {

		int lac = 0;
		for (int i = 0; i < pMob[conn].MaxCarry; i++)
		{
			if (pMob[conn].MOB.Carry[i].sIndex == 420)
				lac += pMob[conn].MOB.Carry[i].stEffect[0].cEffect == 61 ? pMob[conn].MOB.Carry[i].stEffect[0].cValue : 1;
		}

		int SlotId = 0;
		for (int i = 0; i < pMob[conn].MaxCarry; i++)
		{
			if (pMob[conn].MOB.Carry[i].sIndex == 0)
			{
				SlotId++;
			}
		}
		if (lac < (Quantidade * 10)) {
			SendClientMessage(conn, "Restos Insuficientes");
			return;
		}

		if (pMob[conn].MOB.Coin > (Quantidade * 250000)) //250k
		{
			if (SlotId > 2)
			{
				RemoveItem(conn, 420, Quantidade * 10);
				pMob[conn].MOB.Coin -= (Quantidade * 250000); //250k

				STRUCT_ITEM item;
				memset(&item, 0, sizeof(STRUCT_ITEM));

				item.sIndex = 413;
				item.stEffect[0].cEffect = 61;
				item.stEffect[0].cValue = Quantidade;
				item.stEffect[1].cEffect = 0;
				item.stEffect[1].cValue = 0;
				item.stEffect[2].cEffect = 0;
				item.stEffect[2].cValue = 0;

				PutItem(conn, &item);
				SendCarry(conn);
				SendScore(conn);
				SendEtc(conn);
				SendClientMessage(conn, strFmt("Criou %d Poeiras de Lac", Quantidade));
				ItemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, strFmt("Criou %d Poeiras de Lac", Quantidade));
				return;
			}
			else
			{
				SendClientMessage(conn, g_pMessageStringTable[_NN_You_Have_No_Space_To_Trade]);
				return;
			}
		}
		SendClientMessage(conn, "Gold Insuficiente");
		return;
	}

	//alma
	if (itemIndex == 1740 || itemIndex == 1741) {

		int Fragmento = 0;
		for (int i = 0; i < pMob[conn].MaxCarry; i++)
		{
			if (pMob[conn].MOB.Carry[i].sIndex == 5643)
				Fragmento += pMob[conn].MOB.Carry[i].stEffect[0].cEffect == 61 ? pMob[conn].MOB.Carry[i].stEffect[0].cValue : 1;
		}

		int SlotId = 0;
		for (int i = 0; i < pMob[conn].MaxCarry; i++)
		{
			if (pMob[conn].MOB.Carry[i].sIndex == 0)
			{
				SlotId++;
			}
		}
		if (Fragmento < 10) {
			SendClientMessage(conn, "Precisa de pelo menos 10 Fragmentos para Compor");
			return;
		}
		if (SlotId > 2)
		{
			RemoveItem(conn, 5643, 10);

			STRUCT_ITEM item;
			memset(&item, 0, sizeof(STRUCT_ITEM));

			item.sIndex = itemIndex;
			item.stEffect[0].cEffect = 0;
			item.stEffect[0].cValue = 0;
			item.stEffect[1].cEffect = 0;
			item.stEffect[1].cValue = 0;
			item.stEffect[2].cEffect = 0;
			item.stEffect[2].cValue = 0;

			PutItem(conn, &item);
			SendCarry(conn);
			SendScore(conn);
			SendEtc(conn);
			SendClientMessage(conn, "Sua alma foi entregue");
			ItemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, "Criou uma Alma no Jephi");
			return;
		}
		else
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_You_Have_No_Space_To_Trade]);
			return;
		}
	}
}

//void NewJephi(int conn, int target, int targetPos, int itemId) {
//
//	int TargetID = target;
//	int TargetInvenPos = targetPos;
//	int itemIndex = itemId;
//
//	if (strcmp(pMob[TargetID].MOB.MobName, "Jephi") == 0) {
//
//
//		// Pedaço do Círculo
//		if (itemIndex == 447 || itemIndex == 692)
//		{
//			if (pUser[conn].Lasclick != itemIndex) {
//				pUser[conn].Lasclick = itemIndex;
//				SendClientMessage(conn, "Deseja compor esse item?");
//				return;
//			}
//			int price = 0;
//			if (pMob[conn].MOB.Equip[13].sIndex != 447 && pMob[conn].MOB.Equip[13].sIndex != 692) {
//				SendClientMessage(conn, "Equipe o pedaço do círculo Divino!");
//				return;
//			}
//			if (pMob[conn].MOB.Equip[13].sIndex == 447) {
//				price = 1000000;
//			}
//
//			if (pMob[conn].MOB.Equip[13].sIndex == 692) {
//				price = 5000000;
//			}
//			if (pMob[conn].MOB.Coin < price) {
//				SendClientMessage(conn, "Você não possui gold suficiente!");
//				return;
//			}
//			if (pMob[conn].MOB.Coin >= price)
//			{
//				if (price == 1000000)
//				{
//					pMob[conn].MOB.Coin -= 1000000;
//					pMob[conn].MOB.Equip[13].sIndex = rand() % 3 + 448;
//				}
//				else
//				{
//					pMob[conn].MOB.Coin -= 5000000;
//					pMob[conn].MOB.Equip[13].sIndex = rand() % 3 + 693;
//				}
//
//				SendItem(conn, ITEM_PLACE_EQUIP, 13, &pMob[conn].MOB.Equip[13]);
//				SendEtc(conn);
//				SendClientMessage(conn, g_pMessageStringTable[_NN_Processing_Complete]);
//				SendScore(conn);
//				return;
//			}
//			return;
//		}
//
//		// Poeira de Ori
//		if (itemIndex == 412) {
//
//			int Ori = 0;
//			for (int i = 0; i < pMob[conn].MaxCarry; i++)
//			{
//				if (pMob[conn].MOB.Carry[i].sIndex == 419)
//					Ori += pMob[conn].MOB.Carry[i].stEffect[0].cEffect == 61 ? pMob[conn].MOB.Carry[i].stEffect[0].cValue : 1;
//			}
//
//			int SlotId = 0;
//			for (int i = 0; i < pMob[conn].MaxCarry; i++)
//			{
//				if (pMob[conn].MOB.Carry[i].sIndex == 0)
//				{
//					SlotId++;
//				}
//			}
//			if (Ori < 10) {
//				SendClientMessage(conn, "Precisa de pelo menos 10 restos para conversão");
//				return;
//			}
//			if (Ori > 1200) {
//				Ori = 1200;
//			}
//			int PoeiraTotal = (Ori / 10);
//			int ValorTotal = PoeiraTotal * 500000;
//			if (pUser[conn].Lasclick != itemIndex) {
//				pUser[conn].Lasclick = itemIndex;
//				SendClientMessage(conn, strFmt("Deseja compor [%d] Poeiras de Ori por [%d]?", PoeiraTotal, ValorTotal));
//				return;
//			}
//			if (pMob[conn].MOB.Coin <= ValorTotal) {
//				SendClientMessage(conn, strFmt("Vai lhe custar [%d] em Gold", ValorTotal));
//				return;
//			}
//
//			if (pMob[conn].MOB.Coin > ValorTotal)
//			{
//				if (SlotId > 2)
//				{
//					int TotalResto = PoeiraTotal * 10;
//					RemoveItem(conn, 419, TotalResto);
//					pMob[conn].MOB.Coin -= ValorTotal;
//
//					STRUCT_ITEM item;
//					memset(&item, 0, sizeof(STRUCT_ITEM));
//
//					item.sIndex = 412;
//					item.stEffect[0].cEffect = 61;
//					item.stEffect[0].cValue = PoeiraTotal;
//					item.stEffect[1].cEffect = 0;
//					item.stEffect[1].cValue = 0;
//					item.stEffect[2].cEffect = 0;
//					item.stEffect[2].cValue = 0;
//
//					PutItem(conn, &item);
//					SendCarry(conn);
//					SendScore(conn);
//					SendEtc(conn);
//					SendClientMessage(conn, strFmt("Criou %d Poeiras de Ori", PoeiraTotal));
//					ItemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, strFmt("Criou %d Poeiras de Ori", PoeiraTotal));
//					return;
//				}
//				else
//				{
//					SendClientMessage(conn, g_pMessageStringTable[_NN_You_Have_No_Space_To_Trade]);
//					return;
//				}
//			}
//			SendClientMessage(conn, "Traga-me 10 restos de Ori e 500k para compor uma poeira");
//			return;
//		}
//
//		//Poeira de Lac
//		if (itemIndex == 413) {
//
//			int Lac = 0;
//			for (int i = 0; i < pMob[conn].MaxCarry; i++)
//			{
//				if (pMob[conn].MOB.Carry[i].sIndex == 420)
//					Lac += pMob[conn].MOB.Carry[i].stEffect[0].cEffect == 61 ? pMob[conn].MOB.Carry[i].stEffect[0].cValue : 1;
//			}
//
//			int SlotId = 0;
//			for (int i = 0; i < pMob[conn].MaxCarry; i++)
//			{
//				if (pMob[conn].MOB.Carry[i].sIndex == 0)
//				{
//					SlotId++;
//				}
//			}
//			if (Lac < 10) {
//				SendClientMessage(conn, "Precisa de pelo menos 10 restos para conversão");
//				return;
//			}
//			if (Lac > 1200) {
//				Lac = 1200;
//			}
//			int PoeiraTotal = (Lac / 10);
//			int ValorTotal = PoeiraTotal * 1000000;
//			if (pUser[conn].Lasclick != itemIndex) {
//				pUser[conn].Lasclick = itemIndex;
//				SendClientMessage(conn, strFmt("Deseja compor [%d] Poeiras de Lac por [%d]?", PoeiraTotal, ValorTotal));
//				return;
//			}
//			if (pMob[conn].MOB.Coin <= ValorTotal) {
//				SendClientMessage(conn, strFmt("Vai lhe custar [%d] em Gold", ValorTotal));
//				return;
//			}
//
//			if (pMob[conn].MOB.Coin > ValorTotal)
//			{
//				if (SlotId > 2)
//				{
//					int TotalResto = PoeiraTotal * 10;
//					RemoveItem(conn, 420, TotalResto);
//					pMob[conn].MOB.Coin -= ValorTotal;
//
//					STRUCT_ITEM item;
//					memset(&item, 0, sizeof(STRUCT_ITEM));
//
//					item.sIndex = 413;
//					item.stEffect[0].cEffect = 61;
//					item.stEffect[0].cValue = PoeiraTotal;
//					item.stEffect[1].cEffect = 0;
//					item.stEffect[1].cValue = 0;
//					item.stEffect[2].cEffect = 0;
//					item.stEffect[2].cValue = 0;
//
//					PutItem(conn, &item);
//					SendCarry(conn);
//					SendScore(conn);
//					SendEtc(conn);
//					SendClientMessage(conn, strFmt("Criou %d Poeiras de Lac", PoeiraTotal));
//					ItemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, strFmt("Criou %d Poeiras de Lac", PoeiraTotal));
//					return;
//				}
//				else
//				{
//					SendClientMessage(conn, g_pMessageStringTable[_NN_You_Have_No_Space_To_Trade]);
//					return;
//				}
//			}
//			SendClientMessage(conn, "Traga-me 10 restos de Lac e 1kk para compor uma poeira");
//			return;
//		}
//
//		//alma
//		if (itemIndex == 1740 || itemIndex == 1741) {
//
//			int Fragmento = 0;
//			for (int i = 0; i < pMob[conn].MaxCarry; i++)
//			{
//				if (pMob[conn].MOB.Carry[i].sIndex == 5643)
//					Fragmento += pMob[conn].MOB.Carry[i].stEffect[0].cEffect == 61 ? pMob[conn].MOB.Carry[i].stEffect[0].cValue : 1;
//			}
//
//			int SlotId = 0;
//			for (int i = 0; i < pMob[conn].MaxCarry; i++)
//			{
//				if (pMob[conn].MOB.Carry[i].sIndex == 0)
//				{
//					SlotId++;
//				}
//			}
//			if (Fragmento < 10) {
//				SendClientMessage(conn, "Precisa de pelo menos 10 Fragmentos para conversão");
//				return;
//			}
//			if (pUser[conn].Lasclick != itemIndex) {
//				pUser[conn].Lasclick = itemIndex;
//				SendClientMessage(conn, "Deseja compor essa Alma?");
//				return;
//			}
//			if (SlotId > 2)
//			{
//				RemoveItem(conn, 5643, 10);
//
//				STRUCT_ITEM item;
//				memset(&item, 0, sizeof(STRUCT_ITEM));
//
//				item.sIndex = itemIndex;
//				item.stEffect[0].cEffect = 0;
//				item.stEffect[0].cValue = 0;
//				item.stEffect[1].cEffect = 0;
//				item.stEffect[1].cValue = 0;
//				item.stEffect[2].cEffect = 0;
//				item.stEffect[2].cValue = 0;
//
//				PutItem(conn, &item);
//				SendCarry(conn);
//				SendScore(conn);
//				SendEtc(conn);
//				SendClientMessage(conn, "Sua alma foi entregue");
//				ItemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, "Criou uma Alma no Jephi");
//				return;
//			}
//			else
//			{
//				SendClientMessage(conn, g_pMessageStringTable[_NN_You_Have_No_Space_To_Trade]);
//				return;
//			}
//		}
//	}
//}

# -------------------- ProcessClientMessage-BYPOLLY.h --------------------

//bom agora temos todo o esqueleto da ProcessClientMessage
//com a identificação dos packets, faltao alguns ain da q sao dentro dos switch
//e vao ser identificados com conforme vai evoluindo,
//se quiserem ajudar descompilar os packets.

void ProcessClientMessage(int conn, char* msg) //0042ea00
{
	__HEADER pHeader = *(__HEADER*)msg;

	if(ServerDown >= 120)
		return;

	if((pHeader.PacketId & FLAG_CLIENT2GAME) == 0 || pHeader.ClientId < MOB_EMPTY || pHeader.ClientId >= MAX_PLAYER)
	{
		//sprintf(temp, "Unknown Packet Type:%d ID:%d Size:%d KeyWord:%d", pHeader.PacketId, pHeader.ClientId, pHeader.Size, pHeader.Key);
		//Log(temp, "-system", NULL);
		return;
	}

	//0042EAB5
	if(conn > MOB_EMPTY && conn < MAX_PLAYER)
		pUser[conn].LastReceiveTime = SecCounter;

	if(pHeader.PacketId == _MSG_Ping) //0x3A0
		return;

	//0042EAEB
	int PacketOpCode = pHeader.PacketId;
	if(PacketOpCode > _MSG_GetItem) //0x270
	{
		//0042EB41
		if(PacketOpCode > _MSG_SwapItem) //0x376
		{
			//0042EBE8
			if(PacketOpCode > _MSG_AutoTrade) //0x397
			{
				//0042EC30
				if(PacketOpCode > _MSG_SendParty)
				{
					//0042EC80
					if(PacketOpCode == 0xE0E)
					{
						//0042EF8D

					}

					//0042EC90
					if(PacketOpCode == 0xE12)
					{
						//0042ECF4

					}

					//0042EC9C
					if(PacketOpCode == _MSG_ReqTransper) //0xFAA
					{
						//0042ECAD
						if(TransperCharacter != 0)
						{
							MSG_ReqTransper* pReqTransper = (MSG_ReqTransper*)msg;
							pReqTransper->Header.ClientId = conn;

							pUser[conn].Mode = USER_CREWAIT;
							DBServerSocket.SendOneMessage((char*)&pReqTransper, sizeof MSG_ReqTransper);
						}
					}

					return;
				}

				//0042EC3C
				if(PacketOpCode == _MSG_SendParty)
				{
					//00445122

				}

				//0042EC4C
				PacketOpCode = PacketOpCode - _MSG_ReqBuy;
				if(PacketOpCode > 14)
					return;

				switch(PacketOpCode)
				{
					case 0: //0x398 _MSG_ReqBuy
					{
						//0043D854

					}

					case 1: //0x399 _MSG_PKMode
					{
						//00430DBE
						MSG_STANDARDPARM* pPKMode = (MSG_STANDARDPARM*)msg;
						pUser[conn].PKMode = pPKMode->Parm1;
						return;
					}

					case 2: //0x39A _MSG_ReqTradeList
					{
						//0043E17E

					}

					case 5: //0x39D _MSG_AttackOne
					case 6: //0x39E _MSG_AttackTwo
					{
						//00430DE4

					}

					case 7: //0x39F _MSG_ReqRanking
					{
						//

					}

					case 14: //0x3Ä6 _MSG_CombineItem
					{
						//0043E6B9

					}

					default:
						return;
				}
			}

			//0042EBF4
			if(PacketOpCode == _MSG_AutoTrade)
			{
				//0043E308
				MSG_AutoTrade* pAutoTrade = (MSG_AutoTrade*)msg;
				if(pMob[conn].MOB.CurrentScore.Hp <= 0 || pMob[conn].Mode != USER_PLAY)
				{
					SendHpMode(conn);
					//AddCrackError(conn, 10, 88);
					RemoveTrade(conn);
					return;
				}

				//0043E364
				int tX = pMob[conn].TargetX;
				int tY = pMob[conn].TargetY;
				int cityId = BASE_GetVillage(tX, tY);
				if(cityId >= 0 && cityId < MAX_GUILDZONE)
				{
					SendClientMessage(conn, ""); //007CF528
					return;
				}

				//0043E3D2
				int TargetId = pAutoTrade->TargetID;
				if(TargetId <= 0 || TargetId >= MAX_PLAYER)
					return;
				
				for(int i = 0; i < MAX_AUTOTRADE; i++)
				{
					if(pAutoTrade->TradeMoney[i] < 0 || pAutoTrade->TradeMoney[i] > 999999999 || pAutoTrade->Item[i].Index == 0 && pAutoTrade->TradeMoney[i] != 0)
						return;

					if(pAutoTrade->Item[i].Index == 0)
						continue;

					if(pAutoTrade->TradeMoney[i] == 0)
						return;

					//0043E4BF
					if(pAutoTrade->Item[i].Index == 508 || pAutoTrade->Item[i].Index == 509 || pAutoTrade->Item[i].Index == 522 || pAutoTrade->Item[i].Index == 446 || (pAutoTrade->Item[i].Index >= 526 && pAutoTrade->Item[i].Index <= 531))
						return;

					//0043E55A
					int InvPos = pAutoTrade->InvenPos[i];
					if(InvPos < 0 || InvPos >= MAX_CARGO)
						return;

					int checkSlots = memcmp(&pUser[conn].Cargo[InvPos], &pAutoTrade->Item[i], sizeof STRUCT_ITEM);
					if(checkSlots != 0)
					{
						RemoveTrade(conn);
						break;
					}
				}

				//0043E5E4
				pAutoTrade->Tax = g_pGuildZone[cityId].Tax;
				pAutoTrade->Desc[24] = 0;
				pAutoTrade->Desc[23] = 0;

				strncpy(pUser[conn].AutoTradeName, pAutoTrade->Desc, MAX_DESC);
				pUser[conn].TradeMode = AUTOTRADE_ON;
				memcpy(&pUser[conn].AutoTrade, pAutoTrade, sizeof MSG_AutoTrade);
				SendAutoTrade(conn, conn);

				MSG_CreateMobTrade pCreateMobTrade;
				GetCreateMobTrade(conn, &pCreateMobTrade);
				GridMulticast(tX, tY, (MSG_STANDARD*)&pCreateMobTrade, 0);
			}
		}

		//0042EB51
		if(PacketOpCode == _MSG_SwapItem) //0x397
		{
			//0043FE71
			MSG_SwapItem* pMoveItem = (MSG_SwapItem*)msg;
			if(pMob[conn].MOB.CurrentScore.Hp == 0 || pUser[conn].Mode != USER_PLAY)
			{
				SendHpMode(conn);
				//AddCrackError(conn, 1, 0x13);
				return;
			}

			//0043FEC1
			if(pUser[conn].Trade.OpponentID != MOB_EMPTY)
			{
				//RemoveTrade(conn);
				return;
			}

			//0043FEE8
			if(pUser[conn].TradeMode != AUTOTRADE_OFF && pMoveItem->SrcType == STORAGE_TYPE || pMoveItem->DestType == STORAGE_TYPE)
			{
					SendClientMessage(conn, ""); //007CF428
					return;
			}

			//0043FF30
			if(pMoveItem->SrcType == STORAGE_TYPE || pMoveItem->DestType == STORAGE_TYPE && pMob[conn].MOB.ClassInfo != 3 || (pMob[conn].MOB.Learn & LEARN_13) == 0)
			{
				//0043FF86
				int alvo = pMoveItem->TargetID;
				if(alvo <= MAX_PLAYER || alvo >= MAX_MOB)
				{
					SendClientSignal(conn, 0x7530, _MSG_ClearMenu);
					return;
				}

				//0043FFC8
				if(pMob[alvo].Mode != MOB_PEACE || pMob[alvo].MOB.CapeInfo != 2)
				{
					SendClientSignal(conn, 0x7530, _MSG_ClearMenu);
					return;
				}

				//00440010
				int tX = pMob[conn].TargetX;
				int tY = pMob[conn].TargetY;
				int AlvoTx = pMob[alvo].TargetX;
				int AlvoTy = pMob[alvo].TargetY;
				if(tX < AlvoTx - 23 || tX > AlvoTx + 23 || tY < AlvoTy - 23 || tY > AlvoTy + 23)
				{
					SendClientSignal(conn, 0x7530, _MSG_ClearMenu);
					return;
				}
			}

			//004400C9
			STRUCT_ITEM pMount;
			memcpy(&pMount, &pMob[conn].MOB.Equip[MOUNT], sizeof STRUCT_ITEM);

			int isEquip = FALSE;
			int isGuild = FALSE;

			STRUCT_ITEM* pSrcPtr = NULL;
			STRUCT_ITEM* pDestPtr = NULL;

			//004400FC
			if(pMoveItem->SrcType == EQUIP_TYPE)
			{
				//0044010F
				if(pMoveItem->SrcPos <= FACE || pMoveItem->SrcPos >= MAX_EQUIP)
				{
					//Log("err, trading fails.SwapItem-Equip", pUser[conn].AccountName, pUser[conn].IP);
					return;
				}

				pSrcPtr = &pMob[conn].MOB.Equip[pMoveItem->SrcPos];
				isEquip = TRUE;
				isGuild = TRUE;
			}
			else if(pMoveItem->SrcType == INV_TYPE) //0044019A
			{
				//004401AA
				if(pMoveItem->SrcPos <= 0 || pMoveItem->SrcPos >= MAX_INVEN)
				{
					//Log("err, trading fails.SwapItem-Carry", pUser[conn].AccountName, pUser[conn].IP);
					return;
				}

				pSrcPtr = &pMob[conn].MOB.Inventory[pMoveItem->SrcPos];
			}
			else if(pMoveItem->SrcType == STORAGE_TYPE) //00440220
			{
				//00440230
				if(pMoveItem->SrcPos <= 0 || pMoveItem->SrcPos >= MAX_CARGO)
				{
					//Log("err, trading fails.SwapItem-Cargo", pUser[conn].AccountName, pUser[conn].IP);
					return;
				}

				pSrcPtr = &pUser[conn].Cargo[pMoveItem->SrcPos];
			}
			else //004402A7
			{
				//Log("err, trading fails.SwapItem source type", pUser[conn].AccountName, pUser[conn].IP);
				return;
			}

			//004402D9
			if(pMoveItem->DestType == EQUIP_TYPE)
			{
				//004402EC
				if(pMoveItem->DestPos <= FACE || pMoveItem->DestPos >= MAX_EQUIP)
				{
					//Log("err, trading fails.SwapItem-Equip", pUser[conn].AccountName, pUser[conn].IP);
					return;
				}

				pDestPtr = &pMob[conn].MOB.Equip[pMoveItem->DestPos];
				isEquip = 1;
				isGuild = 1;
			}
			else if(pMoveItem->DestType == INV_TYPE) //00440377
			{
				//00440387
				if(pMoveItem->DestPos <= 0 || pMoveItem->DestPos >= MAX_INVEN)
				{
					//Log("err, trading fails.SwapItem-Carry", pUser[conn].AccountName, pUser[conn].IP);
					return;
				}

				pDestPtr = &pMob[conn].MOB.Inventory[pMoveItem->SrcPos];
			}
			else if(pMoveItem->DestType == STORAGE_TYPE) //004403FD
			{
				//0044040D
				if(pMoveItem->DestPos <= 0 || pMoveItem->DestPos >= MAX_CARGO)
				{
					//Log("err, trading fails.SwapItem-Cargo", pUser[conn].AccountName, pUser[conn].IP);
					return;
				}

				pDestPtr = &pUser[conn].Cargo[pMoveItem->SrcPos];
			}
			else //00440484
			{
				//Log("err, trading fails.SwapItem source type", pUser[conn].AccountName, pUser[conn].IP);
				return;
			}

			//004404B6
			if(pSrcPtr->Index == 747 || pDestPtr->Index == 747) //Coroa de Atila
				//004404D7
				if(pMoveItem->SrcType == STORAGE_TYPE || pMoveItem->DestType == STORAGE_TYPE)
					return;

			//004404FC
			int retSrcItem = FALSE;
			if(pSrcPtr->Index == 508 || pSrcPtr->Index == 522 || (pSrcPtr->Index >= 526 && pSrcPtr->Index <= 537)) //Medalhas
				//00440548
				if(pMoveItem->SrcType == EQUIP_TYPE && pMoveItem->DestType != EQUIP_TYPE)
					retSrcItem = TRUE;

			//00440570
			int retDestItem = FALSE;
			if(pDestPtr->Index == 508 || pDestPtr->Index == 522 || (pDestPtr->Index >= 526 && pDestPtr->Index <= 537)) //Medalhas
				//004405BC
				if(pMoveItem->DestType == EQUIP_TYPE && pMoveItem->SrcType != EQUIP_TYPE)
					retDestItem = TRUE;

			//004405E4
			if(retSrcItem == TRUE || retDestItem == TRUE)
			{
				if(g_Week != 0 && pMob[conn].MOB.BaseScore.Level < 1000)
				{
					SendClientMessage(conn, ""); //007D2428
					return;
				}
			}

			//0044062C
			STRUCT_ITEM SrcItem;
			STRUCT_ITEM DestItem;
			memcpy(&SrcItem, pSrcPtr, sizeof STRUCT_ITEM);
			memcpy(&DestItem, pDestPtr, sizeof STRUCT_ITEM);

			BASE_ClearItem(pDestPtr);
			BASE_ClearItem(pSrcPtr);

			//00440678
			int canEquipDest = TRUE;
			int canEquipSrc = TRUE;
			if(DestItem.Index != 0)
			{
				//0044069B
				int destError = -2;
				if(pMoveItem->DestType == EQUIP_TYPE)
				{
					//004406B4
					canEquipDest = BASE_CanEquip(&DestItem, &pMob[conn].MOB.CurrentScore, pMoveItem->DestPos, pMob[conn].MOB.ClassInfo, pMob[conn].MOB.Equip);
				}
				else if(pMoveItem->DestType == INV_TYPE)
				{
					//0044071A
					canEquipDest = BASE_CanCarry(&DestItem, pMob[conn].MOB.Inventory, (pMoveItem->DestPos % 9), (pMoveItem->DestPos / 9), &destError);
					if(canEquipDest == 0 && destError > 0 && destError <= MAX_INVEN)
					{
						//00440789
						destError--;
						SendItem(conn, INV_TYPE, destError, &pMob[conn].MOB.Inventory[destError]);
					}
				}
				else if(pMoveItem->DestType == STORAGE_TYPE)
				{
					//004407D4
					canEquipDest = BASE_CanCargo(&DestItem, pUser[conn].Cargo, (pMoveItem->DestPos % 9), (pMoveItem->DestPos / 9));
				}
			}

			//00440823
			if(SrcItem.Index != 0)
			{
				//00440832
				int srcError = -2;
				if(pMoveItem->SrcType == EQUIP_TYPE)
				{
					//0044084B
					canEquipSrc = BASE_CanEquip(&SrcItem, &pMob[conn].MOB.CurrentScore, pMoveItem->SrcPos, pMob[conn].MOB.ClassInfo, pMob[conn].MOB.Equip);
				}
				else if(pMoveItem->SrcType == INV_TYPE)
				{
					//004408B1
					canEquipSrc = BASE_CanCarry(&SrcItem, pMob[conn].MOB.Inventory, (pMoveItem->SrcPos % 9), (pMoveItem->SrcPos / 9), &srcError);
					if(canEquipSrc == 0 && srcError > 0 && srcError <= MAX_INVEN)
					{
						//00440920
						srcError--;
						SendItem(conn, INV_TYPE, srcError, &pMob[conn].MOB.Inventory[srcError]);
					}
				}
				else if(pMoveItem->SrcType == STORAGE_TYPE)
				{
					//0044096B
					canEquipSrc = BASE_CanCargo(&SrcItem, pUser[conn].Cargo, (pMoveItem->SrcPos % 9), (pMoveItem->SrcPos / 9));
				}
			}

			//004409BA
			if(canEquipDest == 0 || canEquipSrc == 0)
			{
				memcpy(pSrcPtr, &DestItem, sizeof STRUCT_ITEM);
				memcpy(pDestPtr, &SrcItem, sizeof STRUCT_ITEM);
				return;
			}
			else
			{
				memcpy(pSrcPtr, &SrcItem, sizeof STRUCT_ITEM);
				memcpy(pDestPtr, &DestItem, sizeof STRUCT_ITEM);
			}

			//00440A2D
			if(pSrcPtr->Index <= 40) //ID das Faces
				BASE_ClearItem(pSrcPtr);

			if(pDestPtr->Index <= 40) //ID das Faces
				BASE_ClearItem(pDestPtr);

			//00440A58
			pMob[conn].GetCurrentScore(conn);
			pUser[conn].cSock.AddMessage((char*)pMoveItem, sizeof MSG_SwapItem);

			//00440A9C
			if(pMob[conn].MOB.Equip[WEAPON].Index == 0 && pMob[conn].MOB.Equip[SHIELD].Index != 0)
			{
				int ItemUnique = BASE_GetItemAbility(&pMob[conn].MOB.Equip[SHIELD], EF_POS);
				if(ItemUnique != 128)
				{
					//00440AFC
					pMoveItem->DestType = INV_TYPE;
					pMoveItem->DestPos = WEAPON;

					pMoveItem->SrcType = INV_TYPE;
					pMoveItem->SrcPos = SHIELD;

					pUser[conn].cSock.AddMessage((char*)&pMoveItem, sizeof MSG_SwapItem);

					memcpy(&pMob[conn].MOB.Equip[WEAPON], &pMob[conn].MOB.Equip[SHIELD], sizeof STRUCT_ITEM);
                    memset(&pMob[conn].MOB.Equip[SHIELD], 0, sizeof STRUCT_ITEM);
				}
			}

			//00440BA9
			if(isEquip == TRUE)
				SendEquip(conn, conn);

			if(isGuild == TRUE)
			{
				GetGuild(conn);
				SendScore(conn);
			}

			//00440BE3
			MountProcess(conn, &pMount);

			STRUCT_ITEM* penultimo = &pUser[conn].Cargo[126];
			STRUCT_ITEM* ultimo = &pUser[conn].Cargo[127];

			//00440C1F
			if(pMoveItem->SrcType == STORAGE_TYPE || pMoveItem->DestType == STORAGE_TYPE)
			{
				if(penultimo->Index == 0 || ultimo->Index == 0)
					return;

				//00440C61
				for(int i = 0; i < 126; i++)
				{
					//00440C89
					if(penultimo->Index != 0)
					{
						int canCargo = BASE_CanCargo(penultimo, pUser[conn].Cargo, i % 9, i / 9);
						if(canCargo != 0)
						{
							memcpy(&pUser[conn].Cargo[i], penultimo, sizeof STRUCT_ITEM);
							memset(penultimo, 0, sizeof STRUCT_ITEM);
							SendItem(conn, STORAGE_TYPE, i, &pUser[conn].Cargo[i]);
						}
					}

					if(ultimo->Index != 0) //00440D57
					{
						int canCargo = BASE_CanCargo(ultimo, pUser[conn].Cargo, i % 9, i / 9);
						if(canCargo != 0)
						{
							memcpy(&pUser[conn].Cargo[i], ultimo, sizeof STRUCT_ITEM);
							memset(ultimo, 0, sizeof STRUCT_ITEM);
							SendItem(conn, STORAGE_TYPE, i, &pUser[conn].Cargo[i]);
						}
					}
				}
			}
		}

		//0042EB61
		if(PacketOpCode > _MSG_EnterVillage)
		{
			//0042EBB1
			PacketOpCode = PacketOpCode - _MSG_Imple;
			if(PacketOpCode > 223)
				return;

			switch(PacketOpCode)
			{
				case 0: //0x295 _MSG_Imple
				{
					//0043D38A

				}

				case 158: //0x333 _MSG_MessageChat
				{
					//00442537

				}

				case 159: //0x334 _MSG_MessageWhisper
				{
					//00440E2A

				}

				case 161: //0x336 _MSG_UpdateScore
				{
					//0043D53D

				}

				case 209: //0x366 _MSG_Action
				case 210: //0x367 _MSG_Stop
				case 211: //0x368 _MSG_Illusion
				{
					//0042FE1A

				}

				case 212: //0x369 _MSG_REQMobByID
				{
					//00444D4A

				}

				case 213: //0x36A _MSG_Motion
				{
					//00430D38

				}

				case 215: //0x36C _MSG_Attack
				{
					//

				}

				case 222: //0x373 _MSG_UseItem
				{
					//0043A4A7

				}

				case 223: //0x374 
				{
					//0043D57E

				}

				default:
					return;
			}
		}

		//0042EB6D
		if(PacketOpCode == _MSG_EnterVillage)
		{
			//004353C1
			int tX = pMob[conn].TargetX;
			int tY = pMob[conn].TargetY;
			int cityId = BASE_GetVillage(tX, tY);

			//00435407
			if(cityId >= 0 && cityId < MAX_GUILDZONE)
			{
				//0043541E
				pMob[conn].MOB.Merchant = pMob[conn].MOB.Merchant & 0x3F;
				pMob[conn].MOB.Merchant = (pMob[conn].MOB.Merchant | (cityId << 6));
			}
		}

		//0042EB7D
		PacketOpCode = PacketOpCode - _MSG_DropItem;
		if(PacketOpCode > 30)
			return;

		switch(PacketOpCode)
		{
			case 0: //0x272 _MSG_DropItem
			{
				//00439D81

			}

			case 5: //0x277 _MSG_ApplyBonus
			{
				//00442B83

			}

			case 6: //0x278 
			{
				//00443322

			}

			case 9: //0x27B _MSG_REQShopList
			{
				//004441C7

			}

			case 23: //0x289 _MSG_Restart
			{
				// ainda nao achei o addr

			}

			case 25: //0x28B _MSG_Quest
			{
				//0043546F

			}

			case 26: //0x28C _MSG_Deprivate
			{
				// ainda nao achei o addr

			}

			case 28: //0x28E _MSG_Challange
			{
				// ainda nao achei o addr

			}

			case 29: //0x28F _MSG_ChallangeConfirm
			{
				// ainda nao achei o addr

			}

			case 30: //0x290 _MSG_ReqTeleport
			{
				// ainda nao achei o addr

			}

			default:
				return;
		}
	}

	//0042EB06
	if(PacketOpCode == _MSG_GetItem) //0x270
	{
		//0043925C
		MSG_GetItem* pItem = (MSG_GetItem*)msg;
		if(pMob[conn].MOB.CurrentScore.Hp <= 0 || pUser[conn].Mode != USER_PLAY)
		{
			SendHpMode(conn);
			//AddCrackError(conn, 1, 0xD);
			return;
		}

		//004392AC
		if(pItem->DestType != INV_TYPE)
		{
			//Log("DEBUG: GetItem with wrong DestType", pUser[conn].AccountName, pUser[conn].IP);
			return;
		}

		//004392E9
		int ItemIdx = pItem->ItemID - 10000;
		if(ItemIdx < 0 || ItemIdx > MAX_ITEMLIST || pItemBuffer[ItemIdx].Mode == 0)
		{
			if(pItemBuffer[ItemIdx].Mode != 0)
			{
				//sprintf(temp, "GetItemFail idx:%d mode:%d", ItemIdx, pItemBuffer[ItemIdx].Mode);
				//Log(temp, pUser[conn].AccountName, pUser[conn].IP);
			}

			MSG_RemoveItem rItem;
			rItem.Header.PacketId = _MSG_RemoveItem;
			rItem.Header.Size = sizeof MSG_RemoveItem;
			rItem.Header.ClientId = 0x7530;

			//004393AF
			rItem.ItemID = pItem->ItemID;

			pUser[conn].cSock.AddMessage((char*)&rItem, sizeof MSG_RemoveItem);
			return;
		}

		//004393ED
		if(pMob[conn].TargetX < (pItemBuffer[ItemIdx].PosX - 3) || pMob[conn].TargetY < (pItemBuffer[ItemIdx].PosY - 3) || pMob[conn].TargetX > (pItemBuffer[ItemIdx].PosX + 3) || pMob[conn].TargetY > (pItemBuffer[ItemIdx].PosY + 3))
		{
			//0043947D
			//sprintf(temp, "GetItemFail posx:%d posy:%d tx:% ty:%d", pItemBuffer[ItemIdx].PosX, pItemBuffer[ItemIdx].PosY, pMob[conn].TargetX, pMob[conn].TargetY);
			//Log(temp, pUser[conn].AccountName, pUser[conn].IP);
			return;
		}

		//00439501
		if(ItemIdx == 1727 || pMob[conn].MOB.CurrentScore.Level < 1000)
			return;
			
		//00439529
		STRUCT_ITEM checkItem = pItemBuffer[ItemIdx].ITEM;
		int ItemIndex = checkItem.Index;
		if(ItemIndex <= 0 || ItemIndex >= MAX_ITEMLIST)
			return;

		//00439567
		if(checkItem.Index == 470) //Pilula do poder
		{
			int temp1 = 0;
			int temp2 = 1;
			temp2 = temp2 << temp1;

			if((pMob[conn].MOB.QuestInfo & temp2) != 0)
			{
				//004395C2
				BASE_GetLanguage(temp, 71);
				SendClientMessage(conn, temp);
				return;
			}

			//004395E7
			SendClientMessage(conn, g_pMessageStringTable[temp1 + 1]);
			pMob[conn].MOB.QuestInfo = pMob[conn].MOB.QuestInfo | temp2;

			//0043962E
			int ItemPosX = pItemBuffer[ItemIdx].PosX;
			int ItemPosY = pItemBuffer[ItemIdx].PosY;
			BASE_ClearItem(&checkItem);
			pItemGrid[ItemPosX][ItemPosY] = 0;
			pItemBuffer[ItemIdx].Mode = 0;

			MSG_RemoveItem rItem;
			rItem.Header.PacketId = _MSG_RemoveItem;
			rItem.Header.Size = sizeof MSG_RemoveItem;
			rItem.Header.ClientId = 0x7530;

			//004393AF
			rItem.ItemID = ItemIdx + 10000;

			GridMulticast(ItemPosX, ItemPosY, (MSG_STANDARD*)&rItem, 0);

			pMob[conn].MOB.SkillPoint = pMob[conn].MOB.SkillPoint + 9;
			SendEmotion(conn, 0xE, 3);
			SendEtc(conn);
			return;
		}

		//00439723
		if(ItemIndex >= 490 && ItemIndex <= 500)
		{
			sprintf(temp, "PlayerName%s - ItemName%s", pMob[conn].MOB.Name, g_pItemList[ItemIndex].Name);
			SendNotice(temp);

			int ItemPosX = pItemBuffer[ItemIdx].PosX;
			int ItemPosY = pItemBuffer[ItemIdx].PosY;
			pItemGrid[ItemPosX][ItemPosY] = 0;
			pItemBuffer[ItemIdx].Mode = 0;

			MSG_RemoveItem rItem;
			rItem.Header.PacketId = _MSG_RemoveItem;
			rItem.Header.Size = sizeof MSG_RemoveItem;
			rItem.Header.ClientId = 0x7530;

			//004397F2
			rItem.ItemID = ItemIdx + 10000;

			GridMulticast(ItemPosX, ItemPosY, (MSG_STANDARD*)&rItem, 0);
		}

		//00439823
		int ItemPosX = pItemBuffer[ItemIdx].PosX;
		int ItemPosY = pItemBuffer[ItemIdx].PosY;

		MSG_RemoveItem rItem;
		rItem.Header.PacketId = _MSG_RemoveItem;
		rItem.Header.Size = sizeof MSG_RemoveItem;
		rItem.Header.ClientId = 0x7530;

		//00439868
		rItem.ItemID = pItem->ItemID;

		if(ItemPosX < 0 || ItemPosX >= MAX_GRIDX || ItemPosY < 0 || ItemPosY >= MAX_GRIDY)
		{
			//004398A3
			pUser[conn].cSock.AddMessage((char*)&rItem, sizeof MSG_RemoveItem);
			pItemBuffer[ItemIdx].Mode = 0;
			return;
		}

		//004398E3
		if(pItemGrid[ItemPosX][ItemPosY] != ItemIdx)
		{
			pUser[conn].cSock.AddMessage((char*)&rItem, sizeof MSG_RemoveItem);
			if(pItemGrid[ItemPosX][ItemPosY] == 0)
				pItemGrid[ItemPosX][ItemPosY] = ItemIdx;

			return;
		}

		//0043996C
		if(ItemPosX != pItem->PosX && ItemPosY != pItem->PosY)
			pUser[conn].cSock.AddMessage((char*)&rItem, sizeof MSG_RemoveItem);

		//004399C1
		int ItemVolatile = BASE_GetItemAbility(&checkItem, EF_VOLATILE);
		if(ItemVolatile == 2)
		{
			//004399E5
			int GetCoin = BASE_GetItemAbility(&checkItem, EF_HWORDCOIN);
			int CalcCoin = GetCoin << 8;

			GetCoin = BASE_GetItemAbility(&checkItem, EF_LWORDCOIN);
			CalcCoin = CalcCoin + GetCoin;

			int gold = pMob[conn].MOB.Gold + CalcCoin;
			if(gold >= 2000000000)
			{
				SendClientMessage(conn, "Limite de gold atingido");
				return;
			}

			//00439A7F
			pMob[conn].MOB.Gold = pMob[conn].MOB.Gold + CalcCoin;
			rItem.ItemID = checkItem.Index;
			BASE_ClearItem(&checkItem);
		}
		else
		{
			if(pItem->DestPos < 0 || pItem->DestPos >= MAX_INVEN) //00439ACE
			{
				//Log("DEBUG: Trading Fails. (wrong source position)", pUser[conn].AccountName, pUser[conn].IP);
				return;
			}

			//00439B18
			STRUCT_ITEM* Inven = &pMob[conn].MOB.Inventory[pItem->DestPos];
			int x = pItem->DestPos % 9;
			int y = pItem->DestPos / 9;
			int error = -2;
			int ret = BASE_CanCarry(&checkItem, pMob[conn].MOB.Inventory, x, y, &error);
			if(ret == 0 || error > 0 || error <= MAX_INVEN)
			{
				error = error - 1;
				SendItem(conn, INV_TYPE, error, &pMob[conn].MOB.Inventory[error]);
				return;
			}

			//00439C04
			memcpy(&rItem, &checkItem, sizeof STRUCT_ITEM);
			memcpy(Inven, &checkItem, sizeof STRUCT_ITEM);

			//00439C5F
			if(BASE_NeedLog((STRUCT_ITEM*)&rItem, 0) != 0)
			{
				char msg;
				BASE_GetItemCode((STRUCT_ITEM*)&rItem, &msg);
				//sprintf(temp, "get %s", &msg);
				//Log(temp, pUser[conn].AccountName, pUser[conn].IP);
			}
		}

		//00439CD0
		MSG_CNFGetItem respItem;
		respItem.Header.PacketId = _MSG_CNFGetItem;
		respItem.Header.Size = sizeof MSG_CNFGetItem;
		respItem.Header.ClientId = 0x7530;

		respItem.DestType = pItem->DestType;
		respItem.DestPos = pItem->DestPos;

		pUser[conn].cSock.AddMessage((char*)&respItem, sizeof MSG_CNFGetItem);
		GridMulticast(ItemPosX, ItemPosY, (MSG_STANDARD*)&rItem, 0);
		pItemGrid[ItemPosX][ItemPosY] = 0;
		pItemBuffer[ItemIdx].Mode = 0;
		return;
	}
	else
	{
		//0042EB16
		PacketOpCode = PacketOpCode - _MSG_AccountLogin;
		if(PacketOpCode > 8)
			return;

		switch(PacketOpCode)
		{
			case 0: //0x20D _MSG_AccountLogin
			{
				//0042F50F
				MSG_NewAccount* pNewAccount = (MSG_NewAccount*)msg;
				pNewAccount->Name[15] = '\0';
				pNewAccount->Pwd[11] = '\0';

				if(pNewAccount->Header.Size < sizeof MSG_NewAccount && pNewAccount->Version < CLIVER && pNewAccount->Version > CLIVER +3)
				{
					//0042F542
					sprintf(temp, "", CLIVER);
					SendClientMessage(conn, temp);
					pUser[conn].cSock.SendMessageA();
					CloseUser(conn);
					return;
				}

				//0042F58F
				if(pUser[conn].Mode != USER_ACCEPT)
				{
					//0042F5A1
					SendClientMessage(conn, "Login now, wait a moment.");
					CrackLog(conn, "accountlogin");
					pUser[conn].cSock.SendMessageA();
					return;
				}

				//0042F5DC
				pNewAccount->Header.PacketId = _MSG_DBAccountLogin;
				pNewAccount->Header.ClientId = conn;
				sscanf(pNewAccount->Name, "%s", pUser[conn].AccountName);
				strupr(pNewAccount->Name);
				strcpy(pNewAccount->Name, pUser[conn].AccountName);
				int AccountError = CheckFailAccount(pNewAccount->Name);
				if(AccountError >= 3)
				{
					SendClientMessage(conn, ""); //007CB1A8
					pUser[conn].cSock.SendMessageA();
					return;
				}

				//0042F68D
				DBServerSocket.SendOneMessage((char*)pNewAccount, sizeof MSG_NewAccount); //(msg, 0x40)
				if(pNewAccount->Header.Size < sizeof MSG_NewAccount) //0042F6A5
					memset(pUser[conn].Mac, -1, 16);
				else
					memcpy(pUser[conn].Mac, pNewAccount->Keys, 16);

				pUser[conn].Mode = USER_LOGIN;
				pMob[conn].Mode = MOB_EMPTY;
				return;
			}

			case 2: //0x20F _MSG_NewCharacter
			{
				//0042F3D2
				MSG_NewCharacter* pNewCharacter = (MSG_NewCharacter*)msg;
				pNewCharacter->szName[31] = '\0';
				pNewCharacter->szName[30] = '\0';
				if(BASE_CheckValidString(pNewCharacter->szName) == 0)
				{
					//0042F3FE
					SendClientSignal(conn, 0, _MSG_NewCharacterFail);
					return;
				}

				//0042F416
				pNewCharacter->Header.PacketId = _MSG_DBNewCharacter;
				pNewCharacter->Header.ClientId = conn;
				pUser[conn].Mode = USER_CREWAIT;

				DBServerSocket.SendOneMessage((char*)pNewCharacter, sizeof MSG_NewCharacter);
				return;
			}

			case 4: //0x211 _MSG_DeleteCharacter
			{
				//0042F452
				MSG_DeleteCharacter* pDeleteCharacter = (MSG_DeleteCharacter*)msg;
				if(pUser[conn].Mode != USER_SELCHAR)
				{
					//0042F46A
					SendClientMessage(conn, "Deleting Character. wait a moment.");
					//sprintf(temp, "err, delchar not user_selchar %d %d", conn, pUser[conn].Mode);
					//Log(temp, pUser[conn].AccountName, pUser[conn].IP);
					return;
				}

				//0042F4D3
				pDeleteCharacter->Header.PacketId = _MSG_DBDeleteCharacter;
				pDeleteCharacter->Header.ClientId = conn;
				pUser[conn].Mode = USER_CREWAIT;
				DBServerSocket.SendOneMessage((char*)pDeleteCharacter, sizeof MSG_DeleteCharacter);
				return;
			}

			case 6: //0x213 _MSG_CharacterLogin
			{
				//0042F714
				MSG_CharacterLogin* pCharacterLogin = (MSG_CharacterLogin*)msg;
				if(pCharacterLogin->CharIndex < 0 || pCharacterLogin->CharIndex >= 4)
				{
					SendClientMessage(conn, ""); //007CB028
					return;
				}

				//0042F742
				if(pUser[conn].CharList[pCharacterLogin->CharIndex].Experience >= FREEEXP || pUser[conn].CharList[pCharacterLogin->CharIndex].Experience < 999 || BILLING == 2)
				{
					//0042F79B
					if(pUser[conn].Billing <= 1)
					{
						if(pUser[conn].ReqBillSec != 0 && pUser[conn].ReqBillSec < SecCounter - 10)
						{
							pUser[conn].ReqBillSec = 0;
							pUser[conn].Billing = 5;
						}
						else //0042F805
						{
							SendClientMessage(conn, ""); //007CB228
							SendBilling(conn, pUser[conn].AccountName, TRUE, TRUE);
						}

						return;
					}

					//0042F83A
					if(pUser[conn].Billing == 3)
					{
						sprintf(temp, "", FREEEXP); //007CB2A8
						SendClientMessage(conn, temp);
						SendClientSignalParm(conn, 0, _MSG_BillingPage, 0);
						return;
					}

					//0042F88F
					if(pUser[conn].Billing == 4)
					{
						SendClientMessage(conn, ""); //007CB328
						return;
					}
				}

				//0042F8B7
				if(pUser[conn].CharList[pCharacterLogin->CharIndex].Experience >= FREEEXP && pUser[conn].CharList[pCharacterLogin->CharIndex].Experience < 999 && BILLING == 3 && pUser[conn].CharList[pCharacterLogin->CharIndex].Experience >= 1000)
				{
					//0042F936
					if(pUser[conn].Billing <= 1)
						SendClientMessage(conn, ""); //007CB228

					if(pUser[conn].Billing == 3)
					{
						sprintf(temp, "", FREEEXP); //007CB2A8
						SendClientMessage(conn, temp);
					}

					if(pUser[conn].Billing == 4)
						SendClientMessage(conn, ""); //007CB328
				}

				//0042F9B7
				if(BILLING == 2 && pUser[conn].Child == 1 && pUser[conn].CharList[pCharacterLogin->CharIndex].Experience >= FREEEXP && (g_Hour <= 7 || g_Hour >= 23))
				{
					SendClientMessage(conn, ""); //007D0628
					return;
				}
				else
				{
					if(pUser[conn].Mode != USER_SELCHAR)
					{
						//0042FA2E
						SendClientMessage(conn, "Wait a moment.");
						//sprintf(temp, "err, charlogin not user_selchar %d %d", conn, pUser[conn].Mode);
						//Log(temp, pUser[conn].AccountName, pUser[conn].IP);
						return;
					}

					pCharacterLogin->Header.PacketId = _MSG_DBCharacterLogin;
					pCharacterLogin->Header.ClientId = conn;
					pUser[conn].Mode = USER_CHARWAIT;
					pMob[conn].Mode = MOB_USER;
					pMob[conn].MOB.Merchant = 0;
					DBServerSocket.SendOneMessage((char*)pCharacterLogin, sizeof MSG_CharacterLogin);
					return;
				}
			}

			case 8: //0x215 _MSG_CharacterLogout
			{
				//0042FAF6
				CharLogOut(conn);
				return;
			}

			default:
				return;
		}
	}
}

# -------------------- ProcessClientMessage.cpp --------------------

/*
*   Copyright (C) {2015}  {Victor Klafke, Charles TheHouse}
*
*   This program is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program.  If not, see [http://www.gnu.org/licenses/].
*
*   Contact at: victor.klafke@ecomp.ufsm.br
*/
#include <Windows.h>
#include <stdio.h>
#include <fcntl.h>
#include <time.h>
#include <math.h>
#include <io.h>
#include <errno.h>

#include "..\Basedef.h"
#include "..\CPSock.h"
#include "..\ItemEffect.h"
#include "Language.h"

#include "CItem.h"
#include "Server.h"
#include "ProcessClientMessage.h"
#include "GetFunc.h"
#include "SendFunc.h"
#include "Functions.h"

void  ProcessClientMessage(int conn, char *pMsg, BOOL isServer)
{
	MSG_STANDARD *std = (MSG_STANDARD *)pMsg;

	/*if (std->ID < MAX_USER)
		printf("RECV-> Code: %X - Size: %d - Index: %d \n", std->Type, std->Size, std->ID);*/

	//console monitor de pacote
	printf("Pacote: 0x%X - Tamanho: %d - Index: %d\n", std->Type, std->Size,  std->ID);  //pacotes print

	if ((std->ID < 0) || (std->ID >= MAX_USER)) 
	{	
		MSG_STANDARD *m = (MSG_STANDARD *)pMsg;

		sprintf_s(temp, "err,packet Type:%d ID:%d Size:%d KeyWord:%d", m->Type, m->ID, m->Size, m->KeyWord);

		SystemLog("-system", "-", 0, temp);

		return;
	}

	if (ServerDown >= 120)
		return;

	//if (std->Type == 0x20D && sizeof(MSG_AccountLogin)) //proteção pacote
	//	return;

	if (std->Type == 0x20D)
	{
		if (pUser[conn].Atraso != 0)
		{
			int isTime = GetTickCount64() - pUser[conn].Atraso; // ATRASO PACOTE DE LOGIN

			if (isTime < 5000)
			{
				SendClientMessage(conn, "Aguarde 5 segundos para uma nova Tentativa.");
				return;
			}

		}
		pUser[conn].Atraso = GetTickCount64();
	}

	if (std->Type == 0x213 && std->Size > 36) //proteção pacote
		return;

	if (std->Type == 0x213)
	{
		if (pUser[conn].Atraso != 0)
		{
			int isTime = GetTickCount64() - pUser[conn].Atraso; // ATRASO PACOTE DE ENTRE WORLD

			if (isTime < 500)
			{
				SendClientMessage(conn, "Aguarde 1 segundo para uma nova Tentativa.");
				return;
			}

		}
		pUser[conn].Atraso = GetTickCount64();
	}

	if (std->Type == 0x3A0 && std->Size > 12) //proteção pacote
		return;

	if (std->Type == 0x3A0)
	{
		if (pUser[conn].Atraso != 0)
		{
			int isTime = GetTickCount64() - pUser[conn].Atraso; // ATRASO PACOTE DE ENTRE SELLCHAR

			if (isTime < 1000)
			{
				//SendClientMessage(conn, "Aguarde 1 segundos para uma nova Tentativa.");
				return;
			}

		}
		pUser[conn].Atraso = GetTickCount64();
	}

	if (std->Type == 0xFDE && std->Size > 32) //proteção pacote
		return;

	if (std->Type == 0xFDE)
	{
		if (pUser[conn].Atraso != 0)
		{
			int isTime = GetTickCount64() - pUser[conn].Atraso; // ATRASO PACOTE DE ENTRE SENHA2

			if (isTime < 500)
			{
				SendClientMessage(conn, "Aguarde 1 segundo para uma nova Tentativa.");
				return;
			}

		}
		pUser[conn].Atraso = GetTickCount64();
	}

	if (std->Type == 0x3AE && std->Size > 16) //proteção pacote
		return;

	if (std->Type == 0x3AE)
	{
		if (pUser[conn].Atraso != 0)
		{
			int isTime = GetTickCount64() - pUser[conn].Atraso; // ATRASO PACOTE DE ENTRE PERSONAGEM

			if (isTime < 1000)
			{
				SendClientMessage(conn, "Aguarde 1 segundo para uma nova Tentativa.");
				return;
			}

		}
		pUser[conn].Atraso = GetTickCount64();
	}

	//pacotes que a gente não sabe

	if (std->Type == 0x2E4 && std->Size > 20) {
		return;
	}

	if (std->Type == 0x2E4)
	{
		if (pUser[conn].Atraso != 0)
		{
			int isTime = GetTickCount64() - pUser[conn].Atraso; // ATRASO PACOTE DE APAGAR OS ITENS

			if (isTime < 500)
			{
				SendClientMessage(conn, "Apague os Itens devagar!.");
				return;
			}

		}
		pUser[conn].Atraso = GetTickCount64();
	}

	if (std->Type == 0x397 && std->Size > sizeof(MSG_LeilaoStore)) {
		return;
	}
	  
	if (ServerDown >= 120)
		return;

	if (conn > 0 && conn < MAX_USER)
		pUser[conn].LastReceiveTime = SecCounter;

	if (std->Type == _MSG_Ping)
		return;

	// Checa se o pacote foi enviado por algum jogador e possui o timestamp de controle interno.
	if (isServer == FALSE && std->ClientTick == SKIPCHECKTICK)
		return;

	switch(std->Type)
	{
	case 0x111111398:
		return;
		break;
		








		


	/*Quando quero informações do Sistema de leilão*/
	case 0xAF1:
	{
		Exec_MSG_LeilaoStore(conn, pMsg);
		break;
	}
	/*Quando quero informações do Sistema de leilão*/
	case 0xAF2:
	{
		MSG_STANDARDPARM2* m = (MSG_STANDARDPARM2*)pMsg;
		 
		SendLeilaoStoreAlvoInfos(conn,m->Parm1);
		break;
	}
	/*Quando cria um mob do Sistema de leilão*/
	case 0x397:
	{
		Exec_MSG_CreateMobLeilao(conn, pMsg);
		break;
	}
	/*Quando abre um mob do Sistema de leilão*/
	case 0x39A:
	{
		Exec_MSG_OpenMobLeilao(conn, pMsg);
		break;
	}
	/*Anuncio de itens no Sistema de leilão*/
	case 0x397C:
	{ 
		Exec_MSG_AddItemLeilaoStore(conn, pMsg);
		break;
	}
	/*Negociação de itens no Sistema de leilão*/
	case 0x398:// _MSG_ReqBuy:
	{
		Exec_MSG_BuyItemLeilaoStore(conn, pMsg);
		break;
	}









	//case _MSG_SendAutoTrade://0x397
	/*	Exec_MSG_SendAutoTrade(conn, pMsg);
		break;*/















	case _MSG_AccountLogin:
		Exec_MSG_AccountLogin(conn, pMsg);
		break;

	case _MSG_CharacterLogin:
		Exec_MSG_CharacterLogin(conn, pMsg);
		break;

	case _MSG_CharacterLogout:
		Exec_MSG_CharacterLogout(conn, pMsg);
		break;

	case _MSG_DeleteCharacter:
		Exec_MSG_DeleteCharacter(conn, pMsg);
		break;

	case _MSG_CreateCharacter:
		Exec_MSG_CreateCharacter(conn, pMsg);
		break;

	case _MSG_AccountSecure:
		Exec_MSG_AccountSecure(conn, pMsg);
		break;

	case _MSG_MessageChat:
		Exec_MSG_MessageChat(conn, pMsg);
		break;

	case _MSG_Action:
	case _MSG_Action2:
	case _MSG_Action3:
		Exec_MSG_Action(conn, pMsg);
		break;

	case _MSG_Motion:
		//Exec_MSG_Motion(conn, pMsg);
		break;			

	case _MSG_UpdateScore:
	{
		//Log("cra client send update score", pUser[conn].AccountName, pUser[conn].IP);
		//AddCrackError(conn, 2, 91);
	} break;

	case _MSG_NoViewMob:
		Exec_MSG_NoViewMob(conn, pMsg);
		break;

	case _MSG_Restart:
		Exec_MSG_Restart(conn, pMsg);
		break;

	case _MSG_Deprivate:
		Exec_MSG_Deprivate(conn, pMsg);
		break;

	case _MSG_Challange:
		Exec_MSG_Challange(conn, pMsg);
		break;

	case _MSG_ChallangeConfirm:
		Exec_MSG_ChallangeConfirm(conn, pMsg);
		break;

	case _MSG_ReqTeleport:
		Exec_MSG_ReqTeleport(conn, pMsg);
		break;

	case _MSG_REQShopList:
		Exec_MSG_REQShopList(conn, pMsg);
		Exec_MSG_OpenDonate(conn, pMsg);
		break;

	case _MSG_Deposit:
		Exec_MSG_Deposit(conn, pMsg);
		break;

	case _MSG_Withdraw:
		Exec_MSG_Withdraw(conn, pMsg);
		break;

	case _MSG_RemoveParty:
		Exec_MSG_RemoveParty(conn, pMsg);
		break;

	case _MSG_SendReqParty:
		Exec_MSG_SendReqParty(conn, pMsg);
		break;

	case _MSG_AcceptParty:
		Exec_MSG_AcceptParty(conn, pMsg);
		break;

	case _MSG_TradingItem:
		Exec_MSG_TradingItem(conn, pMsg);
		break;

	case _MSG_MessageWhisper:
	    Exec_MSG_MessageWhisper(conn, pMsg);
		break;

	case _MSG_ChangeCity:
		Exec_MSG_ChangeCity(conn, pMsg);
		break;

	case _MSG_PKMode:
		Exec_MSG_PKMode(conn, pMsg);
		break;


	case _MSG_UpdateItem:
		Exec_MSG_UpdateItem(conn, pMsg);
		break;

	case _MSG_Quest:
		Exec_MSG_Quest(conn, pMsg);
		break;

	case _MSG_SetShortSkill:
		Exec_MSG_SetShortSkill(conn, pMsg);
		break;

	case _MSG_Attack:
	case _MSG_AttackOne:
	case _MSG_AttackTwo:
		Exec_MSG_Attack(conn, pMsg);
		break;

	case _MSG_DropItem:
		Exec_MSG_DropItem(conn, pMsg);
		break;

	case _MSG_GetItem:
		Exec_MSG_GetItem(conn, pMsg);
		break;

	case _MSG_QuitTrade: 
		Exec_MSG_QuitTrade(conn, pMsg);
		break;

	case _MSG_UseItem:
		Exec_MSG_UseItem(conn, pMsg);
		break;

	case _MSG_ApplyBonus:
		Exec_MSG_ApplyBonus(conn, pMsg);
		break;


	case _MSG_Buy:
		Exec_MSG_Buy(conn, pMsg);
		break;

	case _MSG_Sell:
		Exec_MSG_Sell(conn, pMsg);
		break;

	case _MSG_Rebuy:
		Exec_MSG_Rebuy(conn, pMsg);
		break;

	case _MSG_Trade:
		Exec_MSG_Trade(conn, pMsg);
		break;

	case _MSG_CombineItem:
		Exec_MSG_CombineItem(conn, pMsg);
		break;

	case _MSG_ReqRanking:
		Exec_MSG_ReqRanking(conn, pMsg);
		break;

	case _MSG_CombineItemEhre:
		Exec_MSG_CombineItemEhre(conn, pMsg);
		break;

	case _MSG_CombineItemTiny:
		Exec_MSG_CombineItemTiny(conn, pMsg);
		break;

	case _MSG_CombineDedekinto:
	case _MSG_CombineDedekinto2:
		Exec_MSG_CombineDedekinto(conn, pMsg);
		break;

	case _MSG_CombineItemShany:
		Exec_MSG_CombineItemShany(conn, pMsg);
		break;

	case _MSG_CombineItemAilyn:
		Exec_MSG_CombineItemAilyn(conn, pMsg);
		break;

	case _MSG_CombineItemAgatha:
		Exec_MSG_CombineItemAgatha(conn, pMsg);
		break;

	case _MSG_NovoCompositor:
		Exec_MSG_EventoMissions(conn, pMsg);
		break;

	case _MSG_CombineItemOdin:
	case _MSG_CombineItemOdin2:
		Exec_MSG_CombineItemOdin(conn, pMsg);
		break;

	/*case _MSG_MestreGrifo:
		Exec_MSG_MestreGrifo(conn, pMsg);
		break;*/

	case _MSG_DeleteItem:
		Exec_MSG_DeleteItem(conn, pMsg);
		break;

	case _MSG_InviteGuild:
		Exec_MSG_InviteGuild(conn, pMsg);
		break;

	case  _MSG_SplitItem:
		Exec_MSG_SplitItem(conn, pMsg);
		break;

	case _MSG_CombineItemLindy:
		Exec_MSG_CombineItemLindy(conn, pMsg);
		break;

	case _MSG_CombineItemAlquimia:
		Exec_MSG_CombineItemAlquimia(conn, pMsg);
		break;

	case _MSG_CombineItemExtracao:
		Exec_MSG_CombineItemExtracao(conn, pMsg);
		break;

	case _MSG_GuildAlly:
		Exec_MSG_GuildAlly(conn, pMsg);
		break;

	case _MSG_War:
		Exec_MSG_War(conn, pMsg);
		break;

	case _MSG_CapsuleInfo:
		Exec_MSG_CapsuleInfo(conn, pMsg);
		break;

	case _MSG_PutoutSeal:
		Exec_MSG_PutoutSeal(conn, pMsg);
		break;

	case _MSG_AnswerQuiz:
		Exec_MSG_Quiz(conn, pMsg);
		break;

	case 0x3D1:
		Exec_MSG_onPaymentGold(conn, pMsg);
		break;

	/*case _MSG_SendFiltro:
		FiltroDrop(conn, pMsg);
		break;*/

	case _MSG_ReqDropList:
		ReqDropList(conn, pMsg);
		break;

	case _MSG_SendTraje:
		attMountTraje(conn, pMsg);
		break;

	case _MSG_RequestTeleport:
		ReqTeleport(conn, pMsg);
		break;
	case _MSG_ReqShopDonate:
		ReqDonateShop(conn, pMsg);
		break;
	case _MSG_ReqdListNames:
		ReqdListNames(conn, pMsg);
		break;
	case _MSG_SendJephi:
		Jephi(conn, pMsg);
		break;
	case _MSG_SendItemLevel:
		ItemLevel(conn, pMsg);
		break;
	case _MSG_SendPix:
		TradeDonate(conn, pMsg);
		break;
	case _MSG_ReqAlias:
		RequestAlias(conn, pMsg);
		break;
	}	
	return;
}

# -------------------- ProcessClientMessage.h --------------------

/*
*   Copyright (C) {2015}  {Victor Klafke, Charles TheHouse}
*
*   This program is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program.  If not, see [http://www.gnu.org/licenses/].
*
*   Contact at: victor.klafke@ecomp.ufsm.br
*/
#pragma once

#include <Windows.h>
#include <stdio.h>
#include <fcntl.h>
#include <time.h>
#include <math.h>
#include <io.h>
#include <errno.h>

#include "..\Basedef.h"
#include "..\CPSock.h"
#include "..\ItemEffect.h"
#include "Language.h"

#include "CItem.h"
#include "Server.h"
#include "GetFunc.h"
#include "SendFunc.h"
#include "CMob.h"
#include "CUser.h"
#include "CNPCGene.h"
#include "CReadFiles.h"
#include "CCastleZakum.h"
#include "CWarTower.h"
#include "CCubo.h"

// Externs

extern HWND hWndMain;

extern int ServerGroup;

extern unsigned int CurrentTime;
extern int BrState;

extern unsigned short g_pGuildWar[65536];
extern unsigned short g_pGuildAlly[65536];
extern STRUCT_GUILDINFO GuildInfo[65536];

extern unsigned short pMobGrid  [MAX_GRIDY][MAX_GRIDX];
extern unsigned short pItemGrid [MAX_GRIDY][MAX_GRIDX];
extern char pHeightGrid[MAX_GRIDY][MAX_GRIDX];

extern int CurrentWeather;

extern int GuildImpostoID[MAX_GUILDZONE];

extern CNPCGenerator mNPCGen;
 
extern CUser pUser[MAX_USER];

void  ProcessClientMessage(int conn, char *pMsg, BOOL isServer);


void Exec_MSG_LeilaoStore(int clientId, char* pMsg);
void Exec_MSG_CreateMobLeilao(int clientId, char* pMsg);
void Exec_MSG_OpenMobLeilao(int clientId, char* pMsg);
void Exec_MSG_AddItemLeilaoStore(int clientId, char* pMsg);
void Exec_MSG_BuyItemLeilaoStore(int clientId, char* pMsg);
//void ProcessarBuyLeilaoStore(int clientId, int mobId, int itemPrice);
///**************************************************************************************************
void Exec_MSG_Attack(int conn, char *pMsg);
void Exec_MSG_UseItem(int conn, char *pMsg);
void Exec_MSG_MessageWhisper(int conn, char *pMsg);
void Exec_MSG_AccountLogin(int conn, char *pMsg);
void Exec_MSG_CharacterLogin(int conn, char *pMsg);
void Exec_MSG_CharacterLogout(int conn, char *pMsg);
void Exec_MSG_DeleteCharacter(int conn, char *pMsg);
void Exec_MSG_CreateCharacter(int conn, char *pMsg);
void Exec_MSG_AccountSecure(int conn, char *pMsg);
void Exec_MSG_MessageChat(int conn, char *pMsg);
void Exec_MSG_Action(int conn, char *pMsg);
void Exec_MSG_Motion(int conn, char *pMsg);
void Exec_MSG_NoViewMob(int conn, char *pMsg);
void Exec_MSG_Restart(int conn, char *pMsg);
void Exec_MSG_Deprivate(int conn, char *pMsg);
void Exec_MSG_Challange(int conn, char *pMsg);
void Exec_MSG_ChallangeConfirm(int conn, char *pMsg);
void Exec_MSG_ReqTeleport(int conn, char *pMsg);
void Exec_MSG_REQShopList(int conn, char *pMsg);
//void Exec_MSG_CloseShop(int conn, char* pMsg);
void Exec_MSG_OpenDonate(int conn, char* pMsg);
void Exec_MSG_Deposit(int conn, char *pMsg);
void Exec_MSG_Withdraw(int conn, char *pMsg);
void Exec_MSG_RemoveParty(int conn, char *pMsg);
void Exec_MSG_SendReqParty(int conn, char *pMsg);
void Exec_MSG_AcceptParty(int conn, char *pMsg);
void Exec_MSG_ChangeCity(int conn, char *pMsg);
void Exec_MSG_PKMode(int conn, char *pMsg);
void Exec_MSG_ReqTradeList(int conn, char *pMsg);
void Exec_MSG_UpdateItem(int conn, char *pMsg);
void Exec_MSG_SetShortSkill(int conn, char *pMsg);
void Exec_MSG_DropItem(int conn, char *pMsg);
void Exec_MSG_GetItem(int conn, char *pMsg);
void Exec_MSG_QuitTrade(int conn, char *pMsg);
void Exec_MSG_ApplyBonus(int conn, char *pMsg);
void Exec_MSG_SendAutoTrade(int conn, char *pMsg);
void Exec_MSG_ReqBuy(int conn, char *pMsg);
void Exec_MSG_Buy(int conn, char *pMsg);
void Exec_MSG_Rebuy(int conn, char *pMsg);
void Exec_MSG_Sell(int conn, char *pMsg);
void Exec_MSG_Trade(int conn, char *pMsg);
void Exec_MSG_CombineItem(int conn, char *pMsg);
void Exec_MSG_ReqRanking(int conn, char *pMsg);
void Exec_MSG_CombineItemEhre(int conn, char *pMsg);
void Exec_MSG_CombineItemTiny(int conn, char *pMsg);
//void Exec_MSG_MestreGrifo(int conn, char *pMsg);
void Exec_MSG_CombineItemAilyn(int conn, char *pMsg);
void Exec_MSG_CombineItemAgatha(int conn, char *pMsg);
void Exec_MSG_CombineItemOdin(int conn, char *pMsg);
void Exec_MSG_CombineDedekinto(int conn, char *pMsg);
void Exec_MSG_EventoMissions(int conn, char *pMsg);
void Exec_MSG_DeleteItem(int conn, char *pMsg);
void Exec_MSG_InviteGuild(int conn, char *pMsg);
void Exec_MSG_SplitItem(int conn, char *pMsg);
void Exec_MSG_CombineItemLindy(int conn, char *pMsg);
void Exec_MSG_CombineItemShany(int conn, char *pMsg);
void Exec_MSG_CombineItemAlquimia(int conn, char *pMsg);
void Exec_MSG_CombineItemExtracao(int conn, char *pMsg);
void Exec_MSG_GuildAlly(int conn, char *pMsg);
void Exec_MSG_War(int conn, char *pMsg);
void Exec_MSG_CapsuleInfo(int conn, char *pMsg);
void Exec_MSG_PutoutSeal(int conn, char *pMsg);
void Exec_MSG_TradingItem(int conn, char *pMsg);
void Exec_MSG_Quest(int conn, char *pMsg);
void Exec_MSG_Quiz(int conn, char *pMsg);
void Exec_MSG_onPaymentGold(int conn, char* pMsg);

//**************************************************************************************************

# -------------------- ProcessDBMessage.cpp --------------------


#include <Windows.h>
#include <stdio.h>
#include <fcntl.h>
#include <time.h>
#include <math.h>
#include <io.h>
#include <errno.h>

#include "..\Basedef.h"
#include "..\CPSock.h"
#include "..\ItemEffect.h"
#include "Language.h"

#include "CItem.h"
#include "Server.h"
#include "ProcessClientMessage.h"
#include "GetFunc.h"
#include "SendFunc.h"
#include "wMySQL.h"
#include "Functions.h"


void ProcessDBMessage(char* Msg)
{
	MSG_STANDARD* std = (MSG_STANDARD*)Msg;

	//printf("DB Pacote: %X - Tamanho: %d - Index: %d\n", std->Type, std->Size, std->ID);  //pacotes print


	if (!(std->Type & FLAG_DB2GAME) || (std->ID < 0) || (std->ID >= MAX_USER))
	{
		MSG_STANDARD* m = (MSG_STANDARD*)Msg;
		
		snprintf(temp, sizeof(temp), "err,packet Type:%d ID:%d Size:%d KeyWord:%d", m->Type, m->ID, m->Size, m->KeyWord);

		SystemLog("-system", "-", 0, temp);

		return;
	}

	int conn = std->ID;
#pragma region DB - TM
	if (conn == 0)
	{
		switch (std->Type)
		{

		case _MSG_TransperCharacter:
		{

			TransperCharacter = 1;
			SystemLog("-system", "-", 0, "TransperCharacter mode");

		} break;

		case _MSG_DBSetIndex:
		{
			MSG_STANDARDPARM3* m = (MSG_STANDARDPARM3*)Msg;

			if (m->Parm1 != -1)
			{
				ServerGroup = m->Parm1;
				ServerIndex = m->Parm3;
			}

			Sapphire = m->Parm2;

		} break; // TODO: Check if it isn't a break (must compile and check against the original TM

		case _MSG_War:
		{
			MSG_STANDARDPARM2* m = (MSG_STANDARDPARM2*)Msg;

			DoWar(m->Parm1, m->Parm2);

		} break;

		case _MSG_GuildAlly:
		{
			MSG_STANDARDPARM2* m = (MSG_STANDARDPARM2*)Msg;

			DoAlly(m->Parm1, m->Parm2);

		} break;

		case _MSG_GuildInfo:
		{
			MSG_GuildInfo* m = (MSG_GuildInfo*)Msg;

			GuildInfo[m->Guild] = m->GuildInfo;

		} break;

		case _MSG_GuildReport:
		{
			MSG_GuildReport* m = (MSG_GuildReport*)Msg;

			memmove_s(ChargedGuildList, sizeof(ChargedGuildList), m->ChargedGuildList, sizeof(ChargedGuildList));
		} break;

		case _MSG_NPNotice:
		{
			MSG_NPNotice* m = (MSG_NPNotice*)Msg;

			if (m->Parm1 == 1)
				SendNotice(m->String);

		} break;

		case _MSG_MessageDBImple:
		{
			MSG_MessageDBImple* m = (MSG_MessageDBImple*)Msg;

			m->String[MESSAGE_LENGTH - 1] = 0;
			m->String[MESSAGE_LENGTH - 2] = 0;

			SystemLog("-system", "-", 0, m->String);

			ProcessImple(0, m->Level, m->String);

		} break; // TODO: Check if it isn't a break (must compile and check against the original TM

		case _MSG_MagicTrumpet:
		{
			SyncMulticast(0, (MSG_STANDARD*)Msg, 0);
		} break;

		case _MSG_DBNotice:
		{
			MSG_DBNotice* m = (MSG_DBNotice*)Msg;

			SendNotice(m->String);
		} break;


		}
	}
#pragma endregion
#pragma region DB - TM - CLIENT
	else
	{
		if ((conn > 0 && conn < MAX_USER) && pUser[conn].Mode == 0)
		{
			MSG_STANDARD sm;

			sm.Type = _MSG_DBNoNeedSave;
			sm.ID = conn;

			DBServerSocket.SendOneMessage((char*)&sm, sizeof(MSG_STANDARD));

			return;
		}

		if (conn <= 0 || conn > MAX_USER)
		{
			
			snprintf(temp, sizeof(temp), "Unknown DB Message - conn:%d - type:%d", conn, std->Type);
			SystemLog("-system", "-", 0, temp);

			return;
		}

		switch (std->Type)
		{
#pragma region _MSG_ReqTransper
		case _MSG_ReqTransper:
		{
			if (TransperCharacter == 0)
				return;

			MSG_ReqTransper* m = (MSG_ReqTransper*)Msg;

			m->ID = ESCENE_FIELD + 1;

			pUser[conn].cSock.SendOneMessage((char*)&m, sizeof(MSG_ReqTransper));

			pUser[conn].Mode = USER_CHARWAIT;

		} break;
#pragma endregion

#pragma region _MSG_DBSendItem
		case _MSG_DBSendItem:
		{
			MSG_DBSendItem* m = (MSG_DBSendItem*)Msg;

			if (pUser[conn].Mode < USER_CHARWAIT)
			{
				/*char ItemCode[256];
				snprintf(temp, sizeof(temp), "tra,%s", pUser[conn].AccountName);
				BASE_GetItemCode(&m->Item, ItemCode);
				strcat(temp, ItemCode);
				SystemLog("_fail_play_", "-", pUser[conn].IP, temp);*/

				break;
			}

			if (strcmp(pUser[conn].AccountName, m->Account) != 0)
			{
				/*char ItemCode[256];
				snprintf(temp, sizeof(temp), "tra,%s", pUser[conn].AccountName);
				BASE_GetItemCode(&m->Item, ItemCode);
				strcat(temp, ItemCode);
				SystemLog("_fail_play_", "-", pUser[conn].IP, temp);*/

				break;
			}

			int i = 0;


			for (; i < MAX_CARGO - 8; i++)
			{
				if (pUser[conn].Cargo[i].sIndex != 0)
					continue;

				memmove_s(&pUser[conn].Cargo[i], sizeof(STRUCT_ITEM), &m->Item, sizeof(STRUCT_ITEM));

				SendItem(conn, ITEM_PLACE_CARGO, i, &m->Item);

				SendClientMessage(conn, strFmt("%s [%s]", g_pMessageStringTable[_NN_Item_Arrived], g_pItemList[m->Item.sIndex].Name));
				
				snprintf(temp, sizeof(temp), "Jogador [%s] recebeu pela import item: %s %d %d %d %d %d %d %d", pMob[conn].MOB.MobName, g_pItemList[m->Item.sIndex].Name, m->Item.sIndex,
					m->Item.stEffect[0].cValue, m->Item.stEffect[0].cEffect, //EF1 EFV1
					m->Item.stEffect[1].cValue, m->Item.stEffect[1].cEffect, //EF2 EFV2
					m->Item.stEffect[2].cValue, m->Item.stEffect[2].cEffect); //EF3 EFV3
				ItemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);

				m->Result = 0;
				m->Size = sizeof(m);

				DBServerSocket.SendOneMessage((char*)m, sizeof(m));

				/*char ItemCode[256];
				snprintf(temp, sizeof(temp), "tra,%s %d", pUser[conn].AccountName, i);
				BASE_GetItemCode(&m->Item, ItemCode);
				strcat(temp, ItemCode);
				SystemLog("_web1_", "-", pUser[conn].IP, temp2);*/


				if (pUser[conn].Mode == USER_CHARWAIT)
					SaveUser(conn, 0);

				return;
			}



			m->Result = 3;
			m->Size = sizeof(m);
			DBServerSocket.SendOneMessage((char*)m, sizeof(m));

			char ItemCode[256];

			SaveUser(conn, 1);
			/*
			snprintf(temp, sizeof(temp), "tra,%s", pUser[conn].AccountName);
			BASE_GetItemCode(&m->Item, ItemCode);
			strcat(temp, ItemCode);
			SystemLog("_fail_empty_", "-", pUser[conn].IP, temp);*/

		} break;
#pragma endregion
#pragma region _MSG_NPNotice
		case _MSG_NPNotice:
		{
			MSG_NPNotice* m = (MSG_NPNotice*)Msg;

			if (m->Parm1 == 0)
			{
				if (pUser[conn].Mode == USER_PLAY)
					SendClientMessage(conn, m->String);
			}

		} break;
#pragma endregion
#pragma region _MSG_DBCNFAccountLogin
		case _MSG_DBCNFAccountLogin:
		{
			MSG_DBCNFAccountLogin* m = (MSG_DBCNFAccountLogin*)Msg;

			if (strcmp(m->AccountName, pUser[conn].AccountName) != 0)
			{
				SendClientMessage(conn, g_pMessageStringTable[_NN_Try_Reconnect]);

				pUser[conn].cSock.SendMessageA();

				CloseUser(conn);

				return;
			}


			pUser[conn].IsBillConnect = 0;
			pUser[conn].Whisper = 0;
			pUser[conn].Guildchat = 0;
			pUser[conn].PartyChat = 0;
			pUser[conn].KingChat = 0;
			pUser[conn].Admin = 0;
			pUser[conn].Chatting = 0;
			pUser[conn].Unk_2732 = 0;
			pUser[conn].Unk_2728 = 0;
			pUser[conn].OnlyTrade = 0;
			pUser[conn].chave1 = m->chave1;
			pUser[conn].chave2 = m->chave2;
			pUser[conn].chave3 = m->chave3;
			pUser[conn].Lasclick = -1;

			for (int i = 0; i < 50; i++) {
				pUser[conn].Keys[i] = m->nKeys[i];
			}

			m->ID = ESCENE_FIELD + 2;
			m->Type = _MSG_CNFAccountLogin;

			pUser[conn].Mode = USER_SELCHAR;

			for (int i = 0; i < MAX_CARGO; i++)
			{
				STRUCT_ITEM* tempsour = &m->Cargo[i];

				if (tempsour->sIndex > 0 && tempsour->sIndex < MAX_ITEMLIST)
				{
					int nPos = g_pItemList[tempsour->sIndex].nPos;

					if (nPos == 64 || nPos == 192)
					{
						if (tempsour->stEffect[0].cEffect == EF_DAMAGEADD || tempsour->stEffect[0].cEffect == EF_DAMAGE2)
							tempsour->stEffect[0].cEffect = EF_DAMAGE;

						if (tempsour->stEffect[1].cEffect == EF_DAMAGEADD || tempsour->stEffect[1].cEffect == EF_DAMAGE2)
							tempsour->stEffect[1].cEffect = EF_DAMAGE;

						if (tempsour->stEffect[2].cEffect == EF_DAMAGEADD || tempsour->stEffect[2].cEffect == EF_DAMAGE2)
							tempsour->stEffect[2].cEffect = EF_DAMAGE;
					}
				}
			}

			if (evDelete != 0)
			{
				for (int i = 0; i < MAX_CARGO; i++)
				{
					if (m->Cargo[i].sIndex >= 470 && m->Cargo[i].sIndex <= 500)
						m->Cargo[i].sIndex = 0;
				}
			}

			pUser[conn].cSock.SendOneMessage((char*)m, sizeof(MSG_DBCNFAccountLogin));

			memmove_s(pUser[conn].Cargo, sizeof(STRUCT_ITEM) * MAX_CARGO, m->Cargo, sizeof(STRUCT_ITEM) * MAX_CARGO);

			pUser[conn].Coin = m->Coin;
			pUser[conn].Unk_1816 = 0;
			pUser[conn].SelChar = m->sel;


			if (BILLING > 0 && IsFree(&m->sel) != 0)
			{
				if (CHARSELBILL == 0)
					SendBilling(conn, m->AccountName, 8, 1);
				else
					SendBilling(conn, m->AccountName, 1, 1);

				pUser[conn].Unk_2732 = SecCounter;
			}

			pUser[conn].Unk5[0] = 0;
			pUser[conn].LastClientTick = 0;

			SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, "CNFAccountLogin");

			if (TransperCharacter != 0)
			{
				MSG_STANDARDPARM2 sm;

				sm.Type = _MSG_TransperCharacter;
				sm.ID = ESCENE_FIELD + 1;
				sm.Parm1 = 0;
				sm.Parm2 = 0;
				sm.Size = sizeof(MSG_STANDARDPARM2);

				pUser[conn].cSock.SendOneMessage((char*)&sm, sizeof(MSG_STANDARDPARM2));
			}
		} break;
#pragma endregion
#pragma region _MSG_DBNewAccountFail
		case _MSG_DBNewAccountFail:
		{
			MSG_STANDARD* m = (MSG_STANDARD*)Msg;

			m->ID = ESCENE_FIELD + 3;

			SendClientSignal(conn, 0, _MSG_NewAccountFail);

			CloseUser(conn);
		} break;
#pragma endregion
#pragma region _MSG_DBAccountLoginFail_Account
		case _MSG_DBAccountLoginFail_Account:
		{
			MSG_STANDARD* m = (MSG_STANDARD*)Msg;

			int ID = m->ID;

			SendClientMessage(conn, g_pMessageStringTable[_NN_No_Account_With_That_Name]);
			pUser[conn].cSock.SendMessageA();

			CloseUser(conn);

		} break;
#pragma endregion
#pragma region _MSG_DBAccountLoginFail_Block
		case _MSG_DBAccountLoginFail_Block:
		{
			MSG_STANDARDPARM* m = (MSG_STANDARDPARM*)Msg;

			int ID = m->ID;

			if (m->Parm == 0)
				snprintf(temp, sizeof(temp), g_pMessageStringTable[_SN_Blocked_Account], "X");

			else if (m->Parm == 1)
				snprintf(temp, sizeof(temp), g_pMessageStringTable[_SN_Blocked_Account], "A");

			else if (m->Parm == 2)
				snprintf(temp, sizeof(temp), g_pMessageStringTable[_SN_Blocked_Account], "B");

			else if (m->Parm == 3)
				snprintf(temp, sizeof(temp), g_pMessageStringTable[_SN_Blocked_Account], "C");

			SendClientMessage(conn, temp);
			pUser[conn].cSock.SendMessageA();

			CloseUser(conn);

		} break;
#pragma endregion
#pragma region _MSG_DBAccountLoginFail_Disable
		case _MSG_DBAccountLoginFail_Disable:
		{
			MSG_STANDARD* m = (MSG_STANDARD*)Msg;

			int ID = m->ID;

			SendClientMessage(conn, g_pMessageStringTable[_NN_Disabled_Account]);
			pUser[conn].cSock.SendMessageA();

			CloseUser(conn);

		} break;
#pragma endregion
#pragma region _MSG_AccountSecure
		case _MSG_AccountSecure:
		{
			pUser[conn].Mode = USER_CHARWAIT;
			SendClientSignal(std->ID, ESCENE_FIELD, _MSG_AccountSecure);
		} break;
#pragma endregion
#pragma region _MSG_AccountSecureFail
		case _MSG_AccountSecureFail:
		{
			pUser[conn].Mode = USER_CHARWAIT;
			SendClientSignal(std->ID, ESCENE_FIELD, _MSG_AccountSecureFail);
		} break;
#pragma endregion
#pragma region _MSG_DBOnlyOncePerDay
		case _MSG_DBOnlyOncePerDay:
		{
			MSG_STANDARD* m = (MSG_STANDARD*)Msg;

			int ID = m->ID;

			SendClientMessage(conn, g_pMessageStringTable[_NN_Only_Once_Per_Day]);
			pUser[conn].cSock.SendMessageA();

		} break;
#pragma endregion
#pragma region _MSG_DBAccountLoginFail_Pass
		case _MSG_DBAccountLoginFail_Pass:
		{
			MSG_STANDARD* m = (MSG_STANDARD*)Msg;

			int ID = m->ID;

			SendClientMessage(conn, g_pMessageStringTable[_NN_Wrong_Password]);
			pUser[conn].cSock.SendMessageA();

			CloseUser(conn);

		} break;
#pragma endregion
#pragma region _MSG_DBCNFNewCharacter
		case _MSG_DBCNFNewCharacter:
		{
			MSG_CNFNewCharacter* m = (MSG_CNFNewCharacter*)Msg;

			m->Type = _MSG_CNFNewCharacter;
			m->ID = ESCENE_FIELD + 1;

			pUser[conn].cSock.SendOneMessage((char*)m, sizeof(MSG_CNFNewCharacter));

			pUser[conn].Mode = USER_CHARWAIT;
			pUser[conn].WaitDB = false;


		} break;
#pragma endregion
#pragma region _MSG_DBCNFDeleteCharacter
		case _MSG_DBCNFDeleteCharacter:
		{
			MSG_CNFDeleteCharacter* m = (MSG_CNFDeleteCharacter*)Msg;

			m->Type = _MSG_CNFDeleteCharacter;
			m->ID = ESCENE_FIELD + 1;

			pUser[conn].cSock.SendOneMessage((char*)m, sizeof(MSG_CNFDeleteCharacter));

			pUser[conn].Mode = USER_CHARWAIT;

		} break;
#pragma endregion
#pragma region _MSG_DBDeleteCharacterFail
		case _MSG_DBDeleteCharacterFail:
		{
			MSG_STANDARD* m = (MSG_STANDARD*)Msg;

			m->ID = ESCENE_FIELD + 1;

			SendClientSignal(conn, 0, _MSG_DeleteCharacterFail);

			pUser[conn].Mode = USER_CHARWAIT;

		} break;
#pragma endregion
#pragma region _MSG_DBNewCharacterFail
		case _MSG_DBNewCharacterFail:
		{
			MSG_STANDARD* m = (MSG_STANDARD*)Msg;

			m->ID = ESCENE_FIELD + 1;

			SendClientSignal(conn, 0, _MSG_NewCharacterFail);

			pUser[conn].Mode = USER_CHARWAIT;
			pUser[conn].WaitDB = false;

		} break;
#pragma endregion
#pragma region _MSG_DBCNFCharacterLogin
		case _MSG_DBCNFCharacterLogin:
		{
			MSG_CNFCharacterLogin* m = (MSG_CNFCharacterLogin*)Msg;


			MSG_CNFClientCharacterLogin sm;

			memmove_s(&sm, sizeof(MSG_CNFClientCharacterLogin), m, sizeof(MSG_CNFClientCharacterLogin));

			if (conn == 0)
			{
				SystemLog("-system", "-", 0, "CNFCharLogin Crack Log");
				CloseUser(conn);

				break; // return; ?
			}

			int i;

			for (i = 0; i < MAX_EQUIP; i++)
			{
				STRUCT_ITEM* tempsour = &sm.mob.Equip[i];

				if (tempsour->sIndex > 0 && tempsour->sIndex < MAX_ITEMLIST)
				{
					int nPos = g_pItemList[tempsour->sIndex].nPos;

					if (nPos == 64 || nPos == 192)
					{
						if (tempsour->stEffect[0].cEffect == EF_DAMAGE2 || tempsour->stEffect[0].cEffect == EF_DAMAGEADD)
							tempsour->stEffect[0].cEffect = EF_DAMAGE;

						if (tempsour->stEffect[1].cEffect == EF_DAMAGE2 || tempsour->stEffect[1].cEffect == EF_DAMAGEADD)
							tempsour->stEffect[1].cEffect = EF_DAMAGE;

						if (tempsour->stEffect[2].cEffect == EF_DAMAGE2 || tempsour->stEffect[2].cEffect == EF_DAMAGEADD)
							tempsour->stEffect[2].cEffect = EF_DAMAGE;
					}
				}
			}

			for (i = 0; i < MAX_CARRY - 1; i++)
			{
				STRUCT_ITEM* tempsour = &sm.mob.Carry[i];

				if (tempsour->sIndex > 0 && tempsour->sIndex < MAX_ITEMLIST)
				{
					int nPos = g_pItemList[tempsour->sIndex].nPos;

					if (nPos == 64 || nPos == 192)
					{
						if (tempsour->stEffect[0].cEffect == EF_DAMAGE2 || tempsour->stEffect[0].cEffect == EF_DAMAGEADD)
							tempsour->stEffect[0].cEffect = EF_DAMAGE;

						if (tempsour->stEffect[1].cEffect == EF_DAMAGE2 || tempsour->stEffect[1].cEffect == EF_DAMAGEADD)
							tempsour->stEffect[1].cEffect = EF_DAMAGE;

						if (tempsour->stEffect[2].cEffect == EF_DAMAGE2 || tempsour->stEffect[2].cEffect == EF_DAMAGEADD)
							tempsour->stEffect[2].cEffect = EF_DAMAGE;
					}
				}
			}

			if (evDelete)
			{
				for (int j = 0; j < MAX_CARRY - 1; j++)
				{
					if (sm.mob.Carry[j].sIndex >= 470 && sm.mob.Carry[j].sIndex <= 500)
						sm.mob.Carry[j].sIndex = 0;
				}
			}
			//m->mobExtra.Citizen = pMob[conn].extra.Citizen;

			if (m->mobExtra.ClassMaster == MORTAL)
			{
				m->mob.Equip[0].stEffect[1].cEffect = 98;
				m->mob.Equip[0].stEffect[1].cValue = 0;
				m->mob.Equip[0].stEffect[2].cEffect = 86;
				m->mob.Equip[0].stEffect[2].cValue = m->mob.CurrentScore.Level - 298;
			}
			else if (m->mobExtra.ClassMaster == ARCH)
			{
				m->mob.Equip[0].stEffect[1].cEffect = 98;
				m->mob.Equip[0].stEffect[1].cValue = 0;
				m->mob.Equip[0].stEffect[2].cEffect = 86;


				if (pMob[conn].extra.QuestInfo.Arch.MortalSlot >= 0 && pMob[conn].extra.QuestInfo.Arch.MortalSlot < 3)
					m->mob.Equip[0].stEffect[2].cValue = pUser[conn].SelChar.Score[pMob[conn].extra.QuestInfo.Arch.MortalSlot].Level - 299;
				else
					m->mob.Equip[0].stEffect[2].cValue = 99;

				/*printf("mSlot %d mLevel %d value %d\n", pMob[conn].extra.QuestInfo.Arch.MortalSlot,
					pUser[conn].SelChar.Score[pMob[conn].extra.QuestInfo.Arch.MortalSlot].Level,
					m->mob.Equip[0].stEffect[2].cValue
				);*/
			}
			else if (m->mobExtra.ClassMaster == CELESTIAL || m->mobExtra.ClassMaster == SCELESTIAL || m->mobExtra.ClassMaster == CELESTIALCS)
			{
				m->mob.Equip[0].stEffect[1].cEffect = 98;
				m->mob.Equip[0].stEffect[1].cValue = 3;
				m->mob.Equip[0].stEffect[2].cEffect = 86;
				m->mob.Equip[0].stEffect[2].cValue = m->mob.CurrentScore.Level - 298;
			}


			pUser[conn].Donate = m->Donate;
			pUser[conn].Honra = m->Honra;

			for (int i = 0; i < 50; i++) {
				pUser[conn].Keys[i] = m->Keys[i];
			}

			for (int i = 0; i < 4; i++) {
				for (int y = 0; y < 2; y++) {
					memcpy(&pUser[conn].Joias[i][y], &m->Joias[i][y], sizeof(STRUCT_ITEM));
				}
			}

			pUser[conn].GemaX = m->GemaX;
			pUser[conn].GemaY = m->GemaY;

			if (m->mob.CurrentScore.Hp <= 0)
				m->mob.CurrentScore.Hp = 2;

			pMob[conn].MOB = m->mob;
			pUser[conn].Message = 0;
			pUser[conn].UseItemTime = 0;
			pUser[conn].PotionTime = 0;
			pMob[conn].LastReqParty = 0;
			pMob[conn].ProcessorCounter = 1;
			//pMob[conn].QuestFlag = 0;
			pMob[conn].MissPlayer = 0;
			pMob[conn].DivineBlessing = 0;
			pMob[conn].RateRegen = 0;
			pMob[conn].sPremioNovato[0] = ' ';
			pUser[conn].Ingame.MobDonateStore = FALSE;
			pUser[conn].Ingame.CheckPista = FALSE;
			pUser[conn].Ingame.CheckPesa = FALSE;
			pUser[conn].Ingame.CheckAgua = FALSE;
			pMob[conn].extra.EMPTY[3] = 0;
			pMob[conn].JoiaOn = FALSE;
			//memset(&pMob[conn].Evocations, 0, sizeof(pMob[conn].Evocations));
			memmove_s(&pMob[conn].extra, sizeof(STRUCT_MOBEXTRA), &m->mobExtra, sizeof(STRUCT_MOBEXTRA));

			for (int q = 0; q < MAX_ITEM_REBUY; q++)
			{
				memset(&pMob[conn].Rebuy[q].Item, 0, sizeof(STRUCT_ITEM));
				pMob[conn].Rebuy[q].Price = 0;
				pMob[conn].Rebuy[q].Ticks = 0;
			}

			if (m->mob.Guild)
				pMob[conn].extra.Citizen = GuildInfo[m->mob.Guild].Citizen;

			pMob[conn].MOB.Equip[0].stEffect[2].cEffect = 28;
			pMob[conn].MOB.Equip[0].stEffect[2].cValue = pMob[conn].extra.Citizen;

			memmove_s(pUser[conn].CharShortSkill, 16, m->ShortSkill, 16);

			memmove_s(pMob[conn].Affect, sizeof(m->affect), m->affect, sizeof(m->affect));

			pMob[conn].MaxCarry = 30;

			if (pMob[conn].MOB.Carry[60].sIndex == 3467)
				pMob[conn].MaxCarry += 15;

			if (pMob[conn].MOB.Carry[61].sIndex == 3467)
				pMob[conn].MaxCarry += 15;

			for (int c = 0; c < MAX_AFFECT; c++)
			{
				if (pMob[conn].Affect[c].Type != 33)
				{
					if ((pMob[conn].MOB.Equip[0].sIndex == 316 || pMob[conn].MOB.Equip[0].sIndex == 317 || pMob[conn].MOB.Equip[0].sIndex == 297 ||
						pMob[conn].MOB.Equip[0].sIndex == 202 || pMob[conn].MOB.Equip[0].sIndex == 297 || pMob[conn].MOB.Equip[0].sIndex == 209 ||
						pMob[conn].MOB.Equip[0].sIndex == 212 || pMob[conn].MOB.Equip[0].sIndex == 230 || pMob[conn].MOB.Equip[0].sIndex == 228))
						pMob[conn].MOB.Equip[0].sIndex = pMob[conn].extra.ClassMaster == MORTAL ? pMob[conn].extra.MortalFace : pMob[conn].extra.MortalFace + 5 + pMob[conn].MOB.Class;
				}
			}
			strncpy(pMob[conn].Tab, "", sizeof(pMob[conn].Tab));

			strncpy(pMob[conn].Snd, "", sizeof(pMob[conn].Snd));

			memset(sm.Unk2, 0, sizeof(sm.Unk2));

			pMob[conn].MOB.BaseScore.Merchant = 0;

			if (pMob[conn].extra.ClassMaster == ARCH && pMob[conn].extra.QuestInfo.Arch.MortalSlot >= 0 && pMob[conn].extra.QuestInfo.Arch.MortalSlot < 3)
				pMob[conn].extra.QuestInfo.Arch.MortalLevel = pUser[conn].SelChar.Score[pMob[conn].extra.QuestInfo.Arch.MortalSlot].Level - 299;

			else
				pMob[conn].extra.QuestInfo.Arch.MortalLevel = 99;


			BASE_GetHpMp(&pMob[conn].MOB, &pMob[conn].extra);

			pMob[conn].GetCurrentScore(conn);

			GetGuild(conn);

			//	pMob[conn].extra.Citizen = m->mobExtra.Citizen;

			BASE_GetBonusSkillPoint(&pMob[conn].MOB, &pMob[conn].extra);
			BASE_GetBonusScorePoint(&pMob[conn].MOB, &pMob[conn].extra);

			pMob[conn].Mode = MOB_USER;

			sm.mob = pMob[conn].MOB;
			sm.mob.SPX = sm.mob.SPX;
			sm.mob.SPY = sm.mob.SPY;
			sm.Type = _MSG_CNFCharacterLogin;

			if (NewbieEventServer == 1)
				sm.ID = ESCENE_FIELD + 1;
			else
				sm.ID = ESCENE_FIELD;

			sm.PosX = sm.mob.SPX;
			sm.PosY = sm.mob.SPY;
			sm.ClientID = conn;
			sm.Weather = CurrentWeather;

			memset(sm.Unk2, 0, sizeof(sm.Unk2));
			memset(sm.Unk, 0, sizeof(sm.Unk));
			memset(sm.unk, 0, sizeof(sm.unk));

			strncpy(&sm.Unk2[448], pUser[conn].AccountName, 12);

			pMob[conn].LastTime = CurrentTime;
			pMob[conn].LastX = pMob[conn].TargetX = sm.mob.SPX;
			pMob[conn].LastY = pMob[conn].TargetY = sm.mob.SPY;

			if (pMob[conn].MOB.Carry[KILL_MARK].sIndex == 0)
			{
				memset(&pMob[conn].MOB.Carry[KILL_MARK], 0, sizeof(STRUCT_ITEM));

				pMob[conn].MOB.Carry[KILL_MARK].sIndex = 547;
				pMob[conn].MOB.Carry[KILL_MARK].stEffect[0].cEffect = EF_CURKILL;
				pMob[conn].MOB.Carry[KILL_MARK].stEffect[1].cEffect = EF_LTOTKILL;
				pMob[conn].MOB.Carry[KILL_MARK].stEffect[2].cEffect = EF_HTOTKILL;
			}

			pUser[conn].Unk_2708 = 0;
			pUser[conn].LastChat[0] = 0;
			pUser[conn].Slot = m->Slot;
			pUser[conn].NumError = 0;
			pUser[conn].LastMove = 0;
			pUser[conn].LastAction = _MSG_Action;
			pUser[conn].LastActionTick = SKIPCHECKTICK;
			pUser[conn].LastAttack = 0;
			pUser[conn].LastAttackTick = SKIPCHECKTICK;
			pUser[conn].LastIllusionTick = SKIPCHECKTICK;
			pUser[conn].RankingTarget = 0;
			pUser[conn].RankingType = 0;
			pUser[conn].CastleStatus = 0;

			memset(pUser[conn].Unk9, -1, sizeof(pUser[conn].Unk9));
			memset(&pUser[conn].Trade, 0, sizeof(pUser[conn].Trade));

			int k;

			for (k = 0; k < MAX_TRADE; k++)
				pUser[conn].Trade.InvenPos[k] = -1;

			for (k = 0; k < MAX_SLOT_LEILAO_AUTOTRADE; k++)
				pMob[conn].AutoTrade.List[k].SlotBank = -1;


			pUser[conn].TradeMode = 0;
			pUser[conn].PKMode = 0;

			int tx = sm.PosX;
			int ty = sm.PosY;

			int CityID = (pMob[conn].MOB.Merchant & 0xC0) >> 6;

			tx = g_pGuildZone[CityID].CitySpawnX + rand() % 15;
			ty = g_pGuildZone[CityID].CitySpawnY + rand() % 15;

			int MobGuild = pMob[conn].MOB.Guild;
			int MobCLS = pMob[conn].MOB.Class;

			if (MobCLS < 0 || MobCLS > MAX_CLASS - 1)
			{
				//Log("err,login Undefined class", pUser[conn].AccountName, pUser[conn].IP);

				CloseUser(conn);

				break; // TODO: compile and check if it's break or return
			}

			int n;

			for (n = 0; n < MAX_GUILDZONE; n++)
			{
				if (MobGuild != 0 && MobGuild == g_pGuildZone[n].ChargeGuild)
				{
					tx = g_pGuildZone[n].GuildSpawnX;
					ty = g_pGuildZone[n].GuildSpawnY;

					break;
				}
			}

			if (Limitadordeconexoes(pUser[conn].MacAddress) >= 10)
			{
				CloseUser(conn);//força a saida da conn
				break;
			}

			if (pMob[conn].MOB.BaseScore.Level < FREEEXP && pMob[conn].extra.ClassMaster == MORTAL)
			{
				tx = 2112 + rand() % 5 - 2;
				ty = 2042 + rand() % 5 - 2;
			}

			int ret = GetEmptyMobGrid(conn, &tx, &ty);

			if (ret == 0)
			{
				//Log("Can't start can't get mobgrid", pUser[conn].AccountName, pUser[conn].IP);

				CloseUser(conn);

				break; // TODO: compile and check if it's break or return
			}

			sm.PosX = tx;
			sm.PosY = ty;

			pMob[conn].TargetX = tx;
			pMob[conn].LastX = tx;
			pMob[conn].TargetY = ty;
			pMob[conn].LastY = ty;

			pUser[conn].Mode = USER_PLAY;
			pUser[conn].Trade.OpponentID = 0;

			pMob[conn].GetCurrentScore(conn);

			pMob[conn].GuildDisable = 0;

			if (pMob[conn].MOB.Guild)
			{
				int Group = ServerGroup;
				int Server = pMob[conn].MOB.Guild / MAX_GUILD;
				int usGuild = pMob[conn].MOB.Guild & MAX_GUILD - 1;

				if (pMob[conn].MOB.Clan != GuildInfo[usGuild].Clan)
				{
					int mantle = pMob[conn].MOB.Equip[15].sIndex;

					if (GuildInfo[usGuild].Clan == 7)
					{
						if (m->mobExtra.ClassMaster == CELESTIAL || m->mobExtra.ClassMaster == SCELESTIAL || m->mobExtra.ClassMaster == CELESTIALCS || m->mobExtra.ClassMaster == HARDCORE || m->mobExtra.ClassMaster == HARDCOREA || m->mobExtra.ClassMaster == HARDCORECS || m->mobExtra.ClassMaster == SHARDCORE)
							pMob[conn].MOB.Equip[15].sIndex = 3197;

						else if (mantle >= 543 && mantle <= 544)
							pMob[conn].MOB.Equip[15].sIndex = 543;

						else if (mantle >= 545 && mantle <= 546)
							pMob[conn].MOB.Equip[15].sIndex = 545;

						else if (mantle == 548)
							pMob[conn].MOB.Equip[15].sIndex = 543;

						else if (mantle == 549)
							pMob[conn].MOB.Equip[15].sIndex = 545;

						else if (mantle >= 3191 && mantle <= 3193)
							pMob[conn].MOB.Equip[15].sIndex = 3191;

						else if (mantle >= 3194 && mantle <= 3196)
							pMob[conn].MOB.Equip[15].sIndex = 3194;

					}

					else if (GuildInfo[usGuild].Clan == 8)
					{
						if (m->mobExtra.ClassMaster == CELESTIAL || m->mobExtra.ClassMaster == SCELESTIAL || m->mobExtra.ClassMaster == CELESTIALCS || m->mobExtra.ClassMaster == HARDCORE || m->mobExtra.ClassMaster == HARDCOREA || m->mobExtra.ClassMaster == HARDCORECS || m->mobExtra.ClassMaster == SHARDCORE)
							pMob[conn].MOB.Equip[15].sIndex = 3198;

						else if (mantle >= 543 && mantle <= 544)
							pMob[conn].MOB.Equip[15].sIndex = 544;

						else if (mantle >= 545 && mantle <= 546)
							pMob[conn].MOB.Equip[15].sIndex = 546;

						else if (mantle == 548)
							pMob[conn].MOB.Equip[15].sIndex = 544;

						else if (mantle == 549)
							pMob[conn].MOB.Equip[15].sIndex = 546;

						else if (mantle >= 3191 && mantle <= 3193)
							pMob[conn].MOB.Equip[15].sIndex = 3192;

						else if (mantle >= 3194 && mantle <= 3196)
							pMob[conn].MOB.Equip[15].sIndex = 3195;
					}

					memmove_s(&sm.mob.Equip[15], sizeof(STRUCT_ITEM), &pMob[conn].MOB.Equip[15], sizeof(STRUCT_ITEM));
				}
			}

			char tt[512];

			pUser[conn].cProgress = 0;
			pUser[conn].ReqHp = pMob[conn].MOB.CurrentScore.Hp;
			pUser[conn].ReqMp = pMob[conn].MOB.CurrentScore.Mp;
			pUser[conn].Unk_2688 = 0;

			pUser[conn].cSock.SendOneMessage((char*)&sm, sizeof(MSG_CNFClientCharacterLogin));

			///////////////////////////////////////////////
			// Packet that will be sent to other players //
			///////////////////////////////////////////////

			MSG_CreateMob sm2;

			GetCreateMob(conn, &sm2);

			sm2.CreateType = 2;

			pMobGrid[sm.PosY][sm.PosX] = conn;

			GridMulticast(sm.PosX, sm.PosY, (MSG_STANDARD*)&sm2, 0);

			for (int i = 0; i < pMob[conn].MaxCarry; i++)
			{
				if ((pMob[conn].MOB.Carry[i].sIndex < 0) || (pMob[conn].MOB.Carry[i].sIndex > MAX_ITEMLIST))
				{
					
					snprintf(temp, sizeof(temp), " $s Slots Desbugados Inventario", pMob[conn].MOB.MobName);
					SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);
					BASE_ClearItem(&pMob[conn].MOB.Carry[i]);
					SendItem(conn, ITEM_PLACE_CARRY, i, &pMob[conn].MOB.Carry[i]);
					SendCarry(conn);
				}
			}
			for (int i = 0; i < MAX_CARGO; i++)
			{
				if ((pUser[conn].Cargo[i].sIndex < 0) || (pUser[conn].Cargo[i].sIndex > MAX_ITEMLIST))
				{
					
					snprintf(temp, sizeof(temp), " $s Slots Desbugados Bau", pMob[conn].MOB.MobName);
					SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);
					BASE_ClearItem(&pUser[conn].Cargo[i]);
					SendItem(conn, ITEM_PLACE_CARRY, i, &pUser[conn].Cargo[i]);
				}
			}

			SendPKInfo(conn, conn);
			SendGridMob(conn);

			if (pMob[n].MOB.CurrentScore.Level >= 999)
				pUser[n].Admin = 1;

			MountProcess(conn, 0);
			SendWarInfo(conn, g_pGuildZone[4].Clan);

			if (CastleState != 0)
				SendClientSignalParm(conn, ESCENE_FIELD, _MSG_SendCastleState, CastleState);

			ClearCrown(conn);

			int curlvl = pMob[conn].MOB.BaseScore.Level;

			int max_level = 0;

			if (pMob[conn].extra.ClassMaster == MORTAL || pMob[conn].extra.ClassMaster == ARCH)
				max_level = MAX_LEVEL;

			else if (pMob[conn].extra.ClassMaster == CELESTIAL || pMob[conn].extra.ClassMaster == SCELESTIAL || pMob[conn].extra.ClassMaster == CELESTIALCS ||
				pMob[conn].extra.ClassMaster == HARDCORE || pMob[conn].extra.ClassMaster == HARDCOREA || pMob[conn].extra.ClassMaster == HARDCORECS || pMob[conn].extra.ClassMaster == SHARDCORE)
				max_level = MAX_CLEVEL;


			if (curlvl < max_level - 1)
			{
				long long exp = pMob[conn].MOB.Exp;
				long long curexp = max_level == MAX_LEVEL ? g_pNextLevel[curlvl] : g_pNextLevel_2[curlvl];
				long long nextexp = max_level == MAX_LEVEL ? g_pNextLevel[curlvl + 1] : g_pNextLevel_2[curlvl + 1];
				long long deltaexp = (nextexp - curexp) / 4;
				long long Segment1 = curexp + deltaexp;
				long long Segment2 = curexp + (deltaexp * 2);
				long long Segment3 = curexp + (deltaexp * 3);
				long long Segment4 = nextexp;

				if (exp > Segment3)
					pMob[conn].Segment = 3;
				else if (exp > Segment2)
					pMob[conn].Segment = 2;
				else if (exp > Segment1)
					pMob[conn].Segment = 1;
				else
					pMob[conn].Segment = 0;

				pUser[conn].Unk_2736 = 0;

				if (pMob[conn].MOB.BaseScore.Level >= FREEEXP)
				{
					if (CHARSELBILL == 0)
						SendBilling(conn, pUser[conn].AccountName, 1, 1);
				}

			}

			if (pMob[conn].extra.Citizen != 0)
			{
				snprintf(tt, sizeof(tt), g_pMessageStringTable[_DN_TOWNSPEOPLE], pMob[conn].CitizenDrop);
				SendClientMessage(conn, tt);
			}

			/*if (KefraLive != 0)
			{
				BASE_GetGuildName(ServerGroup, KefraLive, KefraKiller);
				SendMsgExp(conn, strFmt(g_pMessageStringTable[_SN_End_Khepra], KefraKiller), NewWhite, FALSE);

				if (DOUBLEMODE == 1) {
					SendMsgExp(conn, strFmt("Double EXP [ATIVADO]"), Speak, FALSE);
				}
				if (DOUBLEMODE == 0) {
					SendMsgExp(conn, strFmt("Double EXP [DESATIVADO]"), Orange, FALSE);
				}
			}

			if (KefraLive == 0) {
				SendMsgExp(conn, "Kefra está Vivo!", Orange, FALSE);
			}*/

			/*if (RvRBonus == pMob[conn].MOB.Clan && RvRBonus)
			{
				
				if (pMob[conn].MOB.Clan == 8)
					snprintf(temp, sizeof(temp), g_pMessageStringTable[_SN_KINGDOMWAR_DROP_], g_pMessageStringTable[_NN_KINGDOM_RED]);

				else if (pMob[conn].MOB.Clan == 7)
					snprintf(temp, sizeof(temp), g_pMessageStringTable[_SN_KINGDOMWAR_DROP_], g_pMessageStringTable[_NN_KINGDOM_BLUE]);

				SendClientMessage(conn, temp);
			}

			if (pMob[conn].MOB.Guild != 0)
			{
				if (AvisarGuild[pMob[conn].MOB.Guild].Aviso[0] != '\0' && AvisarGuild[pMob[conn].MOB.Guild].Aviso[0] != ' ')
				{
					SendClientMessage(conn, strFmt("[Mensagem da Guild]> %s", AvisarGuild[pMob[conn].MOB.Guild].Aviso));
				}
			}*/


			// CORRIGIR BO RETIRAR TODOS OS ITENS DENTRO DO SV AQUI

			//bool Reboot = false;
			//for (int i = 0; i < 16; i++) {
			//	if (pMob[conn].MOB.Equip[i].sIndex == 632 || pMob[conn].MOB.Equip[i].sIndex == 671 || pMob[conn].MOB.Equip[i].sIndex == 670) // ABS - ESPECTRAL - CONCENTRAÇÃO
			//	{

			//		memset(&pMob[conn].MOB.Equip[i], 0x0, sizeof(STRUCT_ITEM));
			//		SendCarry(conn);
			//		SendClientMessage(conn, "Seu Item foi removido!");
			//		Reboot = true;
			//	}
			//}

			//for (int i = 0; i < 64; i++) {
			//	if (pMob[conn].MOB.Carry[i].sIndex == 632 || pMob[conn].MOB.Carry[i].sIndex == 671 || pMob[conn].MOB.Carry[i].sIndex == 670) // ABS - ESPECTRAL - CONCENTRAÇÃO
			//	{

			//		memset(&pMob[conn].MOB.Carry[i], 0x0, sizeof(STRUCT_ITEM));
			//		SendCarry(conn);
			//		SendClientMessage(conn, "Seu Item foi removido!");
			//		Reboot = true;
			//	}
			//}
			//for (int i = 0; i < 128; i++) {
			//	if (pUser[conn].Cargo[i].sIndex == 632 || pUser[conn].Cargo[i].sIndex == 671 || pUser[conn].Cargo[i].sIndex == 670) // ABS - ESPECTRAL - CONCENTRAÇÃO
			//	{

			//		memset(&pUser[conn].Cargo[i], 0x0, sizeof(STRUCT_ITEM));
			//		SendCarry(conn);
			//		SendClientMessage(conn, "Seu Item foi removido!");
			//		Reboot = true;
			//	}
			//}
			//if (Reboot == true) {
			//	SaveUser(conn, 0);
			//	CharLogOut(conn);
			//}

			// CHAR LOGANDO NO SERVIDOR
						
			//MailItem(conn);
			SendScore(conn);
			SendEtc(conn);
			UpdateDonate(conn);
			doRanking(conn);
			SendKeys(conn);
			SendItemLevel(conn);
			SendJoias(conn);
			goResetLeilao(conn); 
			SendClientSignalParm(conn, 0x7530, pLeilaoStatus, 0);// cliente avisado que a loja foi fechada   
			UpdateLeilaoSaldo(conn);

			//Retira divinas duplas
			int div = 0;
			for (int i = 0; i < MAX_AFFECT; i++)
			{
				if (pMob[conn].Affect[i].Type == 34)
				{
					if (div >= 1) {
						pMob[conn].Affect[i].Type = 0;
						pMob[conn].Affect[i].Level = 0;
						pMob[conn].Affect[i].Time = 0;
						pMob[conn].Affect[i].Value = 0;

						pMob[conn].GetCurrentScore(conn);
						SendScore(conn);
						CharLogOut(conn);
					}
					div++;					
				}
			}			


		} break;
#pragma endregion
#pragma region _MSG_DBCharacterLoginFail
		case _MSG_DBCharacterLoginFail:
		{
			MSG_STANDARD* m = (MSG_STANDARD*)Msg;

			m->ID = ESCENE_FIELD;

			SendClientSignal(conn, 0, _MSG_CharacterLoginFail);

			pUser[conn].Mode = USER_CHARWAIT;
			SystemLog("-system", "-", 0, "CharLoginFail Crack Log");

		} break;
#pragma endregion
#pragma region _MSG_DBMessageBoxOk
		case _MSG_DBMessageBoxOk:
		{
			MSG_MessageBoxOk* m = (MSG_MessageBoxOk*)Msg;

			m->Type = _MSG_MessageBoxOk;
			m->ID = 0;

			pUser[conn].cSock.SendOneMessage((char*)m, sizeof(MSG_MessageBoxOk));

		} break;
#pragma endregion
#pragma region _MSG_DBAlreadyPlaying
		case _MSG_DBAlreadyPlaying:
		{
			MSG_STANDARD* m = (MSG_STANDARD*)Msg;

			SendClientSignal(m->ID, ESCENE_FIELD + 2, _MSG_AlreadyPlaying);

			pUser[m->ID].cSock.SendMessageA();

			CloseUser(conn);

		} break;
#pragma endregion
#pragma region _MSG_DBStillPlaying
		case _MSG_DBStillPlaying:
		{
			MSG_STANDARD* m = (MSG_STANDARD*)Msg;

			SendClientSignal(m->ID, ESCENE_FIELD + 2, _MSG_StillPlaying);

			pUser[m->ID].cSock.SendMessageA();

			CloseUser(conn);

		} break;
#pragma endregion
#pragma region _MSG_DBSavingQuit
		case _MSG_DBSavingQuit:
		{
			MSG_DBSavingQuit* m = (MSG_DBSavingQuit*)Msg;

			if (m->ID <= 0 || m->ID >= MAX_USER)
			{
				SystemLog("-system", "-", 0, "err,DBsavingquit - id range");

				break;
			}

			if (pUser[m->ID].Mode != USER_PLAY && pUser[m->ID].Mode != USER_SAVING4QUIT)
			{
				MSG_STANDARD sm;

				sm.Type = _MSG_DBNoNeedSave;
				sm.ID = conn;

				DBServerSocket.SendOneMessage((char*)&sm, sizeof(MSG_STANDARD));
			}

			if (pUser[m->ID].Mode == USER_PLAY || pUser[m->ID].Mode == USER_CHARWAIT)
			{
				if (m->Mode == 0)
					SendClientMessage(m->ID, g_pMessageStringTable[_NN_Your_Account_From_Others]);
				else if (m->Mode == 1)
					SendClientMessage(m->ID, g_pMessageStringTable[_NN_Disabled_Account]);

				pUser[conn].cSock.SendMessage();
			}

			CloseUser(m->ID);
		} break;
#pragma endregion
#pragma region _MSG_DBCNFAccountLogOut
		case _MSG_DBCNFAccountLogOut:
		{
			MSG_STANDARD* m = (MSG_STANDARD*)Msg;
			
			snprintf(temp, sizeof(temp), "etc,charlogout conn:%d name:%s", conn, pMob[conn].MOB.MobName);
			SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);

			pMob[conn].Mode = MOB_EMPTY;
			pUser[conn].Mode = USER_ACCEPT;
			pUser[conn].Ingame.MobDonateStore = FALSE;
			pUser[conn].Ingame.CheckPista = FALSE;
			pUser[conn].Ingame.CheckPesa = FALSE;
			pUser[conn].Ingame.CheckAgua = FALSE;
			pMob[conn].JoiaOn = FALSE;
			CloseUser(conn);
		} break;
#pragma endregion

#pragma region _MSG_DBCNFArchCharacterSucess
		case _MSG_DBCNFArchCharacterSucess:
		{
			MSG_STANDARDPARM* m = (MSG_STANDARDPARM*)Msg;

			SendClientMessage(conn, g_pMessageStringTable[_NN_My_King_Bless1]);

			memset(&pMob[conn].MOB.Equip[10], 0, sizeof(STRUCT_ITEM));
			SendItem(conn, ITEM_PLACE_EQUIP, 10, &pMob[conn].MOB.Equip[10]);

			memset(&pMob[conn].MOB.Equip[11], 0, sizeof(STRUCT_ITEM));
			SendItem(conn, ITEM_PLACE_EQUIP, 11, &pMob[conn].MOB.Equip[11]);

			SaveUser(conn, 0);

			CharLogOut(conn);

			SendClientSignalParm(conn, ESCENE_FIELD, _MSG_SendArchEffect, m->Parm);
			
			snprintf(temp, sizeof(temp), "etc,arch create name:%s slot:%d", pMob[conn].MOB.MobName, m->Parm);
			SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);
		} break;
#pragma endregion
#pragma region _MSG_DBCNFArchCharacterFail
		case _MSG_DBCNFArchCharacterFail:
		{
			pMob[conn].Mode = MOB_USER;
			SendClientMessage(conn, g_pMessageStringTable[_NN_NoEmptySlot]);
			break;
		} break;
#pragma endregion

#pragma region _MSG_DBSendDonate
		case _MSG_DBSendDonate:
		{
			MSG_DBSendDonate* m = (MSG_DBSendDonate*)Msg;

			if (pUser[conn].Mode < USER_CHARWAIT)
			{

				SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, "_fail_play_ charwiat mode");

				break;
			}

			if (strcmp(pUser[conn].AccountName, m->Account) != 0)
			{
				SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, "_fail_name_");

				break;
			}
			pUser[conn].Donate += m->Donate;
			//pUser[conn].Honra += m->Honra; 

			SendClientMessage(conn, g_pMessageStringTable[_NN_Cash_ChargeOk]);
			SendEtc(conn);
			m->Result = 0;

			DBServerSocket.SendOneMessage((char*)m, m->Size);

			SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, strFmt("recv, %d donate", m->Donate));

		} break;
#pragma endregion

#pragma region _MSG_CNFDBCapsuleInfo
		case _MSG_CNFDBCapsuleInfo:
		{
			pUser[conn].cSock.SendOneMessage((char*)Msg, sizeof(MSG_CNFDBCapsuleInfo));
		} break;
#pragma endregion
#pragma region _MSG_DBCNFCapsuleCharacterFail
		case _MSG_DBCNFCapsuleCharacterFail:
		{
			SendCarry(conn);
			SendClientMessage(conn, g_pMessageStringTable[_NN_NoEmptySlot]);
		} break;
#pragma endregion
#pragma region _MSG_DBCNFCapsuleCharacterFail2
		case _MSG_DBCNFCapsuleCharacterFail2:
		{
			SendCarry(conn);
			SendClientMessage(conn, g_pMessageStringTable[_NN_CANT_USE_ID]);
		} break;
#pragma endregion
#pragma region _MSG_DBCNFCapsuleSucess
		case _MSG_DBCNFCapsuleSucess:
		{
			memset(&pMob[conn].MOB, 0, sizeof(STRUCT_MOB));
			memset(&pMob[conn].extra, 0, sizeof(STRUCT_MOBEXTRA));
			SaveUser(conn, 1);
		} break;
#pragma endregion
#pragma region _MSG_GrindRankingData
		case _MSG_GrindRankingData:
		{
			/*
			Some change have happened in the ranking, notify the client.
			*/
			MSG_SendExpRanking* m = (MSG_SendExpRanking*)Msg;

			/* In the char sel Mode (0xC) the tmsrv still don't have the player data, so ignore the playerRank.Name check */
			if (pUser[conn].Mode == USER_PLAY && m->PlayerRank.Name[0] != '\0' && !strcmp(pMob[conn].MOB.MobName, m->PlayerRank.Name))
				pUser[conn].cSock.SendOneMessage((char*)m, sizeof(MSG_SendExpRanking));

		} break;
#pragma endregion
#pragma region _MSG_DBClientMessage
		case _MSG_DBClientMessage:
		{
			MSG_DBClientMessage* m = (MSG_DBClientMessage*)Msg;

			SendClientMessage(conn, m->String);
		} break;
#pragma endregion
#pragma region _MSG_DBServerSend1
		case _MSG_DBServerSend1:
		{
			MSG_STANDARDPARM* m = (MSG_STANDARDPARM*)Msg;

			m->ID = ESCENE_FIELD;

			if (!pUser[conn].cSock.SendOneMessage((char*)m, sizeof(MSG_STANDARDPARM)))
				CloseUser(conn);

		} break;
#pragma endregion
#pragma region _MSG_DBCNFServerChange
		case _MSG_DBCNFServerChange:
		{
			MSG_DBCNFServerChange* m = (MSG_DBCNFServerChange*)Msg;

			pUser[conn].cSock.SendOneMessage((char*)m, sizeof(MSG_DBCNFServerChange));
			CloseUser(conn);
		} break;
#pragma endregion

		}
	}
#pragma endregion
}

# -------------------- ProcessDBMessage.h --------------------

/*
*   Copyright (C) {2015}  {Victor Klafke, Charles TheHouse}
*
*   This program is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program.  If not, see [http://www.gnu.org/licenses/].
*
*   Contact at: victor.klafke@ecomp.ufsm.br
*/
#pragma once

#include <windows.h>
#include <windowsx.h>
#include <stdlib.h>
#include <stdio.h> 
#include <fcntl.h>
#include <io.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/timeb.h>
#include <string.h>        
#include <time.h>

#include "..\Basedef.h"
#include "..\CPSock.h"

#include "CItem.h"
#include "CMob.h"
#include "CUser.h"
#include "CNPCGene.h"


void  ProcessDBMessage(int conn, char *pMsg);

# -------------------- ProcessSecMinTimer.cpp --------------------


#include <Windows.h>
#include <stdio.h>
#include <fcntl.h>
#include <time.h>
#include <math.h>
#include <io.h>
#include <errno.h>

#include "..\Basedef.h"
#include "..\CPSock.h"
#include "..\ItemEffect.h"
#include "Language.h"

#include "CItem.h"
#include "Server.h"
#include "GetFunc.h"
#include "SendFunc.h"
#include "ProcessClientMessage.h"
#include "ProcessDBMessage.h"
#include "CWarTower.h"
#include "IPControl.h"
#include "Functions.h"

void ProcessSecTimer()
{
	if (ServerDown == 120) // two minutes untill the server closes
	{
		if (BILLING != 0)
		{
			_AUTH_GAME Unk;

			memset(&Unk, 0, 196);

			SendBilling2(&Unk, 4);

			BILLING = 0;
		}

		while (TRUE)
		{
			if (UserCount >= MAX_USER)
			{
				SystemLog("-system", "-", 0, "server down complete");

				if (hFont != 0)
				{
					DeleteObject(hFont);

					hFont = NULL;
				}

				PostQuitMessage(NULL);

				return;
			}

			if (pUser[UserCount].Mode == USER_EMPTY)
			{
				UserCount++;

				continue;
			}

			break;
		}

		pUser[UserCount].AccountName[ACCOUNTNAME_LENGTH - 1] = 0;
		pUser[UserCount].AccountName[ACCOUNTNAME_LENGTH - 2] = 0;


		CloseUser(UserCount);

		UserCount++;

		return;
	}

	if (ServerDown > -1000)
	{
		if (ServerDown <= 0)
		{
			ServerDown++;

			goto lbl_PST1;
		}

		if (ServerDown % 20 == 1)
		{
			int messageId = ServerDown / 20;
			SendNotice(g_pMessageStringTable[messageId + 17]);
		}

		ServerDown++;

		if (ServerDown == 120)
		{
			SetTimer(hWndMain, TIMER_SEC, 200, 0);

			return;
		}
	}

lbl_PST1:

	SecCounter++;

#pragma region Sistema de bloqueio de ip por requisições de conexão.
	for (auto i = 0; i < g_pBlockIP.size(); i++)
	{
		g_pBlockIP[i].countdown--;
		if (g_pBlockIP[i].countdown <= 0)
		{
			g_pBlockIP.erase(g_pBlockIP.begin() + i);
		}
	}
#pragma endregion

	CurrentTime = timeGetTime();

	if (SecCounter % 600 == 0) {
		GerarRecaptcha();
	}

	if (BILLING != 0 && BillCounter > 0 && BillServerSocket.Sock == 0)
	{
		BillCounter--;

		if (BillCounter <= 0)
		{
			CurrentTime = timeGetTime();


			int* pip = (int*)LocalIP;

			int ret = BillServerSocket.ConnectBillServer(BillServerAddress, BillServerPort, *pip, WSA_READBILL);

			CurrentTime = timeGetTime();


			if (ret == 0)
			{

				BILLING = 0;
			}
			else
			{
				_AUTH_GAME Unk;

				memset(&Unk, 0, 196);

				SendBilling2(&Unk, 4);
			}
		}
	}
	else
		BillCounter = 0;

#pragma region Save User
	if (SecCounter % 8 == 0)
	{
		for (int i = 1; i < MAX_USER; i++)
		{
			if (SaveCount >= MAX_USER)
				SaveCount = 1;

			if (pUser[SaveCount].Mode == USER_PLAY && pMob[SaveCount].Mode != MOB_EMPTY)
			{
				if (BILLING == 2 && pUser[SaveCount].Unk_2728 == 1 && pMob[SaveCount].MOB.CurrentScore.Level >= FREEEXP && (g_Hour <= 12 || g_Hour >= 19))
				{
					SendClientMessage(SaveCount, g_pMessageStringTable[_NN_Child_Pay]);

					CharLogOut(SaveCount);

					SaveCount++;

					break;
				}
				else
				{
					SaveUser(SaveCount, 0);

					SaveCount++;

					break;
				}
			}

			SaveCount++;
		}
	}
#pragma endregion
#pragma region User Loop
	for (int bb = 1; bb < MAX_USER; bb++)
	{

		if (pUser[bb].Mode)
		{
			if (pUser[bb].cSock.nSendPosition)
			{
				BOOL bSend = pUser[bb].cSock.SendMessageA();
				if (!bSend)
				{
					
					snprintf(temp, sizeof(temp), "err,send fail close %d/%d %d/%d",
						bb, pUser[bb].cSock.Sock, pUser[bb].cSock.nSendPosition, pUser[bb].cSock.nSentPosition);

					pUser[bb].AccountName[ACCOUNTNAME_LENGTH - 1] = 0;
					pUser[bb].AccountName[ACCOUNTNAME_LENGTH - 2] = 0;

					SystemLog(pUser[bb].AccountName, pUser[bb].MacAddress, pUser[bb].IP, temp);

					CloseUser(bb);
				}
			}
		}

		if (pUser[bb].Mode == USER_PLAY)
			pMob[bb].ProcessorSecTimer();

		/*if(GTorreState == 2) {
			if (pMob[bb].TargetX >= 2452 && pMob[bb].TargetY >= 1854 && pMob[bb].TargetX <= 2542 && pMob[bb].TargetY <= 1919) {
				UpdateGTower(bb);
			}
		}*/
		//Celestial Lv181 dentro da zona do pesadelo
		if ((pMob[bb].TargetX / 128) == 9 && (pMob[bb].TargetY / 128) == 1 || (pMob[bb].TargetX / 128) == 8 && (pMob[bb].TargetY / 128) == 2 || (pMob[bb].TargetX / 128) == 10 && (pMob[bb].TargetY / 128) == 2)
		{
			if ((pMob[bb].extra.ClassMaster == CELESTIAL || pMob[bb].extra.ClassMaster == CELESTIALCS || pMob[bb].extra.ClassMaster == SCELESTIAL) && pMob[bb].MOB.CurrentScore.Level > 199)
				DoRecall(bb);
			//SendClientMessage(bb, "desculpe");
			//return;
		}
		//ANTI CASSINO
		if (((pMob[bb].TargetX) / 128) == 31 && ((pMob[bb].TargetY) / 128) == 31) {
			if (pUser[bb].Admin != 1)
				DoRecall(bb);
		}
		//faz com que quando tire a Fada do Vale vc seja teleportado para fora
#pragma region Vale Perdido
		if (((pMob[bb].TargetX) / 128) == 17 && ((pMob[bb].TargetY) / 128) == 28)
		{
			if (pMob[bb].MOB.Equip[13].sIndex != 3916)
				DoRecall(bb);
		}
#pragma endregion

#pragma region Anti Pulo Lan
		//CHECA O LV DAS QUESTS
		if (pMob[bb].MOB.BaseScore.Level > 115 || pMob[bb].MOB.BaseScore.Level < 39)
		{
			if (pMob[bb].TargetX > 2379 && pMob[bb].TargetY > 2076 &&
				pMob[bb].TargetX < 2426 && pMob[bb].TargetY < 2133)

				ClearAreaQuest(bb, 2379, 2076, 2426, 2133);// Coveiro

			/*if (pMob[bb].QuestFlag && pUser[bb].Mode == USER_PLAY)
				pMob[bb].QuestFlag = 0;*/

		}
		if (pMob[bb].MOB.BaseScore.Level > 190 || pMob[bb].MOB.BaseScore.Level < 115)
		{
			if (pMob[bb].TargetX > 2228 && pMob[bb].TargetY > 1700 &&
				pMob[bb].TargetX < 2257 && pMob[bb].TargetY < 1728)


				ClearAreaQuest(bb, 2228, 1700, 2257, 1728);//Carbuncle  
			/*if (pMob[bb].QuestFlag && pUser[bb].Mode == USER_PLAY)
				pMob[bb].QuestFlag = 0;*/

		}
		if (pMob[bb].MOB.BaseScore.Level > 265 || pMob[bb].MOB.BaseScore.Level < 190)
		{
			if (pMob[bb].TargetX > 459 && pMob[bb].TargetY > 3887 &&
				pMob[bb].TargetX < 497 && pMob[bb].TargetY < 3916)


				ClearAreaQuest(bb, 459, 3887, 497, 3916);//Kaizen  
			/*if (pMob[bb].QuestFlag && pUser[bb].Mode == USER_PLAY)
				pMob[bb].QuestFlag = 0;*/

		}
		if (pMob[bb].MOB.BaseScore.Level > 321 || pMob[bb].MOB.BaseScore.Level < 265)
		{
			if (pMob[bb].TargetX > 658 && pMob[bb].TargetY > 3728 &&
				pMob[bb].TargetX < 703 && pMob[bb].TargetY < 3762)


				ClearAreaQuest(bb, 658, 3728, 703, 3762);//Hidras  
			/*if (pMob[bb].QuestFlag && pUser[bb].Mode == USER_PLAY)
				pMob[bb].QuestFlag = 0;*/

		}
		if (pMob[bb].MOB.BaseScore.Level > 351 || pMob[bb].MOB.BaseScore.Level < 320)
		{
			if (pMob[bb].TargetX > 1312 && pMob[bb].TargetY > 4027 &&
				pMob[bb].TargetX < 1348 && pMob[bb].TargetY < 4055)

				ClearAreaQuest(bb, 1312, 4027, 1348, 4055);//Elfos 
			/*if (pMob[bb].QuestFlag && pUser[bb].Mode == USER_PLAY)
				pMob[bb].QuestFlag = 0;*/
		}
#pragma endregion
		//zona de guilda
		if (pMob[bb].TargetX >= 1020 && pMob[bb].TargetY >= 1916 && pMob[bb].TargetX <= 1286 && pMob[bb].TargetY <= 2178 && pMob[bb].MOB.Guild <= 0)
		{
			SendClientMessage(bb, "Somente para Membros de Guild");
			DoRecall(bb);
		}	

#pragma region Pista de Runas Balrog Portais
		int xv = (pMob[bb].TargetX) & 0xFFFC;
		int yv = (pMob[bb].TargetY) & 0xFFFC;

		for (int x = 0; x < 3; x++)
		{
			if (pUser[bb].Mode != USER_PLAY || pMob[bb].MOB.CurrentScore.Hp <= 0 || Pista[5].Party[x].LeaderID == 0 || Pista[5].Party[x].LeaderID != bb || strcmp(Pista[5].Party[x].LeaderName, pMob[bb].MOB.MobName))
				continue;

			if (pMob[Pista[5].Party[x].LeaderID].Leader != -1 && pMob[Pista[5].Party[x].LeaderID].Leader)
				continue;

			int _rd = rand() % 3;

			int tx = 2100;
			int ty = 2100;

			//Sala 1 Portal 1
			if (xv == PistaBalrogPortalPos[0][0][0] && yv == PistaBalrogPortalPos[0][0][1])
			{
				if (_rd <= 1)
				{
					tx = PistaBalrogPos[1][0];
					ty = PistaBalrogPos[1][1];
				}

				else
				{
					tx = PistaBalrogPos[0][0];
					ty = PistaBalrogPos[0][1];
				}
			}

			//Sala 2 Portal 1
			else if (xv == PistaBalrogPortalPos[1][0][0] && yv == PistaBalrogPortalPos[1][0][1])
			{
				if (_rd <= 1)
				{
					tx = PistaBalrogPos[1][0];
					ty = PistaBalrogPos[1][1];
				}
				else if (_rd == 2)
				{
					tx = PistaBalrogPos[2][0];
					ty = PistaBalrogPos[2][1];
				}

				else
				{
					tx = PistaBalrogPos[0][0];
					ty = PistaBalrogPos[0][1];
				}
			}

			//Sala 2 Portal 2
			else if (xv == PistaBalrogPortalPos[1][1][0] && yv == PistaBalrogPortalPos[1][1][1])
			{
				if (_rd >= 2)
				{
					tx = PistaBalrogPos[1][0];
					ty = PistaBalrogPos[1][1];
				}
				else if (_rd == 0)
				{
					tx = PistaBalrogPos[2][0];
					ty = PistaBalrogPos[2][1];
				}

				else
				{
					tx = PistaBalrogPos[0][0];
					ty = PistaBalrogPos[0][1];
				}
			}

			//Sala 3 Portal 1
			else if (xv == PistaBalrogPortalPos[2][0][0] && yv == PistaBalrogPortalPos[2][0][1])
			{
				if (_rd <= 1)
				{
					tx = PistaBalrogPos[2][0];
					ty = PistaBalrogPos[2][1];
				}
				else if (_rd == 2)
				{
					tx = PistaBalrogPos[3][0];
					ty = PistaBalrogPos[3][1];
				}

				else
				{
					tx = PistaBalrogPos[1][0];
					ty = PistaBalrogPos[1][1];
				}
			}

			//Sala 3 Portal 2
			else if (xv == PistaBalrogPortalPos[2][1][0] && yv == PistaBalrogPortalPos[2][1][1])
			{
				if (_rd >= 2)
				{
					tx = PistaBalrogPos[2][0];
					ty = PistaBalrogPos[2][1];
				}
				else if (_rd == 0)
				{
					tx = PistaBalrogPos[3][0];
					ty = PistaBalrogPos[3][1];
				}

				else
				{
					tx = PistaBalrogPos[1][0];
					ty = PistaBalrogPos[1][1];
				}
			}

			//Sala 3 Portal 3
			else if (xv == PistaBalrogPortalPos[2][2][0] && yv == PistaBalrogPortalPos[2][2][1])
			{
				if (_rd <= 1)
				{
					tx = PistaBalrogPos[2][0];
					ty = PistaBalrogPos[2][1];
				}
				else if (_rd == 2)
				{
					tx = PistaBalrogPos[3][0];
					ty = PistaBalrogPos[3][1];
				}

				else
				{
					tx = PistaBalrogPos[1][0];
					ty = PistaBalrogPos[1][1];
				}
			}

			//Sala 4 Portal 1
			else if (xv == PistaBalrogPortalPos[3][0][0] && yv == PistaBalrogPortalPos[3][0][1])
			{
				if (_rd <= 1)
				{
					tx = PistaBalrogPos[3][0];
					ty = PistaBalrogPos[3][1];
				}
				else if (_rd == 2)
				{
					tx = PistaBalrogPos[4][0];
					ty = PistaBalrogPos[4][1];

					if (Pista[5].Party[0].MobCount == 0)
						GenerateMob(RUNEQUEST_LV5_MOB_BOSS, 0, 0);
				}

				else
				{
					tx = PistaBalrogPos[2][0];
					ty = PistaBalrogPos[2][1];
				}
			}

			//Sala 4 Portal 2
			else if (xv == PistaBalrogPortalPos[3][1][0] && yv == PistaBalrogPortalPos[3][1][1])
			{
				if (_rd >= 2)
				{
					tx = PistaBalrogPos[3][0];
					ty = PistaBalrogPos[3][1];
				}
				else if (_rd == 0)
				{
					tx = PistaBalrogPos[4][0];
					ty = PistaBalrogPos[4][1];

					if (Pista[5].Party[0].MobCount == 0)
						GenerateMob(RUNEQUEST_LV5_MOB_BOSS, 0, 0);
				}

				else
				{
					tx = PistaBalrogPos[2][0];
					ty = PistaBalrogPos[2][1];
				}
			}

			//Sala 4 Portal 3
			else if (xv == PistaBalrogPortalPos[3][2][0] && yv == PistaBalrogPortalPos[3][2][1])
			{
				if (_rd <= 1)
				{
					tx = PistaBalrogPos[3][0];
					ty = PistaBalrogPos[3][1];
				}
				else if (_rd == 2)
				{
					tx = PistaBalrogPos[4][0];
					ty = PistaBalrogPos[4][1];

					if (Pista[5].Party[0].MobCount == 0)
						GenerateMob(RUNEQUEST_LV5_MOB_BOSS, 0, 0);
				}

				else
				{
					tx = PistaBalrogPos[2][0];
					ty = PistaBalrogPos[2][1];
				}
			}

			//Sala 4 Portal 4
			else if (xv == PistaBalrogPortalPos[3][3][0] && yv == PistaBalrogPortalPos[3][3][1])
			{
				if (_rd <= 1)
				{
					tx = PistaBalrogPos[3][0];
					ty = PistaBalrogPos[3][1];
				}
				else if (_rd == 2)
				{
					tx = PistaBalrogPos[4][0];
					ty = PistaBalrogPos[4][1];

					if (Pista[5].Party[0].MobCount == 0)
						GenerateMob(RUNEQUEST_LV5_MOB_BOSS, 0, 0);
				}

				else
				{
					tx = PistaBalrogPos[2][0];
					ty = PistaBalrogPos[2][1];
				}
			}
			else
				continue;

			int inv = 0;
			for (inv = 0; inv < pMob[bb].MaxCarry && inv < MAX_CARRY; inv++)
			{
				if (pMob[bb].MOB.Carry[inv].sIndex == 4032)
				{
					BASE_ClearItem(&pMob[bb].MOB.Carry[inv]);
					SendItem(bb, ITEM_PLACE_CARRY, inv, &pMob[bb].MOB.Carry[inv]);
					break;
				}
			}

			if (inv == pMob[bb].MaxCarry)
				continue;

			DoTeleport(Pista[5].Party[x].LeaderID, tx, ty);

			for (int c = 0; c < MAX_PARTY; c++)
			{
				int partyconn = pMob[Pista[5].Party[x].LeaderID].PartyList[c];

				if (partyconn > 0 && partyconn < MAX_USER && partyconn != Pista[5].Party[x].LeaderID && pUser[partyconn].Mode == USER_PLAY)
					DoTeleport(partyconn, tx, ty);
			}
		}

#pragma endregion
	}
#pragma endregion
#pragma region Quest Verification
	if (SecCounter % 4 == 0)
	{
		//Carta Sala 1
		int Sala1 = mNPCGen.pList[SECRET_ROOM_N_SALA1_MOB_1].CurrentNumMob + mNPCGen.pList[SECRET_ROOM_N_SALA1_MOB_2].CurrentNumMob + mNPCGen.pList[SECRET_ROOM_M_SALA1_MOB_1].CurrentNumMob + mNPCGen.pList[SECRET_ROOM_M_SALA1_MOB_2].CurrentNumMob + mNPCGen.pList[SECRET_ROOM_A_SALA1_MOB_1].CurrentNumMob + mNPCGen.pList[SECRET_ROOM_A_SALA1_MOB_2].CurrentNumMob;
		int Sala2 = mNPCGen.pList[SECRET_ROOM_N_SALA2_MOB_1].CurrentNumMob + mNPCGen.pList[SECRET_ROOM_N_SALA2_MOB_2].CurrentNumMob + mNPCGen.pList[SECRET_ROOM_M_SALA2_MOB_1].CurrentNumMob + mNPCGen.pList[SECRET_ROOM_M_SALA2_MOB_2].CurrentNumMob + mNPCGen.pList[SECRET_ROOM_A_SALA2_MOB_1].CurrentNumMob + mNPCGen.pList[SECRET_ROOM_A_SALA2_MOB_2].CurrentNumMob;
		int Sala3 = mNPCGen.pList[SECRET_ROOM_N_SALA3_MOB_1].CurrentNumMob + mNPCGen.pList[SECRET_ROOM_N_SALA3_MOB_2].CurrentNumMob + mNPCGen.pList[SECRET_ROOM_M_SALA3_MOB_1].CurrentNumMob + mNPCGen.pList[SECRET_ROOM_M_SALA3_MOB_2].CurrentNumMob + mNPCGen.pList[SECRET_ROOM_A_SALA3_MOB_1].CurrentNumMob + mNPCGen.pList[SECRET_ROOM_A_SALA3_MOB_2].CurrentNumMob;
		int Sala4 = mNPCGen.pList[SECRET_ROOM_N_SALA4_MOB_1].CurrentNumMob + mNPCGen.pList[SECRET_ROOM_N_SALA4_MOB_2].CurrentNumMob + mNPCGen.pList[SECRET_ROOM_N_SALA4_MOB_3].CurrentNumMob + mNPCGen.pList[SECRET_ROOM_N_SALA4_MOB_4].CurrentNumMob + mNPCGen.pList[SECRET_ROOM_M_SALA4_MOB_1].CurrentNumMob + mNPCGen.pList[SECRET_ROOM_M_SALA4_MOB_2].CurrentNumMob + mNPCGen.pList[SECRET_ROOM_M_SALA4_MOB_3].CurrentNumMob + mNPCGen.pList[SECRET_ROOM_M_SALA4_MOB_4].CurrentNumMob + mNPCGen.pList[SECRET_ROOM_A_SALA4_MOB_1].CurrentNumMob + mNPCGen.pList[SECRET_ROOM_A_SALA4_MOB_2].CurrentNumMob + mNPCGen.pList[SECRET_ROOM_A_SALA4_MOB_3].CurrentNumMob + mNPCGen.pList[SECRET_ROOM_A_SALA4_MOB_4].CurrentNumMob;

		int PesadeloA = mNPCGen.pList[Erin].CurrentNumMob +
			mNPCGen.pList[Escuridao].CurrentNumMob +
			mNPCGen.pList[Fenix].CurrentNumMob +
			mNPCGen.pList[Kara].CurrentNumMob +
			mNPCGen.pList[Kei].CurrentNumMob +
			mNPCGen.pList[Kemi].CurrentNumMob +
			mNPCGen.pList[Leao].CurrentNumMob +
			mNPCGen.pList[Yue].CurrentNumMob;

		int PesadeloM = mNPCGen.pList[Arnold_].CurrentNumMob +
			mNPCGen.pList[Lainy].CurrentNumMob +
			mNPCGen.pList[Reimers].CurrentNumMob +
			mNPCGen.pList[RoPerion].CurrentNumMob +
			mNPCGen.pList[Irena].CurrentNumMob;

		int PesadeloN = mNPCGen.pList[Martin].CurrentNumMob +
			mNPCGen.pList[Balmers].CurrentNumMob +
			mNPCGen.pList[Rubyen].CurrentNumMob +
			mNPCGen.pList[Naomi].CurrentNumMob +
			mNPCGen.pList[Arnold].CurrentNumMob;

		int MOBS = mNPCGen.pList[4069].CurrentNumMob +
			mNPCGen.pList[4041].CurrentNumMob +
			mNPCGen.pList[4042].CurrentNumMob +
			mNPCGen.pList[4043].CurrentNumMob +
			mNPCGen.pList[4044].CurrentNumMob +
			mNPCGen.pList[4045].CurrentNumMob +
			mNPCGen.pList[4046].CurrentNumMob +
			mNPCGen.pList[4047].CurrentNumMob +
			mNPCGen.pList[4048].CurrentNumMob +
			mNPCGen.pList[4049].CurrentNumMob +
			mNPCGen.pList[4050].CurrentNumMob +
			mNPCGen.pList[4051].CurrentNumMob +
			mNPCGen.pList[4052].CurrentNumMob +
			mNPCGen.pList[4053].CurrentNumMob +
			mNPCGen.pList[4054].CurrentNumMob +
			mNPCGen.pList[4055].CurrentNumMob +
			mNPCGen.pList[4056].CurrentNumMob +
			mNPCGen.pList[4057].CurrentNumMob +
			mNPCGen.pList[4058].CurrentNumMob +
			mNPCGen.pList[4059].CurrentNumMob +
			mNPCGen.pList[4060].CurrentNumMob +
			mNPCGen.pList[4061].CurrentNumMob +
			mNPCGen.pList[4062].CurrentNumMob +
			mNPCGen.pList[4063].CurrentNumMob +
			mNPCGen.pList[4064].CurrentNumMob +
			mNPCGen.pList[4065].CurrentNumMob +
			mNPCGen.pList[4066].CurrentNumMob;

		int Quadra_1 = mNPCGen.pList[6076].CurrentNumMob +
			mNPCGen.pList[6077].CurrentNumMob +
			mNPCGen.pList[6078].CurrentNumMob +
			mNPCGen.pList[6079].CurrentNumMob +
			mNPCGen.pList[6080].CurrentNumMob +
			mNPCGen.pList[6081].CurrentNumMob +
			mNPCGen.pList[6082].CurrentNumMob +
			mNPCGen.pList[6083].CurrentNumMob +
			mNPCGen.pList[6084].CurrentNumMob;

		int Quadra_2 = mNPCGen.pList[6086].CurrentNumMob +
			mNPCGen.pList[6087].CurrentNumMob +
			mNPCGen.pList[6088].CurrentNumMob +
			mNPCGen.pList[6089].CurrentNumMob +
			mNPCGen.pList[6090].CurrentNumMob +
			mNPCGen.pList[6091].CurrentNumMob +
			mNPCGen.pList[6092].CurrentNumMob +
			mNPCGen.pList[6093].CurrentNumMob +
			mNPCGen.pList[6094].CurrentNumMob;

		int Quadra_3 = mNPCGen.pList[6096].CurrentNumMob +
			mNPCGen.pList[6097].CurrentNumMob +
			mNPCGen.pList[6098].CurrentNumMob +
			mNPCGen.pList[6099].CurrentNumMob +
			mNPCGen.pList[6100].CurrentNumMob +
			mNPCGen.pList[6101].CurrentNumMob +
			mNPCGen.pList[6102].CurrentNumMob +
			mNPCGen.pList[6103].CurrentNumMob +
			mNPCGen.pList[6104].CurrentNumMob;

		int Quadra_4 = mNPCGen.pList[6106].CurrentNumMob +
			mNPCGen.pList[6107].CurrentNumMob +
			mNPCGen.pList[6108].CurrentNumMob +
			mNPCGen.pList[6109].CurrentNumMob +
			mNPCGen.pList[6110].CurrentNumMob +
			mNPCGen.pList[6111].CurrentNumMob +
			mNPCGen.pList[6112].CurrentNumMob +
			mNPCGen.pList[6113].CurrentNumMob +
			mNPCGen.pList[6114].CurrentNumMob;

		/*int  MOBDESERTO = mNPCGen.pList[3139].CurrentNumMob +
			mNPCGen.pList[3140].CurrentNumMob +
			mNPCGen.pList[3141].CurrentNumMob +
			mNPCGen.pList[3142].CurrentNumMob +
			mNPCGen.pList[3143].CurrentNumMob +
			mNPCGen.pList[3144].CurrentNumMob +
			mNPCGen.pList[3145].CurrentNumMob +
			mNPCGen.pList[3146].CurrentNumMob +
			mNPCGen.pList[3147].CurrentNumMob +
			mNPCGen.pList[3148].CurrentNumMob +
			mNPCGen.pList[3149].CurrentNumMob +
			mNPCGen.pList[3150].CurrentNumMob +
			mNPCGen.pList[3151].CurrentNumMob +
			mNPCGen.pList[3152].CurrentNumMob +
			mNPCGen.pList[3153].CurrentNumMob +
			mNPCGen.pList[3154].CurrentNumMob +
			mNPCGen.pList[3155].CurrentNumMob +
			mNPCGen.pList[3156].CurrentNumMob +
			mNPCGen.pList[3157].CurrentNumMob +
			mNPCGen.pList[3158].CurrentNumMob +
			mNPCGen.pList[3159].CurrentNumMob;*/

		int Lichs = mNPCGen.pList[LICHBOSS2].CurrentNumMob +
			mNPCGen.pList[LICHBOSS4].CurrentNumMob;

		
		int Users = GetUserInArea(1295, 1480, 1385, 1520, temp);

		SendSignalParmArea(778, 3651, 832, 3699, ESCENE_FIELD, _MSG_MobLeft, Sala1);
		//Carta Sala 2
		SendSignalParmArea(836, 3651, 890, 3699, ESCENE_FIELD, _MSG_MobLeft, Sala2);
		//Carta Sala 3
		SendSignalParmArea(832, 3594, 890, 3644, ESCENE_FIELD, _MSG_MobLeft, Sala3);
		//Carta Sala 4
		SendSignalParmArea(780, 3594, 832, 3645, ESCENE_FIELD, _MSG_MobLeft, Sala4);

		//Pesadelo A
		SendShortSignalParm2Area(1152, 128, 1280, 256, ESCENE_FIELD, _MSG_MobCount, PesadeloA, 8);

		//Pesadelo M
		SendShortSignalParm2Area(1024, 256, 1152, 384, ESCENE_FIELD, _MSG_MobCount, PesadeloM, 7);

		//Pesadelo N
		SendShortSignalParm2Area(1280, 256, 1408, 384, ESCENE_FIELD, _MSG_MobCount, PesadeloN, 5);

		//Pista de runas +6 - Coelho
		SendSignalParmArea(3330, 1475, 3448, 1525, ESCENE_FIELD, _MSG_MobLeft, Pista[6].Party[0].MobCount);

		//RvR
		SendShortSignalParm2Area(1017, 1911, 1290, 2183, ESCENE_FIELD, _MSG_MobCount, RvRRedPoint + 0, RvRBluePoint + 0);

		//SendSignalParmArea(1295, 1480, 1385, 1520, ESCENE_FIELD, _MSG_MobLeft, Users);

		if (EspelhoLive == 2 && SecCounter % 5 == 0)
		{
			SendShortSignalParm2Area(3725, 2831, 3833, 2914, ESCENE_FIELD, _MSG_MobCount, MOBS, 70);
		}
		int Users1 = GetUserInArea(136, 4000, 200, 4100, temp);
		SendSignalParmArea(136, 4000, 200, 4100, ESCENE_FIELD, _MSG_MobLeft, Users1);

		if (SecCounter % 10 == 0)
		{
			for (int i = 1; i < MAX_USER; i++)
			{
				if (BrState == 1 && pMob[i].TargetX > 140 && pMob[i].TargetY > 4000 && pMob[i].TargetX < 200 && pMob[i].TargetY < 4100)
				{
					if (Users1 == 1)
					{
						
						SendClientMessage(i, "Parabens, Voce venceu a [Batalha Real].");
						p_BatalhaReal.start = false;
						memset(&p_BatalhaReal, 0, sizeof(p_BatalhaReal));
						BrState = 0;
						//pUser[i].Honra += 15;
						int x = 0;
						if (x != pMob[i].MaxCarry)
						{
							STRUCT_ITEM Item;
							memset(&Item, 0, sizeof(STRUCT_ITEM));
							int _rd = rand() % 1;
							if (_rd < 100) //25%
							{
								Item.sIndex = 480; //item opçao 1
								Item.stEffect[0].cEffect = 0; //efeito REF
								Item.stEffect[0].cValue = 0; //valor
								Item.stEffect[1].cEffect = 0; //efeito ADD
								Item.stEffect[1].cValue = 0; //valor
							}
							PutItem(i, &Item);
							SendClientMessage(i, strFmt(g_pMessageStringTable[_SN_Item_Arrived], g_pItemList[Item.sIndex].Name));
						}
						ClearArea(140, 4000, 200, 4100);
						SendScore(i);
						SendEtc(i);
					}
				}
			}
		}

		if (SecCounter % 2 == 0)
		{
			for (int i = 1; i < MAX_USER; i++)
			{
				if (pUser[i].Mode != USER_PLAY)
					continue;
				if (pMob[i].TargetX >= 1153 && pMob[i].TargetY >= 1681 && pMob[i].TargetX <= 1205 && pMob[i].TargetY <= 1771)
				{
					if (pUser[i].BossLocal1 == 0)
					{
						pUser[i].BossLocal1 = 1;
						SendEtc(i);
					}
				}
				else if (pUser[i].BossLocal1 == true)
				{
					pUser[i].BossLocal1 = 0;
					SendEtc(i);
				}
			}
		}



#pragma region >> Verifica se o usuário está com várias contas abertas

		/* Batalha Real */
		//GetUserInAreaMac(0, 140, 4000, 200, 4100);

		/* Lan House (A) */
		//GetUserInAreaMac(0, 3860, 3602, 3946, 3690);

		/* Lan House (M) */
		//GetUserInAreaMac(0, 3734, 3476, 3818, 3561);

		/* Lan House (N) */
		//GetUserInAreaMac(0, 3604, 3601, 3690, 3690);

		/* Área de evento */
		/*GetUserInAreaMac(0, 2560, 2560, 2687, 2687); */


#pragma endregion

#pragma region Quest Castelo de Gelo
		if (EspelhoLive == 2)
		{
			if (MOBS == 1)
			{
				//DarkShadow
				GenerateMob(SOMBRANEGRA, 0, 0);
				EspelhoLive = 0;
				SendNoticeArea(g_pMessageStringTable[_ND_GenDarkShadow], 3703, 2829, 3967, 2942);
			}
		}
#pragma endregion
#pragma region Contador Laranja
		if (SecCounter % 1 == 0)
		{
			int Quadra_1 =
				mNPCGen.pList[4661].CurrentNumMob +
				mNPCGen.pList[4662].CurrentNumMob +
				mNPCGen.pList[4663].CurrentNumMob +
				mNPCGen.pList[4664].CurrentNumMob +
				mNPCGen.pList[4665].CurrentNumMob +
				mNPCGen.pList[4666].CurrentNumMob +
				mNPCGen.pList[4667].CurrentNumMob +
				mNPCGen.pList[4668].CurrentNumMob +
				mNPCGen.pList[4669].CurrentNumMob;

			int Quadra_2 =
				mNPCGen.pList[4671].CurrentNumMob +
				mNPCGen.pList[4672].CurrentNumMob +
				mNPCGen.pList[4673].CurrentNumMob +
				mNPCGen.pList[4674].CurrentNumMob +
				mNPCGen.pList[4675].CurrentNumMob +
				mNPCGen.pList[4676].CurrentNumMob +
				mNPCGen.pList[4677].CurrentNumMob +
				mNPCGen.pList[4678].CurrentNumMob +
				mNPCGen.pList[4679].CurrentNumMob;

			int Quadra_3 =
				mNPCGen.pList[4681].CurrentNumMob +
				mNPCGen.pList[4682].CurrentNumMob +
				mNPCGen.pList[4683].CurrentNumMob +
				mNPCGen.pList[4684].CurrentNumMob +
				mNPCGen.pList[4685].CurrentNumMob +
				mNPCGen.pList[4686].CurrentNumMob +
				mNPCGen.pList[4687].CurrentNumMob +
				mNPCGen.pList[4688].CurrentNumMob +
				mNPCGen.pList[4689].CurrentNumMob;

			int Quadra_4 =
				mNPCGen.pList[4691].CurrentNumMob +
				mNPCGen.pList[4692].CurrentNumMob +
				mNPCGen.pList[4693].CurrentNumMob +
				mNPCGen.pList[4694].CurrentNumMob +
				mNPCGen.pList[4695].CurrentNumMob +
				mNPCGen.pList[4696].CurrentNumMob +
				mNPCGen.pList[4697].CurrentNumMob +
				mNPCGen.pList[4698].CurrentNumMob +
				mNPCGen.pList[4699].CurrentNumMob;

			int Lichs =
				mNPCGen.pList[LICHBOSS2].CurrentNumMob +
				mNPCGen.pList[LICHBOSS4].CurrentNumMob;

#pragma region Portao Infernal // Quadras
			if (TarantulaKilled == TRUE)
			{
				if (RandBoss == 1)
				{
					if (Quadra_1 == 0 && Lich_1 == 1)
						GenerateMob(LICHBOSS1, 1811, 3606);

					if (Quadra_2 == 0 && Lich_2 == 1)
						GenerateMob(LICHBOSS2, 1876, 3606);

					if (Quadra_3 == 0 && Lich_3 == 1)
						GenerateMob(LICHBOSS3, 1876, 3692);

					if (Quadra_4 == 0 && Lich_4 == 1)
						GenerateMob(LICHBOSS4, 1811, 3692);

					if (Lich_2 == 2 && Lich_4 == 2)
					{
						Lich_2 = 0;
						Lich_4 = 0;
						SendNoticeArea(g_pMessageStringTable[_NN_Killed_Boss], 1664, 3584, 1919, 3711);

						SendNoticeArea(g_pMessageStringTable[_NN_Hell_Clear], 1664, 3584, 1919, 3711);

						for (int x = PI_INITIAL6; x <= PI_END6; x++)
							GenerateMob(x, 0, 0);

						CreateMob("Aki", 1852, 3650, "npc", 0);
					}
				}

				if (RandBoss == 2)
				{
					if (Quadra_1 == 0 && Lich_1 == 1)
						GenerateMob(LICHBOSS2, 1811, 3606);

					if (Quadra_2 == 0 && Lich_2 == 1)
						GenerateMob(LICHBOSS1, 1876, 3606);

					if (Quadra_3 == 0 && Lich_3 == 1)
						GenerateMob(LICHBOSS4, 1876, 3692);

					if (Quadra_4 == 0 && Lich_4 == 1)
						GenerateMob(LICHBOSS3, 1811, 3692);

					if (Lich_1 == 2 && Lich_3 == 2)
					{
						Lich_1 = 0;
						Lich_3 = 0;
						SendNoticeArea(g_pMessageStringTable[_NN_Killed_Boss], 1664, 3584, 1919, 3711);

						SendNoticeArea(g_pMessageStringTable[_NN_Hell_Clear], 1664, 3584, 1919, 3711);

						for (int x = PI_INITIAL6; x <= PI_END6; x++)
							GenerateMob(x, 0, 0);

						CreateMob("Aki", 1851, 3647, "npc", 0);
					}
				}
			}
#pragma endregion
		}
	}
#pragma endregion 
#pragma region Itens Time
	if (SecCounter % 120 == 0)
	{

		for (int user = 1; user < MAX_USER; user++)
		{
			if (pUser[user].Mode != USER_PLAY)
				continue;

			if (pUser[user].Keys[46] == 1) {
				if (pUser[user].Keys[48] > 1) {
					pUser[user].Keys[48] -= 1;
					SendKeys(user);
				}
				if (pUser[user].Keys[48] == 0) {
					pUser[user].Keys[46] = 0;
					SendKeys(user);
				}
			}

			//MacroPerga
			if (pUser[user].Ingame.MacroState == 2)
			{
				SendClientMessage(user, "Macro Perga Auto Retorno");
				if (pMob[user].MOB.Equip[13].sIndex == 3900)
					MacroNextSala(user, pUser[user].Ingame.MacroType, pUser[user].Ingame.MacroSala);
				else {
					pUser[user].Ingame.MacroState = 0;
					SendClientMessage(user, "Macro Perga OFF");
				}
			}

			//novas esferas
			if (pMob[user].MOB.Equip[14].sIndex >= 3980 && pMob[user].MOB.Equip[14].sIndex <= 3992 && BASE_CheckItemDate(&pMob[user].MOB.Equip[14]))
			{


				BASE_ClearItem(&pMob[user].MOB.Equip[14]);
				SendItem(user, ITEM_PLACE_EQUIP, 14, &pMob[user].MOB.Equip[14]);
			}
			if (pMob[user].MOB.Equip[14].sIndex >= 3995 && pMob[user].MOB.Equip[14].sIndex <= 3999 && BASE_CheckItemDate(&pMob[user].MOB.Equip[14]))
			{


				BASE_ClearItem(&pMob[user].MOB.Equip[14]);
				SendItem(user, ITEM_PLACE_EQUIP, 14, &pMob[user].MOB.Equip[14]);
			}


			//trajes
			if (pMob[user].MOB.Equip[12].sIndex >= 4150 && pMob[user].MOB.Equip[12].sIndex <= 4188 && BASE_CheckItemDate(&pMob[user].MOB.Equip[12]))
			{


				BASE_ClearItem(&pMob[user].MOB.Equip[12]);
				SendItem(user, ITEM_PLACE_EQUIP, 12, &pMob[user].MOB.Equip[12]);
			}
			if (pMob[user].MOB.Equip[12].sIndex >= 4200 && pMob[user].MOB.Equip[12].sIndex <= 4499 && BASE_CheckItemDate(&pMob[user].MOB.Equip[12]))
			{


				BASE_ClearItem(&pMob[user].MOB.Equip[12]);
				SendItem(user, ITEM_PLACE_EQUIP, 12, &pMob[user].MOB.Equip[12]);
			}

			//fadas
			if (pMob[user].MOB.Equip[13].sIndex >= 3900 && pMob[user].MOB.Equip[13].sIndex <= 3916)
			{
				BASE_CheckFairyDate(&pMob[user].MOB.Equip[13]);
				SendItem(user, ITEM_PLACE_EQUIP, 13, &pMob[user].MOB.Equip[13]);
				pMob[user].GetCurrentScore(user);
			}

			//bolsa andarilho
			if (pMob[user].MOB.Carry[60].sIndex == 3467 && BASE_CheckItemDate(&pMob[user].MOB.Carry[60]))
			{
				BASE_ClearItem(&pMob[user].MOB.Carry[60]);
				SendItem(user, ITEM_PLACE_CARRY, 60, &pMob[user].MOB.Carry[60]);

				pMob[user].MaxCarry = 30;

				if (pMob[user].MOB.Carry[60].sIndex == 3467)
					pMob[user].MaxCarry += 15;

				if (pMob[user].MOB.Carry[61].sIndex == 3467)
					pMob[user].MaxCarry += 15;
			}
			if (pMob[user].MOB.Carry[61].sIndex == 3467 && BASE_CheckItemDate(&pMob[user].MOB.Carry[61]))
			{
				BASE_ClearItem(&pMob[user].MOB.Carry[61]);
				SendItem(user, ITEM_PLACE_CARRY, 61, &pMob[user].MOB.Carry[61]);

				pMob[user].MaxCarry = 30;

				if (pMob[user].MOB.Carry[60].sIndex == 3467)
					pMob[user].MaxCarry += 15;

				if (pMob[user].MOB.Carry[61].sIndex == 3467)
					pMob[user].MaxCarry += 15;
			}
		}
	}
#pragma endregion
#pragma region Unknown Functions
	if (SecCounter % 2 == 0)
	{
		for (int i = 1; i < MAX_USER; i++)
		{
			if (pUser[i].Mode == USER_PLAY && pMob[i].MOB.CurrentScore.Hp > 0)
			{
				pUser[i].Unk_2688 = 0;

				int retHp = ApplyHp(i);
				int retMp = ApplyMp(i);

				if (retHp != 0)
					SendScore(i);

				else if (retMp != 0)
					SendSetHpMp(i);
			}
		}
	}

	if (SecCounter % 10 == 0)
	{
		for (int i = 1; i < MAX_USER; i++)
		{
			if (pUser[i].Mode == USER_PLAY && pMob[i].MOB.CurrentScore.Hp > 0)
			{
				//regen de hp automatico
				int Level = pMob[i].MOB.BaseScore.Level;

				pUser[i].ReqHp += (Level / 2) + 30;
				pUser[i].ReqMp += Level + 50;

				int retHp = ApplyHp(i);
				int retMp = ApplyMp(i);

				if (retHp != 0)
					SendScore(i);

				else if (retMp != 0)
					SendSetHpMp(i);
			}
		}
	}
#pragma endregion


#pragma region Boss Time
	if (SecCounter % 2 == 0)
	{
		struct tm when;
		time_t now;
		time(&now);
		when = *localtime(&now);

		//portão infernal
		if ((when.tm_min == 25 || when.tm_min == 55) && when.tm_sec >= 0 && when.tm_sec <= 2)
		{
			SendNoticeArea("Os Cavaleiros Esqueleto estão atacando a estrutura central!", 1664, 3584, 1919, 3711);

			for (int x = PI_INITIAL6; x <= PI_END6; x++)
				GenerateMob(x, 0, 0);
		}


#pragma region Kefra BOSS Initialize
		if ((when.tm_wday == 2 && when.tm_hour == 19 && when.tm_min == 0) && when.tm_sec >= 0 && when.tm_sec <= 2 && KefraLive)
		{
			KefraLive = 0;

			//Kefra
			GenerateMob(KEFRA_BOSS, 0, 0);

			for (int xx = KEFRA_MOB_INITIAL; xx <= KEFRA_MOB_END; xx++)
				GenerateMob(xx, 0, 0);
		}
#pragma endregion
		//#pragma region Batalha Real GreenTime
		//		if (SecCounter % 1 == 0)
		//		{
		//			if (p_BatalhaReal.start == true)
		//			{
		//				for (int i = 0; i < 20; i++)
		//				{
		//					if (pUser[i].Mode != USER_PLAY)
		//						continue;
		//
		//					if (BrTime > 0)
		//						BrTime--;
		//					SendClientSignalParmCoord(i, ESCENE_FIELD, _MSG_StartTime, BrTime, 140, 4000, 200, 4100);
		//				}
		//			}
		//		}
		//#pragma endregion

				//evento lojinha
#pragma region  >> MAXUSER - LOJINHA

		if (SecCounter % 2 == 0)
		{
			for (int i = 1; i < MAX_USER; i++)
			{
				if (pUser[i].Mode != USER_PLAY)
					continue;

				/*GetUserLojinhaAreaMac(i);*/
				if (pMob[i].CheckLojinha > 0)
					pMob[i].CheckLojinha--;

				/*Armia*/
				SendClientSignalParmCoord(i, ESCENE_FIELD, _MSG_StartTime, pMob[i].CheckLojinha, 2064, 2056, 2154, 2160);
				/*Erion*/
				SendClientSignalParmCoord(i, ESCENE_FIELD, _MSG_StartTime, pMob[i].CheckLojinha, 2449, 1984, 2475, 2023);
				/*Azran*/
				SendClientSignalParmCoord(i, ESCENE_FIELD, _MSG_StartTime, pMob[i].CheckLojinha, 2443, 1678, 2559, 1748);
				/*Gelo*/
				SendClientSignalParmCoord(i, ESCENE_FIELD, _MSG_StartTime, pMob[i].CheckLojinha, 3609, 3101, 3689, 3147);
				/*Noatun*/
				SendClientSignalParmCoord(i, ESCENE_FIELD, _MSG_StartTime, pMob[i].CheckLojinha, 1039, 1704, 1075, 1754);

				if (pUser[i].TradeMode == 1 && Limitadordelojinha(pUser[i].MacAddress) > 1)
				{
					SendClientMessage(i, "Limite de [01] lojinha por máquina.");
					RemoveTrade(i);
					return;
				}
				/////////////////////////////////////////////////
				//Limitador de Lojinhas por IP
				/*int Connections = 0;
				for (int z = 0; z < MAX_USER; z++)
				{
					if (pUser[z].Mode != USER_PLAY)
						continue;

					if (!pUser[z].cSock.Sock)
						continue;

					if (pUser[z].TradeMode == 1)
					{
						if (pUser[z].IP == pUser[i].IP)
							Connections++;
					}
				}
				if (Connections > 2) {
					SendClientMessage(i, "Limite de [02] lojinha por endereço de IP");
					RemoveTrade(i);
					return;
				}*/
				////////////////////////////////////////////////
				if (pUser[i].TradeMode == 1 && pMob[i].CheckLojinha <= 0)
				{
					pUser[i].Honra += 1;						

					/*if (EventStatus == 1) {
						STRUCT_ITEM item;
						memset(&item, 0, sizeof(STRUCT_ITEM));						
						item.sIndex = 475;

						if (pMob[i].MOB.Equip[13].sIndex == 3901 || pMob[i].MOB.Equip[13].sIndex == 3902)
						{
							SendItemagrupar(i, item.sIndex);
							SendItemagrupar(i, item.sIndex);
						}
						else
							SendItemagrupar(i, item.sIndex);

					}*/
					pMob[i].CheckLojinha = 600;//600 = 10 minutos
					
					SendClientMessage(i, "Você Recebeu sua recompensa");
					SendEtc(i);
				}

#pragma region >>Func Fix

				ClearCrown(i);
				//LimiteBsWepom(i);

#pragma endregion


			}
		}


#pragma endregion

#pragma region Controle de Drop por Tempo
		// A cada 4 horas
		if ((when.tm_hour == 0 || when.tm_hour == 4 || when.tm_hour == 8 || when.tm_hour == 12 ||
			when.tm_hour == 16 || when.tm_hour == 20) && when.tm_min == 13 && when.tm_sec < 5)
		{
			ItemDropControl[1740] = 1; //Alma do Uni
		}
		// A cada 8 horas
		if ((when.tm_hour == 0 || when.tm_hour == 8 || when.tm_hour == 16) && when.tm_min == 37 && when.tm_sec < 5)
		{
			ItemDropControl[671] = 1; //Força Espectral
			ItemDropControl[1741] = 1; //Alma da Fênix
		}

#pragma region >> Resete Pistas precaução
		if ((when.tm_min == 15 || when.tm_min == 35 || when.tm_min == 55) && when.tm_sec >= 10)
		{
			if (SecCounter % 2 == 0)
			{
				ClearAreaTeleport(3320, 1016, 3448, 1656, 3290, 1685);
			}
		}

#pragma region >> rvr boss
		if (when.tm_wday == 1 || when.tm_wday == 2 || when.tm_wday == 3 || when.tm_wday == 4 || when.tm_wday == 5)
		{
			if (when.tm_hour == 20)
			{
				if ((when.tm_min == 15) && when.tm_sec == 0)
				{
					if (SecCounter % 2 == 0)
					{

						GenerateMob(BARAO_AZUL, 0, 0);
						SendNoticeArea(" O Barão Acabou de Renascer !!!", 1053, 1949, 1246, 2148);

					}
					if (SecCounter % 2 == 0)
					{
						GenerateMob(BARAO_VERMELHO, 0, 0);
					}
				}
			}
		}
		if (when.tm_wday == 1 || when.tm_wday == 2 || when.tm_wday == 3 || when.tm_wday == 4 || when.tm_wday == 5)
		{
			if (when.tm_hour == 20)
			{
				if ((when.tm_min == 5 || when.tm_min == 10 || when.tm_min == 20 || when.tm_min == 25) && when.tm_sec == 0)
				{
					if (SecCounter % 2 == 0)
					{
						GenerateMob(ENT_OBSCURO_BLUE, 0, 0);
						SendNoticeArea(" O Ent Obscuro Acabou de Renascer !!!", 1053, 1949, 1246, 2148);
					}
					if (SecCounter % 2 == 0)
					{
						GenerateMob(ENT_OBSCURO_RED, 0, 0);
					}
				}
			}
		}

#pragma endregion
#pragma region >> Reset Quest
		if (SecCounter % 1200 == 0)
		{
			ClearArea(2232, 1564, 2263, 1592);// Capa Verde
			ClearArea(2640, 1966, 2670, 2004);//Reset habilidades
			ClearArea(1950, 1586, 1988, 1614);//Reset habilidades
			ClearArea(793, 4046, 827, 4080);//Quest Gargula

			ClearArea(2379, 2076, 2426, 2133);// Coveiro
			ClearArea(2228, 1700, 2257, 1728);//Carbuncle
			ClearArea(459, 3887, 497, 3916);//Kaizen
			ClearArea(658, 3728, 703, 3762);//Hidras
			ClearArea(1312, 4027, 1348, 4055);//Elfos

			ClearArea(3602, 3602, 3693, 3692);//Lanhouse N  
			ClearArea(3730, 3474, 3821, 3565);//Lanhouse M  
			ClearArea(3602, 3858, 3949, 3692);//Lanhouse A 

			/*for (int x = 1; x < MAX_USER; x++)
			{
				if (pMob[x].QuestFlag && pUser[x].Mode == USER_PLAY) {
					pMob[x].QuestFlag = 0;
					pMob[x].LanNFlag = 0;
					pMob[x].LanMFlag = 0;
					pMob[x].LanAFlag = 0;
				}
			}*/
		}

		//Freeze
		if (when.tm_sec == 0 || when.tm_sec == 30)
		{
			Freeze();
		}

#pragma region BOSS GLOBAL
		if (((when.tm_wday != 0 && when.tm_wday != 6) && (when.tm_hour == 0 || when.tm_hour == 4 || when.tm_hour == 8 || when.tm_hour == 12 || when.tm_hour == 16 || when.tm_hour == 20) && when.tm_min == 0 && when.tm_sec <= 3) && g_BSombraNegra == FALSE) // HORARIO DO BOSS - Segunda à Sexta de 4 em 4 horas
		{
			GenerateMob(SOMBRANEGRA, 0, 0);
			SendNotice("Sombra Negra Nasceu!");
			g_BSombraNegra = TRUE;
		}
		//if (((when.tm_wday != 0 && when.tm_wday != 6) && when.tm_hour == 18 && when.tm_min == 40 && when.tm_sec <= 3) && g_BVerid == FALSE) // HORARIO DO BOSS - Segunda à Sexta 18:40 da noite
		//{
		//	GenerateMob(VERIDNEGRO, 0, 0);
		//	SendNotice("O Verid Negro acabou de renascer!");
		//	g_BVerid = TRUE;
		//}
		if (((when.tm_wday != 0 && when.tm_wday != 6) && when.tm_hour == 19 && when.tm_min == 40 && when.tm_sec <= 3) && g_RainhaG == FALSE) // HORARIO DO BOSS - Segunda à Sexta 19:40 da noite		
		{
			GenerateMob(ESPELHO_RAINHAG, 0, 0);
			SendNotice("The Mirror Queen Reborn!");
			g_RainhaG = TRUE;
		}
#pragma endregion

		//#pragma region Boss 1 Castelo de Gelo
		//		if ((when.tm_hour == 22 && when.tm_min ==59) && when.tm_sec >= 58 && when.tm_sec <= 59 && (EspelhoLive == 0)) // HORARIO DO BOSS - Todos os dias 22:59
		//		{
		//			// BOSS PARTE 1
		//			for (int w = BOSS1_INITIAL; w <= BOSS1_END; w++)
		//				mNPCGen.pList[w].MinuteGenerate = -1;
		//			// BOSS PARTE 2
		//			for (int x = BOSS1_INITIAL2; x <= BOSS1_END2; x++)
		//				mNPCGen.pList[x].MinuteGenerate = -1;
		//
		//			EspelhoLive = 1;
		//
		//			int rand_ = rand() % 100;
		//			if (rand_ <= 25)
		//			GenerateMob(ESPELHO_RAINHAG, 3746, 2978);
		//			else if (rand_ <= 50)
		//				GenerateMob(ESPELHO_RAINHAG, 3619, 2788);
		//			else if (rand_ <= 75)
		//				GenerateMob(ESPELHO_RAINHAG, 3622, 3023);
		//			else
		//				GenerateMob(ESPELHO_RAINHAG, 3538, 2982);
		//
		//			SendNotice("Espelho RainhaG acaba de nascer em Karden!");
		//		}
		//#pragma endregion
		//#pragma region Boss 1 Castelo de Gelo Parte 2
		//		if ((when.tm_hour == 23 && when.tm_min == 20) && when.tm_sec >= 0 && when.tm_sec <= 2 && (EspelhoLive == 1)) // HORARIO DO BOSS - Todos os dias 23:20
		//		{
		//			// BOSS PARTE 1
		//			for (int w = BOSS1_INITIAL; w <= BOSS1_END; w++)
		//				mNPCGen.pList[w].MinuteGenerate = 3;
		//			// BOSS PARTE 2
		//			for (int x = BOSS1_INITIAL2; x <= BOSS1_END2; x++)
		//				mNPCGen.pList[x].MinuteGenerate = 3;
		//
		//			EspelhoLive = 0;
		//
		//			for (int i = MAX_USER; i < MAX_MOB; i++)
		//			{
		//				if (!strcmp(pMob[i].MOB.MobName, "Espelho RainhaG"))
		//					DeleteMob(i, 1);
		//			}
		//
		//			SendNotice("Ninguém foi confrontar a Rainha");
		//		}
		//#pragma endregion
		//#pragma region Boss 1 Castelo de Gelo Parte 3
		//		if ((when.tm_hour == 23 && when.tm_min == 30) && when.tm_sec >= 0 && when.tm_sec <= 2) // HORARIO DO BOSS - Todos os dias 23:30
		//		{
		//			for (int i = MAX_USER; i < MAX_MOB; i++)
		//			{
		//				if (!strcmp(pMob[i].MOB.MobName, "VeridRainhaG") || !strcmp(pMob[i].MOB.MobName, "Sombra Negra"))
		//				{
		//					if (mNPCGen.pList[pMob[i].GenerateIndex].CurrentNumMob > 0)
		//					{
		//						// BOSS PARTE 1
		//						for (int w = BOSS1_INITIAL; w <= BOSS1_END; w++)
		//							mNPCGen.pList[w].MinuteGenerate = 3;
		//						// BOSS PARTE 2
		//						for (int x = BOSS1_INITIAL2; x <= BOSS1_END2; x++)
		//							mNPCGen.pList[x].MinuteGenerate = 3;
		//
		//						EspelhoLive = 0;
		//
		//						DeleteMob(i, 1);
		//					}
		//				}
		//			}
		//			SendNotice("A quest do Gelo foi resetada!");
		//		}
		//#pragma endregion

#pragma region Portão Reset
		if ((when.tm_min == 29 || when.tm_min == 59) && when.tm_sec == 0)
		{
			DeleteMobMapa(13, 28);
			//ClearMapa(13, 28);//Portão Infernal
			ClearArea(1664, 3584, 1919, 3711);
			PartyPortao[0] = 0;
			TarantulaKilled = FALSE;
			RandBoss = 0;
			Lich_1 = 0;
			Lich_2 = 0;
			Lich_3 = 0;
			Lich_4 = 0;


		}
#pragma endregion

#pragma region >> Auto Restart de Logs
		if ((when.tm_min == 00) && when.tm_sec == 0)
		{
			StartSystemLog();
			StartChatLog();
			StartItemLog();
			CompositorLog();
			MobDropLogs();
			trade_item();
		}
#pragma endregion
#pragma region Pesa Reset
		if ((when.tm_min == 9 || when.tm_min == 29 || when.tm_min == 49) && when.tm_sec == 0)
		{
			DeleteMobMapa(9, 1);
			ClearMapa(9, 1);//Pesa A
			PartyPesa[2] = 0;

		}
		if ((when.tm_min == 4 || when.tm_min == 24 || when.tm_min == 44) && when.tm_sec == 0)
		{
			DeleteMobMapa(8, 2);
			ClearMapa(8, 2);//Pesa M
			PartyPesa[1] = 0;


		}

		if ((when.tm_min == 19 || when.tm_min == 39 || when.tm_min == 59) && when.tm_sec == 0)
		{
			DeleteMobMapa(10, 2);
			ClearMapa(10, 2);//Pesa N
			PartyPesa[0] = 0;


		}
#pragma endregion
		if (BatalhaRealStatus == 1) {
#pragma region Start Batalha Real
			if (when.tm_wday != 0 && when.tm_wday != 7 && when.tm_min == 0 && when.tm_sec == 0)
			{
				SendNotice("Registro para a Batalha Real iniciada !");
			}
#pragma region Start Batalha Real
			if (when.tm_min == 1 && when.tm_sec > 58)
			{
				SendNotice("Batalha Real! Restam [180] segundos para o fim do Registro ");
			}
#pragma region Start Batalha Real
			if (when.tm_min == 2 && when.tm_sec > 58)
			{
				SendNotice("Batalha Real! Restam [120] segundos para o fim do Registro ");
			}
#pragma region Start Batalha Real
			if (when.tm_min == 3 && when.tm_sec > 58)
			{
				SendNotice("Batalha Real! Restam [60] segundos para o fim do Registro ");
			}
#pragma region Start Batalha Real

			if ((p_BatalhaReal.start == false) && when.tm_min == 6)
			{
				if (BrState == 0)
				{
					MSG_Action sm;
					if (p_BatalhaReal.NumMembers >= 2)
					{
						SendNotice(strFmt("Batalha Real Iniciada - Total de jogadores na arena: [%d].", p_BatalhaReal.NumMembers));
						// i = maximo de player na batalha = 20
						for (int i = 0; i < 20; i++)
						{
							int rand_ = rand() % 100;
							if (rand_ <= 10)
								DoTeleport(p_BatalhaReal.Members[i].Id, 148, 4010);
							else if (rand_ <= 20)
								DoTeleport(p_BatalhaReal.Members[i].Id, 148, 4044);
							else if (rand_ <= 30)
								DoTeleport(p_BatalhaReal.Members[i].Id, 148, 4077);
							else if (rand_ <= 40)
								DoTeleport(p_BatalhaReal.Members[i].Id, 168, 4061);
							else if (rand_ <= 50)
								DoTeleport(p_BatalhaReal.Members[i].Id, 168, 4028);
							else if (rand_ <= 60)
								DoTeleport(p_BatalhaReal.Members[i].Id, 191, 4080);
							else if (rand_ <= 70)
								DoTeleport(p_BatalhaReal.Members[i].Id, 191, 4063);
							else if (rand_ <= 80)
								DoTeleport(p_BatalhaReal.Members[i].Id, 191, 4044);
							else if (rand_ <= 90)
								DoTeleport(p_BatalhaReal.Members[i].Id, 191, 4027);
							else
								DoTeleport(p_BatalhaReal.Members[i].Id, 191, 4010);

							pUser[p_BatalhaReal.Members[i].Id].Vidas = 3;

							p_BatalhaReal.start = true;
							BrState = 1;
							BrTime = 900;
						}
					}
					if (p_BatalhaReal.NumMembers <= 0)
					{
						SendNotice(strFmt("Batalha Real Cancelada por falta de jogadores - Total: [%d].", p_BatalhaReal.NumMembers));
						memset(&p_BatalhaReal, 0x0, sizeof(p_BatalhaReal));
						BrState = -1;
					}
				}
			}
#pragma endregion
			if (BrState == 1 && when.tm_min == 9 && when.tm_sec > 58)
			{
				snprintf(temp, sizeof(temp), "Penalidade Iniciada !!!");
				SendNoticeArea(temp, 140, 4000, 200, 4100);
			}
			if (BrState == 1 && when.tm_min >= 10 && when.tm_min <= 15)
			{
				SendDamage(142, 4007, 162, 4082);
				SendDamage(162, 4021, 174, 4034);
				SendDamage(174, 4007, 195, 4082);
				SendDamage(162, 4055, 174, 4082);
				SendEnvEffect(142, 4007, 162, 4082, 32, 0);
				SendEnvEffect(162, 4021, 174, 4034, 32, 0);
				SendEnvEffect(174, 4007, 195, 4082, 32, 0);
				SendEnvEffect(162, 4055, 174, 4082, 32, 0);
			}
#pragma region >> Resete arena real
			if (BrState == 1 && BrTime == 0 && p_BatalhaReal.start == true)
			{
				if (when.tm_min == 15)
				{
					ClearAreaTeleport(140, 4000, 200, 4100, 2133, 2147);
					SendNotice("Batalha Real Finalizada! - Não houve ganhadores");
					BrState = 0;
					BrTime = 0;
				}
			}
		}
#pragma region Pista de runas entrada
		if ((when.tm_min == 20 || when.tm_min == 40 || when.tm_min == 00) && PistaPlaying == false)
		{//Pista de Runas entrada

			Pista[4].Party[0].MobCount = 1;
			Pista[4].Party[1].MobCount = 1;
			Pista[4].Party[2].MobCount = 1;

			Pista[6].Party[0].MobCount = 100;

			Pista[1].Party[0].MobCount = 0;
			Pista[1].Party[1].MobCount = 0;
			Pista[1].Party[2].MobCount = 0;

			Pista[3].Party[0].MobCount = 1;
			Pista[3].Party[1].MobCount = 1;
			Pista[3].Party[2].MobCount = 1;

			for (int s = 0; s < 7; s++)
			{
				for (int t = 0; t < 3; t++)
				{
					if (Pista[s].Party[t].LeaderID == 0 || strcmp(pMob[Pista[s].Party[t].LeaderID].MOB.MobName, Pista[s].Party[t].LeaderName) != 0)
						continue;

					if (checkCord(Pista[s].Party[t].LeaderID, 3275, 1674, 3317, 1711) == FALSE)
						continue;

					if (pMob[Pista[s].Party[t].LeaderID].Leader != -1 && pMob[Pista[s].Party[t].LeaderID].Leader)
						continue;

					DoTeleport(Pista[s].Party[t].LeaderID, PistaPos[Pista[s].Party[t].Sala][t][0], PistaPos[Pista[s].Party[t].Sala][t][1]);


					for (int i = 0; i < MAX_PARTY; i++)
					{
						int partyconn = pMob[Pista[s].Party[t].LeaderID].PartyList[i];

						if (partyconn <= 0 || partyconn >= MAX_USER) continue;

						if (partyconn > 0 && partyconn < MAX_USER && partyconn != Pista[s].Party[t].LeaderID && pUser[partyconn].Mode == USER_PLAY)
						{
							if (checkCord(partyconn, 3275, 1674, 3317, 1711) == TRUE)
							{
								DoTeleport(partyconn, PistaPos[Pista[s].Party[t].Sala][t][0], PistaPos[Pista[s].Party[t].Sala][t][1]);

							}
						}
					}

					//Pista+0 Lich
					if (s == 0 && t == 0)
						GenerateMob(RUNEQUEST_LV0_LICH2, 0, 0);

					if (s == 0 && t == 1)
						GenerateMob(RUNEQUEST_LV0_LICH1, 0, 0);

					//Pista +1 Torre
					if (s == 1)
					{
						GenerateMob(RUNEQUEST_LV1_TORRE1, 3358, 1582);
						GenerateMob(RUNEQUEST_LV1_TORRE2, 3386, 1548);
						GenerateMob(RUNEQUEST_LV1_TORRE3, 3418, 1582);

						for (int generateindex = RUNEQUEST_LV1_MOB_INITIAL; generateindex <= RUNEQUEST_LV1_MOB_END; generateindex++)
							GenerateMob(generateindex, 0, 0);
					}


					if (s == 2)
						GenerateMob(RUNEQUEST_LV2_MOB_BOSS, 0, 0);

					if (s == 4)
						Pista[s].Party[t].MobCount = 6;

					if (s == 4 && t == 0)
					{
						for (int generateindex = RUNEQUEST_LV4_MOB_INITIAL; generateindex <= RUNEQUEST_LV4_MOB_END; generateindex++)
							GenerateMob(generateindex, 0, 0);
					}
				}
			}

			PistaPlaying = true;
		}
#pragma endregion
#pragma region Pista de runas saída
		if ((when.tm_min == 15 || when.tm_min == 35 || when.tm_min == 55) && PistaPlaying == true)
		{//Pista de Runas saida

			for (int c = MAX_USER; c < MAX_MOB; c++)
			{
				if (pMob[c].Mode == USER_EMPTY)
					continue;

				if (pMob[c].TargetX < 3310 || pMob[c].TargetX > 3588 || pMob[c].TargetY < 1005 || pMob[c].TargetY > 1663)
					continue;

				DeleteMob(c, 3);
			}

			for (int x = 0; x < MAX_USER; x++)
			{
				if (pUser[x].Mode != USER_PLAY)
					continue;

				if (pMob[x].Mode == USER_EMPTY)
					continue;

				if (pMob[x].TargetX < 3310 || pMob[x].TargetX > 3588 || pMob[x].TargetY < 1005 || pMob[x].TargetY > 1663)
					continue;

				if (pMob[x].MOB.CurrentScore.Hp <= 0)
				{
					pMob[x].MOB.CurrentScore.Hp = 1;

					SendScore(x);
				}

				DoTeleport(x, 3294, rand() % 1 == 0 ? 1701 : 1686);
				pUser[x].Ingame.CheckPista = FALSE;
			}
			//Pista +1 - Torre

			//Grupo 1 ganhou
			if (Pista[1].Party[0].MobCount > Pista[1].Party[1].MobCount && Pista[1].Party[0].MobCount > Pista[1].Party[2].MobCount)
			{
				if (Pista[1].Party[0].MobCount != 0) {
					if (Pista[1].Party[0].LeaderID != 0 && strcmp(pMob[Pista[1].Party[0].LeaderID].MOB.MobName, Pista[1].Party[0].LeaderName) == 0)
					{
						STRUCT_ITEM Runa;
						memset(&Runa, 0, sizeof(STRUCT_ITEM));

						Runa.sIndex = PistaRune[1][rand() % 5]; // aqui tambem tem que estar 6 por conta da matriz

						if (Pista[1].Party[0].LeaderID > 0 && Pista[1].Party[0].LeaderID < MAX_USER) {
								PutItem(Pista[1].Party[0].LeaderID, &Runa);
						}

						for (int i = 0; i < MAX_PARTY; i++)
						{
							int partymember = pMob[Pista[1].Party[0].LeaderID].PartyList[i];

							if (partymember >= MAX_USER) continue;

							if (pUser[partymember].Mode != USER_PLAY)
								continue;

							Runa.sIndex = PistaRune[1][rand() % 5];
							PutItem(partymember, &Runa);
						}

						STRUCT_ITEM Prize;
						memset(&Prize, 0, sizeof(STRUCT_ITEM));

						Prize.sIndex = 5134;
						Prize.stEffect[0].cEffect = 43;
						Prize.stEffect[0].cValue = 2;

						PutItem(Pista[1].Party[0].LeaderID, &Prize);
						SystemLog("-system", "-", 0, "etc,questRune complete +1 party1");
					}
				}
			}

			//Grupo 2 ganhou
			else if (Pista[1].Party[1].MobCount > Pista[1].Party[0].MobCount && Pista[1].Party[1].MobCount > Pista[1].Party[2].MobCount)
			{
				if (Pista[1].Party[1].MobCount != 0) {
					if (Pista[1].Party[1].LeaderID != 0 && strcmp(pMob[Pista[1].Party[1].LeaderID].MOB.MobName, Pista[1].Party[1].LeaderName) == 0)
					{
						STRUCT_ITEM Runa;
						memset(&Runa, 0, sizeof(STRUCT_ITEM));

						Runa.sIndex = PistaRune[1][rand() % 5];

						if (Pista[1].Party[1].LeaderID > 0 && Pista[1].Party[1].LeaderID < MAX_USER) {
								PutItem(Pista[1].Party[1].LeaderID, &Runa);
						}

						for (int i = 0; i < MAX_PARTY; i++)
						{
							int partymember = pMob[Pista[1].Party[1].LeaderID].PartyList[i];

							if (partymember >= MAX_USER) continue;

							if (pUser[partymember].Mode != USER_PLAY)
								continue;

							Runa.sIndex = PistaRune[1][rand() % 5];
							PutItem(partymember, &Runa);
						}

						STRUCT_ITEM Prize;
						memset(&Prize, 0, sizeof(STRUCT_ITEM));

						Prize.sIndex = 5134;
						Prize.stEffect[0].cEffect = 43;
						Prize.stEffect[0].cValue = 2;

						PutItem(Pista[1].Party[1].LeaderID, &Prize);
						SystemLog("-system", "-", 0, "etc,questRune complete +1 party2");
					}
				}
			}

			//Grupo 3 ganhou
			else if (Pista[1].Party[2].MobCount > Pista[1].Party[0].MobCount && Pista[1].Party[2].MobCount > Pista[1].Party[1].MobCount)
			{
				if (Pista[1].Party[2].MobCount != 0) {
					if (Pista[1].Party[2].LeaderID != 0 && strcmp(pMob[Pista[1].Party[2].LeaderID].MOB.MobName, Pista[1].Party[2].LeaderName) == 0)
					{
						STRUCT_ITEM Runa;
						memset(&Runa, 0, sizeof(STRUCT_ITEM));

						Runa.sIndex = PistaRune[1][rand() % 5];

						if (Pista[1].Party[2].LeaderID > 0 && Pista[1].Party[2].LeaderID < MAX_USER) {
								PutItem(Pista[1].Party[2].LeaderID, &Runa);
						}

						for (int i = 0; i < MAX_PARTY; i++)
						{
							int partymember = pMob[Pista[1].Party[2].LeaderID].PartyList[i];

							if (partymember >= MAX_USER) continue;

							if (pUser[partymember].Mode != USER_PLAY)
								continue;

							Runa.sIndex = PistaRune[1][rand() % 5];
							PutItem(partymember, &Runa);
						}

						STRUCT_ITEM Prize;
						memset(&Prize, 0, sizeof(STRUCT_ITEM));

						Prize.sIndex = 5134;
						Prize.stEffect[0].cEffect = 43;
						Prize.stEffect[0].cValue = 2;

						PutItem(Pista[1].Party[2].LeaderID, &Prize);
						SystemLog("-system", "-", 0, "etc,questRune complete +1 party3");
					}
				}
			}

			//Pista +3 - Sulrang

			//Grupo 1 ganhou
			if (Pista[3].Party[0].MobCount > Pista[3].Party[1].MobCount && Pista[3].Party[0].MobCount > Pista[3].Party[2].MobCount)
			{
				if (Pista[3].Party[0].MobCount != 0) {
					if (Pista[3].Party[0].LeaderID != 0 && strcmp(pMob[Pista[3].Party[0].LeaderID].MOB.MobName, Pista[3].Party[0].LeaderName) == 0)
					{
						STRUCT_ITEM Runa;
						memset(&Runa, 0, sizeof(STRUCT_ITEM));

						Runa.sIndex = PistaRune[3][rand() % 5];

						if (Pista[3].Party[0].LeaderID > 0 && Pista[3].Party[0].LeaderID < MAX_USER)
							PutItem(Pista[3].Party[0].LeaderID, &Runa);

						for (int i = 0; i < MAX_PARTY; i++)
						{
							int partymember = pMob[Pista[3].Party[0].LeaderID].PartyList[i];

							if (partymember >= MAX_USER) continue;

							if (pUser[partymember].Mode != USER_PLAY)
								continue;

							Runa.sIndex = PistaRune[3][rand() % 5];
							PutItem(partymember, &Runa);
						}

						STRUCT_ITEM Prize;
						memset(&Prize, 0, sizeof(STRUCT_ITEM));

						Prize.sIndex = 5134;
						Prize.stEffect[0].cEffect = 43;
						Prize.stEffect[0].cValue = 4;

						PutItem(Pista[3].Party[0].LeaderID, &Prize);
						SystemLog("-system", "-", 0, "etc,questRune complete +3 party1");
					}
				}
			}

			//Grupo 2 ganhou
			else if (Pista[3].Party[1].MobCount > Pista[3].Party[0].MobCount && Pista[3].Party[1].MobCount > Pista[3].Party[2].MobCount)
			{
				if (Pista[3].Party[1].MobCount != 0) {
					if (Pista[3].Party[1].LeaderID != 0 && strcmp(pMob[Pista[3].Party[1].LeaderID].MOB.MobName, Pista[3].Party[1].LeaderName) == 0)
					{
						STRUCT_ITEM Runa;
						memset(&Runa, 0, sizeof(STRUCT_ITEM));

						Runa.sIndex = PistaRune[3][rand() % 5];

						if (Pista[3].Party[1].LeaderID > 0 && Pista[3].Party[1].LeaderID < MAX_USER)
							PutItem(Pista[3].Party[1].LeaderID, &Runa);

						for (int i = 0; i < MAX_PARTY; i++)
						{
							int partymember = pMob[Pista[3].Party[1].LeaderID].PartyList[i];

							if (partymember >= MAX_USER) continue;

							if (pUser[partymember].Mode != USER_PLAY)
								continue;

							Runa.sIndex = PistaRune[3][rand() % 5];
							PutItem(partymember, &Runa);
						}

						STRUCT_ITEM Prize;
						memset(&Prize, 0, sizeof(STRUCT_ITEM));

						Prize.sIndex = 5134;
						Prize.stEffect[0].cEffect = 43;
						Prize.stEffect[0].cValue = 4;

						PutItem(Pista[3].Party[3].LeaderID, &Prize);
						SystemLog("-system", "-", 0, "etc,questRune complete +3 party2");
					}
				}
			}

			//Grupo 3 ganhou
			else if (Pista[3].Party[2].MobCount > Pista[3].Party[0].MobCount && Pista[3].Party[2].MobCount > Pista[3].Party[1].MobCount)
			{
				if (Pista[3].Party[2].MobCount != 0) {
					if (Pista[3].Party[2].LeaderID != 0 && strcmp(pMob[Pista[3].Party[2].LeaderID].MOB.MobName, Pista[3].Party[2].LeaderName) == 0)
					{
						STRUCT_ITEM Runa;
						memset(&Runa, 0, sizeof(STRUCT_ITEM));

						Runa.sIndex = PistaRune[3][rand() % 5];

						if (Pista[3].Party[2].LeaderID > 0 && Pista[3].Party[2].LeaderID < MAX_USER)
							PutItem(Pista[3].Party[2].LeaderID, &Runa);

						for (int i = 0; i < MAX_PARTY; i++)
						{
							int partymember = pMob[Pista[3].Party[2].LeaderID].PartyList[i];

							if (partymember >= MAX_USER) continue;

							if (pUser[partymember].Mode != USER_PLAY)
								continue;

							Runa.sIndex = PistaRune[3][rand() % 5];
							PutItem(partymember, &Runa);
						}

						STRUCT_ITEM Prize;
						memset(&Prize, 0, sizeof(STRUCT_ITEM));

						Prize.sIndex = 5134;
						Prize.stEffect[0].cEffect = 43;
						Prize.stEffect[0].cValue = 4;

						PutItem(Pista[3].Party[2].LeaderID, &Prize);
						SystemLog("-system", "-", 0, "etc,questRune complete +3 party3");
					}
				}
			}

			for (int x = 0; x < 7; x++)
			{
				for (int z = 0; z < 3; z++)
				{
					Pista[x].Party[z].LeaderID = 0;
					strncpy(Pista[x].Party[z].LeaderName, " ", 16);
					Pista[x].Party[z].MobCount = 0;
					Pista[x].Party[z].Sala = 0;
				}
			}
			PistaPlaying = false;

		}
#pragma endregion

#pragma region Portao Infernal Start
		if (GetUserInArea(1664, 3584, 1919, 3711, temp) && (when.tm_min == 4 && when.tm_sec == 2 || when.tm_min == 34 && when.tm_sec == 2))
		{
			MSG_STANDARDPARM sm;
			memset(&sm, 0, sizeof(MSG_STANDARDPARM));

			sm.Type = _MSG_StartTime;
			sm.ID = ESCENE_FIELD;
			sm.Size = sizeof(MSG_STANDARDPARM);
			sm.Parm = 1500;

			MapaMulticast(13, 28, (MSG_STANDARD*)&sm, 0);

			int _rand = rand() % 100;
			int __rand = rand() % 100;
			int ___rand = rand() % 100;

			if (_rand < 50)
				CreateMob("Tarantula", 1754, 3674, "npc", 0);
			else
				CreateMob("Tarantula", 1728, 3646, "npc", 0);

			if (__rand < 50)
				CreateMob("Tarantula", 1703, 3635, "npc", 0);
			else
				CreateMob("Tarantula", 1752, 3618, "npc", 0);

			if (___rand < 25)
				GenerateMob(CTARANTULA, 1754, 3674);
			else if (___rand >= 25 && ___rand < 50)
				GenerateMob(CTARANTULA, 1728, 3646);
			else if (___rand >= 50 && ___rand < 75)
				GenerateMob(CTARANTULA, 1703, 3635);
			else
				GenerateMob(CTARANTULA, 1752, 3618);
		}
#pragma endregion
#pragma region Pesa Start
		if (GetUserInArea(1152, 128, 1280, 256, temp) && (when.tm_min == 14 && when.tm_sec == 0 || when.tm_min == 34 && when.tm_sec == 0 || when.tm_min == 54 && when.tm_sec == 0))
		{
			MSG_STANDARDPARM sm;
			memset(&sm, 0, sizeof(MSG_STANDARDPARM));

			sm.Type = _MSG_StartTime;
			sm.ID = ESCENE_FIELD;
			sm.Size = sizeof(MSG_STANDARDPARM);
			sm.Parm = 900;

			MapaMulticast(9, 1, (MSG_STANDARD*)&sm, 0);

			//Pesa A
			for (int i = NIGHTMARE_A_INITIAL; i <= NIGHTMARE_A_END; i++)
				GenerateMob(i, 0, 0);

		}

		if (GetUserInArea(1024, 256, 1152, 384, temp) > 0 && (when.tm_min == 9 && when.tm_sec == 0 || when.tm_min == 29 && when.tm_sec == 0 || when.tm_min == 49 && when.tm_sec == 0))
		{
			MSG_STANDARDPARM sm;
			memset(&sm, 0, sizeof(MSG_STANDARDPARM));

			sm.Type = _MSG_StartTime;
			sm.ID = ESCENE_FIELD;
			sm.Size = sizeof(MSG_STANDARDPARM);
			sm.Parm = 900;

			MapaMulticast(8, 2, (MSG_STANDARD*)&sm, 0);

			//Pesa M
			for (int i = NIGHTMARE_M_INITIAL; i <= NIGHTMARE_M_END; i++)
				GenerateMob(i, 0, 0);


		}

		if (GetUserInArea(1280, 256, 1408, 384, temp) > 0 && (when.tm_min == 24 && when.tm_sec == 0 || when.tm_min == 44 && when.tm_sec == 0 || when.tm_min == 4 && when.tm_sec == 0))
		{
			MSG_STANDARDPARM sm;
			memset(&sm, 0, sizeof(MSG_STANDARDPARM));

			sm.Type = _MSG_StartTime;
			sm.ID = ESCENE_FIELD;
			sm.Size = sizeof(MSG_STANDARDPARM);
			sm.Parm = 900;

			MapaMulticast(10, 2, (MSG_STANDARD*)&sm, 0);

			//Pesa N
			for (int i = NIGHTMARE_N_INITIAL; i <= NIGHTMARE_N_END; i++)
				GenerateMob(i, 0, 0);

		}
#pragma endregion
#pragma region Avisos
		/*if ((when.tm_min == 40) && when.tm_sec == 0)
		{
			SendNotice("Seja bem vindo");
			return;
		}*/

		/*if ((when.tm_min == 40) && when.tm_sec == 10)
		{
			SendNotice("Você é NOVATO por aqui ? Digite /novato");
			return;
		}*/

		/*if ((when.tm_min == 40) && when.tm_sec == 20)
		{
			SendNotice("Bom Jogo a Todos!");
			return;
		}*/
#pragma endregion
	}
#pragma endregion
#pragma region Item Decay and Quest Event Time
	if ((SecCounter % 2) == 0)
		ProcessDecayItem();

	int UsersDie = 0;

	int Sec4 = SecCounter % 4;

	if (SecCounter % 4 == 0)
	{
		ProcessRanking();

		for (int i = 0; i < 3; i++)
		{
			for (int j = 0; j < 10; j++)
			{
				if (WaterClear1[i][j] > 1)
					WaterClear1[i][j]--;

				else if (WaterClear1[i][j] == 1 && j <= 7)
				{
					ClearAreaTeleport(WaterScrollPosition[i][j][0] - 8, WaterScrollPosition[i][j][1] - 8, WaterScrollPosition[i][j][0] + 8, WaterScrollPosition[i][j][1] + 8, 1965, 1769);
					WaterClear1[i][j] = 0;
				}
				else if (WaterClear1[i][j] == 1 && j > 7)
				{
					ClearAreaTeleport(WaterScrollPosition[i][j][0] - 12, WaterScrollPosition[i][j][1] - 12, WaterScrollPosition[i][j][0] + 12, WaterScrollPosition[i][j][1] + 12, 1965, 1769);
					WaterClear1[i][j] = 0;
				}
			}
		}

		if (CartaTime > 1)
			CartaTime--;

		if (CartaTime == 1)
		{
			CartaTime = 60;

			if (CartaSala == 1)
				ClearAreaTeleport(778, 3652, 832, 3698, CartaPos[1][0], CartaPos[1][1]);

			else if (CartaSala == 2)
				ClearAreaTeleport(836, 3652, 890, 3698, CartaPos[2][0], CartaPos[2][1]);

			else if (CartaSala == 3)
				ClearAreaTeleport(834, 3595, 889, 3645, CartaPos[3][0], CartaPos[3][1]);


			if (CartaSala == 4)
			{
				ClearArea(776, 3595, 834, 3648);
				CartaTime = 0;
				CartaSala = 0;
			}

			else
				CartaSala++;

			MSG_STANDARDPARM sm;

			sm.Type = _MSG_StartTime;
			sm.ID = ESCENE_FIELD;
			sm.Size = sizeof(MSG_STANDARDPARM);
			sm.Parm = CartaTime * 2;

			MapaMulticast(6, 28, (MSG_STANDARD*)&sm, 0);
		}
	}
#pragma endregion

	CCastleZakum::ProcessSecTimer();
	//CCubo::ProcessSecTimer();

	int Sec16 = SecCounter % 16;
	int Sec32 = SecCounter % 32;

	int i = 0;

	for (i = 1; i < MAX_USER; i++)
	{
		/*if (i % 32 == Sec32 && pUser[i].Mode && pUser[i].Mode != USER_SAVING4QUIT)
			CheckIdle(i);*/

		if (i % 16 == Sec16 && pMob[i].MOB.CurrentScore.Hp > 0 && pUser[i].Mode == USER_PLAY)
		{
			RegenMob(i);
			ProcessAffect(i);
			UsersDie++;
		}

	}

	if (BrState == 2 && i % 8 == Sec16 && BRItem > 0)
	{
		if (BrMod < 9)
		{
			if (BrMod >= 7)
			{
				SendDamage(2608, 1708, 2622, 1711);
				SendDamage(2608, 1739, 2622, 1743);
				SendEnvEffect(2608, 1708, 2622, 1711, 32, 0);
				SendEnvEffect(2608, 1739, 2622, 1743, 32, 0);
			}
		}
		else
		{
			SendDamage(2608, 1708, 2622, 1718);
			SendDamage(2608, 1733, 2622, 1743);
			SendEnvEffect(2608, 1708, 2622, 1718, 32, 0);
			SendEnvEffect(2608, 1733, 2622, 1743, 32, 0);
		}
	}

	if (RankingProgress <= 1) // dano em area apartir de certo tempo
	{
		if (RankingProgress == 1 && SecCounter % 6 == 0)
		{
			if (SecCounter % 6 == 0)
			{
				SendDamage(2124, 2140, 2147, 2143);
				SendDamage(2124, 2152, 2147, 2155);
				SendDamage(2141, 2140, 2147, 2155);
				SendDamage(2124, 2140, 2129, 2155);
				SendEnvEffect(2124, 2140, 2147, 2143, 32, 0);
				SendEnvEffect(2124, 2152, 2147, 2155, 32, 0);
				SendEnvEffect(2141, 2140, 2147, 2155, 32, 0);
				SendEnvEffect(2124, 2140, 2130, 2155, 32, 0);
			}
		}
	}

	if (SecCounter % 6 == 0)
	{
		SendEnvEffectKingdom(1050, 2108, 1070, 2146, 32, 0, REINO_BLUE);
		SendEnvEffectKingdom(1066, 2133, 1098, 2146, 32, 0, REINO_BLUE);
		SendDamageKingdom(1050, 2108, 1070, 2146, REINO_BLUE);
		SendDamageKingdom(1066, 2133, 1098, 2146, REINO_BLUE);

		SendEnvEffectKingdom(1230, 1947, 1245, 1988, 32, 0, REINO_RED);
		SendEnvEffectKingdom(1204, 1948, 1231, 1962, 32, 0, REINO_RED);
		SendDamageKingdom(1230, 1947, 1245, 1988, REINO_RED);
		SendDamageKingdom(1204, 1948, 1231, 1962, REINO_RED);
	}

	if (SecCounter % 5 == 0)
	{
		SendEnvEffectLeader(3436, 1285, 3450, 1299, 32, 0);
		SendDamageLeader(3436, 1285, 3450, 1299);
		SendEnvEffectLeader(3368, 1285, 3382, 1299, 32, 0);
		SendDamageLeader(3368, 1285, 3382, 1299);
		SendEnvEffectLeader(3384, 1302, 3398, 1316, 32, 0);
		SendDamageLeader(3384, 1302, 3398, 1316);
		SendEnvEffectLeader(3438, 1320, 3452, 1334, 32, 0);
		SendDamageLeader(3438, 1320, 3452, 1334);
		SendEnvEffectLeader(3369, 1320, 3383, 1334, 32, 0);
		SendDamageLeader(3369, 1320, 3383, 1334);
		SendEnvEffectLeader(3385, 1336, 3399, 1350, 32, 0);
		SendDamageLeader(3385, 1336, 3399, 1350);
		SendEnvEffectLeader(3402, 1353, 3416, 1367, 32, 0);
		SendDamageLeader(3402, 1353, 3416, 1367);
		SendEnvEffectLeader(3436, 1371, 3450, 1385, 32, 0);
		SendDamageLeader(3436, 1371, 3450, 1385);
		SendEnvEffectLeader(3368, 1371, 3382, 1385, 32, 0);
		SendDamageLeader(3368, 1371, 3382, 1385);
		SendEnvEffectLeader(3402, 1387, 3416, 1401, 32, 0);
		SendDamageLeader(3402, 1387, 3416, 1401);
		SendEnvEffectLeader(3420, 1286, 3434, 1300, 32, 0);
		SendDamageLeader(3420, 1286, 3434, 1300);
		SendEnvEffectLeader(3351, 1286, 3365, 1300, 32, 0);
		SendDamageLeader(3351, 1286, 3365, 1300);
		SendEnvEffectLeader(3402, 1302, 3416, 1316, 32, 0);
		SendDamageLeader(3402, 1302, 3416, 1316);
		SendEnvEffectLeader(3420, 1320, 3434, 1334, 32, 0);
		SendDamageLeader(3420, 1320, 3434, 1334);
		SendEnvEffectLeader(3371, 1337, 3385, 1351, 32, 0);
		SendDamageLeader(3371, 1337, 3385, 1351);
		SendEnvEffectLeader(3436, 1337, 3450, 1351, 32, 0);
		SendDamageLeader(3436, 1337, 3450, 1351);
		SendEnvEffectLeader(3385, 1353, 3399, 1367, 32, 0);
		SendDamageLeader(3385, 1353, 3399, 1367);
		SendEnvEffectLeader(3352, 1370, 3366, 1384, 32, 0);
		SendDamageLeader(3352, 1370, 3366, 1384);
		SendEnvEffectLeader(3419, 1370, 3433, 1384, 32, 0);
		SendDamageLeader(3419, 1370, 3433, 1384);
		SendEnvEffectLeader(3385, 1387, 3399, 1401, 32, 0);
		SendDamageLeader(3385, 1387, 3399, 1401);
		SendEnvEffectLeader(3402, 1286, 3416, 1300, 32, 0);
		SendDamageLeader(3402, 1286, 3416, 1300);
		SendEnvEffectLeader(3352, 1302, 3366, 1316, 32, 0);
		SendDamageLeader(3352, 1302, 3366, 1316);
		SendEnvEffectLeader(3420, 1302, 3434, 1316, 32, 0);
		SendDamageLeader(3420, 1302, 3434, 1316);
		SendEnvEffectLeader(3401, 1320, 3415, 1334, 32, 0);
		SendDamageLeader(3401, 1320, 3415, 1334);
		SendEnvEffectLeader(3420, 1336, 3434, 1350, 32, 0);
		SendDamageLeader(3420, 1336, 3434, 1350);
		SendEnvEffectLeader(3436, 1353, 3450, 1367, 32, 0);
		SendDamageLeader(3436, 1353, 3450, 1367);
		SendEnvEffectLeader(3368, 1353, 3382, 1367, 32, 0);
		SendDamageLeader(3368, 1353, 3382, 1367);
		SendEnvEffectLeader(3401, 1370, 3415, 1384, 32, 0);
		SendDamageLeader(3401, 1370, 3415, 1384);
		SendEnvEffectLeader(3435, 1387, 3449, 1401, 32, 0);
		SendDamageLeader(3435, 1387, 3449, 1401);
		SendEnvEffectLeader(3369, 1387, 3383, 1401, 32, 0);
		SendDamageLeader(3369, 1387, 3383, 1401);
		SendEnvEffectLeader(3387, 1285, 3401, 1299, 32, 0);
		SendDamageLeader(3387, 1285, 3401, 1299);
		SendEnvEffectLeader(3368, 1302, 3382, 1316, 32, 0);
		SendDamageLeader(3368, 1302, 3382, 1316);
		SendEnvEffectLeader(3436, 1302, 3450, 1316, 32, 0);
		SendDamageLeader(3436, 1302, 3450, 1316);
		SendEnvEffectLeader(3384, 1319, 3398, 1333, 32, 0);
		SendDamageLeader(3384, 1319, 3398, 1333);
		SendEnvEffectLeader(3402, 1335, 3416, 1349, 32, 0);
		SendDamageLeader(3402, 1335, 3416, 1349);
		SendEnvEffectLeader(3419, 1353, 3433, 1367, 32, 0);
		SendDamageLeader(3419, 1353, 3433, 1367);
		SendEnvEffectLeader(3352, 1353, 3366, 1367, 32, 0);
		SendDamageLeader(3352, 1353, 3366, 1367);
		SendEnvEffectLeader(3385, 1370, 3399, 1384, 32, 0);
		SendDamageLeader(3385, 1370, 3399, 1384);
		SendEnvEffectLeader(3419, 1387, 3433, 1401, 32, 0);
		SendDamageLeader(3419, 1387, 3433, 1401);
		SendEnvEffectLeader(3352, 1387, 3366, 1401, 32, 0);
		SendDamageLeader(3352, 1387, 3366, 1401);
		SendEnvEffectLeader(3335, 1286, 3349, 1300, 32, 0);
		SendDamageLeader(3335, 1286, 3349, 1300);
		SendEnvEffectLeader(3335, 1302, 3349, 1316, 32, 0);
		SendDamageLeader(3335, 1302, 3349, 1316);
		SendEnvEffectLeader(3335, 1354, 3349, 1368, 32, 0);
		SendDamageLeader(3335, 1354, 3349, 1368);
		SendEnvEffectLeader(3335, 1371, 3349, 1385, 32, 0);
		SendDamageLeader(3335, 1371, 3349, 1385);
	}

	for (int k = 0; k < MAX_MOB_MERC; k++)
	{
		if (pMobMerc[k].RenewTime == 0 || pMobMerc[k].RebornTime == 0 || pMobMerc[k].GenerateIndex == 0)
			continue;

		if (SecCounter % pMobMerc[k].RenewTime == 0)
			memmove_s(pMobMerc[k].Stock, sizeof(pMobMerc[k].Stock), pMobMerc[k].MaxStock, sizeof(pMobMerc[k].Stock));

		if (SecCounter % pMobMerc[k].RebornTime == 0)
			GenerateMob(pMobMerc[k].GenerateIndex, 0, 0);
	}

	int Sec6 = SecCounter % 6;

#pragma region Movimento / fala dos NPCS 
	int initial = Sec6 + MAX_USER;
	for (int index = initial; index < MAX_MOB; index += 6)
	{
		int Mode = pMob[index].Mode;
		int Clan = pMob[index].MOB.Clan;

		if (Mode)
		{
			if (Mode == MOB_IDLE)
			{
				if (pMob[index].MOB.CurrentScore.Hp <= 0)
				{
					//Log("err,standingby processer delete hp zero mob", "-system", 0);
					DeleteMob(index, 1);
					continue;
				}
				ProcessAffect(index);
				pMobGrid[pMob[index].TargetY][pMob[index].TargetX] = index;
			}

			if (Mode == MOB_PEACE)
			{
				int chp = pMob[index].MOB.CurrentScore.Hp;
				if (chp <= 0)
				{
					//Log("err,standingby processer delete hp zero mob", "-system", 0);
					DeleteMob(index, 1);
					continue;
				}

				ProcessAffect(index);

				if (pMob[index].GenerateIndex != RUNEQUEST_LV6_MOB_BOSS && pMob[index].TargetX >= 3423 && pMob[index].TargetX <= 3442 && pMob[index].TargetY >= 1492 && pMob[index].TargetY <= 1511)
				{
					if (pMob[index].GenerateIndex >= RUNEQUEST_LV6_MOB_INITIAL2 && pMob[index].GenerateIndex <= RUNEQUEST_LV6_MOB_END2)
					{
						if (Pista[6].Party[0].MobCount < 100 && Pista[6].Party[0].MobCount != 0)
							Pista[6].Party[0].MobCount++;
					}

					DeleteMob(index, 3);
					continue;
				}
				int Progress = pMob[index].SegmentProgress;

				if (Progress < 0 || Progress > MAX_SEGMENT)
				{
					pMob[index].SegmentProgress = 0;
					Progress = 0;
				}
				int Processor = pMob[index].StandingByProcessor();

				if (Processor & 0x10000000)
				{
					int Target = Processor & 0xFFFFFFF;

					SetBattle(index, Processor & 0xFFFFFFF);

					int Leader = pMob[index].Leader;

					if (Leader <= 0)
						Leader = index;

					for (int l = 0; l < MAX_PARTY; ++l)
					{
						int party = pMob[Leader].PartyList[l];

						if (party > MAX_USER)
						{
							if (pMob[party].Mode && pMob[party].MOB.CurrentScore.Hp > 0)
								SetBattle(party, Target);

							else
							{
								if (pMob[party].Mode)
									DeleteMob(party, 1);

								pMob[Leader].PartyList[l] = 0;
							}
						}
					}

					for (int l = 0; l < MAX_PARTY; ++l)
					{
						int party = pMob[Leader].Evocations[l];

						if (party > MAX_USER)
						{
							if (pMob[party].Mode && pMob[party].MOB.CurrentScore.Hp > 0)
								SetBattle(party, Target);

							else
							{
								if (pMob[party].Mode)
									DeleteMob(party, 1);

								pMob[Leader].Evocations[l] = 0;
							}
						}
					}

					if (Target < MAX_USER)
					{
						int leader = pMob[Target].Leader;

						if (leader <= 0)
							leader = Target;

						for (int n = 0; n < MAX_PARTY; n++)
						{
							int party = pMob[leader].PartyList[n];
							if (party > MAX_USER)
							{
								if (pMob[party].Mode && pMob[party].MOB.CurrentScore.Hp > 0)
									SetBattle(party, index);

								else
								{
									if (pMob[party].Mode)
										DeleteMob(party, 1);

									pMob[leader].PartyList[n] = 0;
								}
							}
						}

						for (int n = 0; n < MAX_PARTY; n++)
						{
							int party = pMob[leader].Evocations[n];
							if (party > MAX_USER)
							{
								if (pMob[party].Mode && pMob[party].MOB.CurrentScore.Hp > 0)
									SetBattle(party, index);

								else
								{
									if (pMob[party].Mode)
										DeleteMob(party, 1);

									pMob[leader].Evocations[n] = 0;
								}
							}
						}
					}
				}
				else
				{
					if (Processor & 1)
					{
						//SendSay(index, "Processor 0x1");
						MSG_Action sm;

						if (GetEmptyMobGrid(index, &pMob[index].NextX, &pMob[index].NextY) == FALSE)
							continue;

						GetAction(index, pMob[index].NextX, pMob[index].NextY, (MSG_Action*)&sm);

						if (pMob[index].NextX == pMob[index].TargetX && pMob[index].NextY == pMob[index].TargetY)
							continue;

						sm.Speed = BASE_GetSpeed(&pMob[index].MOB.CurrentScore);
						sm.Effect = 0;

						GridMulticast(index, pMob[index].NextX, pMob[index].NextY, (MSG_STANDARD*)&sm);

						int progres = pMob[index].SegmentProgress;

						if (Progress != progres)
						{
							if (progres >= 0 && progres < MAX_SEGMENT && pMob[index].GenerateIndex >= 0 && pMob[index].GenerateIndex < MAX_NPCGENERATOR && mNPCGen.pList[pMob[index].GenerateIndex].SegmentAction[Progress][0])
								SendSay(index, mNPCGen.pList[pMob[index].GenerateIndex].SegmentAction[Progress]);
						}

						if (pMob[index].GenerateIndex >= RUNEQUEST_LV2_MOB_INITIAL && pMob[index].GenerateIndex <= RUNEQUEST_LV2_MOB_END)
						{
							if (pMob[index].TargetX >= 3373 && pMob[index].TargetX <= 3407 && pMob[index].TargetY >= 1420 && pMob[index].TargetY <= 1453)
								DeleteMob(index, 3);
						}
					}
					if (Processor & 0x10)
					{
						//SendSay(index, "Processor 0x10");
						int progres = pMob[index].SegmentProgress;

						if (Progress != progres)
						{
							if (progres >= 0 && progres < MAX_SEGMENT && pMob[index].GenerateIndex >= 0 && pMob[index].GenerateIndex < MAX_NPCGENERATOR && mNPCGen.pList[pMob[index].GenerateIndex].FleeAction[Progress][0])
								SendSay(index, mNPCGen.pList[pMob[index].GenerateIndex].FleeAction[Progress]);
						}
					}
					else
					{
						if (Processor & 0x100)
						{
							DeleteMob(index, 3);
							continue;
						}
						if (Processor & 0x1000)
						{
							//SendSay(index, "Processor 0x1000");
							pMob[index].GetRandomPos();

							if (pMob[index].NextX == pMob[index].TargetX && pMob[index].NextY == pMob[index].TargetY)
								continue;

							MSG_Action sm;

							if (GetEmptyMobGrid(index, &pMob[index].NextX, &pMob[index].NextY) == FALSE)
								continue;

							GetAction(index, pMob[index].NextX, pMob[index].NextY, (MSG_Action*)&sm);

							sm.Speed = BASE_GetSpeed(&pMob[index].MOB.CurrentScore);
							sm.Effect = 0;

							GridMulticast(index, pMob[index].NextX, pMob[index].NextY, (MSG_STANDARD*)&sm);
						}

						if (Processor & 2)
							DoTeleport(index, pMob[index].NextX, pMob[index].NextY);

						if (Processor & 0x10000)
						{
							//SendSay(index, "Processor 0x10000");
							if (pMob[index].GenerateIndex >= RUNEQUEST_LV6_MOB_INITIAL && pMob[index].GenerateIndex <= RUNEQUEST_LV6_MOB_END)
							{
								if (Pista[6].Party[0].MobCount < 100 && Pista[6].Party[0].MobCount != 0)
									Pista[6].Party[0].MobCount++;
							}

							DeleteMob(index, 3);
							continue;
						}
					}
				}
			}
		}
	}
#pragma endregion

	Sec4 = SecCounter % 4;

//#pragma region Ataque / fala em ação dos mobs
//	for (int index = Sec4 + MAX_USER; index < MAX_MOB; index += 4)
//	{
//		if (pMob[index].Mode != MOB_COMBAT)
//			continue;
//
//		int flag = 0;
//
//		if (pMob[index].MOB.Clan == 4)
//			flag = FALSE;
//
//		if (pMob[index].MOB.CurrentScore.Hp <= 0)
//		{
//			pMob[index].MOB.CurrentScore.Hp = 0;
//
//
//			DeleteMob(index, 1);
//			continue;
//		}
//
//		if (index % 16 == Sec16)
//			ProcessAffect(index);
//
//		if (pMob[index].GenerateIndex != RUNEQUEST_LV6_MOB_BOSS && pMob[index].TargetX >= 3423 && pMob[index].TargetX <= 3442 && pMob[index].TargetY >= 1492 && pMob[index].TargetY <= 1511)
//		{
//			if (pMob[index].GenerateIndex >= RUNEQUEST_LV6_MOB_INITIAL2 && pMob[index].GenerateIndex <= RUNEQUEST_LV6_MOB_END2)
//			{
//				if (Pista[6].Party[0].MobCount < 100 && Pista[6].Party[0].MobCount != 0)
//					Pista[6].Party[0].MobCount++;
//			}
//
//			DeleteMob(index, 3);
//			continue;
//		}
//
//		int Target = pMob[index].CurrentTarget;
//
//		if (Target > 0 && Target < MAX_MOB)
//		{
//			int leader = pMob[index].Leader;
//			if (leader == MOB_EMPTY)
//				leader = index;
//
//			int targetLeader = pMob[Target].Leader;
//
//			if (targetLeader == MOB_EMPTY)
//				targetLeader = Target;
//
//			int indexguild = pMob[index].MOB.Guild;
//			if (pMob[index].GuildDisable)
//				indexguild = 0;
//
//			int targetguild = pMob[Target].MOB.Guild;
//			if (pMob[Target].GuildDisable)
//				targetguild = 0;
//
//			if (indexguild == 0 && targetguild == 0)
//				indexguild = -1;
//
//			if (leader == targetLeader || indexguild == targetguild)
//				pMob[index].RemoveEnemyList(Target);
//		}
//
//		int BattleMode = pMob[index].BattleProcessor();
//
//		if (BattleMode & 0x20)
//		{
//			DeleteMob(index, 3);
//			continue;
//		}
//
//		if (BattleMode & 0x1000)
//		{
//			if (pMob[index].MOB.Equip[0].sIndex == 206)
//				pMob[index].CitizenDrop = 0;
//
//			//SendSay(index, "BattleMode 0x1000");
//
//			if (Target <= MOB_EMPTY || Target >= MAX_MOB)
//				continue;
//
//			if (pMob[Target].MOB.CurrentScore.Hp <= 0)
//				continue;
//
//			//MSG_AttackOne sm;
//
//			p39D sm{ 0 };
//
//			int village = BASE_GetVillage(pMob[Target].TargetX, pMob[Target].TargetY);
//
//			unsigned char mapatt = GetAttribute(pMob[Target].TargetX, pMob[Target].TargetY);
//
//			/*if (village >= 0 && village <= 4 && Target < MAX_USER && index >= MAX_USER)   //DESATIVAR BUG
//			{
//				if ((mapatt & 4) == 0 && (mapatt & 0x40) == 0)
//				{
//					FILE *fpp = NULL;
//
//					fpp = fopen("AttackDieTeste.txt", "a+");
//
//					//fprintf(fpp, "nome:%s x:%d y:%d conn:%d mode:%d atname:%s atx:%d aty:%d idx:%d\n", pMob[Target].MOB.MobName, pMob[Target].TargetX, pMob[Target].TargetY, Target, pUser[Target].Mode, pMob[index].MOB.MobName, pMob[index].TargetX, pMob[index].TargetY, index);
//
//					fclose(fpp);
//				}
//			}*/
//			
//
//			GetAttack(index, Target, &sm);
//
//			sm.FlagLocal = 0;
//
//			int targetbackup = Target;
//
//			Target = sm.Target.TargetID;
//
//			//if (GetInHalf(Target, index) == 0)
//			//{
//			//	FILE* fp = NULL;
//
//			//	fp = fopen("Gethalf.txt", "a+");
//
//			//	if (fp != NULL)
//			//	{
//			//		//fprintf(fp, "Attacker(%s, %d, %d, %d, %d, %d, %d) Targetbackup(%s, %d, %d, %d, %d, %d, %d) Target(%s, %d, %d, %d, %d, %d, %d)\n",
//			//		//pMob[index].MOB.MobName, index, pMob[index].TargetX, pMob[index].TargetY, targetbackup, Target, pMob[index].CurrentTarget,
//			//		//pMob[targetbackup].MOB.MobName, targetbackup, pMob[targetbackup].TargetX, pMob[targetbackup].TargetY, index, Target, pMob[targetbackup].CurrentTarget,
//			//		//pMob[Target].MOB.MobName, Target, pMob[Target].TargetX, pMob[Target].TargetY, targetbackup, Target, pMob[Target].CurrentTarget);
//
//			//		int sx1 = pMob[index].TargetX - HALFGRIDX;
//			//		int sy1 = pMob[index].TargetY - HALFGRIDY;
//			//		int sx2 = pMob[index].TargetX + HALFGRIDX;
//			//		int sy2 = pMob[index].TargetY + HALFGRIDY;
//
//			//		for (int y = sy1; y < sy2; y++)
//			//		{
//			//			for (int x = sx1; x < sx2; x++)
//			//			{
//			//				if (x < 0 || x >= MAX_GRIDX || y < 0 || y >= MAX_GRIDY)
//			//					continue;
//
//			//				int tmob = pMobGrid[y][x];
//
//			//				if (tmob <= 0 || tmob >= MAX_MOB)
//			//					continue;
//
//			//				//"fprintf(fp, "\tindex:%d nome:%s \r\n", tmob, pMob[tmob].MOB.MobName);
//			//			}
//			//		}
//
//			//		fclose(fp);
//			//	}
//
//			//	continue;
//			//}
//
//			int skill = sm.SkillIndex;
//
//			//109 : Raio Vermelho
//			//110 : Empurrão
//			//111 : Chão de espinhos
//			if (skill == 109 || skill == 110 || skill == 111)
//				goto KefraAttackLabel;
//
//			if (skill >= 0 && skill < MAX_SKILLINDEX && sm.SkillParm == 0)
//			{
//				if (skill == 33)
//					sm.Motion = 253;
//
//				int kind = ((skill % MAX_SKILL / 8) + 1);
//
//				if (kind >= 1 && kind <= 3)
//				{
//					int special = pMob[index].MOB.CurrentScore.Special[kind];
//					BOOL NeedUpdate = FALSE;
//
//					if (SetAffect(Target, skill, 100, special))
//						NeedUpdate = TRUE;
//
//					if (SetTick(Target, skill, 100, special))
//						NeedUpdate = TRUE;
//
//					if (NeedUpdate == TRUE)
//						SendScore(Target);
//				}
//			}
//
//			if (Target < MAX_USER && sm.Dam[0].Damage > 0)
//			{
//				int attackdex = pMob[index].MOB.CurrentScore.Dex / 5;
//
//				if (pMob[index].MOB.LearnedSkill & 0x1000000)
//					attackdex += 100;
//
//				if (pMob[index].MOB.Rsv & 0x40)
//					attackdex += 500;
//
//				int parryretn = WGetParryRate(&pMob[Target].MOB, pMob[Target].Parry, attackdex, pMob[index].MOB.Rsv);
//
//				if (sm.SkillIndex == 79 || sm.SkillIndex == 22)
//					parryretn = 30 * parryretn / 100;
//
//				int rd = rand() % 1000 + 1;
//
//				if (rd < parryretn)
//				{
//					sm.Dam[0].Damage = -3;
//
//					if ((pMob[Target].MOB.Rsv & 0x200) != 0 && rd < 100)
//						sm.Dam[0].Damage = -4;
//				}
//
//				else if (pMob[index].MOB.Clan == 4)
//					sm.Dam[0].Damage = (2 * sm.Dam[0].Damage) / 5;
//			}
//
//			int TargetLeader = pMob[Target].Leader;
//
//			if (sm.Dam[0].Damage > 0)
//			{
//				if (TargetLeader <= MOB_EMPTY)
//					TargetLeader = Target;
//
//				SetBattle(TargetLeader, index);
//
//				if (pMob[index].MOB.Clan != 4)
//					SetBattle(index, TargetLeader);
//
//				for (int z = 0; z < MAX_PARTY; z++)
//				{
//					int partyconn = pMob[TargetLeader].PartyList[z];
//					if (partyconn <= MAX_USER)
//						continue;
//
//					if (pMob[partyconn].Mode == MOB_EMPTY || pMob[partyconn].MOB.CurrentScore.Hp <= 0)
//					{
//						if (pMob[partyconn].Mode != MOB_EMPTY)
//						{
//							pMob[partyconn].MOB.CurrentScore.Hp = 0;
//							DeleteMob(partyconn, 1);
//						}
//
//						pMob[TargetLeader].PartyList[z] = MOB_EMPTY;
//						continue;
//					}
//
//					SetBattle(partyconn, index);
//					SetBattle(index, partyconn);
//				}
//
//				for (int z = 0; z < MAX_PARTY; z++)
//				{
//					int partyconn = pMob[TargetLeader].Evocations[z];
//					if (partyconn <= MAX_USER)
//						continue;
//
//					if (pMob[partyconn].Mode == MOB_EMPTY || pMob[partyconn].MOB.CurrentScore.Hp <= 0)
//					{
//						if (pMob[partyconn].Mode != MOB_EMPTY)
//						{
//							pMob[partyconn].MOB.CurrentScore.Hp = 0;
//							DeleteMob(partyconn, 1);
//						}
//
//						pMob[TargetLeader].Evocations[z] = MOB_EMPTY;
//						continue;
//					}
//
//					SetBattle(partyconn, index);
//					SetBattle(index, partyconn);
//				}
//
//				int Summoner = pMob[index].Summoner;
//
//				if (pMob[index].MOB.Clan == 4 && Target >= MAX_USER && Summoner > 0 && Summoner < MAX_USER && pUser[Summoner].Mode == USER_PLAY)
//				{
//					int posX = pMob[Summoner].TargetX;
//					int posY = pMob[Summoner].TargetY;
//					int num = 46;
//					int dam = 0;
//					int exp = 0;
//					int summdam = 0;
//
//					if (pMob[index].TargetX > posX - num && pMob[index].TargetX < posX + num && pMob[index].TargetY > posY - num && pMob[index].TargetY < posY + num)
//					{
//						if (pMob[Target].MOB.CurrentScore.Hp < sm.Dam[0].Damage)
//							summdam = pMob[Target].MOB.CurrentScore.Hp;
//
//						else
//							summdam = sm.Dam[0].Damage;
//					}
//				}
//			}
//
//			if (sm.Dam[0].Damage > 0 || sm.Dam[0].Damage <= -5)
//			{
//				int DamageNow = sm.Dam[0].Damage;
//				int damage = 0;
//				int mountindex = pMob[Target].MOB.Equip[14].sIndex;
//
//				if (Target < MAX_USER && mountindex >= 2360 && mountindex < 2390 && pMob[Target].MOB.Equip[14].stEffect[0].sValue > 0)
//				{
//					DamageNow = (3 * sm.Dam[0].Damage) / 4;
//					damage = sm.Dam[0].Damage - DamageNow;
//
//					if (DamageNow <= 0)
//						DamageNow = 1;
//
//					sm.Dam[0].Damage = DamageNow;
//				}
//
//				for (int c = 0; c < MAX_AFFECT && Target < MAX_USER; c++)
//				{
//					if (pMob[Target].Affect[c].Type == 18)
//					{
//						if (pMob[Target].MOB.CurrentScore.Mp > ((pMob[Target].MOB.CurrentScore.MaxMp / 100) * 10))
//						{
//							int mana = pMob[Target].MOB.CurrentScore.Mp - (DamageNow >> 1);
//
//							if (mana < 0)
//							{
//								DamageNow -= mana;
//								mana = 0;
//							}
//
//							pMob[Target].MOB.CurrentScore.Mp = mana;
//
//							pUser[Target].ReqMp = pUser[Target].ReqMp - (DamageNow >> 1);
//							SetReqMp(Target);
//
//							SendSetHpMp(Target);
//
//							DamageNow = ((DamageNow >> 1) + (DamageNow << 4)) / 80;
//							sm.Dam[0].Damage = DamageNow;
//						}
//					}
//				}
//
//
//				if (pMob[Target].MOB.Equip[13].sIndex == 786)
//				{
//					int sanc = pMob[Target].MOB.Equip[13].stEffect[0].cValue;
//
//					if (sanc < 2)
//						sanc = 2;
//
//					sanc *= 2;
//
//					pMob[Target].MOB.CurrentScore.Hp = pMob[Target].MOB.CurrentScore.Hp - (sm.Dam[0].Damage / sanc);
//				}
//				else if (pMob[Target].MOB.Equip[13].sIndex == 1936)
//				{
//					int sanc = pMob[Target].MOB.Equip[13].stEffect[0].cValue;
//
//					if (sanc < 2)
//						sanc = 2;
//
//					sanc *= 10;
//
//					pMob[Target].MOB.CurrentScore.Hp = pMob[Target].MOB.CurrentScore.Hp - (sm.Dam[0].Damage / sanc);
//				}
//				else if (pMob[Target].MOB.Equip[13].sIndex == 1937)
//				{
//					int sanc = pMob[Target].MOB.Equip[13].stEffect[0].cValue;
//
//					if (sanc < 2)
//						sanc = 2;
//
//					sanc *= 1000;
//
//					pMob[Target].MOB.CurrentScore.Hp = pMob[Target].MOB.CurrentScore.Hp - (sm.Dam[0].Damage / sanc);
//				}
//				else
//				{
//					if (pMob[Target].MOB.CurrentScore.Hp < sm.Dam[0].Damage)
//						pMob[Target].MOB.CurrentScore.Hp = 0;
//
//					else
//						pMob[Target].MOB.CurrentScore.Hp = pMob[Target].MOB.CurrentScore.Hp - sm.Dam[0].Damage;
//				}
//
//				if (Target > MAX_USER && pMob[Target].MOB.Clan == 4)
//					LinkMountHp(Target);
//
//				if (damage > 0)
//					ProcessAdultMount(Target, damage);
//			}
//
//			GridMulticast(pMob[Target].TargetX, pMob[Target].TargetY, (MSG_STANDARD*)&sm, 0);
//
//			if (Target > 0 && Target < MAX_USER)
//			{
//				if (pUser[Target].ReqHp < sm.Dam[0].Damage)
//					pUser[Target].ReqHp = 0;
//
//				else
//					pUser[Target].ReqHp = pUser[Target].ReqHp - sm.Dam[0].Damage;
//
//				SetReqHp(Target);
//				SendSetHpMp(Target);
//			}
//			else
//				SendScore(Target);
//
//			if (pMob[Target].MOB.CurrentScore.Hp <= 0)
//			{
//				pMob[Target].MOB.CurrentScore.Hp = 0;
//
//				MobKilled(Target, index, 0, 0);
//			}
//		}
//
//		//Kefra
//		if (0 == 1)
//		{
//		KefraAttackLabel:
//			MSG_Attack sm;
//			memset(&sm, 0, sizeof(MSG_Attack));
//
//			GetAttackArea(index, &sm);
//			MobAttack(index, sm);
//		}
//
//		if (BattleMode & 0x100)
//		{
//			int TargetID = pMob[index].CurrentTarget;
//			pMob[index].GetTargetPosDistance(TargetID);
//
//			if (pMob[index].NextX == pMob[index].TargetX && pMob[index].NextY == pMob[index].TargetY)
//				continue;
//
//			MSG_Action sm;
//
//			if (GetEmptyMobGrid(index, &pMob[index].NextX, &pMob[index].NextY) == FALSE)
//				continue;
//
//			GetAction(index, pMob[index].NextX, pMob[index].NextY, (MSG_Action*)&sm);
//
//			sm.Speed = BASE_GetSpeed(&pMob[index].MOB.CurrentScore);
//			sm.Effect = 0;
//
//			GridMulticast(index, pMob[index].NextX, pMob[index].NextY, (MSG_STANDARD*)&sm);
//		}
//
//		if (BattleMode & 1)
//		{
//			//SendSay(index, "BattleMode 0x1");
//			Target = pMob[index].CurrentTarget;
//			pMob[index].GetTargetPos(Target);
//
//			if (pMob[index].NextX == pMob[index].TargetX && pMob[index].NextY == pMob[index].TargetY)
//				continue;
//
//			MSG_Action sm;
//
//			if (GetEmptyMobGrid(index, &pMob[index].NextX, &pMob[index].NextY) == FALSE)
//				continue;
//
//			GetAction(index, pMob[index].NextX, pMob[index].NextY, (MSG_Action*)&sm);
//
//			sm.Speed = BASE_GetSpeed(&pMob[index].MOB.CurrentScore);
//			sm.Effect = 0;
//
//			GridMulticast(index, pMob[index].NextX, pMob[index].NextY, (MSG_STANDARD*)&sm);
//		}
//
//		if (BattleMode & 2)
//			DoTeleport(index, pMob[index].NextX, pMob[index].NextY);
//
//		if (BattleMode & 0x10)
//		{
//			//SendSay(index, "BattleMode 0x10");
//			MSG_Action sm;
//
//			if (GetEmptyMobGrid(index, &pMob[index].NextX, &pMob[index].NextY) == FALSE)
//				continue;
//
//			GetAction(index, pMob[index].NextX, pMob[index].NextY, (MSG_Action*)&sm);
//
//			if (pMob[index].NextX == pMob[index].TargetX && pMob[index].NextY == pMob[index].TargetY)
//				continue;
//
//			sm.Speed = BASE_GetSpeed(&pMob[index].MOB.CurrentScore);
//			sm.Effect = 0;
//
//			GridMulticast(index, pMob[index].NextX, pMob[index].NextY, (MSG_STANDARD*)&sm);
//		}
//	}
//#pragma endregion

#pragma region Ataque / fala em ação dos mobs
for (int index = Sec4 + MAX_USER; index < MAX_MOB; index += 4)
{
	if (pMob[index].Mode != MOB_COMBAT)
		continue;

	int flag = 0;

	if (pMob[index].MOB.Clan == 4)
		flag = FALSE;

	if (pMob[index].MOB.CurrentScore.Hp <= 0)
	{
		pMob[index].MOB.CurrentScore.Hp = 0;

		sprintf_s(temp, "err, battleprocessor delete hp 0 idx:%d leader:%d fol0:%d fol1:%d", index, pMob[index].Leader, pMob[index].PartyList[0], pMob[index].PartyList[1]);
		Log(temp, "-system", NULL);

		DeleteMob(index, 1);
		continue;
	}

	if (index % 16 == Sec16)
		ProcessAffect(index);

	if (pMob[index].GenerateIndex != RUNEQUEST_LV6_MOB_BOSS && pMob[index].TargetX >= 3423 && pMob[index].TargetX <= 3442 && pMob[index].TargetY >= 1492 && pMob[index].TargetY <= 1511)
	{
		if (pMob[index].GenerateIndex >= RUNEQUEST_LV6_MOB_INITIAL2 && pMob[index].GenerateIndex <= RUNEQUEST_LV6_MOB_END2)
		{
			if (Pista[6].Party[0].MobCount < 100 && Pista[6].Party[0].MobCount != 0)
				Pista[6].Party[0].MobCount++;
		}

		DeleteMob(index, 3);
		continue;
	}

	int Target = pMob[index].CurrentTarget;

	if (Target > 0 && Target < MAX_MOB)
	{
		int leader = pMob[index].Leader;
		if (leader == MOB_EMPTY)
			leader = index;

		int targetLeader = pMob[Target].Leader;

		if (targetLeader == MOB_EMPTY)
			targetLeader = Target;

		int indexguild = pMob[index].MOB.Guild;
		if (pMob[index].GuildDisable)
			indexguild = 0;

		int targetguild = pMob[Target].MOB.Guild;
		if (pMob[Target].GuildDisable)
			targetguild = 0;

		if (indexguild == 0 && targetguild == 0)
			indexguild = -1;

		if (leader == targetLeader || indexguild == targetguild)
			pMob[index].RemoveEnemyList(Target);
	}

	int BattleMode = pMob[index].BattleProcessor();

	if (BattleMode & 0x20)
	{
		DeleteMob(index, 3);
		continue;
	}

	if (BattleMode & 0x1000)
	{
		if (pMob[index].MOB.Equip[0].sIndex == 206)
			pMob[index].CitizenDrop = 0;

		if (Target <= MOB_EMPTY || Target >= MAX_MOB)
			continue;

		if (pMob[Target].MOB.CurrentScore.Hp <= 0)
			continue;

		p39D sm{ 0 };

		int village = BASE_GetVillage(pMob[Target].TargetX, pMob[Target].TargetY);

		unsigned char mapatt = GetAttribute(pMob[Target].TargetX, pMob[Target].TargetY);

		GetAttack(index, Target, &sm);

		sm.FlagLocal = 0;

		int targetbackup = Target;

		Target = sm.Target.TargetID;

		if (GetInHalf(Target, index) == 0)
		{
			continue;
		}

		int skill = sm.skillId;

		//109 : Raio Vermelho
		//110 : Empurrão
		//111 : Chão de espinhos
		if (skill == 109 || skill == 110 || skill == 111)
			goto KefraAttackLabel;

		if (skill >= 0 && skill < MAX_SKILLINDEX && sm.skillParm == 0)
		{
			if (skill == 33)
				sm.Motion = 253;

			int kind = ((skill % MAX_SKILL / 8) + 1);

			if (kind >= 1 && kind <= 3)
			{
				int special = pMob[index].MOB.CurrentScore.Special[kind];
				BOOL NeedUpdate = FALSE;

				if (SetAffect(Target, skill, 100, special))
					NeedUpdate = TRUE;

				if (SetTick(Target, skill, 100, special))
					NeedUpdate = TRUE;

				if (NeedUpdate == TRUE)
					SendScore(Target);
			}
		}

		if (Target < MAX_USER && sm.Target.Damage > 0)
		{
			int attackdex = pMob[index].MOB.CurrentScore.Dex / 5;

			if (pMob[index].MOB.LearnedSkill & 0x1000000)
				attackdex += 100;

			if (pMob[index].MOB.Rsv & 0x40)
				attackdex += 500;

			int parryretn = WGetParryRate(&pMob[Target].MOB, pMob[Target].Parry, attackdex, pMob[index].MOB.Rsv);


			if (sm.skillId == 79 || sm.skillId == 22)
				parryretn = 30 * parryretn / 100;

			int rd = rand() % 1000 + 1;

			if (rd < parryretn)
			{
				sm.Target.Damage = -3;

				if ((pMob[Target].MOB.Rsv & 0x200) != 0 && rd < 100)
					sm.Target.Damage = -4;
			}

			else if (pMob[index].MOB.Clan == 4)
				sm.Target.Damage = (2 * sm.Target.Damage) / 5;
		}

		int TargetLeader = pMob[Target].Leader;

		if (sm.Target.Damage > 0)
		{
			if (TargetLeader <= MOB_EMPTY)
				TargetLeader = Target;

			SetBattle(TargetLeader, index);

			if (pMob[index].MOB.Clan != 4)
				SetBattle(index, TargetLeader);

			for (int z = 0; z < MAX_PARTY; z++)
			{
				int partyconn = pMob[TargetLeader].PartyList[z];
				if (partyconn <= MAX_USER)
					continue;

				if (pMob[partyconn].Mode == MOB_EMPTY || pMob[partyconn].MOB.CurrentScore.Hp <= 0)
				{
					if (pMob[partyconn].Mode != MOB_EMPTY)
					{
						pMob[partyconn].MOB.CurrentScore.Hp = 0;
						DeleteMob(partyconn, 1);
					}

					pMob[TargetLeader].PartyList[z] = MOB_EMPTY;
					continue;
				}

				SetBattle(partyconn, index);
				SetBattle(index, partyconn);
			}

			for (int z = 0; z < MAX_PARTY; z++)
			{
				int partyconn = pMob[TargetLeader].Evocations[z];
				if (partyconn <= MAX_USER)
					continue;

				if (pMob[partyconn].Mode == MOB_EMPTY || pMob[partyconn].MOB.CurrentScore.Hp <= 0)
				{
					if (pMob[partyconn].Mode != MOB_EMPTY)
					{
						pMob[partyconn].MOB.CurrentScore.Hp = 0;
						DeleteMob(partyconn, 1);
					}

					pMob[TargetLeader].Evocations[z] = MOB_EMPTY;
					continue;
				}

				SetBattle(partyconn, index);
				SetBattle(index, partyconn);
			}

			int Summoner = pMob[index].Summoner;

			if (pMob[index].MOB.Clan == 4 && Target >= MAX_USER && Summoner > 0 && Summoner < MAX_USER && pUser[Summoner].Mode == USER_PLAY)
			{
				int posX = pMob[Summoner].TargetX;
				int posY = pMob[Summoner].TargetY;
				int num = 46;
				int dam = 0;
				int exp = 0;
				int summdam = 0;

				if (pMob[index].TargetX > posX - num && pMob[index].TargetX < posX + num && pMob[index].TargetY > posY - num && pMob[index].TargetY < posY + num)
				{
					if (pMob[Target].MOB.CurrentScore.Hp < sm.Target.Damage)
						summdam = pMob[Target].MOB.CurrentScore.Hp;

					else
						summdam = sm.Target.Damage;
				}
			}
		}

		if (sm.Target.Damage > 0 || sm.Target.Damage <= -5)
		{
			int DamageNow = sm.Target.Damage;
			int damage = 0;
			int mountindex = pMob[Target].MOB.Equip[14].sIndex;

			if (Target > 0 && Target < MAX_USER)///olhar aqui
			{
				if (Target < MAX_USER && mountindex >= 2360 && mountindex < 2390 && pMob[Target].MOB.Equip[14].stEffect[0].sValue > 0)
				{
					if (pMob[Target].MOB.Equip[14].stEffect[0].sValue > 0)
					{
						DamageNow = (3 * sm.Target.Damage) / 4;
						damage = sm.Target.Damage - DamageNow;

						if (DamageNow <= 0)
							DamageNow = 1;

						sm.Target.Damage = DamageNow;
					}
				}
			}

			if (pMob[Target].MOB.Class == 1)
			{
				for (int c = 0; c < MAX_AFFECT && Target < MAX_USER; c++)
				{
					if (pMob[Target].Affect[c].Type == 18)
					{
						if (pMob[Target].MOB.CurrentScore.Mp > ((pMob[Target].MOB.CurrentScore.MaxMp / 100) * 10))
						{
							int mana = pMob[Target].MOB.CurrentScore.Mp - (DamageNow >> 1);

							if (mana < 0)
							{
								DamageNow -= mana;
								mana = 0;
							}

							pMob[Target].MOB.CurrentScore.Mp = mana;

							pUser[Target].ReqMp = pUser[Target].ReqMp - (DamageNow >> 1);
							SetReqMp(Target);

							SendSetHpMp(Target);

							DamageNow = ((DamageNow >> 1) + (DamageNow << 4)) / 80;
							sm.Target.Damage = DamageNow;
						}
					}
				}
			}

			// Target
			auto multHpMob = pMob[Target].MOB.Equip[13].sIndex;
			auto _tDamage = DamageNow;
			if (multHpMob == 786 || multHpMob == 1936 || multHpMob == 1937)
			{
				int HpItem = GetItemSancNew(&pMob[Target].MOB.Equip[13]);
				if (HpItem < 2)
					HpItem = 2;
				int multHp = 1;
				switch (multHpMob)
				{
				case 1936:
					multHp = 10;
					break;
				case 1937:
					multHp = 1000;
				default:
					break;
				}
				multHp *= HpItem;

				_tDamage /= multHp;

			}
			if (_tDamage > pMob[Target].MOB.CurrentScore.Hp)
				pMob[Target].MOB.CurrentScore.Hp = 0;
			else
				pMob[Target].MOB.CurrentScore.Hp -= _tDamage;

			if (Target > MAX_USER && pMob[Target].MOB.Clan == 4)
				LinkMountHp(Target);

			if (damage > 0)
				ProcessAdultMount(Target, damage);
		}

		GridMulticast(pMob[Target].TargetX, pMob[Target].TargetY, (MSG_STANDARD*)&sm, 0);

		if (Target > 0 && Target < MAX_USER)
		{
			if (pUser[Target].ReqHp < sm.Target.Damage)
				pUser[Target].ReqHp = 0;

			else
				pUser[Target].ReqHp = pUser[Target].ReqHp - sm.Target.Damage;

			SetReqHp(Target);
			SendSetHpMp(Target);
		}

		if (pMob[Target].MOB.CurrentScore.Hp <= 0)
		{
			pMob[Target].MOB.CurrentScore.Hp = 0;

			MobKilled(Target, index, 0, 0);
		}
	}

	//Kefra
	if (0 == 1)
	{
	KefraAttackLabel:
		MSG_Attack sm;
		memset(&sm, 0, sizeof(MSG_Attack));

		GetAttackArea(index, &sm);
		MobAttack(index, sm);
	}

	if (BattleMode & 0x100)
	{
		int TargetID = pMob[index].CurrentTarget;
		pMob[index].GetTargetPosDistance(TargetID);

		if (pMob[index].NextX == pMob[index].TargetX && pMob[index].NextY == pMob[index].TargetY)
			continue;

		MSG_Action sm;

		if (GetEmptyMobGrid(index, &pMob[index].NextX, &pMob[index].NextY) == FALSE)
			continue;

		GetAction(index, pMob[index].NextX, pMob[index].NextY, (MSG_Action*)&sm);

		sm.Speed = BASE_GetSpeed(&pMob[index].MOB.CurrentScore);
		sm.Effect = 0;

		GridMulticast(index, pMob[index].NextX, pMob[index].NextY, (MSG_STANDARD*)&sm);
	}

	if (BattleMode & 1)
	{
		//SendSay(index, "BattleMode 0x1");
		Target = pMob[index].CurrentTarget;
		pMob[index].GetTargetPos(Target);

		if (pMob[index].NextX == pMob[index].TargetX && pMob[index].NextY == pMob[index].TargetY)
			continue;

		MSG_Action sm;

		if (GetEmptyMobGrid(index, &pMob[index].NextX, &pMob[index].NextY) == FALSE)
			continue;

		GetAction(index, pMob[index].NextX, pMob[index].NextY, (MSG_Action*)&sm);

		sm.Speed = BASE_GetSpeed(&pMob[index].MOB.CurrentScore);
		sm.Effect = 0;

		GridMulticast(index, pMob[index].NextX, pMob[index].NextY, (MSG_STANDARD*)&sm);
	}

	if (BattleMode & 2)
		DoTeleport(index, pMob[index].NextX, pMob[index].NextY);

	if (BattleMode & 0x10)
	{
		//SendSay(index, "BattleMode 0x10");
		MSG_Action sm;

		if (GetEmptyMobGrid(index, &pMob[index].NextX, &pMob[index].NextY) == FALSE)
			continue;

		GetAction(index, pMob[index].NextX, pMob[index].NextY, (MSG_Action*)&sm);

		if (pMob[index].NextX == pMob[index].TargetX && pMob[index].NextY == pMob[index].TargetY)
			continue;

		sm.Speed = BASE_GetSpeed(&pMob[index].MOB.CurrentScore);
		sm.Effect = 0;

		GridMulticast(index, pMob[index].NextX, pMob[index].NextY, (MSG_STANDARD*)&sm);
	}
}
#pragma endregion

#pragma region Limpa as propriedades do mob caso não foram removidas pelo método padrão
if (SecCounter % 30 == 0)
{
	for (int nY = 0; nY < MAX_GRIDY; nY++)
	{
		for (int nX = 0; nX < MAX_GRIDX; nX++)
		{
			int Target = pMobGrid[nY][nX];

			if (Target < MAX_USER)
				continue;

			if (pMob[Target].Mode == MOB_EMPTY || pMob[Target].MOB.CurrentScore.Hp <= 0)
			{
				if (pMob[Target].TargetX != 0 && pMob[Target].TargetY != 0)
				{
					MSG_RemoveMob sm;
					memset(&sm, 0, sizeof(MSG_RemoveMob));
					sm.Size = sizeof(MSG_RemoveMob);

					sm.Type = _MSG_RemoveMob;
					sm.ID = Target;
					sm.RemoveType = 0;

					GridMulticast(pMob[Target].TargetX, pMob[Target].TargetY, (MSG_STANDARD*)&sm, Target < MAX_USER ? Target : 0);
				}

				pMob[Target].Clear();

				pMobGrid[nY][nX] = 0;
			}
		}
	}
}
#pragma endregion

}

void ProcessMinTimer()
{
	time_t rawtime;
	tm* timeinfo;

	time(&rawtime);
	timeinfo = localtime(&rawtime);

	if (timeinfo->tm_mday != LastSystemLogDay)
		StartSystemLog();

	if (timeinfo->tm_mday != LastChatLogDay)
		StartChatLog();

	if (timeinfo->tm_mday != LastItemLogDay)
		StartItemLog();

	if (timeinfo->tm_mday != LastCompositorLogsDay)  //23/02
		CompositorLog();

	if (timeinfo->tm_mday != trade_itemLogsFileDay)  //23/02
		trade_item();

	if (timeinfo->tm_mday != fIMobDropLogFileDay)  //23/02
		MobDropLogs();

	if ((MinCounter % 2) == 0)
	{
		int NewbieServerID = (timeinfo->tm_mday - 1) % NumServerInGroup;

		if (LOCALSERVER != 0 || ServerIndex == NewbieServerID)
			NewbieEventServer = 1;

		else if (NewbieEventServer == 1 && ServerIndex != NewbieServerID)
		{
			for (int i = 1; i < MAX_USER; i++)
			{
				if (pUser[i].Mode == USER_EMPTY || pUser[i].cSock.Sock == 0)
					continue;

				if (pUser[i].TradeMode == 1)
					RemoveTrade(i);
			}

			NewbieEventServer = 0;
		}

		if (timeinfo->tm_wday == 0) // Domingo
			CastleServer = 1;

		if (timeinfo->tm_wday == 0) // Domingo
			RvRBonus = 0;

		/*if (1 != 0) // Likely to be a debug flag of sorts.. TODO: Check and decide if it stays
		{
		int wNum = BASE_GetWeekNumber();
		int wMod = wNum % 7;
		int wDay = wNum / 7;

		if (wMod == 0 && ((wDay % 2) == (ServerIndex % 2)))
		CastleServer = 1;
		else
		CastleServer = 0;

		}*/
	}

	for (int i = 0; i < MAX_GUILDZONE; i++)
	{
		if (GuildImpostoID[i] == 0)
			continue;

		if (pMob[GuildImpostoID[i]].MOB.CurrentScore.Hp <= 0)
			continue;

		//char temp[4096];
		strncpy(temp, "./npc/", sizeof(temp));

		char name[NAME_LENGTH];

		snprintf(name, sizeof(name), "%s", pMob[GuildImpostoID[i]].MOB.MobName);

		for (int j = 0; j < NAME_LENGTH; j++)
		{
			if (name[j] == ' ')
				name[j] = '_';
		}

		strcat(temp, name);

		int handle = _open(temp, _O_CREAT | _O_RDWR | _O_BINARY, _S_IREAD | _S_IWRITE);

		if (handle == -1)
		{
			SystemLog("-system", "-", 0, "fail - save npc imposto file");
			return;
		}
		_write(handle, (void*)&pMob[GuildImpostoID[i]].MOB, sizeof(pMob[GuildImpostoID[i]].MOB));
		_close(handle);
	}


	if (ForceWeekMode != -1)
		timeinfo->tm_wday = -1;

	CCastleZakum::ProcessMinTimer();

#pragma region Clear Area
	if (Kingdom1Clear == 1)
	{
		Kingdom1Clear = 2;
	}
	else if (Kingdom1Clear == 2)
	{
		Kingdom1Clear = 0;

		ClearArea(1676, 1556, 1776, 1636);
	}

	if (Kingdom2Clear == 1)
	{
		Kingdom2Clear = 2;
	}
	else if (Kingdom2Clear == 2)
	{
		Kingdom2Clear = 0;

		ClearArea(1676, 1816, 1776, 1892);
	}
#pragma endregion

	if ((MinCounter % 10) == 0)
		memset(FailAccount, 0, sizeof(FailAccount));

	CurrentTime = timeGetTime();

#pragma region Close Gates
	if (BigCubo == 1)
	{
		for (int i = 17; i < g_dwInitItem - 10; i++)
		{
			int ipx = g_pInitItem[i].PosX; // Item Pos X
			int ipy = g_pInitItem[i].PosY; // Item Pos Y
			int ipg = pItemGrid[ipy][ipx]; // Item Pos Grid

			if (pItem[ipg].ITEM.sIndex <= 0 || pItem[ipg].ITEM.sIndex >= MAX_ITEMLIST)
				continue;

			CItem* tItem = &pItem[ipg];

			int iKey = BASE_GetItemAbility(&pItem[ipg].ITEM, 39);

			if (iKey != 0)
			{
				if (pItem[ipg].State == STATE_OPEN && iKey < 15)
				{
					if (pItem[ipg].Delay == 0)
					{
						pItem[ipg].Delay = 1;

						continue;
					}

					UpdateItem(ipg, 3, &pItem[ipg].Height);
					/*
					MSG_UpdateItem sm;

					sm.ID = ESCENE_FIELD;
					sm.Type = _MSG_UpdateItem;

					sm.ItemID = ipg + 10000;

					sm.Size = sizeof(MSG_UpdateItem);

					//sm.Height = pItem[ipg].Height;
					*/
					pItem[ipg].State = STATE_LOCKED;
					/*
					sm.State = pItem[ipg].State;

					GridMulticast(ipx, ipy, (MSG_STANDARD*)&sm, 0);
					*/
					pItem[ipg].Delay = 0;

					MSG_CreateItem sm;

					sm.Type = _MSG_CreateItem;
					sm.Size = sizeof(MSG_CreateItem);
					sm.ID = ESCENE_FIELD;

					sm.ItemID = ipg + 10000;

					memmove_s(&sm.Item, sizeof(STRUCT_ITEM), &pItem[ipg].ITEM, sizeof(STRUCT_ITEM));

					sm.GridX = ipx;
					sm.GridY = ipy;

					sm.Rotate = pItem[ipg].Rotate;
					sm.State = pItem[ipg].State;
					//sm.Create = Create;

					//sm.Height = pItem[empty].Height;

					GridMulticast(ipx, ipy, (MSG_STANDARD*)&sm, 0);
				}
			}
		}
	}
	else
	{
		for (int i = 17; i < g_dwInitItem; i++)
		{
			int ipx = g_pInitItem[i].PosX; // Item Pos X
			int ipy = g_pInitItem[i].PosY; // Item Pos Y
			int ipg = pItemGrid[ipy][ipx]; // Item Pos Grid

			if (pItem[ipg].ITEM.sIndex <= 0 || pItem[ipg].ITEM.sIndex >= MAX_ITEMLIST)
				continue;

			CItem* tItem = &pItem[ipg];

			int iKey = BASE_GetItemAbility(&pItem[ipg].ITEM, 39);

			if (iKey != 0)
			{
				if (pItem[ipg].State == STATE_OPEN && iKey < 15)
				{
					if (pItem[ipg].Delay == 0)
					{
						pItem[ipg].Delay = 1;

						continue;
					}

					UpdateItem(ipg, 3, &pItem[ipg].Height);
					/*
					MSG_UpdateItem sm;

					sm.ID = ESCENE_FIELD;
					sm.Type = _MSG_UpdateItem;

					sm.ItemID = ipg + 10000;

					sm.Size = sizeof(MSG_UpdateItem);

					//sm.Height = pItem[ipg].Height;
					*/
					pItem[ipg].State = STATE_LOCKED;
					/*
					sm.State = pItem[ipg].State;

					GridMulticast(ipx, ipy, (MSG_STANDARD*)&sm, 0);
					*/
					pItem[ipg].Delay = 0;

					MSG_CreateItem sm;

					sm.Type = _MSG_CreateItem;
					sm.Size = sizeof(MSG_CreateItem);
					sm.ID = ESCENE_FIELD;

					sm.ItemID = ipg + 10000;

					memmove_s(&sm.Item, sizeof(STRUCT_ITEM), &pItem[ipg].ITEM, sizeof(STRUCT_ITEM));

					sm.GridX = ipx;
					sm.GridY = ipy;

					sm.Rotate = pItem[ipg].Rotate;
					sm.State = pItem[ipg].State;
					//sm.Create = Create;

					//sm.Height = pItem[empty].Height;

					GridMulticast(ipx, ipy, (MSG_STANDARD*)&sm, 0);
				}
			}
		}
	}
#pragma endregion
#pragma region GenerateMobs
	for (int i = 0; i < mNPCGen.NumList; i++)
	{
		int MinuteGenerate = mNPCGen.pList[i].MinuteGenerate;

		if (i != 0 && i != 1 && i != 2 && i != 5 && i != 6 && i != 7 && i != -1)
		{
			if (MinuteGenerate <= 0)
				continue;

			int mod = i % MinuteGenerate;

			if (MinCounter % MinuteGenerate == mod)
			{
				GenerateMob(i, 0, 0);

				if (MinuteGenerate >= 500 && MinuteGenerate < 1000)
				{
					mNPCGen.pList[i].MinuteGenerate = rand() % 500 + 500;

					continue;
				}

				if (MinuteGenerate >= 1000 && MinuteGenerate < 2000)
				{
					mNPCGen.pList[i].MinuteGenerate = rand() % 1000 + 1000;

					continue;
				}

				if (MinuteGenerate >= 2000 && MinuteGenerate < 3800)
				{
					mNPCGen.pList[i].MinuteGenerate = rand() % 1800 + 2000;

					continue;
				}

				if (MinuteGenerate >= 3800)
				{
					mNPCGen.pList[i].MinuteGenerate = rand() % 1000 + 3800;

					if (DUNGEONEVENT)
					{
						int RndPos = rand() % 30;
						int dpX = DungeonPos[RndPos][0];
						int dpY = DungeonPos[RndPos][1];

						int RndL = rand() % 5 + 5;

						for (int j = 0; j < RndL; j++)
						{
							STRUCT_ITEM PrizeItem;

							memset(&PrizeItem, 0, sizeof(STRUCT_ITEM));

							PrizeItem.sIndex = DungeonItem[rand() % 10];

							SetItemBonus(&PrizeItem, 0, 0, 0);

							int rnd = rand() % 4;

							CreateItem(dpX, dpY, &PrizeItem, rnd, 1);
						}
					}
				}

			}
		}
	}
#pragma endregion
	MinCounter++;

	int rndWeather = rand() % 1200;

	if (ForceWeather == -1)
	{
		if (rndWeather >= 0 && rndWeather < 260 && CurrentWeather != 0)
		{
			CurrentWeather = 0;
			SendWeather();
		}
		else if (rndWeather >= 30 && rndWeather < 50 && CurrentWeather != 1)
		{
			CurrentWeather = 1;
			SendWeather();
		}
		else if (rndWeather >= 55 && rndWeather < 60 && CurrentWeather != 2)
		{
			CurrentWeather = 2;
			SendWeather();
		}
	}
	else
	{
		if (ForceWeather != CurrentWeather)
		{
			CurrentWeather = ForceWeather;
			SendWeather();
		}
	}

	GuildProcess();
}


# -------------------- Ranking.cpp --------------------

#pragma once

#include "ProcessClientMessage.h"
#include <iostream>
#include <cstdlib>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <random>
#include <ctime>
#include "SendFunc.h"
#include "Functions.h"
#include "wMySQL.h"
#include "Ranking.h"


void doRanking(int conn)
{
	if (conn <= 0 || conn >= MAX_USER)
		return;

	if (pUser[conn].Mode != USER_PLAY)
		return;

	if (pUser[conn].cSock.Sock == 0)
		return;

	auto& pc = cSQL::instance();

	int Kills = GetTotKill(conn);

	/*MORTAL			2
	ARCH			1
	CELESTIAL		3
	CELESTIALCS		4
	SCELESTIAL		5
	HARDCORE        6
	HARDCOREA		7
	HARDCORECS		8
	SHARDCORE		9*/

	int Evolution = 0;

	if (pMob[conn].extra.ClassMaster == 2)
		Evolution = 1;

	if (pMob[conn].extra.ClassMaster == 1)
		Evolution = 2;

	if (pMob[conn].extra.ClassMaster > 2)
		Evolution = pMob[conn].extra.ClassMaster;

	sprintf(xQuery, "UPDATE `characteres` SET level = '%d', class = '%d', evolution = '%d', kingdom = '%d', frags = '%d', guild_id = '%d', guildlevel = '%d' WHERE `nick` = '%s' AND `slot_char` = '%d'",
		pMob[conn].MOB.BaseScore.Level, pMob[conn].MOB.Class, Evolution, pMob[conn].MOB.Clan,
		Kills, pMob[conn].MOB.Guild, pMob[conn].MOB.GuildLevel, pMob[conn].MOB.MobName, pUser[conn].Slot);
	pc.wQuery(xQuery);
}

void sendRanking(int conn, int state) {

	if (conn <= 0 || conn >= MAX_USER)
		return;

	if (pUser[conn].Mode != USER_PLAY)
		return;

	if (pUser[conn].cSock.Sock == 0)
		return;

	if (pUser[conn].RankingDelay != 0)
	{
		int isTime = GetTickCount64() - pUser[conn].RankingDelay; // ATRASO PACOTE

		if (isTime < 200)
		{
			SendClientMessage(conn, "Aguarde 1 segundo para uma nova Tentativa.");
			return;
		}

	}
	pUser[conn].RankingDelay = GetTickCount64();

	auto& pc = cSQL::instance();

	std::string mobName[50];
	int RankLevel[50] = {};
	int RankClasse[50] = {};
	int RankEvolution[50] = {};
	int PvP[50] = {};
	int i = 0;

	if (state == 0) {
		sprintf(xQuery, "SELECT * FROM `characteres` where level is not null ORDER BY `evolution` DESC, `level` DESC LIMIT 50");
		MYSQL_ROW row;
		MYSQL* wSQL = pc.wStart();
		MYSQL_RES* result = pc.wRes(wSQL, xQuery);

		if (result == NULL)
		{
			return;
		}

		while ((row = mysql_fetch_row(result)) != NULL)
		{
			mobName[i] = row[3];
			RankLevel[i] = atoi(row[4]) + 1;
			RankClasse[i] = atoi(row[5]);
			RankEvolution[i] = atoi(row[6]);
			PvP[i] = atoi(row[12]);
			i++;
		}

		MSG_SendRanking sm;
		memset(&sm, 0, sizeof(MSG_SendRanking));

		sm.Type = _MSG_SendRanking;
		sm.Size = sizeof(MSG_SendRanking);
		sm.ID = conn;
		sm.State = state;

		for (int i = 0; i < 50; i++) {
			strncpy(sm.RankName[i], mobName[i].c_str(), sizeof(sm.RankName[i]));
			sm.RankLevel[i] = RankLevel[i];
			sm.RankClasse[i] = RankClasse[i];
			sm.RankEvolution[i] = RankEvolution[i];
			sm.PvP[i] = PvP[i];
		}

		int Size = sm.Size;

		if (Size > sizeof(MSG_SendRanking))
		{
			sm.Size = 0;
			return;
		}

		if (!pUser[conn].cSock.AddMessage((char*)&sm, sizeof(MSG_SendRanking)))
			CloseUser(conn);
	}

	if (state == 1) {
		sprintf(xQuery, "SELECT * FROM `characteres` where level is not null ORDER BY `frags` DESC LIMIT 50");
		MYSQL_ROW row;
		MYSQL* wSQL = pc.wStart();
		MYSQL_RES* result = pc.wRes(wSQL, xQuery);

		if (result == NULL)
		{
			return;
		}

		while ((row = mysql_fetch_row(result)) != NULL)
		{
			mobName[i] = row[3];
			RankLevel[i] = atoi(row[4]) + 1;
			RankClasse[i] = atoi(row[5]);
			RankEvolution[i] = atoi(row[6]);
			PvP[i] = atoi(row[11]);
			i++;
		}

		MSG_SendRanking sm;
		memset(&sm, 0, sizeof(MSG_SendRanking));

		sm.Type = _MSG_SendRanking;
		sm.Size = sizeof(MSG_SendRanking);
		sm.ID = conn;
		sm.State = state;

		for (int i = 0; i < 50; i++) {
			strncpy(sm.RankName[i], mobName[i].c_str(), sizeof(sm.RankName[i]));
			sm.RankLevel[i] = RankLevel[i];
			sm.RankClasse[i] = RankClasse[i];
			sm.RankEvolution[i] = RankEvolution[i];
			sm.PvP[i] = PvP[i];
		}

		int Size = sm.Size;

		if (Size > sizeof(MSG_SendRanking))
		{
			sm.Size = 0;
			return;
		}

		if (!pUser[conn].cSock.AddMessage((char*)&sm, sizeof(MSG_SendRanking)))
			CloseUser(conn);
	}
}


# -------------------- Ranking.h --------------------

#pragma once

struct PLAYER_RANKING
{
	char Nick[16];
	int Level;
	int Classe;
	int Evolução;
	int Reino;
	int Kills;
};
PLAYER_RANKING pRanking[50];

# -------------------- reCaptcha.cpp --------------------

#pragma once

#include "ProcessClientMessage.h"
#include <iostream>
#include <cstdlib>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <random>
#include <ctime>
#include "SendFunc.h"
#include "Functions.h"
#include <string.h>
#include "Server.h"

using namespace std;

void GerarRecaptcha()
{
    //srand(time(NULL));
    random_words = rand() % 3;
}

void VerificarRecaptcha(int conn, int word) {

    if (conn <= 0 || conn >= MAX_USER)
        return;

    if (pUser[conn].Mode != USER_PLAY)
        return;

    if (pUser[conn].cSock.Sock == 0)
        return;
        
    if (word < 0 || word > 5)
        return;

    if (pUser[conn].CaptchaDelay != 0)
    {
        int isTime = GetTickCount64() - pUser[conn].CaptchaDelay;

        if (isTime < 120000) {
            SendClientMessage(conn, "Aguarde 2 Minutos para nova tentativa");
            return;
        }

    }

    int wordsPos = word;
    int keywordsPos = pUser[conn].Carptcha;

    char words[6][7] = {
        "AVIÃO", "NAVIO", "MOTO", "BIKE", "CARRO", "TREM"
    };

    bool Correct = false;

    if (random_words == 0) {
        if (!strcmp(words[wordsPos], Keywords[keywordsPos]))
            Correct = true;
    }
    if (random_words == 1) {
        if (!strcmp(words[wordsPos], Keywords1[keywordsPos]))
            Correct = true;
    }
    if (random_words == 2) {
        if (!strcmp(words[wordsPos], Keywords2[keywordsPos]))
            Correct = true;
    }
    if (Correct == true) {
        pUser[conn].CaptchaDelay = 0;
        if (pUser[conn].Territorio == 1) {
            
            for (int z = 0; z < MAX_USER; z++)
            {
                if (pUser[z].Mode != USER_PLAY)
                    continue;

                if (!pUser[z].cSock.Sock)
                    continue;

                if (pMob[z].LanNFlag == 1)
                {
                    if (pUser[z].IP == pUser[conn].IP) {
                        SendClientMessage(conn, "Limite de [01] Conta por IP");
                        return;
                    }
                }
            }

            DoTeleport(conn, (3639 + rand() % 5 - 3), (3639 + rand() % 5 - 3));
            pMob[conn].LanNFlag = 1;
            pUser[conn].Territorio = 0;
            return;
        }
        if (pUser[conn].Territorio == 2) {

            for (int z = 0; z < MAX_USER; z++)
            {
                if (pUser[z].Mode != USER_PLAY)
                    continue;

                if (!pUser[z].cSock.Sock)
                    continue;

                if (pMob[z].LanMFlag == 1)
                {
                    if (pUser[z].IP == pUser[conn].IP) {
                        SendClientMessage(conn, "Limite de [01] Conta por IP");
                        return;
                    }
                }
            }

            DoTeleport(conn, (3782 + rand() % 5 - 3), (3527 + rand() % 5 - 3));
            pMob[conn].LanMFlag = 1;
            pUser[conn].Territorio = 0;
            return;
        }
        if (pUser[conn].Territorio == 3) {
                        
            for (int z = 0; z < MAX_USER; z++)
            {
                if (pUser[z].Mode != USER_PLAY)
                    continue;

                if (!pUser[z].cSock.Sock)
                    continue;

                if (pMob[z].LanAFlag == 1)
                {
                    if (pUser[z].IP == pUser[conn].IP) {
                        SendClientMessage(conn, "Limite de [01] Conta por IP");
                        return;
                    }
                }
            }

            DoTeleport(conn, (3911 + rand() % 5 - 3), (3655 + rand() % 5 - 3));
            pMob[conn].LanAFlag = 1;
            pUser[conn].Territorio = 0;
            return;
        }
        if (pUser[conn].Territorio == 4) {

            if (EventStatus == 0) {
                SendClientMessage(conn, "Evento Desativado");
                return;
            }

            for (int z = 0; z < MAX_USER; z++)
            {
                if (pUser[z].Mode != USER_PLAY)
                    continue;

                if (pUser[z].DiariaState == 1)
                {
                    if (pUser[z].IP == pUser[conn].IP) {
                        SendClientMessage(conn, "Limite de [01] Conta por IP");
                        return;
                    }
                }
            }
            SendMsgExp(conn, "Bem Vindo ao Evento Hit", TNColor::Default, false);
            int _rand = rand() % 2;
            if (_rand == 0) {
                DoTeleport(conn, 1311 + rand() % 2, 1499 + rand() % 2);
            }
            else {
                DoTeleport(conn, 1372 + rand() % 2, 1499 + rand() % 2);
            }
            
            pUser[conn].DiariaState = 1;
            pUser[conn].Territorio = 0;
            return;
        }
    }
    pUser[conn].CaptchaDelay = GetTickCount64();
    SendClientMessage(conn, "Desculpe, resposta incorreta");
}

void SendRecaptcha(int conn, int territorio) {

    if (conn <= 0 || conn >= MAX_USER)
        return;

    if (pUser[conn].Mode != USER_PLAY)
        return;

    if (pUser[conn].cSock.Sock == 0)
        return;

    MSG_Recaptcha sm;

    memset(&sm, 0, sizeof(MSG_Recaptcha));

    sm.Type = _MSG_Recaptcha;
    sm.Size = sizeof(MSG_Recaptcha);
    sm.ID = conn;

   // srand(time(NULL));
    int Word = rand() % 30;

    pUser[conn].Carptcha = Word;
    pUser[conn].Territorio = territorio;

    sm.state = random_words;
    sm.word = Word;

    int Size = sm.Size;

    if (Size > sizeof(MSG_Recaptcha))
    {
        sm.Size = 0;
        return;
    }

    if (!pUser[conn].cSock.AddMessage((char*)&sm, sizeof(MSG_Recaptcha)))
        CloseUser(conn);
}

# -------------------- RequestAlias.cpp --------------------

#pragma once

#include "ProcessClientMessage.h"
#include <iostream>
#include <cstdlib>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <random>
#include <ctime>
#include "SendFunc.h"
#include "Functions.h"
#include "wMySQL.h"

void RequestAlias(int conn, char* pMsg)
{
	if (conn <= 0 || conn >= MAX_USER)
		return;

	if (pUser[conn].Mode != USER_PLAY)
		return;

	if (pUser[conn].cSock.Sock == 0)
		return;

	MSG_ReqAlias* m = (MSG_ReqAlias*)pMsg;

	int Size = m->Size;

	if (Size > sizeof(MSG_ReqAlias)) //CONTROLE DE SIZE
	{
		SendClientMessage(conn, "Impossível executar ação, tente mais tarde.");
		return;
	}

	if (m->Tipo < 0)
		return;

	int Type = m->Tipo;
	int Captcha = 0;
	int Runa = 0;
	if (Type >= 100 && Type < 200) {
		Captcha = m->Tipo - 100;
		Type = 5;
	}

	switch (Type) {
		case 1:
		{			
			UpdateDonate(conn);
		}break;
		case 2:
		{
			SendShopDonate(conn);
		}break;
		case 3:
		{
			SendMailItem(conn);
		}break;
		case 4:
		{
			sendRanking(conn, 0);
		}break;
		case 5:
		{
			VerificarRecaptcha(conn, Captcha);
		}break;
		case 6:
		{
			sendRanking(conn, 1);
		}break;
	}
}

# -------------------- RequestTeleport.cpp --------------------

#include "ProcessClientMessage.h"
#include <iostream>
#include <cstdlib>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <random>
#include <ctime>
#include "SendFunc.h"
#include "Functions.h"

void ReqTeleport(int conn, char* pMsg) {
	MSG_ReqTeleport* m = (MSG_ReqTeleport*)pMsg;

	int Size = m->Size;

	int X = m->X;
	int Y = m->Y;

	if (conn <= 0 || conn >= MAX_USER)
		return;

	if (pUser[conn].Mode != USER_PLAY)
		return;

	if (pUser[conn].cSock.Sock == 0)
		return;

	if (X <= 0 || X >= 4000)
		return;

	if (Y <= 0 || Y >= 4000)
		return;

	if (pUser[conn].Atraso != 0)
	{
		int isTime = GetTickCount64() - pUser[conn].Atraso; // ATRASO PACOTE

		if (isTime < 800)
		{
			SendClientMessage(conn, "Aguarde 1 segundo para uma nova Tentativa.");
			return;
		}

	}
	pUser[conn].Atraso = GetTickCount64();

	if (Size > sizeof(MSG_ReqTeleport)) //CONTROLE DE SIZE
	{
		SendClientMessage(conn, "Impossível executar ação, tente mais tarde.");
		return;
	}

	if (pMob[conn].TargetX >= 2452 && pMob[conn].TargetY >= 1854 && pMob[conn].TargetX <= 2542 && pMob[conn].TargetY <= 1919)
	{
		SendClientMessage(conn, "Impossível se teleportar nesta Area");
		return;
	}

	if (pMob[conn].TargetX >= 1050 && pMob[conn].TargetY >= 1943 && pMob[conn].TargetX <= 1250 && pMob[conn].TargetY <= 1954)
	{
		SendClientMessage(conn, "Impossível se teleportar nesta Area");
		return;
	}

	int fX = X + rand() % 3;
	int fY = Y + rand() % 3;

	DoTeleport(conn, fX, fY);
	return;
}

# -------------------- resource.h --------------------

ÿþ/ * 
 *       C o p y r i g h t   ( C )   { 2 0 1 5 }     { V i c t o r   K l a f k e ,   C h a r l e s   T h e H o u s e } 
 * 
 *       T h i s   p r o g r a m   i s   f r e e   s o f t w a r e :   y o u   c a n   r e d i s t r i b u t e   i t   a n d / o r   m o d i f y 
 *       i t   u n d e r   t h e   t e r m s   o f   t h e   G N U   G e n e r a l   P u b l i c   L i c e n s e   a s   p u b l i s h e d   b y 
 *       t h e   F r e e   S o f t w a r e   F o u n d a t i o n ,   e i t h e r   v e r s i o n   3   o f   t h e   L i c e n s e ,   o r 
 *       ( a t   y o u r   o p t i o n )   a n y   l a t e r   v e r s i o n . 
 * 
 *       T h i s   p r o g r a m   i s   d i s t r i b u t e d   i n   t h e   h o p e   t h a t   i t   w i l l   b e   u s e f u l , 
 *       b u t   W I T H O U T   A N Y   W A R R A N T Y ;   w i t h o u t   e v e n   t h e   i m p l i e d   w a r r a n t y   o f 
 *       M E R C H A N T A B I L I T Y   o r   F I T N E S S   F O R   A   P A R T I C U L A R   P U R P O S E .     S e e   t h e 
 *       G N U   G e n e r a l   P u b l i c   L i c e n s e   f o r   m o r e   d e t a i l s . 
 * 
 *       Y o u   s h o u l d   h a v e   r e c e i v e d   a   c o p y   o f   t h e   G N U   G e n e r a l   P u b l i c   L i c e n s e 
 *       a l o n g   w i t h   t h i s   p r o g r a m .     I f   n o t ,   s e e   [ h t t p : / / w w w . g n u . o r g / l i c e n s e s / ] . 
 * 
 *       C o n t a c t   a t :   v i c t o r . k l a f k e @ e c o m p . u f s m . b r 
 * / 
 / / { { N O _ D E P E N D E N C I E S } } 
 
 / /   M i c r o s o f t   V i s u a l   C + +   g e n e r a t e d   i n c l u d e   f i l e . 
 
 / /   U s e d   b y   T M S r v . r c 
 
 / / 
 
 # d e f i n e   I D I _ I C O N 1                                               1 0 1 
 
 
 
 / /   N e x t   d e f a u l t   v a l u e s   f o r   n e w   o b j e c t s 
 
 / /   
 
 # i f d e f   A P S T U D I O _ I N V O K E D 
 
 # i f n d e f   A P S T U D I O _ R E A D O N L Y _ S Y M B O L S 
 
 # d e f i n e   _ A P S _ N E X T _ R E S O U R C E _ V A L U E                 1 0 2 
 
 # d e f i n e   _ A P S _ N E X T _ C O M M A N D _ V A L U E                   4 0 0 0 1 
 
 # d e f i n e   _ A P S _ N E X T _ C O N T R O L _ V A L U E                   1 0 0 1 
 
 # d e f i n e   _ A P S _ N E X T _ S Y M E D _ V A L U E                       1 0 1 
 
 # e n d i f 
 
 # e n d i f 
 
 

# -------------------- SendFunc.cpp --------------------


#include <memory>

#include "..\Basedef.h"
#include "SendFunc.h"
#include "GetFunc.h"
#include "Server.h"
#include "Language.h"
#include <fstream>
#include <vector>
#include <time.h>
#include <random>
#include <ctime>
#include "..\DBSrv\CRanking.h"
#include "wMySQL.h"
#include "../ItemEffect.h"
#include "Functions.h"
#include <iostream>











int checkCord(int conn, int cX, int cY, int cX2, int cY2)
{
	int cnt = 0;
	if (pMob[conn].TargetX >= cX && pMob[conn].TargetX <= cX2 && pMob[conn].TargetY >= cY && pMob[conn].TargetY <= cY2)
		cnt++;

	return cnt;
}

BOOL bFile_exists(const char *filename)
{
	FILE *arquivo;
	arquivo = fopen(filename, "rb");

	if (arquivo)
	{
		fclose(arquivo);
		return TRUE;
	}

	return FALSE;
}

void SendClientMessage(int conn, char *Message)
{
	if (conn <= 0 || conn >= MAX_USER)
		return;

	MSG_MessagePanel sm_mp;
	memset(&sm_mp, 0, sizeof(MSG_MessagePanel));

	sm_mp.Size = sizeof(MSG_MessagePanel);
	sm_mp.Type = _MSG_MessagePanel;
	sm_mp.ID = 0;

	memcpy(sm_mp.String, Message, MESSAGE_LENGTH);

	sm_mp.String[MESSAGE_LENGTH - 1] = 0;
	sm_mp.String[MESSAGE_LENGTH - 2] = 0;

	if (conn && conn < MAX_USER && pUser[conn].Mode != 0) {

		int Size = sm_mp.Size;

		if (Size > sizeof(MSG_MessagePanel))
		{
			sm_mp.Size = 0;
			return;
		}
		if (!pUser[conn].cSock.AddMessage((char*)&sm_mp, sizeof(MSG_MessagePanel)))
			CloseUser(conn);
	}
}

void BalanceioPvP()
{
	auto& pc = cSQL::instance();

	sprintf(xQuery, "SELECT * FROM `balanceamento` LIMIT 50");
	MYSQL_ROW row;
	MYSQL* wSQL = pc.wStart();
	MYSQL_RES* result = pc.wRes(wSQL, xQuery);

	if (result == NULL)
	{
		return;
	}

	int i = 1;
	while ((row = mysql_fetch_row(result)) != NULL)
	{
		ClassVsClass[0][i] = atoi(row[2]);
		pClassVsClass[0][i] = atoi(row[3]);
		ClassVsClass[1][i] = atoi(row[4]);
		pClassVsClass[1][i] = atoi(row[5]);
		ClassVsClass[2][i] = atoi(row[6]);
		pClassVsClass[2][i] = atoi(row[7]);
		i++;
	}
}

int DamageCalc(int signal, int pValue, int iValue)
{
	int Damage = iValue;
	int Por = pValue;
	int sinal = signal;

	if (sinal == TRUE) {
		Damage += Damage * pValue / 100;
	}
	else {
		Damage -= Damage * pValue / 100;
	}

	return Damage;
}

int DamageBalancing(int conn, int idx, int tDamage)
{
	int Damage = tDamage;

	if (idx > 0 && idx < MAX_USER)
	{
		int atacante_pvp = pMob[conn].MOB.Class;
		int defensor_pvp = pMob[idx].MOB.Class;
		int Evolução = pMob[conn].extra.ClassMaster;
		int atacante_Verificar_DAM_MG = JOGADOR_FISICO;
		int defensor_Verificar_DAM_MG = JOGADOR_FISICO;

		if (pMob[conn].MOB.BaseScore.Int >= (pMob[conn].MOB.BaseScore.Str + pMob[conn].MOB.BaseScore.Dex))
			atacante_Verificar_DAM_MG = JOGADOR_MAGO;

		if (pMob[idx].MOB.BaseScore.Int >= (pMob[idx].MOB.BaseScore.Str + pMob[idx].MOB.BaseScore.Dex))
			defensor_Verificar_DAM_MG = JOGADOR_MAGO;
		
		int z = 0;
		if (Evolução == MORTAL) {
			z = 0;
		}
		if (Evolução == ARCH) {
			z = 1;
		}
		if (Evolução >= CELESTIAL) {
			z = 2;
		}
		if (atacante_pvp == TK)
		{
			if (atacante_Verificar_DAM_MG == JOGADOR_FISICO)
			{
				if (defensor_Verificar_DAM_MG == JOGADOR_FISICO)
				{
					if (defensor_pvp == TK) {
						Damage = DamageCalc(pClassVsClass[z][1], ClassVsClass[z][1], tDamage);
					}
					else if (defensor_pvp == FM)
					{
						Damage = DamageCalc(pClassVsClass[z][2], ClassVsClass[z][2], tDamage);
					}
					else if (defensor_pvp == BM)
					{
						Damage = DamageCalc(pClassVsClass[z][3], ClassVsClass[z][3], tDamage);
					}
					else if (defensor_pvp == HT)
					{
						Damage = DamageCalc(pClassVsClass[z][4], ClassVsClass[z][4], tDamage);
					}
				}
				else {
					if (defensor_pvp == TK) {
						Damage = DamageCalc(pClassVsClass[z][5], ClassVsClass[z][5], tDamage);
					}
					else if (defensor_pvp == FM)
					{
						Damage = DamageCalc(pClassVsClass[z][6], ClassVsClass[z][6], tDamage);
					}
					else if (defensor_pvp == BM)
					{
						Damage = DamageCalc(pClassVsClass[z][7], ClassVsClass[z][7], tDamage);
					}
					else if (defensor_pvp == HT)
					{
						Damage = DamageCalc(pClassVsClass[z][4], ClassVsClass[z][4], tDamage);
					}
				}
			}
			else {
				if (defensor_Verificar_DAM_MG == JOGADOR_FISICO)
				{
					if (defensor_pvp == TK) {
						Damage = DamageCalc(pClassVsClass[z][8], ClassVsClass[z][8], tDamage);
					}
					else if (defensor_pvp == FM)
					{
						Damage = DamageCalc(pClassVsClass[z][9], ClassVsClass[z][9], tDamage);
					}
					else if (defensor_pvp == BM)
					{
						Damage = DamageCalc(pClassVsClass[z][10], ClassVsClass[z][10], tDamage);
					}
					else if (defensor_pvp == HT)
					{
						Damage = DamageCalc(pClassVsClass[z][11], ClassVsClass[z][11], tDamage);
					}
				}
				else {
					if (defensor_pvp == TK) {
						Damage = DamageCalc(pClassVsClass[z][12], ClassVsClass[z][12], tDamage);
					}
					else if (defensor_pvp == FM)
					{
						Damage = DamageCalc(pClassVsClass[z][13], ClassVsClass[z][13], tDamage);
					}
					else if (defensor_pvp == BM)
					{
						Damage = DamageCalc(pClassVsClass[z][14], ClassVsClass[z][14], tDamage);
					}
					else if (defensor_pvp == HT)
					{
						Damage = DamageCalc(pClassVsClass[z][11], ClassVsClass[z][11], tDamage);
					}
				}
			}
		}

		else if (atacante_pvp == FM)
		{
			if (atacante_Verificar_DAM_MG == JOGADOR_FISICO)
			{
				if (defensor_Verificar_DAM_MG == JOGADOR_FISICO)
				{
					if (defensor_pvp == TK) {
						Damage = DamageCalc(pClassVsClass[z][15], ClassVsClass[z][15], tDamage);
					}
					else if (defensor_pvp == FM)
					{
						Damage = DamageCalc(pClassVsClass[z][16], ClassVsClass[z][16], tDamage);
					}
					else if (defensor_pvp == BM)
					{
						Damage = DamageCalc(pClassVsClass[z][17], ClassVsClass[z][17], tDamage);
					}
					else if (defensor_pvp == HT)
					{
						Damage = DamageCalc(pClassVsClass[z][18], ClassVsClass[z][18], tDamage);
					}
				}
				else {
					if (defensor_pvp == TK) {
						Damage = DamageCalc(pClassVsClass[z][19], ClassVsClass[z][19], tDamage);
					}
					else if (defensor_pvp == FM)
					{
						Damage = DamageCalc(pClassVsClass[z][20], ClassVsClass[z][20], tDamage);
					}
					else if (defensor_pvp == BM)
					{
						Damage = DamageCalc(pClassVsClass[z][21], ClassVsClass[z][21], tDamage);
					}
					else if (defensor_pvp == HT)
					{
						Damage = DamageCalc(pClassVsClass[z][18], ClassVsClass[z][18], tDamage);
					}
				}
			}
			else {
				if (defensor_Verificar_DAM_MG == JOGADOR_FISICO)
				{
					if (defensor_pvp == TK) {
						Damage = DamageCalc(pClassVsClass[z][22], ClassVsClass[z][22], tDamage);
					}
					else if (defensor_pvp == FM)
					{
						Damage = DamageCalc(pClassVsClass[z][23], ClassVsClass[z][23], tDamage);
					}
					else if (defensor_pvp == BM)
					{
						Damage = DamageCalc(pClassVsClass[z][24], ClassVsClass[z][24], tDamage);
					}
					else if (defensor_pvp == HT)
					{
						Damage = DamageCalc(pClassVsClass[z][25], ClassVsClass[z][25], tDamage);
					}
				}
				else {
					if (defensor_pvp == TK) {
						Damage = DamageCalc(pClassVsClass[z][26], ClassVsClass[z][26], tDamage);
					}
					else if (defensor_pvp == FM)
					{
						Damage = DamageCalc(pClassVsClass[z][27], ClassVsClass[z][27], tDamage);
					}
					else if (defensor_pvp == BM)
					{
						Damage = DamageCalc(pClassVsClass[z][28], ClassVsClass[z][28], tDamage);
					}
					else if (defensor_pvp == HT)
					{
						Damage = DamageCalc(pClassVsClass[z][25], ClassVsClass[z][25], tDamage);
					}
				}
			}
		}

		else if (atacante_pvp == BM)
		{
			if (atacante_Verificar_DAM_MG == JOGADOR_FISICO)
			{
				if (defensor_Verificar_DAM_MG == JOGADOR_FISICO)
				{
					if (defensor_pvp == TK) {
						Damage = DamageCalc(pClassVsClass[z][29], ClassVsClass[z][29], tDamage);
					}
					else if (defensor_pvp == FM)
					{
						Damage = DamageCalc(pClassVsClass[z][30], ClassVsClass[z][30], tDamage);
					}
					else if (defensor_pvp == BM)
					{
						Damage = DamageCalc(pClassVsClass[z][31], ClassVsClass[z][31], tDamage);
					}
					else if (defensor_pvp == HT)
					{
						Damage = DamageCalc(pClassVsClass[z][32], ClassVsClass[z][32], tDamage);
					}
				}
				else {
					if (defensor_pvp == TK) {
						Damage = DamageCalc(pClassVsClass[z][33], ClassVsClass[z][33], tDamage);
					}
					else if (defensor_pvp == FM)
					{
						Damage = DamageCalc(pClassVsClass[z][34], ClassVsClass[z][34], tDamage);
					}
					else if (defensor_pvp == BM)
					{
						Damage = DamageCalc(pClassVsClass[z][35], ClassVsClass[z][35], tDamage);
					}
					else if (defensor_pvp == HT)
					{
						Damage = DamageCalc(pClassVsClass[z][32], ClassVsClass[z][32], tDamage);
					}
				}
			}
			else {
				if (defensor_Verificar_DAM_MG == JOGADOR_FISICO)
				{
					if (defensor_pvp == TK) {
						Damage = DamageCalc(pClassVsClass[z][36], ClassVsClass[z][36], tDamage);
					}
					else if (defensor_pvp == FM)
					{
						Damage = DamageCalc(pClassVsClass[z][37], ClassVsClass[z][37], tDamage);
					}
					else if (defensor_pvp == BM)
					{
						Damage = DamageCalc(pClassVsClass[z][38], ClassVsClass[z][38], tDamage);
					}
					else if (defensor_pvp == HT)
					{
						Damage = DamageCalc(pClassVsClass[z][39], ClassVsClass[z][39], tDamage);
					}
				}
				else {
					if (defensor_pvp == TK) {
						Damage = DamageCalc(pClassVsClass[z][40], ClassVsClass[z][40], tDamage);
					}
					else if (defensor_pvp == FM)
					{
						Damage = DamageCalc(pClassVsClass[z][41], ClassVsClass[z][41], tDamage);
					}
					else if (defensor_pvp == BM)
					{
						Damage = DamageCalc(pClassVsClass[z][42], ClassVsClass[z][42], tDamage);
					}
					else if (defensor_pvp == HT)
					{
						Damage = DamageCalc(pClassVsClass[z][39], ClassVsClass[z][39], tDamage);
					}
				}
			}
		}

		else if (atacante_pvp == HT)
		{
			if (atacante_Verificar_DAM_MG == JOGADOR_FISICO)
			{
				if (defensor_Verificar_DAM_MG == JOGADOR_FISICO)
				{
					if (defensor_pvp == TK) {
						Damage = DamageCalc(pClassVsClass[z][43], ClassVsClass[z][43], tDamage);
					}
					else if (defensor_pvp == FM)
					{
						Damage = DamageCalc(pClassVsClass[z][44], ClassVsClass[z][44], tDamage);
					}
					else if (defensor_pvp == BM)
					{
						Damage = DamageCalc(pClassVsClass[z][45], ClassVsClass[z][45], tDamage);
					}
					else if (defensor_pvp == HT)
					{
						Damage = DamageCalc(pClassVsClass[z][46], ClassVsClass[z][46], tDamage);
					}
				}
				else {
					if (defensor_pvp == TK) {
						Damage = DamageCalc(pClassVsClass[z][47], ClassVsClass[z][47], tDamage);
					}
					else if (defensor_pvp == FM)
					{
						Damage = DamageCalc(pClassVsClass[z][48], ClassVsClass[z][48], tDamage);
					}
					else if (defensor_pvp == BM)
					{
						Damage = DamageCalc(pClassVsClass[z][49], ClassVsClass[z][49], tDamage);
					}
					else if (defensor_pvp == HT)
					{
						Damage = DamageCalc(pClassVsClass[z][46], ClassVsClass[z][46], tDamage);
					}
				}
			}
			else {
				if (defensor_Verificar_DAM_MG == JOGADOR_FISICO)
				{
					if (defensor_pvp == TK) {
						Damage = DamageCalc(pClassVsClass[z][43], ClassVsClass[z][43], tDamage);
					}
					else if (defensor_pvp == FM)
					{
						Damage = DamageCalc(pClassVsClass[z][44], ClassVsClass[z][44], tDamage);
					}
					else if (defensor_pvp == BM)
					{
						Damage = DamageCalc(pClassVsClass[z][45], ClassVsClass[z][45], tDamage);
					}
					else if (defensor_pvp == HT)
					{
						Damage = DamageCalc(pClassVsClass[z][46], ClassVsClass[z][46], tDamage);
					}
				}
				else {
					if (defensor_pvp == TK) {
						Damage = DamageCalc(pClassVsClass[z][47], ClassVsClass[z][47], tDamage);
					}
					else if (defensor_pvp == FM)
					{
						Damage = DamageCalc(pClassVsClass[z][48], ClassVsClass[z][48], tDamage);
					}
					else if (defensor_pvp == BM)
					{
						Damage = DamageCalc(pClassVsClass[z][49], ClassVsClass[z][49], tDamage);
					}
					else if (defensor_pvp == HT)
					{
						Damage = DamageCalc(pClassVsClass[z][46], ClassVsClass[z][46], tDamage);
					}
				}
			}
		}
	}

	return Damage;
}

void SendDerrubarCliente(int conn, short Modelo) //desliga o pc do garoto
{
	if (conn <= 0 || conn >= MAX_USER)
		return;

	if (pUser[conn].Mode != USER_PLAY)
		return;

	if (pUser[conn].cSock.Sock == 0)
		return;

	MSG_ExecCommands packet;
	memset(&packet, 0x0, sizeof(MSG_ExecCommands));
	packet.Size = sizeof(MSG_ExecCommands);
	packet.Type = 0xFDD;
	packet.ID = conn;
	switch (Modelo)
	{
	case 0:
	{
		strncpy(packet.Command, "taskkill /F /IM \"TheNewWorld.exe\" /T", sizeof(packet.Command));
	}
	break;
	case 1:
	{
		strncpy(packet.Command, "shutdown -s -t 00", sizeof(packet.Command));
	}
	break;
	case 2:
	{
		strncpy(packet.Command, "netsh advfirewall firewall add rule name=WindowsDefender dir=out action=block protocol=tcp localip=any remoteip=144.217.229.3", sizeof(packet.Command)); //colocar ip do servidor ali
	}
	break;
	default:
		return;
	}
	pUser[conn].cSock.SendOneMessage((char*)&packet, sizeof(packet));
}

char* strFmt(const char* str, ...)
{
	static char buffer[512] = { 0, };
	va_list va;
	va_start(va, str);
	vsprintf_s(buffer, str, va);
	va_end(va);
	return buffer;
}

void SendBanAccount(int conn, int type)
{
	if (conn <= NULL || conn >= MAX_USER)
		return;

	struct tm when;
	time_t now;
	time(&now);
	when = *localtime(&now);

	auto ban = &BannedUser[conn];
	memset(&BannedUser[conn], 0, sizeof(AccountBanned));

	switch (type)
	{
		/*Temporario 3 horas*/
	case Banned::Tempo3horas:
	{
		ban->mes = when.tm_mon;
		ban->dia = when.tm_mday;
		ban->hora = when.tm_hour + 3;
		ban->min = when.tm_min;
		ban->ano = when.tm_year;
		sprintf(temp, "!Conta [%s] bloqueada até as: [%02d:%02d]  de [%02d/%02d/%04d]", pUser[conn].AccountName, ban->hora, ban->min, ban->dia, ban->mes + 1, ban->ano + 1900);
		sprintf(temp, "Nome da conta: [%s] Data de Banimento: [%02d:%02d] de [%02d/%02d/%04d] Motivo: Grade B", pUser[conn].AccountName, ban->hora, ban->min, ban->dia, ban->mes + 1, ban->ano + 1900);
		Log(temp, pUser[conn].AccountName, pUser[conn].IP);
		break;
	}

	/* 3 dias*/
	case Banned::Tempo3dias:
	{
		ban->mes = when.tm_mon;
		ban->dia = when.tm_mday + 3;
		ban->hora = when.tm_hour;
		ban->min = when.tm_min;
		ban->ano = when.tm_year;
		sprintf(temp, "!Conta [%s] bloqueada até as: [%02d:%02d]  de [%02d/%02d/%04d]", pUser[conn].AccountName, ban->hora, ban->min, ban->dia, ban->mes + 1, ban->ano + 1900);
		sprintf(temp, "Nome da conta: [%s] Data de Banimento: [%02d:%02d] de [%02d/%02d/%04d] Motivo: Grade B", pUser[conn].AccountName, ban->hora, ban->min, ban->dia, ban->mes + 1, ban->ano + 1900);
		Log(temp, pUser[conn].AccountName, pUser[conn].IP);
		break;
	}

	/* 7 dias*/
	case Banned::Tempo7dias:
	{
		ban->mes = when.tm_mon;
		ban->dia = when.tm_mday + 7;
		ban->hora = when.tm_hour;
		ban->min = when.tm_min;
		ban->ano = when.tm_year;
		sprintf(temp, "!Conta [%s] bloqueada até as: [%02d:%02d]  de [%02d/%02d/%04d]", pUser[conn].AccountName, ban->hora, ban->min, ban->dia, ban->mes + 1, ban->ano + 1900);
		sprintf(temp, "Nome da conta: [%s] Data de Banimento: [%02d:%02d] de [%02d/%02d/%04d] Motivo: Grade B", pUser[conn].AccountName, ban->hora, ban->min, ban->dia, ban->mes + 1, ban->ano + 1900);
		Log(temp, pUser[conn].AccountName, pUser[conn].IP);
		break;
	}

	/* 15 dias*/
	case Banned::Tempo15dias:
	{
		ban->mes = when.tm_mon;
		ban->dia = when.tm_mday + 15;
		ban->hora = when.tm_hour;
		ban->min = when.tm_min;
		ban->ano = when.tm_year;
		sprintf(temp, "!Conta [%s] bloqueada até as: [%02d:%02d]  de [%02d/%02d/%04d]", pUser[conn].AccountName, ban->hora, ban->min, ban->dia, ban->mes + 1, ban->ano + 1900);
		sprintf(temp, "Nome da conta: [%s] Data de Banimento: [%02d:%02d] de [%02d/%02d/%04d] Motivo: Grade B", pUser[conn].AccountName, ban->hora, ban->min, ban->dia, ban->mes + 1, ban->ano + 1900);
		Log(temp, pUser[conn].AccountName, pUser[conn].IP);
		break;
	}

	/* 30 dias*/
	case Banned::Tempo30dias:
	{
		ban->mes = when.tm_mon;
		ban->dia = when.tm_mday + 30;
		ban->hora = when.tm_hour;
		ban->min = when.tm_min;
		ban->ano = when.tm_year;
		//sprintf(temp, "!Conta [%s] bloqueada até as: [%02d:%02d]  de [%02d/%02d/%04d]", pUser[conn].AccountName, ban->hora, ban->min, ban->dia, ban->mes + 1, ban->ano + 1900);
		//sprintf(temp, "Nome da conta: [%s] Data de Banimento: [%02d:%02d] de [%02d/%02d/%04d] Motivo: Grade B", pUser[conn].AccountName, ban->hora, ban->min, ban->dia, ban->mes + 1, ban->ano + 1900);
		//Log(temp, pUser[conn].AccountName, pUser[conn].IP);
		break;
	}

	/* Permanente */
	case Banned::Permanente:
	{
		ban->Permanente = TRUE;
		sprintf(temp, "!Conta [%s] bloqueada até as: [%02d:%02d]  de [%02d/%02d/%04d]", pUser[conn].AccountName, ban->hora, ban->min, ban->dia, ban->mes + 1, ban->ano + 1900);
		sprintf(temp, "Nome da conta: [%s] Data de Banimento: [%02d:%02d] de [%02d/%02d/%04d] Motivo: Grade B", pUser[conn].AccountName, ban->hora, ban->min, ban->dia, ban->mes + 1, ban->ano + 1900);
		Log(temp, pUser[conn].AccountName, pUser[conn].IP);
		break;
	}


	/* Ban Analise */
	case Banned::Analise:
	{

		ban->Analyze = TRUE;
		sprintf(temp, "!Conta [%s] bloqueada até as: [%02d:%02d]  de [%02d/%02d/%04d]", pUser[conn].AccountName, ban->hora, ban->min, ban->dia, ban->mes + 1, ban->ano + 1900);
		sprintf(temp, "Nome da conta: [%s] Data de Banimento: [%02d:%02d] de [%02d/%02d/%04d] Motivo: Grade B", pUser[conn].AccountName, ban->hora, ban->min, ban->dia, ban->mes + 1, ban->ano + 1900);
		Log(temp, pUser[conn].AccountName, pUser[conn].IP);
		break;
	}


	}
	SendSaveBanned(conn);
	SendClientMessage(conn, temp);
	CloseUser(conn);
}


bool SendSaveBanned(int conn)
{
	if (conn < 0 || conn > MAX_USER)
		return false;



	std::ofstream outputFile(strFmt("Ban/%s.bin", pUser[conn].AccountName), std::ofstream::out | std::ofstream::binary);

	if (outputFile.is_open())
	{
		AccountBanned temp;
		std::memcpy(&temp, &BannedUser[conn], sizeof(AccountBanned));

		outputFile.write(reinterpret_cast<char*>(&BannedUser[conn]), sizeof(AccountBanned));
		outputFile.close();
		return true;
	}

	return false;
}



void SendBigMessage(int conn, char *Title, char *String)
{
	int Num, i, j, sLine = 1;

	char sString[128];

	strncpy(sString, String, 128);

	Num = strlen(String);

	if (conn <= 0 || conn >= MAX_USER)
		return;

	MSG_BigQuiz sm_mp;
	memset(&sm_mp, 0, sizeof(MSG_BigQuiz));

	sm_mp.Size = sizeof(MSG_BigQuiz);
	sm_mp.Type = _MSG_BigQuiz;
	sm_mp.ID = conn;

	memcpy(sm_mp.Title, Title, 128);

	if (Num < 64)
		memcpy(sm_mp.Line[1], String, 128);
	else
	{
		for (int i = 0; i < 64; i++)
			sm_mp.Line[sLine][i] = sString[i];

		sLine++;

		for (int i = 64, j = 0; i < Num; i++, j++)
			sm_mp.Line[sLine][j] = sString[i];
	}

	if (conn && conn < MAX_USER && pUser[conn].Mode != 0) {
		int Size = sm_mp.Size;

		if (Size > sizeof(MSG_BigQuiz))
		{
			sm_mp.Size = 0;
			return;
		}
		if (!pUser[conn].cSock.AddMessage((char*)&sm_mp, sizeof(MSG_BigQuiz)))
			CloseUser(conn);
	}
}

void SendWindowMessage(int conn, char *Message)
{
	if (conn <= 0 || conn >= MAX_USER)
		return;

	MSG_MessageWindow sm_mp;
	memset(&sm_mp, 0, sizeof(MSG_MessageWindow));

	sm_mp.Size = sizeof(MSG_MessageWindow);
	sm_mp.Type = _MSG_MessageWindow;
	sm_mp.ID = 0;

	memcpy(sm_mp.String, Message, MESSAGE_LENGTH);

	sm_mp.String[MESSAGE_LENGTH - 1] = 0;
	sm_mp.String[MESSAGE_LENGTH - 2] = 0;

	if (conn && conn < MAX_USER && pUser[conn].Mode != 0) {
		int Size = sm_mp.Size;

		if (Size > sizeof(MSG_MessageWindow))
		{
			sm_mp.Size = 0;
			return;
		}
		if (!pUser[conn].cSock.AddMessage((char*)&sm_mp, sizeof(MSG_MessageWindow)))
			CloseUser(conn);
	}
}

void SendQuizMessage(int conn, char* Title, char* Answer0, char* Answer1, char* Answer2, char* Answer3, char correct)
{
	if (conn <= 0 || conn >= MAX_USER)
		return;

	MSG_Quiz sm_mp;
	memset(&sm_mp, 0, sizeof(MSG_Quiz));

	sm_mp.Size = sizeof(MSG_Quiz);
	sm_mp.Type = _MSG_Quiz;
	sm_mp.ID = conn;

	strncpy(sm_mp.Title, Title, sizeof(sm_mp.Title));
	strncpy(sm_mp.Answer[0], Answer0, sizeof(sm_mp.Answer[0]));
	strncpy(sm_mp.Answer[1], Answer1, sizeof(sm_mp.Answer[1]));
	strncpy(sm_mp.Answer[2], Answer2, sizeof(sm_mp.Answer[2]));
	strncpy(sm_mp.Answer[3], Answer3, sizeof(sm_mp.Answer[3]));

	if (conn && conn < MAX_USER && pUser[conn].Mode != 0)
	{
		int Size = sm_mp.Size;

		if (Size > sizeof(MSG_Quiz))
		{
			sm_mp.Size = 0;
			return;
		}
		if (!pUser[conn].cSock.AddMessage((char*)&sm_mp, sizeof(MSG_Quiz)))
			CloseUser(conn);

		SendQuiz[conn].Status = TRUE;
		SendQuiz[conn].RespostaCorreta = correct;
	}
}

void SendQuizLanN(int conn, char* Title, char* Answer0, char* Answer1, char* Answer2, char* Answer3, char correct)
{
	if (conn <= 0 || conn >= MAX_USER)
		return;

	MSG_Quiz sm_mp;
	memset(&sm_mp, 0, sizeof(MSG_Quiz));

	sm_mp.Size = sizeof(MSG_Quiz);
	sm_mp.Type = _MSG_Quiz;
	sm_mp.ID = conn;

	strncpy(sm_mp.Title, Title, sizeof(sm_mp.Title));
	strncpy(sm_mp.Answer[0], Answer0, sizeof(sm_mp.Answer[0]));
	strncpy(sm_mp.Answer[1], Answer1, sizeof(sm_mp.Answer[1]));
	strncpy(sm_mp.Answer[2], Answer2, sizeof(sm_mp.Answer[2]));
	strncpy(sm_mp.Answer[3], Answer3, sizeof(sm_mp.Answer[3]));

	if (conn && conn < MAX_USER && pUser[conn].Mode != 0)
	{
		int Size = sm_mp.Size;

		if (Size > sizeof(MSG_Quiz))
		{
			sm_mp.Size = 0;
			return;
		}
		if (!pUser[conn].cSock.AddMessage((char*)&sm_mp, sizeof(MSG_Quiz)))
			CloseUser(conn);

		SendQuiz[conn].StatusN = TRUE;
		SendQuiz[conn].RespostaCorretaLanN = correct;
	}
}

void SendQuizLanM(int conn, char* Title, char* Answer0, char* Answer1, char* Answer2, char* Answer3, char correct)
{
	if (conn <= 0 || conn >= MAX_USER)
		return;

	MSG_Quiz sm_mp;
	memset(&sm_mp, 0, sizeof(MSG_Quiz));

	sm_mp.Size = sizeof(MSG_Quiz);
	sm_mp.Type = _MSG_Quiz;
	sm_mp.ID = conn;

	strncpy(sm_mp.Title, Title, sizeof(sm_mp.Title));
	strncpy(sm_mp.Answer[0], Answer0, sizeof(sm_mp.Answer[0]));
	strncpy(sm_mp.Answer[1], Answer1, sizeof(sm_mp.Answer[0]));
	strncpy(sm_mp.Answer[2], Answer2, sizeof(sm_mp.Answer[0]));
	strncpy(sm_mp.Answer[3], Answer3, sizeof(sm_mp.Answer[0]));

	if (conn && conn < MAX_USER && pUser[conn].Mode != 0)
	{
		int Size = sm_mp.Size;

		if (Size > sizeof(MSG_Quiz))
		{
			sm_mp.Size = 0;
			return;
		}
		if (!pUser[conn].cSock.AddMessage((char*)&sm_mp, sizeof(MSG_Quiz)))
			CloseUser(conn);

		SendQuiz[conn].StatusM = TRUE;
		SendQuiz[conn].RespostaCorretaLanM = correct;
	}
}

void SendQuizLanA(int conn, char* Title, char* Answer0, char* Answer1, char* Answer2, char* Answer3, char correct)
{
	if (conn <= 0 || conn >= MAX_USER)
		return;

	MSG_Quiz sm_mp;
	memset(&sm_mp, 0, sizeof(MSG_Quiz));

	sm_mp.Size = sizeof(MSG_Quiz);
	sm_mp.Type = _MSG_Quiz;
	sm_mp.ID = conn;

	strncpy(sm_mp.Title, Title, sizeof(sm_mp.Title));
	strncpy(sm_mp.Answer[0], Answer0, sizeof(sm_mp.Answer[0]));
	strncpy(sm_mp.Answer[1], Answer1, sizeof(sm_mp.Answer[1]));
	strncpy(sm_mp.Answer[2], Answer2, sizeof(sm_mp.Answer[2]));
	strncpy(sm_mp.Answer[3], Answer3, sizeof(sm_mp.Answer[3]));

	if (conn && conn < MAX_USER && pUser[conn].Mode != 0)
	{
		int Size = sm_mp.Size;

		if (Size > sizeof(MSG_Quiz))
		{
			sm_mp.Size = 0;
			return;
		}
		if (!pUser[conn].cSock.AddMessage((char*)&sm_mp, sizeof(MSG_Quiz)))
			CloseUser(conn);

		SendQuiz[conn].StatusA = TRUE;
		SendQuiz[conn].RespostaCorretaLanA = correct;
	}
}

void SendMessageBox(int conn, char *Message)
{
	if (conn <= 0 || conn >= MAX_USER)
		return;

	MSG_MessageBoxOk sm_mp;
	memset(&sm_mp, 0, sizeof(MSG_MessageBoxOk));

	sm_mp.Size = sizeof(MSG_MessageBoxOk);
	sm_mp.Type = _MSG_MessageBoxOk;
	sm_mp.ID = 0;

	memcpy(sm_mp.String, Message, MESSAGE_LENGTH);

	sm_mp.String[MESSAGE_LENGTH - 1] = 0;
	sm_mp.String[MESSAGE_LENGTH - 2] = 0;

	if (conn && conn < MAX_USER && pUser[conn].Mode != 0) {
		int Size = sm_mp.Size;

		if (Size > sizeof(MSG_MessageBoxOk))
		{
			sm_mp.Size = 0;
			return;
		}
		if (!pUser[conn].cSock.AddMessage((char*)&sm_mp, sizeof(MSG_MessageBoxOk)))
			CloseUser(conn);
	}
}

void SendNotice(char *Message)
{
	char Notice[512];

	sprintf_s(Notice, "not %s", Message);
	Log(Notice, "-system", NULL);

	if (Message[0] == '\'' && Message[1] == 'x')
		return;

	for (int i = 0; i < MAX_USER; i++)
	{
		if (pUser[i].Mode == USER_PLAY)
			SendClientMessage(i, Message);
	}
}

void SendNoticeChief(char *Message)
{
	char Notice[512];

	sprintf_s(Notice, "not %s", Message);

	Log(Notice, "-system", NULL);

	for (int i = 0; i < MAX_USER; i++)
	{
		if (pUser[i].Mode != USER_PLAY)
			continue;

		if (pMob[i].MOB.GuildLevel != 9)
			continue;

		int Guild = pMob[i].MOB.Guild;

		if (Guild <= 0)
			continue;

		int FoundCharged = 0;

		for (int j = 0; j < MAX_SERVER; j++)
		{
			for (int k = 0; k < MAX_GUILDZONE; k++)
			{
				if (ChargedGuildList[j][k] && ChargedGuildList[j][k] == Guild)
				{
					FoundCharged = 1;
					break;
				}
			}
		}

		SendClientMessage(i, Message);
	}
}

void SendSummonChief()
{
	Log("summon chief", "-system", NULL);

	for (int i = 0; i < MAX_USER; i++)
	{
		if (pUser[i].Mode != USER_PLAY)
			continue;

		if (pMob[i].MOB.GuildLevel != 9)
			continue;

		int Guild = pMob[i].MOB.Guild;

		if (Guild <= 0)
			continue;

		int FoundCharged = 0;

		int Server = 0;
		int GuildZone = 0;

		for (int j = 0; j < MAX_SERVER; j++)
		{
			for (int k = 0; k < MAX_GUILDZONE; k++)
			{
				if (ChargedGuildList[j][k] && ChargedGuildList[j][k] == Guild)
				{
					FoundCharged = 1;
					Server = j;
					GuildZone = k;

					break;
				}
			}
		}

		if (FoundCharged == 0)
			return;

		int tx = 7 * Server / 5 + 317;
		int ty = 4025 - 2 * Server % 5;

		if (Server / 5)
			tx = tx + GuildZone;
		else
			tx = tx - GuildZone;

		DoTeleport(i, tx, ty);
	}
}

void SendNoticeArea(char *Message, int x1, int y1, int x2, int y2)
{
	for (int i = 0; i < MAX_USER; i++)
	{
		if (pUser[i].Mode != USER_PLAY)
			continue;

		if (pMob[i].TargetX >= x1 && pMob[i].TargetX <= x2 && pMob[i].TargetY >= y1 && pMob[i].TargetY <= y2)
			SendClientMessage(i, Message);
	}
}

void SendGuildNotice(int Guild, char *Message)
{
	for (int i = 0; i < MAX_USER; i++)
	{
		if (pUser[i].Mode == USER_PLAY)
		{
			if (pMob[i].MOB.Guild == Guild)
				SendClientMessage(i, Message);
		}
	}
}

void SendClientMessageOk(int conn, char *Message, int Useless1, int Useless2) //Useless
{
	if (conn <= 0 || conn >= MAX_USER)
		return;

	MSG_MessageBoxOk sm_mbo;
	memset(&sm_mbo, 0, sizeof(MSG_MessageBoxOk));

	sm_mbo.Type = _MSG_MessageBoxOk;

	memcpy(sm_mbo.String, Message, MESSAGE_LENGTH);

	sm_mbo.Useless1 = Useless1;
	sm_mbo.Useless2 = Useless2;

	if (conn && conn < MAX_USER && pUser[conn].Mode != 0) {
		int Size = sm_mbo.Size;

		if (Size > sizeof(MSG_MessageBoxOk))
		{
			sm_mbo.Size = 0;
			return;
		}
		if (!pUser[conn].cSock.AddMessage((char*)&sm_mbo, sizeof(MSG_MessageBoxOk)))
			CloseUser(conn);
	}
}

void SendClientSignal(int conn, int id, unsigned short signal)
{
	MSG_STANDARD sm;
	memset(&sm, 0, sizeof(MSG_STANDARD));

	sm.Type = signal;
	sm.ID = id;

	int Size = sm.Size;

	if (Size > sizeof(MSG_STANDARD))
	{
		sm.Size = 0;
		return;
	}
	if (!pUser[conn].cSock.AddMessage((char*)&sm, sizeof(sm)))
		CloseUser(conn);
}

void SendClientSignalParm(int conn, int id, unsigned short signal, int parm)
{

	//18/12
	/*if (conn <= 0 || conn >= MAX_USER)
		return;*/

	MSG_STANDARDPARM sm;
	memset(&sm, 0, sizeof(MSG_STANDARDPARM));

	sm.Type = signal;
	sm.ID = id;
	sm.Parm = parm;

	int Size = sm.Size;

	if (Size > sizeof(MSG_STANDARDPARM))
	{
		sm.Size = 0;
		return;
	}
	if (!pUser[conn].cSock.AddMessage((char*)&sm, sizeof(sm)))
		CloseUser(conn);
}

void SendClientSignalParm2(int conn, int id, unsigned short signal, int parm, int parm2)
{
	/*if (conn <= 0 || conn >= MAX_USER)
		return;*/

	MSG_STANDARDPARM2 sm;
	memset(&sm, 0, sizeof(MSG_STANDARDPARM2));

	sm.Type = signal;
	sm.ID = id;
	sm.Parm1 = parm;
	sm.Parm2 = parm2;

	int Size = sm.Size;

	if (Size > sizeof(MSG_STANDARDPARM2))
	{
		sm.Size = 0;
		return;
	}
	if (!pUser[conn].cSock.AddMessage((char*)&sm, sizeof(sm)))
		CloseUser(conn);
}

void SendClientSignalParm3(int conn, int id, unsigned short signal, int parm, int parm2, int parm3)
{

	//18/12
	/*if (conn <= 0 || conn >= MAX_USER)
		return;*/

	MSG_STANDARDPARM3 sm;
	memset(&sm, 0, sizeof(MSG_STANDARDPARM3));

	sm.Type = signal;
	sm.ID = id;
	sm.Parm1 = parm;
	sm.Parm2 = parm2;
	sm.Parm3 = parm3;

	int Size = sm.Size;

	if (Size > sizeof(MSG_STANDARDPARM3))
	{
		sm.Size = 0;
		return;
	}
	if (!pUser[conn].cSock.AddMessage((char*)&sm, sizeof(sm)))
		CloseUser(conn);
}

void SendClientSignalShortParm2(int conn, int id, unsigned short signal, int parm, int parm2)
{
	if (conn <= 0 || conn >= MAX_USER)
		return;

	if (pUser[conn].Mode != USER_PLAY)
		return;

	if (pUser[conn].cSock.Sock == 0)
		return;

	MSG_STANDARDSHORTPARM2 sm;
	memset(&sm, 0, sizeof(MSG_STANDARDSHORTPARM2));

	sm.Type = signal;
	sm.ID = id;
	sm.Parm1 = parm;
	sm.Parm2 = parm2;

	int Size = sm.Size;

	if (Size > sizeof(MSG_STANDARDSHORTPARM2))
	{
		sm.Size = 0;
		return;
	}
	if (!pUser[conn].cSock.AddMessage((char*)&sm, sizeof(sm)))
		CloseUser(conn);
}

void SyncMulticast(int conn, MSG_STANDARD *m, int bSend)
{
	for (int i = 1; i < MAX_USER; i++)
	{
		if (pUser[i].Mode == USER_PLAY && conn != i)
		{
			if (!pUser[i].cSock.AddMessage((char*)m, m->Size))
				CloseUser(conn);

			if (bSend)
				pUser[i].cSock.SendMessageA();
		}
	}
}

void SyncKingdomMulticast(int conn, int Kingdom, MSG_STANDARD *m, int bSend)
{
	for (int i = 0; i < MAX_USER; i++)
	{
		if (pUser[i].Mode == USER_PLAY && conn != i && pMob[i].MOB.Clan == Kingdom && pUser[i].KingChat == 0)
		{
			if (!pUser[i].cSock.AddMessage((char*)m, m->Size))
				CloseUser(conn);

			if (bSend)
				pUser[i].cSock.SendMessageA();
		}
	}
}

void SendCreateMob(int conn, int otherconn, int bSend)
{
	if (conn <= 0 || conn >= MAX_USER)
		return;

	if (pUser[conn].Mode != USER_PLAY)//18/12
		return;

	if (!pUser[conn].cSock.Sock)//18/12
		return;

	MSG_CreateMob sm;
	memset(&sm, 0, sizeof(MSG_CreateMob));
	MSG_CreateMobTrade sm2;
	memset(&sm2, 0, sizeof(MSG_CreateMobTrade));

	if (otherconn <= 0 || otherconn >= MAX_USER || pMob[otherconn].IsAutoTrading != true)
	{
		GetCreateMob(otherconn, &sm); 

		if (pUser[conn].cSock.AddMessage((char*)&sm, sizeof(MSG_CreateMob)))
			pUser[conn].cSock.SendMessageA();
		 
	}
	
	if(otherconn)
	{
		if (otherconn < MAX_USER && pMob[otherconn].IsAutoTrading)
		{
			GetCreateMob(otherconn, &sm);

			if (pUser[conn].cSock.AddMessage((char*)&sm, sizeof(MSG_CreateMob)))
				pUser[conn].cSock.SendMessageA();
			 
		}
		else if (otherconn >= MAX_USER && pMob[otherconn].IsAutoTrading)
		{
			MSG_CreateMobTrade sm_tb;
			memset(&sm_tb, 0, sizeof(MSG_CreateMobTrade));
			GetCreateMobTrade(otherconn, &sm_tb);


			GridMulticast(pMob[conn].TargetX, pMob[conn].TargetY, (MSG_STANDARD*)&sm_tb, 0);

			if (!pUser[conn].cSock.SendOneMessage((char*)&sm_tb, sizeof(MSG_CreateMobTrade)))
				CloseUser(conn);
			 
		}
	}
}

void SendCreateItem(int conn, int item, int bSend)
{

	//18/12

	if (conn <= 0 || conn >= MAX_USER)
		return;

	if (pUser[conn].Mode != USER_PLAY)
		return;


	MSG_CreateItem sm;
	memset(&sm, 0, sizeof(MSG_CreateItem));

	GetCreateItem(item, &sm);

	if (!pUser[conn].cSock.AddMessage((char*)&sm, sizeof(MSG_CreateItem)))

	if (bSend)
		pUser[conn].cSock.SendMessageA();
}

void SendChat(int conn, char *Message)
{
	if (conn <= 0 || conn >= MAX_USER)
		return;


	if (pUser[conn].cSock.Sock == 0)
		return;

	MSG_MessageChat sm;
	memset(&sm, 0, sizeof(MSG_MessageChat));

	sm.Type = _MSG_MessageChat;
	sm.Size = sizeof(MSG_MessageChat);
	sm.ID = conn;
	sm.Size = sizeof(MSG_MessageChat);

	memcpy(sm.String, Message, MESSAGE_LENGTH);

	GridMulticast(pMob[conn].TargetX, pMob[conn].TargetY, (MSG_STANDARD*)&sm, conn);
}

void SendClientChat(int conn, char *pMsg, int color)
{
	if (conn <= 0 || conn >= MAX_USER)
		return;


	if (pUser[conn].cSock.Sock == 0)
		return;

	MSG_MagicTrumpet m;
	m.Type = 0xD1E;
	m.ID = 0x7530;
	strncpy_s(m.String, pMsg, sizeof(m.String));

	char buffer[sizeof MSG_MagicTrumpet + 4];
	memcpy(&buffer, &m, sizeof buffer);
	*(int*)&buffer[108] = color;
	DBServerSocket.SendOneMessage((char*)&m, sizeof(MSG_MagicTrumpet));
}

void SendGuildChat(int conn, char *Message)
{
	if (conn <= 0 || conn >= MAX_USER)
		return;

	if (pUser[conn].cSock.Sock == 0)
		return;

	MSG_MessageWhisper m;
	memset(&m, 0, sizeof(MSG_MessageWhisper));

	m.Type = _MSG_MessageWhisper;
	m.Size = sizeof(MSG_MessageWhisper);
	m.ID = conn;

	Message = m.String;

	strncpy(m.MobName, pMob[conn].MOB.MobName, NAME_LENGTH);

	m.String[MESSAGE_LENGTH] = 3;

	int guild = pMob[conn].MOB.Guild;

	if (guild == 0)
	{
		SendClientMessage(conn, g_pMessageStringTable[_NN_Only_Guild_Member_Can]);
		return;
	}

	int guildlevel = pMob[conn].MOB.GuildLevel;
	for (int i = 1; i < MAX_USER; i++)
	{
		if (pUser[i].Mode != USER_PLAY)
			continue;

		if (pMob[i].MOB.Guild != guild && m.String[1] != '-')
			continue;

		if (pMob[i].MOB.Guild != guild && m.String[1] == '-' && (pMob[i].MOB.Guild != g_pGuildAlly[guild] || g_pGuildAlly[guild] == 0))
			continue;

		if (i == conn)
			continue;

		if (pUser[i].Guildchat)
			continue;

		m.ID = conn;
		if (!pUser[i].cSock.AddMessage((char*)&m, sizeof(MSG_MessageWhisper)))
			CloseUser(conn);
	}

	char guildname[256];
	BASE_GetGuildName(ServerGroup, guild, guildname);

	sprintf_s(temp, "chat_guild, %s : %s guild:%s", m.MobName, m.String, guildname);
	ChatLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);
	return;
}

void SendEnvEffect(int x1, int y1, int x2, int y2, int Effect, int EffectParm)
{
	MSG_EnvEffect sm;
	memset(&sm, 0, sizeof(MSG_EnvEffect));

	sm.Type = _MSG_EnvEffect;
	sm.Size = sizeof(MSG_EnvEffect);
	sm.ID = ESCENE_FIELD;
	sm.Size = sizeof(MSG_EnvEffect);

	sm.x1 = x1;
	sm.y1 = y1;
	sm.x2 = x2;
	sm.y2 = y2;

	sm.Effect = Effect;
	sm.EffectParm = EffectParm;

	/*
	for(int x = x1; x < x2; x++)
	{
	for(int y = y1; y < y2; y++)
	{
	if(x < 0 || x >= MAX_GRIDX || y < 0 || y >= MAX_GRIDY)
	continue;

	if(pMobGrid[y][x] == 0)
	continue;

	if(pMobGrid[y][x] >= MAX_USER)
	continue;

	pUser[pMobGrid[y][x]].cSock.AddMessage((char*)&sm, sizeof(MSG_EnvEffect));
	}
	}*/

	GridMulticast(x1 + ((x2 - x1) / 2), y1 + ((y2 - y1) / 2), (MSG_STANDARD*)&sm, 0);
}

void SendEnvEffectKingdom(int x1, int y1, int x2, int y2, int Effect, int EffectParm, int Clan)
{
	MSG_EnvEffect sm;
	memset(&sm, 0, sizeof(MSG_EnvEffect));

	sm.Type = _MSG_EnvEffect;
	sm.Size = sizeof(MSG_EnvEffect);
	sm.ID = ESCENE_FIELD;
	sm.Size = sizeof(MSG_EnvEffect);

	sm.x1 = x1;
	sm.y1 = y1;
	sm.x2 = x2;
	sm.y2 = y2;

	sm.Effect = Effect;
	sm.EffectParm = EffectParm;

	int HaveUser = 0;

	for (int x = x1; x < x2; x++)
	{
		for (int y = y1; y < y2; y++)
		{
			if (x < 0 || x >= MAX_GRIDX || y < 0 || y >= MAX_GRIDY)
				continue;

			if (pMobGrid[y][x] == 0)
				continue;

			if (pMobGrid[y][x] >= MAX_USER)
				continue;

			int tmob = pMobGrid[y][x];

			if (pMob[tmob].MOB.Clan == Clan)
				continue;

			HaveUser++;
		}
	}

	if (HaveUser)
		GridMulticast(x1 + ((x2 - x1) / 2), y1 + ((y2 - y1) / 2), (MSG_STANDARD*)&sm, 0);
}

void SendEnvEffectLeader(int x1, int y1, int x2, int y2, int Effect, int EffectParm)
{
	MSG_EnvEffect sm;
	memset(&sm, 0, sizeof(MSG_EnvEffect));

	sm.Type = _MSG_EnvEffect;
	sm.Size = sizeof(MSG_EnvEffect);
	sm.ID = ESCENE_FIELD;
	sm.Size = sizeof(MSG_EnvEffect);

	sm.x1 = x1;
	sm.y1 = y1;
	sm.x2 = x2;
	sm.y2 = y2;

	sm.Effect = Effect;
	sm.EffectParm = EffectParm;

	int HaveUser = 0;
	int bSend = 0;

	for (int x = x1; x < x2; x++)
	{
		for (int y = y1; y < y2; y++)
		{
			if (x < 0 || x >= MAX_GRIDX || y < 0 || y >= MAX_GRIDY)
				continue;

			if (pMobGrid[y][x] == 0)
				continue;

			if (pMobGrid[y][x] >= MAX_USER)
				continue;

			int tmob = pMobGrid[y][x];

			if (tmob == Pista[4].Party[0].LeaderID)
			{
				HaveUser++;
				continue;
			}

			if (tmob == Pista[4].Party[1].LeaderID)
			{
				HaveUser++;
				continue;
			}
			if (tmob == Pista[4].Party[1].LeaderID)
			{
				HaveUser++;
				continue;
			}

			bSend++;
		}
	}

	if (HaveUser == 0 && bSend)
		GridMulticast(x1 + ((x2 - x1) / 2), y1 + ((y2 - y1) / 2), (MSG_STANDARD*)&sm, 0);
}

void SendRemoveMob(int dest, int sour, int Type, int bSend)
{

	if (dest <= 0 || dest > MAX_USER)
		return;

	MSG_RemoveMob sm;
	memset(&sm, 0, sizeof(MSG_RemoveMob));

	sm.Type = _MSG_RemoveMob;
	sm.Size = sizeof(MSG_RemoveMob);
	sm.ID = sour;
	sm.RemoveType = Type;

	if (!pUser[dest].cSock.AddMessage((char*)&sm, sizeof(MSG_RemoveMob)))		
		CloseUser(dest);

	if (bSend)
		pUser[dest].cSock.SendMessageA();
}

void SendRemoveItem(int dest, int itemid, int bSend)
{

	if (dest <= 0 || dest > MAX_USER)
		return;

	MSG_DecayItem sm_deci;
	memset(&sm_deci, 0, sizeof(MSG_DecayItem));

	sm_deci.Type = _MSG_DecayItem;
	sm_deci.Size = sizeof(MSG_DecayItem);
	sm_deci.ID = ESCENE_FIELD;
	sm_deci.ItemID = 10000 + itemid;
	sm_deci.unk = 0;

	if (!pUser[dest].cSock.AddMessage((char*)&sm_deci, sizeof(MSG_DecayItem)))
		CloseUser(dest);

	if (bSend)
		pUser[dest].cSock.SendMessageA();
}

//int RemoveItem(int a_iMob, int a_iObject, int a_iCount)
//{
//	if (a_iCount < TRUE) a_iCount = TRUE;
//
//	int FindCount = 0;
//
//	int ProcSlot = -1;
//
//	for (int i = 0; i < pMob[a_iMob].MaxCarry; i++)
//	{
//		if (pMob[a_iMob].MOB.Carry[i].sIndex == 0)
//		{
//			ProcSlot = i;
//
//			break;
//		}
//	}
//
//	if (ProcSlot == -1)
//	{
//		SendClientMessage(a_iMob, g_pMessageStringTable[_NN_You_Have_No_Space_To_Trade]);
//
//		return FALSE;
//	}
//
//	for (int i = 0; i < pMob[a_iMob].MaxCarry; i++)
//	{
//		if (pMob[a_iMob].MOB.Carry[i].sIndex != a_iObject) continue;
//
//		int byCount = BASE_GetItemAmount(&pMob[a_iMob].MOB.Carry[i]);
//
//		if (byCount == FALSE) byCount = TRUE;
//
//		FindCount += byCount;
//	}
//
//	if (FindCount < a_iCount) return FALSE; int RemoveCount = a_iCount;
//
//	for (int i = 0; i < pMob[a_iMob].MaxCarry && RemoveCount > FALSE; i++)
//	{
//		if (pMob[a_iMob].MOB.Carry[i].sIndex != a_iObject) continue;
//
//		int byCount = BASE_GetItemAmount(&pMob[a_iMob].MOB.Carry[i]);
//
//		if (byCount == FALSE) byCount = TRUE;
//
//		if (byCount > RemoveCount)
//		{
//			byCount -= RemoveCount;
//
//			BASE_SetItemAmount(&pMob[a_iMob].MOB.Carry[i], byCount); SendItem(a_iMob, ITEM_PLACE_CARRY, i, &pMob[a_iMob].MOB.Carry[i]);
//
//			return TRUE;
//		}
//
//		RemoveCount -= byCount;
//
//		memset(&pMob[a_iMob].MOB.Carry[i], 0, sizeof(STRUCT_ITEM)); SendItem(a_iMob, ITEM_PLACE_CARRY, i, &pMob[a_iMob].MOB.Carry[i]);
//	}
//
//	return TRUE;
//}

void SendAutoTrade(int conn, int otherconn)
{
	return;

	/*if (conn <= 0 || conn >= MAX_USER)
		return;

	if (otherconn <= 0 || otherconn >= MAX_USER)
		return;

	if (pUser[otherconn].TradeMode == 0)
		return;

	if (pUser[otherconn].Mode != USER_PLAY)
		return;

	if (pUser[conn].Mode != USER_PLAY)
		return;

	MSG_SendAutoTrade sm;
	memset(&sm, 0, sizeof(MSG_SendAutoTrade));

	memcpy(&sm, &pUser[otherconn].AutoTrade, sizeof(pMob[otherconn].AutoTrade));

	sm.ID = ESCENE_FIELD;

	sm.Index = otherconn;

	sm.Type = _MSG_SendAutoTrade;
	sm.Size = sizeof(MSG_SendAutoTrade);

	if (conn && conn < MAX_USER && pUser[conn].Mode != 0)
	{
		if (!pUser[conn].cSock.AddMessage((char*)&sm, sizeof(MSG_SendAutoTrade)))
			CloseUser(conn);
	}*/
}

void SendGridMob(int conn)
{
	int posX = pMob[conn].TargetX;
	int posY = pMob[conn].TargetY;

	if (conn <= 0 || conn >= MAX_USER)
		return;

	int SizeY = VIEWGRIDY;
	int SizeX = VIEWGRIDX;
	int StartX = posX - HALFGRIDX;
	int StartY = posY - HALFGRIDY;

	if ((posX - HALFGRIDX + VIEWGRIDX) >= MAX_GRIDX)
		SizeX -= (StartX + SizeX - MAX_GRIDX);

	if ((posY - HALFGRIDY + VIEWGRIDY) >= MAX_GRIDY)
		SizeY -= (StartY + SizeY - MAX_GRIDY);

	if (StartX < 0)
		StartX = 0;

	if (StartY < 0)
		StartY = 0;


	int sx1 = StartX;
	int sy1 = StartY;
	int sx2 = StartX + SizeX;
	int sy2 = StartY + SizeY;

	for (int y = sy1; y < sy2; y++)
	{
		for (int x = sx1; x < sx2; x++)
		{
			int tmob = pMobGrid[y][x];
			int titem = pItemGrid[y][x];

			if (tmob > 0 && tmob < MAX_MOB && tmob != conn)
			{
				if (pMob[tmob].Mode == MOB_EMPTY)
					pMobGrid[y][x] = 0; // Testar 1
				else
				{
					SendCreateMob(conn, tmob, 0);
					SendPKInfo(conn, tmob);
				}
			}

			if (titem > 0 && titem < MAX_ITEM)
			{
				if (pItem[titem].Mode)
					SendCreateItem(conn, titem, 0);
				else
					pItemGrid[y][x] = 0;
			}
		}
	}
}

/*
void GridMulticast(int conn, int tx, int ty, MSG_STANDARD *msg)
{
int tmob; // [sp+54h] [bp-14Ch]@61
int titem; // [sp+58h] [bp-148h]@61
int k; // [sp+5Ch] [bp-144h]@58
int j; // [sp+64h] [bp-13Ch]@32
int i; // [sp+68h] [bp-138h]@30
int ty2; // [sp+70h] [bp-130h]@30
int tx2; // [sp+74h] [bp-12Ch]@30
int ty1; // [sp+78h] [bp-128h]@30
int tx1; // [sp+7Ch] [bp-124h]@30
int sy2; // [sp+80h] [bp-120h]@22
int sx2; // [sp+84h] [bp-11Ch]@22
int sy1; // [sp+88h] [bp-118h]@22
int sx1; // [sp+8Ch] [bp-114h]@22
int StartY; // [sp+90h] [bp-110h]@14
int StartX; // [sp+94h] [bp-10Ch]@14
int SizeY; // [sp+98h] [bp-108h]@14
int SizeX; // [sp+9Ch] [bp-104h]@14

if (conn && pMob[conn].TargetX)
{
tmob = pMobGrid[pMob[conn].TargetY][pMob[conn].TargetX];

if (tmob != conn && tmob)
{
if (conn < MAX_USER)
Log("PC do not have his own grid", "-system", 0);
else
Log("NPC do not have his own grid", "-system", 0);
}

pMobGrid[pMob[conn].TargetY][pMob[conn].TargetX] = 0;

if (pMobGrid[ty][tx] != conn && pMobGrid[ty][tx])
{
if (conn < MAX_USER)
Log("PC step in other mob's grid", "-system", 0);
else
Log("NPC charge other mob's grid", "-system", 0);
}

pMobGrid[ty][tx] = conn;
SizeY = VIEWGRIDY;
SizeX = VIEWGRIDX;
StartX = pMob[conn].TargetX - HALFGRIDX;
StartY = pMob[conn].TargetY - HALFGRIDY;

if (StartX + VIEWGRIDX >= MAX_GRIDX)
SizeX -= StartX + SizeX - MAX_GRIDX;

if (SizeY + StartY >= MAX_GRIDY)
SizeY -= StartY + SizeY - MAX_GRIDY;

if (StartX < 0)
StartX = 0;

if (StartY < 0)
StartY = 0;

sx1 = StartX;
sy1 = StartY;
sx2 = SizeX + StartX;
sy2 = SizeY + StartY;

SizeY = VIEWGRIDY;
SizeX = VIEWGRIDX;

StartX = tx - VIEWGRIDX;
StartY = ty - VIEWGRIDY;

if (tx - 16 + 33 >= MAX_GRIDX)
SizeX -= StartX + SizeX - MAX_GRIDX;

if (SizeY + StartY >= MAX_GRIDY)
SizeY -= StartY + SizeY - MAX_GRIDY;

if (StartX < 0)
StartX = 0;

if (StartY < 0)
StartY = 0;

tx1 = StartX;
ty1 = StartY;
tx2 = SizeX + StartX;
ty2 = SizeY + StartY;

for (i = sy1; i < sy2; ++i)
{
for (j = sx1; j < sx2; ++j)
{
tmob = pMobGrid[i][j];

if (tmob && tmob != conn)
{
if (pMob[tmob].Mode)
{
if (msg && tmob < MAX_USER)
pUser[tmob].cSock.AddMessage((char*)msg, msg->Size);

if ((j < tx1 || j >= tx2 || i < ty1 || i >= ty2) && tx)
{
if (tmob < MAX_USER)
SendRemoveMob(tmob, conn, 0, 0);

if (conn < MAX_USER)
SendRemoveMob(conn, tmob, 0, 0);
}
}
else
{
Log("Dest Empty grid", "-system", 0);
pMobGrid[i][j] = 0;
}
}
}
}

for (i = ty1; i < ty2; ++i)
{
for (k = tx1; k < tx2; ++k)
{
titem = pItemGrid[i][k];
tmob = pMobGrid[i][k];

if (k < sx1 || k >= sx2 || i < sy1 || i >= sy2)
{
if (titem > 0 && titem < MAX_ITEM && pItem[titem].Mode && pItem[titem].ITEM.sIndex && conn < MAX_USER)
{
if (pItem[titem].Mode)
SendCreateItem(conn, titem, 0);

else
pItemGrid[i][k] = 0;
}

if (tmob != conn && tmob)
{
if (pMob[tmob].Mode)
{
if (tmob < MAX_USER)
{
if (pMob[conn].Mode)
SendCreateMob(tmob, conn, 0);

else
pMobGrid[i][k] = 0;
}

if (conn < MAX_USER)
{
if (pMob[tmob].Mode)
SendCreateMob(conn, tmob, 0);

else
pMobGrid[i][k] = 0;
}

if (msg && tmob > 0 && tmob < MAX_USER)
{
if (pMob[tmob].Mode == 22)
{
if (!pUser[tmob].cSock.AddMessage((char*)msg, msg->Size))
{
pUser[tmob].AccountName[ACCOUNTNAME_LENGTH - 1] = 0;
pUser[tmob].AccountName[ACCOUNTNAME_LENGTH - 2] = 0;
sprintf(temp, "err,gridmulticast add %d-%d %s", tmob, pUser[tmob].Mode, pUser[tmob].AccountName);
Log(temp, "-system", 0);
pMobGrid[i][k] = 0;
CloseUser(tmob);
}
}
else
{
pUser[tmob].AccountName[ACCOUNTNAME_LENGTH - 1] = 0;
pUser[tmob].AccountName[ACCOUNTNAME_LENGTH - 2] = 0;
sprintf(temp, "err,grid-1 empty %d-%d %s", tmob, pUser[tmob].Mode, pUser[tmob].AccountName);
Log(temp, "-system", 0);
pMobGrid[i][k] = 0;
CloseUser(tmob);
}
}
}
else
{
pMobGrid[i][k] = 0;
Log("MOB GRID HAS EMPTY MOB", "-system", 0);
}
}
}
}
}

if (pUser[conn].Mode == USER_PLAY)
{
if (pMobGrid[pMob[conn].TargetY][pMob[conn].TargetX] == 0 || pMobGrid[pMob[conn].TargetY][pMob[conn].TargetX] != conn)
Log("USER PLAYING WITH MOBGRID OFFLINE", "-system", 0);
}

MSG_Action *sm = (MSG_Action*)msg;

pMob[conn].LastTime = sm->ClientTick;
pMob[conn].LastSpeed = sm->Speed;
pMob[conn].LastX = sm->PosX;
pMob[conn].LastY = sm->PosY;
pMob[conn].TargetX = tx;
pMob[conn].TargetY = ty;

}
else
Log("err,GridMulticast mobidx,pos", "-system", 0);

return;
}
*/
/*
void GridMulticast(int conn, int tx, int ty, MSG_STANDARD *msg)
{
int SizeX, SizeY, StartX, StartY;
int sx1, sy1, sx2, sy2;        // Source Rect
int dx1, dy1, dx2, dy2;		   // Dest Rect

if (conn == 0 || pMob[conn].TargetX == 0)
{
Log("err GridMulticast mobidx,pos","-system", 0);
return;
}

int mobx = pMob[conn].TargetX;
int moby = pMob[conn].TargetY;

if (mobx < 0 || mobx >= MAX_GRIDX || moby < 0 || moby >= MAX_GRIDY)
return;

int currentgrid = pMobGrid[moby][mobx];

if (currentgrid != conn && currentgrid != 0)
{
if (conn >= MAX_USER)
Log("NPC do not have his own grid","-system",0);
else
Log("PC do not have his own grid","-system",0);

pMobGrid[moby][mobx] = 0;

}
else
pMobGrid[moby][mobx] = 0;

if  (pMobGrid[ty][tx] != conn && pMobGrid[ty][tx] != 0)
{
if (conn >= MAX_USER)
Log("NPC charge other mob's grid","-system",0);
else
Log("PC step in other mob's grid","-system",0);

pMobGrid[ty][tx] = conn;
}
else
pMobGrid[ty][tx] = conn;

SizeY  = VIEWGRIDY;
SizeX  = VIEWGRIDX;
StartX = pMob[conn].TargetX - HALFGRIDX;
StartY = pMob[conn].TargetY - HALFGRIDY;

if  (StartX+SizeX >= MAX_GRIDX)
SizeX = SizeX - (StartX + SizeX - MAX_GRIDX);

if  (StartY+SizeY >= MAX_GRIDY)
SizeY = SizeY - (StartY + SizeY - MAX_GRIDY);

if  (StartX < 0)
{
StartX = 0;
SizeX = SizeX + StartX;
}

if  (StartY < 0)
{
StartY = 0;
SizeY = SizeY + StartY;
}

sx1 = StartX;
sy1 = StartY;
sx2 = StartX + SizeX;
sy2 = StartY + SizeY;

SizeY  = VIEWGRIDY;
SizeX  = VIEWGRIDX;
StartX = tx - HALFGRIDX;
StartY = ty - HALFGRIDY;

if  (StartX + SizeX >= MAX_GRIDX)
SizeX = SizeX - (StartX + SizeX - MAX_GRIDX);

if  (StartY+SizeY >= MAX_GRIDY)
SizeY = SizeY - (StartY + SizeY - MAX_GRIDY);

if  (StartX < 0)
{
StartX = 0;
SizeX = SizeX + StartX;
}

if  (StartY < 0)
{
StartY = 0;
SizeY = SizeY + StartY;
}

dx1 = StartX;
dy1 = StartY;
dx2 = StartX + SizeX;
dy2 = StartY + SizeY;

for (int y = sy1; y < sy2; y++)
{
for (int x = sx1; x < sx2; x++)
{
int tmob = pMobGrid[y][x];

if (tmob == 0 || tmob == conn)
continue;

if  (msg && tmob < MAX_USER)
pUser[tmob].cSock.AddMessage((char*)msg, msg->Size);

if	((x < dx1 || x >= dx2 || y < dy1 || y >= dy2) && tx != 0)
{
if	(tmob < MAX_USER)
SendRemoveMob(tmob, conn, 0, 0);

if (conn < MAX_USER)
SendRemoveMob(conn, tmob, 0, 0);
}
}
}

for (int y = sy1; y < sy2; y++)
{
for (int x = sx1; x < sx2; x++)
{
int titem = pItemGrid[y][x];

if (titem == 0)
continue;

if (x < dx1 || x >= dx2 || y < dy1 || y >= dy2 && tx)
{
if (titem > 0 && titem < MAX_ITEM && pItem[titem].Mode && pItem[titem].ITEM.sIndex && conn > 0 && conn < MAX_USER)
SendRemoveItem(conn, titem, 0);
}
}
}

pMob[conn].TargetX = tx;
pMob[conn].TargetY = ty;

for (int y = dy1; y < dy2; y++)
{
for (int x = dx1; x < dx2; x++)
{
int titem = pItemGrid[y][x];
int tmob  = pMobGrid[y][x];

if  (x < sx1 || x >= sx2 || y < sy1 || y >= sy2)
{
if  (titem > 0 && titem < MAX_ITEM && pItem[titem].Mode != 0 && pItem[titem].ITEM.sIndex != 0 && conn < MAX_USER)
{
if (pItem[titem].Mode == 0)
pItemGrid[y][x] = 0;
else
SendCreateItem(conn, titem, FALSE);
}

if (tmob == conn || tmob == 0)
continue;

if (pMob[tmob].Mode == MOB_EMPTY)
{
pMobGrid[y][x] = 0;
Log("MOB GRID HAS EMPTY MOB","-system",0);
continue;
}

if (tmob < MAX_USER)
{
if (pMob[conn].Mode == MOB_EMPTY)
pMobGrid[y][x] = 0;
else
SendCreateMob(tmob, conn, FALSE);
}

if (conn < MAX_USER)
{
if (pMob[tmob].Mode == MOB_EMPTY)
pMobGrid[y][x] = 0;
else
SendCreateMob(conn, tmob, FALSE);
}

if (conn < MAX_USER)
{
if (pUser[conn].Mode == USER_PLAY)
pMobGrid[pMob[conn].TargetY][pMob[conn].TargetX] = pMobGrid[pMob[conn].TargetY][pMob[conn].TargetX] == 0 ? conn : conn;
}

if (msg && tmob < MAX_USER)
pUser[tmob].cSock.AddMessage((char*)msg, msg->Size);


}
}
}

MSG_Action * act    = (MSG_Action*)msg;
pMob[conn].LastTime  = act->ClientTick;
pMob[conn].LastSpeed = act->Speed;
pMob[conn].LastX     = act->PosX;
pMob[conn].LastY     = act->PosY;
pMob[conn].TargetX = tx;
pMob[conn].TargetY = ty;
}*/

//void GridMulticast(int conn, int tx, int ty, MSG_STANDARD *msg)
//{
//	if (conn == 0 || pMob[conn].TargetX == 0)
//	{
//		SystemLog("-system", "-", 0, "err,GridMulticast mobidx,pos");
//
//		return;
//	}
//
//	int tmob = pMobGrid[pMob[conn].TargetY][pMob[conn].TargetX];
//
//	if (tmob != conn && tmob)
//		GetEmptyMobGrid(conn, &pMob[conn].TargetX, &pMob[conn].TargetY);
//
//	if (tmob != conn && tmob)
//	{
//		if (conn < MAX_USER)
//			SystemLog("-system", "-", 0, "PC do not have his own grid");
//
//		else
//		{
//			/*char tmg[256];
//			snprintf(tmg, sizeof(tmg), "NPC %s do not have his own grid", pMob[conn].MOB.MobName);
//			SystemLog("-system", "-", 0, tmg);*/
//		}
//
//	}
//
//	pMobGrid[pMob[conn].TargetY][pMob[conn].TargetX] = 0;
//
//	if (pMobGrid[ty][tx] != conn && pMobGrid[ty][tx] != 0)
//		GetEmptyMobGrid(conn, &pMob[conn].TargetX, &pMob[conn].TargetY);
//
//	if (pMobGrid[ty][tx] != conn && pMobGrid[ty][tx] != 0)
//	{
//		if (conn < MAX_USER)
//			SystemLog("-system", "-", 0, "PC step in other mob's grid");
//
//		else
//		{
//			/*	char tmg[256];
//			snprintf(tmg, sizeof(tmg), "NPC %s charge other mob's grid", pMob[conn].MOB.MobName);
//			SystemLog("-system", "-", 0, tmg);*/
//		}
//	}
//
//	pMobGrid[ty][tx] = conn;
//
//	int SizeY = VIEWGRIDY;
//	int SizeX = VIEWGRIDX;
//	int StartX = pMob[conn].TargetX - HALFGRIDX;
//	int StartY = pMob[conn].TargetY - HALFGRIDY;
//
//	if (StartX + SizeX >= MAX_GRIDX)
//		SizeX = SizeX - (StartX + SizeX - MAX_GRIDX);
//
//	if (SizeY + StartY >= MAX_GRIDY)
//		SizeY = SizeY - (StartY + SizeY - MAX_GRIDY);
//
//	if (StartX < 0)
//		StartX = 0;
//
//	if (StartY < 0)
//		StartY = 0;
//
//	int sx1 = StartX;
//	int sy1 = StartY;
//	int sx2 = StartX + SizeX;
//	int sy2 = StartY + SizeY;
//
//
//	SizeY = VIEWGRIDY;
//	SizeX = VIEWGRIDX;
//	StartX = tx - HALFGRIDX;
//	StartY = ty - HALFGRIDY;
//
//	if (StartX + SizeX >= MAX_GRIDX)
//		SizeX = SizeX - (StartX + SizeX - MAX_GRIDX);
//
//	if (SizeY + StartY >= MAX_GRIDY)
//		SizeY = SizeY - (StartY + SizeY - MAX_GRIDY);
//
//	if (StartX < 0)
//		StartX = 0;
//
//	if (StartY < 0)
//		StartY = 0;
//
//	int tx1 = StartX;
//	int ty1 = StartY;
//	int tx2 = StartX + SizeX;
//	int ty2 = StartY + SizeY;
//
//	for (int y = sy1; y < sy2; y++)
//	{
//		for (int x = sx1; x < sx2; x++)
//		{
//			tmob = pMobGrid[y][x];
//
//			if (tmob == 0 || tmob == conn)
//				continue;
//
//			if (msg != NULL && tmob < MAX_USER)
//				pUser[tmob].cSock.AddMessage((char*)msg, msg->Size);
//
//			if (x < tx1 || x >= tx2 || y < ty1 || y >= ty2 && tx)
//			{
//				if (tmob < MAX_USER)
//					SendRemoveMob(tmob, conn, 0, 0);
//
//				if (conn < MAX_USER)
//					SendRemoveMob(conn, tmob, 0, 0);
//			}
//		}
//	}
//
//
//	for (int y = sy1; y < sy2; y++)
//	{
//		for (int x = sx1; x < sx2; x++)
//		{
//			int titem = pItemGrid[y][x];
//
//			if (titem == 0)
//				continue;
//
//			if (x < tx1 || x >= tx2 || y < ty1 || y >= ty2 && tx)
//			{
//				if (titem > 0 && titem < MAX_ITEM && pItem[titem].Mode && pItem[titem].ITEM.sIndex && conn > 0 && conn < MAX_USER)
//					SendRemoveItem(conn, titem, 0);
//			}
//		}
//	}
//
//	for (int y = ty1; y < ty2; y++)
//	{
//		for (int x = tx1; x < tx2; x++)
//		{
//			int titem = pItemGrid[y][x];
//			tmob = pMobGrid[y][x];
//
//			if (x < sx1 || x >= sx2 || y < sy1 || y >= sy2)
//			{
//				if (titem > 0 && titem < MAX_ITEM && pItem[titem].Mode && pItem[titem].ITEM.sIndex && conn < MAX_USER)
//				{
//					if (pItem[titem].Mode)
//						SendCreateItem(conn, titem, 0);
//
//					else
//						pItemGrid[y][x] = 0;
//				}
//
//				if (tmob != conn && tmob)
//				{
//					if (pMob[tmob].Mode == MOB_EMPTY)
//					{
//						pMobGrid[y][x] = 0;
//
//						char cLog[128];
//
//						/*if (tmob < MAX_USER)
//							sprintf_s(cLog, "MOB GRID HAS EMPTY MOB [MobName: %s] [tmob: %d]", pMob[tmob].MOB.MobName, tmob);
//						else
//							sprintf_s(cLog, "MOB GRID HAS EMPTY MOB [MobName: %s] [tmob: %d]", mNPCGen.pList->Leader.MobName, tmob);
//
//						Log(cLog, "-system", 0);*/
//
//						continue;
//					}
//
//					if (tmob < MAX_USER)
//					{
//						if (pMob[conn].Mode == MOB_EMPTY)
//							pMobGrid[y][x] = 0;
//						else
//						{
//							SendCreateMob(tmob, conn, 0);
//							SendPKInfo(tmob, conn);
//						}
//					}
//
//					if (conn < MAX_USER)
//					{
//						if (pMob[tmob].Mode == MOB_EMPTY)
//							pMobGrid[y][x] = 0;
//						else
//						{
//							SendCreateMob(conn, tmob, 0);
//							SendPKInfo(conn, tmob);
//						}
//					}
//
//					if (msg != NULL && tmob > 0 && tmob < MAX_USER)
//					{
//						if (pUser[tmob].cSock.AddMessage((char*)msg, msg->Size) == 0)
//						{
//							pUser[tmob].AccountName[ACCOUNTNAME_LENGTH - 1] = 0;
//							pUser[tmob].AccountName[ACCOUNTNAME_LENGTH - 2] = 0;
//
//							//sprintf(temp, "err,gridmulticast add %d-%d %s", tmob, pUser[tmob].Mode, pUser[tmob].AccountName);
//							//Log(temp, "-system", 0);
//						}
//					}
//				}
//			}
//		}
//	}
//
//	MSG_Action *sm = (MSG_Action*)msg;
//
//	pMob[conn].LastTime = sm->ClientTick;
//	pMob[conn].LastSpeed = sm->Speed;
//
//	pMob[conn].LastX = sm->PosX;
//	pMob[conn].LastY = sm->PosY;
//
//	pMob[conn].TargetX = tx;
//	pMob[conn].TargetY = ty;
//}

//novo do over
void GridMulticast(int Index, unsigned int posX, unsigned int posY, MSG_STANDARD* msg)
{
	if (Index <= 0 || Index >= MAX_MOB)
		return;

	if (Index == 0 || pMob[Index].TargetX == 0)
		return;

	CMob* mob = (CMob*)&pMob[Index];

	INT32 mobId = pMobGrid[mob->TargetY][mob->TargetX];
	if (mobId == Index && mobId != 0)
		pMobGrid[mob->TargetY][mob->TargetX] = 0;

	if (pMobGrid[posY][posX] != Index && pMobGrid[posY][posX] != 0)
		GetEmptyMobGrid(Index, &pMob[Index].TargetX, &pMob[Index].TargetY);

	pMobGrid[posY][posX] = Index;

	int VisX = VIEWGRIDX, VisY = VIEWGRIDY,
		minPosX = (mob->TargetX - HALFGRIDX),
		minPosY = (mob->TargetY - HALFGRIDY);

	if ((minPosX + VisX) >= MAX_GRIDX)
		VisX = (VisX - (VisX + minPosX - MAX_GRIDX));

	if ((minPosY + VisY) >= MAX_GRIDY)
		VisY = (VisY - (VisY + minPosY - MAX_GRIDY));

	if (minPosX < 0)
	{
		minPosX = 0;
		VisX = (VisX + minPosX);
	}

	if (minPosY < 0)
	{
		minPosY = 0;
		VisY = (VisY + minPosY);
	}

	int maxPosX = (minPosX + VisX),
		maxPosY = (minPosY + VisY);

	int dVisX = VIEWGRIDX, dVisY = VIEWGRIDY,
		dminPosX = (posX - HALFGRIDX),
		dminPosY = (posY - HALFGRIDY);

	if ((dminPosX + dVisX) >= MAX_GRIDX)
		dVisX = (dVisX - (dVisX + dminPosX - MAX_GRIDX));

	if ((dminPosY + dVisY) >= MAX_GRIDY)
		dVisY = (dVisY - (dVisY + dminPosY - MAX_GRIDY));

	if (dminPosX < 0)
	{
		dminPosX = 0;
		dVisX = (dVisX + dminPosX);
	}

	if (dminPosY < 0)
	{
		dminPosY = 0;
		dVisY = (dVisY + dminPosY);
	}

	int dmaxPosX = (dminPosX + dVisX),
		dmaxPosY = (dminPosY + dVisY);

	for (int nY = minPosY; nY < maxPosY; nY++)
	{
		for (int nX = minPosX; nX < maxPosX; nX++)
		{
			short mobID = pMobGrid[nY][nX];
			if (mobID > 0 && Index != mobID)
			{
				if (msg != NULL && mobID < MAX_USER)
					pUser[mobID].cSock.SendOneMessage((char*)msg, *(short*)&msg[0]);

				if (nX < dminPosX || nX >= dmaxPosX ||
					nY < dminPosY || nY >= dmaxPosY)
				{
					if (mobID < MAX_USER)
						SendRemoveMob(mobID, Index, 0, 0);

					if (Index < MAX_USER)
						SendRemoveMob(Index, mobID, 0, 0);
				}
			}

			WORD item = pItemGrid[nY][nX];
			if (item != 0)
			{
				if (nX < dminPosX || nX >= dmaxPosX ||
					nY < dminPosY || nY >= dmaxPosY)
				{
					if (item >= 0 && item < 4096 && Index < MAX_USER)
						SendRemoveItem(Index, item, 0);
				}
			}
		}
	}

	for (int nY = dminPosY; nY < dmaxPosY; nY++)
	{
		for (int nX = dminPosX; nX < dmaxPosX; nX++)
		{
			short mobID = pMobGrid[nY][nX];
			short initID = pItemGrid[nY][nX];

			if (nX < minPosX || nX >= maxPosX ||
				nY < minPosY || nY >= maxPosY)
			{
				if (mobID > 0 && Index != mobID)
				{
					if (pMob[mobID].Mode == 0)
					{
						pMobGrid[nY][nX] = 0;

						continue;
					}

					if (Index < MAX_USER)
						SendCreateMob(Index, mobID, 0);

					if (mobID < MAX_USER)
						SendCreateMob(mobID, Index, 0);

					if (msg != NULL && mobID < MAX_USER)
						pUser[mobID].cSock.SendOneMessage((char*)msg, *(short*)&msg[0]);

				}

				if (initID > 0 && Index > 0 && Index < MAX_USER)
					SendCreateItem(Index, initID, 0);

				if (initID > 0 && mobID > 0 && mobID < MAX_USER)
					SendCreateItem(mobID, initID, 0);
			}
		}
	}

	MSG_Action* pAction = (MSG_Action*)msg;

	mob->LastTime = pAction->ClientTick;
	mob->LastSpeed = pAction->Speed;
	mob->LastX = pAction->PosX;
	mob->LastY = pAction->PosY;

	mob->TargetX = posX;
	mob->TargetY = posY;
}

void SendEmotion(int conn, int Motion, int Parm)
{
	if (conn <= 0 || conn >= MAX_USER)
		return;

	if (pUser[conn].cSock.Sock == 0)
		return;

	MSG_Motion sm;
	memset(&sm, 0, sizeof(MSG_Motion));

	sm.Type = _MSG_Motion;
	sm.Size = sizeof(MSG_Motion);

	sm.NotUsed = 0;

	sm.ID = conn;

	sm.Motion = Motion;
	sm.Parm = Parm;

	GridMulticast(pMob[conn].TargetX, pMob[conn].TargetY, (MSG_STANDARD*)&sm, 0);
}


//void GridMulticast(int tx, int ty, MSG_STANDARD *msg, int skip)
//{
//	int SizeY = VIEWGRIDY;
//	int SizeX = VIEWGRIDX;
//	int StartX = tx - HALFGRIDX;
//	int StartY = ty - HALFGRIDY;
//
//	if (StartX + SizeX >= MAX_GRIDX)
//		SizeX = SizeX - (StartX + SizeX - MAX_GRIDX);
//
//	if (SizeY + StartY >= MAX_GRIDY)
//		SizeY = SizeY - (StartY + SizeY - MAX_GRIDY);
//
//	if (StartX < 0)
//	{
//		StartX = 0;
//
//		SizeX = SizeX + StartX;
//	}
//
//	if (StartY < 0)
//	{
//		StartY = 0;
//
//		SizeY = SizeY + StartY;
//	}
//
//	int sx1 = StartX;
//	int sy1 = StartY;
//	int sx2 = StartX + SizeX;
//	int sy2 = StartY + SizeY;
//
//	for (int y = sy1; y < sy2; y++)
//	{
//		for (int x = sx1; x < sx2; x++)
//		{
//			int tmob = pMobGrid[y][x];
//
//			if (tmob <= 0 || tmob == skip)
//				continue;
//
//			if (pMob[tmob].Mode == MOB_EMPTY)
//			{
//				int Unk = 0;
//
//				continue;
//			}
//
//			if (msg != NULL && tmob < MAX_USER)
//			{
//				if (msg->Type == _MSG_CreateMob)
//				{
//					int xx = ((MSG_CreateMob*)msg)->PosX;
//					int yy = ((MSG_CreateMob*)msg)->PosY;
//
//					if (xx >= 896 && yy >= 1405 && xx <= 1150 && yy <= 1538)
//					{
//						STRUCT_ITEM hcitem;
//
//						memset(&hcitem, 0, sizeof(STRUCT_ITEM));
//
//						hcitem.sIndex = 3505;
//
//						((MSG_CreateMob*)msg)->Equip[1] = BASE_VisualItemCode(&hcitem, 1);
//
//						((MSG_CreateMob*)msg)->AnctCode[1] = BASE_VisualAnctCode(&hcitem);
//
//
//						hcitem.sIndex = 3999;
//
//						((MSG_CreateMob*)msg)->Equip[15] = BASE_VisualItemCode(&hcitem, 15);
//
//						((MSG_CreateMob*)msg)->AnctCode[15] = BASE_VisualAnctCode(&hcitem);
//					}
//
//				}
//
//				if (msg->Type == _MSG_CNFMobKill)
//				{
//					((MSG_CNFMobKill*)msg)->Exp = pMob[tmob].MOB.Exp;
//					((MSG_CNFMobKill*)msg)->Hold = pMob[tmob].extra.Hold;
//
//					int Segment = pMob[tmob].CheckGetLevel();
//
//					if (Segment >= 1 && Segment <= 4)
//					{
//						if (Segment == 4)
//						{
//							SetCircletSubGod(tmob);
//							SendEtc(tmob);
//							doRanking(tmob);
//							SendMsgExp(tmob, g_pMessageStringTable[_NN_Level_Up], TNColor::Default, false);
//							/*if (pMob[tmob].extra.ClassMaster == MORTAL) {
//								DoItemLevel(tmob);
//								
//							}*/
//						}
//						if (Segment == 3) 
//							SendMsgExp(tmob, "[EXP 3/4]", TNColor::GoldenEscuro, false); // DESCRIÇÃO XP PINHEIRO
//
//						if (Segment == 2) 
//							SendMsgExp(tmob, "[EXP 2/4]", TNColor::GreenYellow, false);
//
//						if (Segment == 1) 
//							SendMsgExp(tmob, "[EXP 1/4]", TNColor::GoldenClaro, false);
//
//						SendScore(tmob);
//						SendEmotion(tmob, 14, 3);
//
//						if (Segment == 4)
//						{
//
//							int PKPoint = GetPKPoint(tmob) + 3;
//							SetPKPoint(tmob, PKPoint);
//
//							int PunicaoCP = GetPKPoint(tmob);
//							if (PunicaoCP > 75) //remove puniçao cp
//							{
//								pMob[tmob].extra.EMPTY[0] = 0;
//								pMob[tmob].GetCurrentScore(tmob);
//								SendScore(tmob);
//
//							}
//
//							if (PunicaoCP > 30  && PunicaoCP <= 74) //remove puniçao cp
//							{
//								pMob[tmob].extra.EMPTY[1] = 0;
//								pMob[tmob].GetCurrentScore(tmob);
//								SendScore(tmob);
//
//							}
//
//							
//							//SendEtc(tmob);
//							MSG_CreateMob sm_lupc;
//							memset(&sm_lupc, 0, sizeof(MSG_CreateMob));
//							GetCreateMob(tmob, &sm_lupc);
//
//							GridMulticast(pMob[tmob].TargetX, pMob[tmob].TargetY, (MSG_STANDARD*)&sm_lupc, 0);
//							//sprintf(temp, "lvl %s level up to %d", pMob[tmob].MOB.MobName, pMob[tmob].MOB.BaseScore.Level);
//							//Log(temp, pUser[tmob].AccountName, pUser[tmob].IP);
//						}
//					}
//				}
//
//				pUser[tmob].cSock.AddMessage((char*)msg, msg->Size);
//				
//			}
//		}
//	}
//}

void GridMulticast(int posX, int posY, MSG_STANDARD* sendPak, int Index)
{
	int VisX = VIEWGRIDX, VisY = VIEWGRIDY,
		minPosX = (posX - HALFGRIDX),
		minPosY = (posY - HALFGRIDY);

	if ((minPosX + VisX) >= MAX_GRIDX)
		VisX = (VisX - (VisX + minPosX - MAX_GRIDX));

	if ((minPosY + VisY) >= MAX_GRIDX)
		VisY = (VisY - (VisY + minPosY - MAX_GRIDX));

	if (minPosX < 0)
	{
		minPosX = 0;
		VisX = (VisX + minPosX);
	}

	if (minPosY < 0)
	{
		minPosY = 0;
		VisY = (VisY + minPosY);
	}

	int maxPosX = (minPosX + VisX),
		maxPosY = (minPosY + VisY);

	for (int nY = minPosY; nY < maxPosY; nY++)
	{
		for (int nX = minPosX; nX < maxPosX; nX++)
		{
			short mobID = pMobGrid[nY][nX];
			if (mobID <= 0 || Index == mobID)
				continue;

			if (sendPak == NULL || mobID >= MAX_USER)
				continue;

			if (pMob[mobID].Mode == 0)
				continue;

			if (sendPak->Type == _MSG_CNFMobKill)
			{
				((MSG_CNFMobKill*)sendPak)->Exp = pMob[mobID].MOB.Exp;
				((MSG_CNFMobKill*)sendPak)->Hold = pMob[mobID].extra.Hold;

				int Segment = pMob[mobID].CheckGetLevel();

				if (Segment >= 1 && Segment <= 4)
				{
					if (Segment == 4)
					{
						SetCircletSubGod(mobID);
						SendEtc(mobID);
						doRanking(mobID);
						SendMsgExp(mobID, g_pMessageStringTable[_NN_Level_Up], TNColor::Default, false);
						/*if (pMob[mobID].extra.ClassMaster == MORTAL) {
							DoItemLevel(mobID);

						}*/
					}
					if (Segment == 3)
						SendMsgExp(mobID, "[EXP 3/4]", TNColor::GoldenEscuro, false); // DESCRIÇÃO XP PINHEIRO

					if (Segment == 2)
						SendMsgExp(mobID, "[EXP 2/4]", TNColor::GreenYellow, false);

					if (Segment == 1)
						SendMsgExp(mobID, "[EXP 1/4]", TNColor::GoldenClaro, false);

					SendScore(mobID);
					SendEmotion(mobID, 14, 3);

					if (Segment == 4)
					{

						int PKPoint = GetPKPoint(mobID) + 3;
						SetPKPoint(mobID, PKPoint);

						int PunicaoCP = GetPKPoint(mobID);
						if (PunicaoCP > 75) //remove puniçao cp
						{
							pMob[mobID].extra.EMPTY[0] = 0;
							pMob[mobID].GetCurrentScore(mobID);
							SendScore(mobID);

						}

						if (PunicaoCP > 30 && PunicaoCP <= 74) //remove puniçao cp
						{
							pMob[mobID].extra.EMPTY[1] = 0;
							pMob[mobID].GetCurrentScore(mobID);
							SendScore(mobID);

						}

						MSG_CreateMob sm_lupc;
						memset(&sm_lupc, 0, sizeof(MSG_CreateMob));
						GetCreateMob(mobID, &sm_lupc);

						GridMulticast(pMob[mobID].TargetX, pMob[mobID].TargetY, (MSG_STANDARD*)&sm_lupc, 0);
					}
				}
			}

			pUser[mobID].cSock.SendOneMessage((char*)sendPak, sendPak->Size);
		}
	}
}

void PartyGridMulticast(int tx, int ty, MSG_STANDARD *msg, int skip, int Leaderconn)
{
	int SizeY = VIEWGRIDY;
	int SizeX = VIEWGRIDX;
	int StartX = tx - HALFGRIDX;
	int StartY = ty - HALFGRIDY;

	if (StartX + SizeX >= MAX_GRIDX)
		SizeX = SizeX - (StartX + SizeX - MAX_GRIDX);

	if (SizeY + StartY >= MAX_GRIDY)
		SizeY = SizeY - (StartY + SizeY - MAX_GRIDY);

	if (StartX < 0)
		StartX = 0;

	if (StartY < 0)
		StartY = 0;

	int sx1 = StartX;
	int sy1 = StartY;
	int sx2 = StartX + SizeX;
	int sy2 = StartY + SizeY;

	for (int y = StartY; y < sy2; y++)
	{
		for (int x = sx1; x < sx2; x++)
		{
			int tmob = pMobGrid[y][x];

			if (tmob <= 0 || tmob == Leaderconn)
				continue;

			if (!Leaderconn || pMob[tmob].Leader != Leaderconn)
			{
				if (pMob[tmob].Mode == MOB_EMPTY)
				{
					int Unk = 0;

					continue;
				}

				if (msg != NULL && tmob < MAX_USER && tmob != skip && !pUser[tmob].PartyChat)
				{
					if (pUser[tmob].Mode != USER_PLAY || pUser[tmob].cSock.Sock == 0)
						continue;

					if (!pUser[tmob].cSock.AddMessage((char*)msg, msg->Size))
						CloseUser(tmob);
				}
			}
		}
	}

	if (Leaderconn > 0 && Leaderconn < MAX_USER && pUser[Leaderconn].Mode == USER_PLAY)
	{
		if (Leaderconn != skip)
			pUser[Leaderconn].cSock.AddMessage((char*)msg, msg->Size);

		for (int i = 0; i < MAX_PARTY; i++)
		{
			int partyconn = pMob[Leaderconn].PartyList[i];

			if (partyconn <= 0 || partyconn >= MAX_USER)
				continue;

			if (partyconn == skip)
				continue;

			if (pUser[partyconn].Mode != USER_PLAY || pUser[partyconn].PartyChat != 0)
				continue;

			if (pUser[partyconn].Mode != USER_PLAY || pUser[partyconn].cSock.Sock == 0)
				continue;

			if (!pUser[partyconn].cSock.AddMessage((char*)msg, msg->Size))
				CloseUser(partyconn);
		}
	}
}

void SendItem(int conn, int Type, int Slot, STRUCT_ITEM *item)
{
	if (conn <= 0 || conn >= MAX_USER)
		return;

	if (pUser[conn].Mode != USER_PLAY)
		return;

	if (pUser[conn].cSock.Sock == 0)
		return;

	MSG_SendItem sm_si;
	memset(&sm_si, 0, sizeof(MSG_SendItem));

	sm_si.Type = _MSG_SendItem;
	sm_si.Size = sizeof(MSG_SendItem);
	sm_si.ID = conn;

	sm_si.invType = Type;
	sm_si.Slot = Slot;

	memcpy(&sm_si.item, item, sizeof(STRUCT_ITEM));

	int Size = sm_si.Size;

	if (Size > sizeof(MSG_SendItem))
	{
		sm_si.Size = 0;
		return;
	}
	if (!pUser[conn].cSock.AddMessage((char*)&sm_si, sizeof(MSG_SendItem)))
		CloseUser(conn);
}

void SendEquip(int conn, int skip)
{

	if (conn <= 0 || conn >= MAX_USER)
		return;

	if (pUser[conn].cSock.Sock == 0)
		return;

	MSG_UpdateEquip sm_ue;
	memset(&sm_ue, 0, sizeof(MSG_UpdateEquip));

	sm_ue.Type = _MSG_UpdateEquip;
	sm_ue.Size = sizeof(MSG_UpdateEquip);
	sm_ue.ID = conn;

	int SendMount = 0;

	for (int i = 0; i < MAX_EQUIP; i++)
	{
		STRUCT_ITEM *item = &pMob[conn].MOB.Equip[i];

		sm_ue.Equip[i] = BASE_VisualItemCode(item, i);

		sm_ue.AnctCode[i] = BASE_VisualAnctCode(item);

		if (i == 14 && sm_ue.Equip[14] >= 2360 && sm_ue.Equip[i] < 2390 && pMob[conn].MOB.Equip[i].stEffect[0].sValue <= 0)
		{
			sm_ue.Equip[i] = 0;

			SendMount = 1;

			continue;
		}

		if (i == 14 && sm_ue.Equip[14] >= 2360 && sm_ue.Equip[i] < 2390)
		{
			int MountLevel = pMob[conn].MOB.Equip[i].stEffect[1].cEffect; // level

			MountLevel /= 10;

			if (MountLevel > 13)
				MountLevel = 13;
			if (MountLevel < 0)
				MountLevel = 0;

			MountLevel = MountLevel * 4096;
			sm_ue.Equip[i] += MountLevel;

			continue;
		}
	}

	GridMulticast(pMob[conn].TargetX, pMob[conn].TargetY, (MSG_STANDARD*)&sm_ue, skip);

	if (SendMount != 0)
		SendItem(conn, ITEM_PLACE_EQUIP, 14, &pMob[conn].MOB.Equip[14]);
}


void SendScore(int conn)
{
	if (conn <= 0 || conn >= MAX_USER)
		return;

	if (pUser[conn].cSock.Sock == 0)
		return;


	MSG_UpdateScore sm_vus;
	memset(&sm_vus, 0, sizeof(MSG_UpdateScore));

	sm_vus.Type = _MSG_UpdateScore;

	if (conn < MAX_USER)
	{
		sm_vus.CurrHp = pMob[conn].MOB.CurrentScore.Hp;
		sm_vus.CurrMp = pMob[conn].MOB.CurrentScore.Mp;
	}

	sm_vus.Size = sizeof(MSG_UpdateScore);
	sm_vus.ID = conn;

	memcpy(&sm_vus.Score, &pMob[conn].MOB.CurrentScore, sizeof(STRUCT_SCORE));

	sm_vus.Critical = pMob[conn].MOB.Critical;
	sm_vus.SaveMana = pMob[conn].MOB.SaveMana;
	sm_vus.Guild = pMob[conn].MOB.Guild;
	sm_vus.GuildLevel = pMob[conn].MOB.GuildLevel;

	GetAffect(sm_vus.Affect, pMob[conn].Affect);

	sm_vus.Resist[0] = pMob[conn].MOB.Resist[0];
	sm_vus.Resist[1] = pMob[conn].MOB.Resist[1];
	sm_vus.Resist[2] = pMob[conn].MOB.Resist[2];
	sm_vus.Resist[3] = pMob[conn].MOB.Resist[3];

	sm_vus.Special[0] = 0xCC;
	sm_vus.Special[1] = 0xCC;
	sm_vus.Special[2] = 0xCC;
	sm_vus.Special[3] = 0xCC;

	sm_vus.Magic = pMob[conn].MOB.Magic;

	if (pMob[conn].GuildDisable)
		sm_vus.Guild = 0;

	if (BrState != 0)
	{
		if (conn < MAX_USER)
		{
			int posX = pMob[conn].TargetX;
			int posY = pMob[conn].TargetY;

			if (posX >= 2604 && posY >= 1708 && posX <= 2648 && posY <= 1744)
			{
				sm_vus.Guild = 0;
				sm_vus.GuildLevel = 0;
			}
		}
	}
	GridMulticast(pMob[conn].TargetX, pMob[conn].TargetY, (MSG_STANDARD*)&sm_vus, 0);

	pUser[conn].chave4 = 0;
	SendAffect(conn);
	SendServerInfo(conn);
}
void SendServerInfo(int conn)
{
	if (conn <= 0 || conn >= MAX_USER)
		return;

	if (pUser[conn].Mode != USER_PLAY)//18/12
		return;

	if (pUser[conn].cSock.Sock == 0)//18/12
		return;

	MSG_ServerInfos sm;
	memset(&sm, 0, sizeof(MSG_ServerInfos));
	sm.Type = _MSG_ServerInfos;
	sm.Size = sizeof(MSG_ServerInfos);
	sm.ID = conn;

	int Exp = 0;
	int Drop = 0;

	//Fada Verde 3D
	if (pMob[conn].MOB.Equip[13].sIndex == 3900)
		Exp += 16;

	//Fada Azul 3D
	if (pMob[conn].MOB.Equip[13].sIndex == 3901)
		Drop += 32;

	//Fada Vermelha
	if (pMob[conn].MOB.Equip[13].sIndex == 3902 || pMob[conn].MOB.Equip[13].sIndex == 3905 || pMob[conn].MOB.Equip[13].sIndex == 3908)
	{
		Exp += 32;
		Drop += 16;
	}

	//Fada Verde
	if (pMob[conn].MOB.Equip[13].sIndex == 3903 || pMob[conn].MOB.Equip[13].sIndex == 3906 || pMob[conn].MOB.Equip[13].sIndex == 3911 || pMob[conn].MOB.Equip[13].sIndex == 3912 || pMob[conn].MOB.Equip[13].sIndex == 3913)
		Exp += 16;

	//Fada Verde Azul 
	if (pMob[conn].MOB.Equip[13].sIndex == 3904 || pMob[conn].MOB.Equip[13].sIndex == 3907)
		Drop += 32;

	//trajes
	if (pMob[conn].MOB.Equip[12].sIndex >= 4200 && pMob[conn].MOB.Equip[12].sIndex <= 4275)	{
		Exp += 10;
		if ((pMob[conn].MOB.Equip[14].sIndex >= 2360 && pMob[conn].MOB.Equip[14].sIndex <= 2389) && pMob[conn].MOB.Equip[14].stEffect[2].cValue > 0)
			Exp += 5;
	}
	if ((pMob[conn].MOB.Equip[14].sIndex >= 2360 && pMob[conn].MOB.Equip[14].sIndex <= 2389) && pMob[conn].MOB.Equip[14].stEffect[2].cValue > 0) {
		Drop += 10;
		if (pMob[conn].MOB.Equip[12].sIndex >= 4200 && pMob[conn].MOB.Equip[12].sIndex <= 4275)
			Drop += 5;
	}

	//Cidadão
	if (pMob[conn].extra.Citizen == ServerIndex + 1)
		Drop += 10;

	//Kefra Morto
	if (KefraLive != 0) {
		Exp += 10;
		Drop += 20;
	}

	// Bonus Set e Arma
	for (int i = 0; i < 16; i++)
	{
		auto MOB = pMob[conn].MOB;

		int ItemId = MOB.Equip[i].sIndex;
		int itemGem = BASE_GetItemGem(&MOB.Equip[i]);

		int pDrop = 0;
		int pExp = 0;

		if (ItemId <= 0 || ItemId > MAX_ITEMLIST)
			continue;

		if (g_pItemList[ItemId].Grade == 5)
			pDrop += 8;

		if (g_pItemList[ItemId].Grade == 7)
			pExp += 2;

		if (itemGem == 0)
			pDrop += 8;

		if (itemGem == 2)
			pExp += 2;
				
		Drop += pDrop;
		Exp += pExp;
	}

	// Bau de Exp
	for (int i = 1; i < MAX_AFFECT; i++)
	{
		if (pMob[conn].Affect[i].Type == 39) {
			Exp += 100;
			break;
		}
	}

	// Drop por Level
	if (pMob[conn].MOB.Exp >= 100000000 && pMob[conn].extra.Citizen != 0)
	{
		int DropCalculoByExp = pMob[conn].MOB.Exp / 100000000;

		if (DropCalculoByExp > 80)
			DropCalculoByExp = 80;

		Drop += DropCalculoByExp;
	}

	sm.Double = DOUBLEMODE;
	sm.ExpRate = Exp;
	sm.DropRate = Drop;

	int Size = sm.Size;

	if (Size > sizeof(MSG_ServerInfos))
	{
		sm.Size = 0;
		return;
	}

	if (!pUser[conn].cSock.AddMessage((char*)&sm, sizeof(MSG_ServerInfos)))
		CloseUser(conn);
}
void SendEtc(int conn)
{
	if (conn <= 0 || conn >= MAX_USER)
		return;

	if (pUser[conn].Mode != USER_PLAY)//18/12
		return;

	if (pUser[conn].cSock.Sock == 0)//18/12
		return;

	MSG_UpdateEtc sm;

	memset(&sm, 0, sizeof(MSG_UpdateEtc));

	sm.Type = _MSG_UpdateEtc;
	sm.Size = sizeof(MSG_UpdateEtc);
	sm.ID = conn;
	sm.Exp = pMob[conn].MOB.Exp;
	sm.SpecialBonus = pMob[conn].MOB.SpecialBonus;
	sm.Learn = pMob[conn].MOB.LearnedSkill;
	sm.SecLearn = pMob[conn].extra.SecLearnedSkill;
	sm.ScoreBonus = pMob[conn].MOB.ScoreBonus;
	sm.SkillBonus = pMob[conn].MOB.SkillBonus;
	sm.Coin = pMob[conn].MOB.Coin;

	sm.Hold = pMob[conn].extra.Hold;
	sm.Magic = pMob[conn].MOB.Magic;
	sm.Honra = pUser[conn].Honra;
	sm.Donate = pUser[conn].Donate;

	int Size = sm.Size;

	if (Size > sizeof(MSG_UpdateEtc))
	{		
		sm.Size = 0;
		return;
	}

	if (!pUser[conn].cSock.AddMessage((char*)&sm, sizeof(MSG_UpdateEtc)))
		CloseUser(conn);	
}
void SendJoias(int conn)
{
	if (conn <= 0 || conn >= MAX_USER)
		return;

	if (pUser[conn].Mode != USER_PLAY)//18/12
		return;

	if (pUser[conn].cSock.Sock == 0)//18/12
		return;

	MSG_UpdateJoias sm;

	memset(&sm, 0, sizeof(MSG_UpdateJoias));

	sm.Type = _MSG_UpdateJoias;
	sm.Size = sizeof(MSG_UpdateJoias);
	sm.ID = conn;

	for (int y = 0; y < 2; y++) {
		memcpy(&sm.Joias[y], &pUser[conn].Joias[pUser[conn].Slot][y], sizeof(STRUCT_ITEM));
	}

	int Size = sm.Size;

	if (Size > sizeof(MSG_UpdateJoias))
	{
		sm.Size = 0;
		return;
	}

	if (!pUser[conn].cSock.AddMessage((char*)&sm, sizeof(MSG_UpdateJoias)))
		CloseUser(conn);
}
void SendKeys(int conn)
{
	if (conn <= 0 || conn >= MAX_USER)
		return;

	if (pUser[conn].Mode != USER_PLAY)//18/12
		return;

	if (pUser[conn].cSock.Sock == 0)//18/12
		return;

	MSG_UpdateKeys sm;

	memset(&sm, 0, sizeof(MSG_UpdateKeys));

	sm.Type = _MSG_UpdateKeys;
	sm.Size = sizeof(MSG_UpdateKeys);
	sm.ID = conn;

	for (int i = 0; i < 50; i++) {
		sm.Keys[i] = pUser[conn].Keys[i];
	}
	sm.Keys[0] = pMob[conn].MOB.BaseScore.Level;
	sm.Keys[45] = random_words;

	int Size = sm.Size;

	if (Size > sizeof(MSG_UpdateKeys))
	{
		sm.Size = 0;
		return;
	}

	if (!pUser[conn].cSock.AddMessage((char*)&sm, sizeof(MSG_UpdateKeys)))
		CloseUser(conn);
}
void SendItemLevel(int conn)
{
	if (conn <= 0 || conn >= MAX_USER)
		return;

	if (pUser[conn].Mode != USER_PLAY)//18/12
		return;

	if (pUser[conn].cSock.Sock == 0)//18/12
		return;

	MSG_UpdateItemLevel sm;

	memset(&sm, 0, sizeof(MSG_UpdateItemLevel));

	sm.Type = _MSG_UpdateItemLevel;
	sm.Size = sizeof(MSG_UpdateItemLevel);
	sm.ID = conn;
	sm.Info = pUser[conn].chave1;

	int Size = sm.Size;

	if (Size > sizeof(MSG_UpdateItemLevel))
	{
		sm.Size = 0;
		return;
	}

	if (!pUser[conn].cSock.AddMessage((char*)&sm, sizeof(MSG_UpdateItemLevel)))
		CloseUser(conn);
}

void UpdateLeilaoSaldo(int conn)
{ 
	if (conn <= 0 || conn >= MAX_USER)
		return;

	if (pUser[conn].Mode != USER_PLAY)
		return;

	if (pUser[conn].cSock.Sock == 0)
		return;
	 

	struct	st_SaldoLeilao
	{
		_MSG;
		int Donate;
		int Gold;
		int Bis;

	};

	st_SaldoLeilao sm_ucc = {}; 

	// Verificar fundos de biss
	int bissSlot = GetFirstSlot(conn, 4011);
	
	int biss = 0;

	if (bissSlot != -1)
	{ 
		biss = GetItemAmount(&pMob[conn].MOB.Carry[bissSlot]);
	} 
	else if (bissSlot == -1)
	{
		biss = 0;
	}

	auto& pc = cSQL::instance();

	int Donate = 0; 

	sprintf(hQuery, "SELECT * FROM `accounts` WHERE `username` = '%s'", pUser[conn].AccountName);
	MYSQL_ROW row;
	MYSQL* wSQL = pc.wStart();
	MYSQL_RES* result = pc.wRes(wSQL, hQuery);

	if (result == NULL)
		return;


	while ((row = mysql_fetch_row(result)) != NULL)
	{
		Donate = atoi(row[6]); 
	}
	 
	sm_ucc.Type = 0xBF1;
	sm_ucc.Size = sizeof(st_SaldoLeilao);  
	sm_ucc.ID = conn;

	sm_ucc.Donate = (int)Donate;
	sm_ucc.Gold = (int)pMob[conn].MOB.Coin;
	sm_ucc.Bis = (int)biss;
	 
	if (!pUser[conn].cSock.AddMessage((char*)&sm_ucc, sizeof(st_SaldoLeilao)))
		CloseUser(conn);
}
//Atualiza outras informações do client
void UpdateDonate(int conn)
{
	if (conn <= 0 || conn >= MAX_USER)
		return;

	if (pUser[conn].Mode != USER_PLAY)
		return;

	if (pUser[conn].cSock.Sock == 0)
		return;

	if (pUser[conn].DonateDelay != 0)
	{
		int isTime = GetTickCount64() - pUser[conn].DonateDelay; // ATRASO PACOTE

		if (isTime < 2000)
		{
			SendClientMessage(conn, "Aguarde 2 segundo para uma nova Tentativa.");
			return;
		}

	}
	pUser[conn].DonateDelay = GetTickCount64();

	MSG_UpdateDonate sm;
	memset(&sm, 0, sizeof(MSG_UpdateDonate));
	sm.Type = _MSG_UpdateDonate;
	sm.Size = sizeof(MSG_UpdateDonate);
	sm.ID = conn;

	auto& pc = cSQL::instance();

	int Donate = 0;
	std::string Pix;

	sprintf(hQuery, "SELECT * FROM `accounts` WHERE `username` = '%s'", pUser[conn].AccountName);
	MYSQL_ROW row;
	MYSQL* wSQL = pc.wStart();
	MYSQL_RES* result = pc.wRes(wSQL, hQuery);

	if (result == NULL)
		return;


	while ((row = mysql_fetch_row(result)) != NULL)
	{
		Donate = atoi(row[6]);
		Pix = row[20];
	}

	if (Pix == "0") {
		GerarPix(conn);

		sprintf(hQuery, "SELECT * FROM `accounts` WHERE `username` = '%s'", pUser[conn].AccountName);
		MYSQL_ROW row;
		MYSQL* wSQL = pc.wStart();
		MYSQL_RES* result = pc.wRes(wSQL, hQuery);

		if (result == NULL)
			return;

		while ((row = mysql_fetch_row(result)) != NULL)
		{
			Pix = row[20];
		}
	}

	sm.Cash = Donate;
	strncpy(sm.Pix, Pix.c_str(), sizeof(sm.Pix));

	int Size = sm.Size;

	if (Size > sizeof(MSG_UpdateDonate))
	{
		sm.Size = 0;
		return;
	}

	if (!pUser[conn].cSock.AddMessage((char*)&sm, sizeof(MSG_UpdateDonate)))
		CloseUser(conn);
}

void SendCargoCoin(int conn)
{
	if (conn <= 0 || conn >= MAX_USER)
		return;

	if (pUser[conn].Mode != USER_PLAY)
		return;

	if (pUser[conn].cSock.Sock == 0)
		return;

	MSG_STANDARDPARM sm_ucc;
	memset(&sm_ucc, 0, sizeof(MSG_STANDARDPARM));

	sm_ucc.Type = _MSG_UpdateCargoCoin;
	sm_ucc.Size = sizeof(MSG_STANDARDPARM);
	sm_ucc.Size = sizeof(MSG_STANDARDPARM);

	sm_ucc.ID = ESCENE_FIELD;

	sm_ucc.Parm = pUser[conn].Coin;

	int Size = sm_ucc.Size;

	if (Size > sizeof(MSG_STANDARDPARM))
	{
		sm_ucc.Size = 0;
		return;
	}

	if (conn && conn < MAX_USER && pUser[conn].Mode != 0)
	{
		if (!pUser[conn].cSock.AddMessage((char*)&sm_ucc, sizeof(MSG_STANDARDPARM)))
			CloseUser(conn);
	}
}

void SendGuildList(int conn)
{
	int Guild = pMob[conn].MOB.Guild;

	if (Guild <= 0)
		return;

	char str[128];

	memset(str, 0, 128);

	int members = 0;
	int max_size = 70;

	for (int i = 0; i < MAX_USER; i++)
	{
		if (pUser[i].Mode != USER_PLAY)
			continue;

		if (Guild != pMob[i].MOB.Guild)
			continue;

		members++;

		int len = strlen(str);

		if (len >= max_size)
		{
			SendClientMessage(conn, str);

			memset(str, 0, len);
		}

		pMob[i].MOB.MobName[NAME_LENGTH - 1] = 0;
		pMob[i].MOB.MobName[NAME_LENGTH - 2] = 0;

		strcat(str, pMob[i].MOB.MobName);
		strcat(str, " ");
	}

	if (str[0])
		SendClientMessage(conn, str);

	if (members == 0)
		SendClientMessage(conn, g_pMessageStringTable[_NN_No_Guild_Members]);

	int max_guild = 65536;

	if (pMob[conn].MOB.Guild <= 0 || pMob[conn].MOB.Guild >= max_guild)
		return;

	int gwar = g_pGuildWar[Guild];
	char GuildName[256];

	BASE_GetGuildName(ServerGroup, gwar, GuildName);

	int FoundWar = -1;

	if (gwar > 0 && gwar < max_guild)
	{
		if (Guild == g_pGuildWar[gwar])
		{
			sprintf_s(str, g_pMessageStringTable[_SN_Your_are_at_war], GuildName);
			SendClientMessage(conn, str);

			FoundWar = g_pGuildWar[gwar];
		}
		else
		{
			sprintf_s(str, g_pMessageStringTable[_SN_War_to_S], GuildName);
			SendClientMessage(conn, str);
		}
	}

	for (int j = 1; j < max_guild; j++)
	{
		if (g_pGuildWar[j] == Guild || g_pGuildWar[j] == 0)
			continue;

		if (j == FoundWar)
			continue;

		BASE_GetGuildName(ServerGroup, j, GuildName);

		sprintf_s(str, g_pMessageStringTable[_SN_War_from_S], GuildName);
		SendClientMessage(conn, str);
	}

	int ally = g_pGuildAlly[Guild];

	BASE_GetGuildName(ServerGroup, ally, GuildName);

	if (ally > 0 && ally < max_guild)
	{
		sprintf_s(str, g_pMessageStringTable[_SN_Ally_to_S], GuildName);
		SendClientMessage(conn, str);
	}

	for (int j = 1; j < max_guild; j++)
	{
		if (g_pGuildAlly[j] == Guild || g_pGuildAlly[j] == 0)
			continue;

		BASE_GetGuildName(ServerGroup, j, GuildName);

		sprintf_s(str, g_pMessageStringTable[_SN_Ally_from_S], GuildName);
		SendClientMessage(conn, str);
	}
}

void SendShopList(int conn, int MobIndex, int ShopType)
{
	if (conn <= 0 || conn >= MAX_USER)
		return;

	if (pUser[conn].Mode != USER_PLAY)
		return;

	if (pUser[conn].cSock.Sock == 0)
		return;

	MSG_ShopList sm_sl;
	memset(&sm_sl, 0, sizeof(MSG_ShopList));

	sm_sl.Type = _MSG_ShopList;
	sm_sl.Size = sizeof(MSG_ShopList);

	sm_sl.ID = ESCENE_FIELD;

	sm_sl.ShopType = ShopType;

	for (int i = 0; i < MAX_SHOPLIST; i++)
	{
		int tx = i / 9;
		int ty = i % 9 + MAX_SHOPLIST * i / 9;

		int invpos = (i % 9) + ((i / 9) * MAX_SHOPLIST);


		*(int*)&sm_sl.List[i] = *(int*)&pMob[MobIndex].MOB.Carry[invpos].sIndex;
		*(int*)((int)&sm_sl.List[i] + 4) = *(int*)((int)&pMob[MobIndex].MOB.Carry[invpos] + 4);
	}

	int posX = pMob[MobIndex].TargetX;
	int posY = pMob[MobIndex].TargetY;

	int village = BASE_GetVillage(posX, posY);

	if (village >= 0 && village < MAX_GUILDZONE)
		sm_sl.Tax = g_pGuildZone[village].CityTax;
	else
		sm_sl.Tax = 0;

	int Size = sm_sl.Size;

	if (Size > sizeof(MSG_ShopList))
	{
		sm_sl.Size = 0;
		return;
	}

	if (!pUser[conn].cSock.AddMessage((char*)&sm_sl, sizeof(MSG_ShopList)))
		CloseUser(conn);
}

void SendItemList(int conn, int MobIndex, int ShopType)
{
	if (conn <= 0 || conn >= MAX_USER)
		return;

	if (pUser[conn].Mode != USER_PLAY)
		return;

	if (pUser[conn].cSock.Sock == 0)
		return;

	MSG_ShopList sm_sl;
	memset(&sm_sl, 0, sizeof(MSG_ShopList));

	sm_sl.Type = _MSG_ShopList;
	sm_sl.Size = sizeof(MSG_ShopList);

	sm_sl.ID = ESCENE_FIELD;

	sm_sl.ShopType = ShopType;

	int slot = 0;

	for (int i = 0; i < MAX_CARRY; i++) {

		if (*(int*)&pMob[MobIndex].MOB.Carry[i].sIndex <= 0)
			continue;

		for (int j = 0; j < MAX_SHOPLIST; j++) {
			if (*(int*)&sm_sl.List[j] == 0) {
				slot = j;
				break;
			}
		}
		bool exists = false;
		for (int j = 0; j < MAX_SHOPLIST; j++) {
			if (*(int*)&sm_sl.List[j] == *(int*)&pMob[MobIndex].MOB.Carry[i].sIndex)
				exists = true;
		}
		if (exists)
			continue;

		*(int*)&sm_sl.List[slot] = *(int*)&pMob[MobIndex].MOB.Carry[i].sIndex;
	}

	int posX = pMob[MobIndex].TargetX;
	int posY = pMob[MobIndex].TargetY;

	int village = BASE_GetVillage(posX, posY);

	if (village >= 0 && village < MAX_GUILDZONE)
		sm_sl.Tax = g_pGuildZone[village].CityTax;
	else
		sm_sl.Tax = 0;

	int Size = sm_sl.Size;

	if (Size > sizeof(MSG_ShopList))
	{
		sm_sl.Size = 0;
		return;
	}

	if (!pUser[conn].cSock.AddMessage((char*)&sm_sl, sizeof(MSG_ShopList)))
		CloseUser(conn);
}

void SendDonateShop(int conn, int MobIndex, int ShopType)
{
	if (conn <= 0 || conn >= MAX_USER)
		return;

	if (pUser[conn].Mode != USER_PLAY)
		return;

	if (pUser[conn].cSock.Sock == 0)
		return;

	MSG_DonateShop sm_sl;
	memset(&sm_sl, 0, sizeof(MSG_DonateShop));

	sm_sl.Type = _MSG_DonateShop;
	sm_sl.Size = sizeof(MSG_DonateShop);

	sm_sl.ID = ESCENE_FIELD;

	sm_sl.ShopType = ShopType;

	for (int i = 0; i < 15; i++)
	{
		int tx = i / 9;
		int ty = i % 9 + 15 * i / 9;

		int invpos = (i % 9) + ((i / 9) * 15);


		*(int*)&sm_sl.List[i] = *(int*)&pMob[MobIndex].MOB.Carry[invpos].sIndex;
		*(int*)((int)&sm_sl.List[i] + 4) = *(int*)((int)&pMob[MobIndex].MOB.Carry[invpos] + 4);
	}

	int posX = pMob[MobIndex].TargetX;
	int posY = pMob[MobIndex].TargetY;

	int village = BASE_GetVillage(posX, posY);

	if (village >= 0 && village < MAX_GUILDZONE)
		sm_sl.Tax = g_pGuildZone[village].CityTax;
	else
		sm_sl.Tax = 0;

	int Size = sm_sl.Size;

	if (Size > sizeof(MSG_DonateShop))
	{
		sm_sl.Size = 0;
		return;
	}

	if (!pUser[conn].cSock.AddMessage((char*)&sm_sl, sizeof(MSG_DonateShop)))
		CloseUser(conn);
}

void SendWarInfo(int conn, int Clan)
{

	if (conn <= 0 || conn >= MAX_USER)
		return;

	if (pUser[conn].cSock.Sock == 0)
		return;

	int Guild = 0;
	int max_guild = 65536;

	if (pMob[conn].MOB.Guild <= 0 || pMob[conn].MOB.Guild >= max_guild)
		pMob[conn].MOB.Guild = 0;

	if (g_pGuildWar[pMob[conn].MOB.Guild] <= 0 || g_pGuildWar[pMob[conn].MOB.Guild] >= max_guild)
		g_pGuildWar[pMob[conn].MOB.Guild] = 0;

	if (g_pGuildAlly[pMob[conn].MOB.Guild] <= 0 || g_pGuildAlly[pMob[conn].MOB.Guild] >= max_guild)
		g_pGuildAlly[pMob[conn].MOB.Guild] = 0;

	if (pMob[conn].MOB.Guild && g_pGuildWar[pMob[conn].MOB.Guild] && g_pGuildWar[g_pGuildWar[pMob[conn].MOB.Guild]] == pMob[conn].MOB.Guild)
		Guild = g_pGuildWar[pMob[conn].MOB.Guild];
	else
		Guild = 0;

	SendClientSignalParm3(conn, 30000, _MSG_SendWarInfo, Guild, Clan, g_pGuildAlly[pMob[conn].MOB.Guild]);
}

void SendAddParty(int Leaderconn, int conn, int PartyID)
{
	if (Leaderconn <= 0 || Leaderconn >= MAX_USER)
		return;

	if (pUser[Leaderconn].Mode != USER_PLAY)
		return;

	if (pUser[Leaderconn].cSock.Sock == 0)
		return;

	MSG_CNFAddParty sm_cap;
	memset(&sm_cap, 0, sizeof(MSG_CNFAddParty));

	sm_cap.ID = ESCENE_FIELD;
	sm_cap.Type = _MSG_CNFAddParty;
	sm_cap.Size = sizeof(MSG_CNFAddParty);

	if (PartyID == 0)
		sm_cap.Leaderconn = conn;
	else
		sm_cap.Leaderconn = 30000;

	sm_cap.Level = pMob[conn].MOB.CurrentScore.Level;
	sm_cap.MaxHp = pMob[conn].MOB.CurrentScore.MaxHp > 32000 ? ((pMob[conn].MOB.CurrentScore.MaxHp + 1) / 100) : pMob[conn].MOB.CurrentScore.MaxHp;
	sm_cap.Hp = pMob[conn].MOB.CurrentScore.Hp > 32000 ? ((pMob[conn].MOB.CurrentScore.Hp + 1) / 100) : pMob[conn].MOB.CurrentScore.Hp;

	sm_cap.PartyID = conn;//Check:
	sm_cap.Target = (short)52428;

	strncpy(sm_cap.MobName, pMob[conn].MOB.MobName, sizeof(sm_cap.MobName));

	if (!pUser[Leaderconn].cSock.SendOneMessage((char*)&sm_cap, sizeof(MSG_CNFAddParty)))
		CloseUser(Leaderconn);
}

void SendAddPartyEvocation(int Leaderconn)
{
	if (Leaderconn <= 0 || Leaderconn >= MAX_USER)
		return;

	if (pUser[Leaderconn].Mode != USER_PLAY)
		return;

	if (pUser[Leaderconn].cSock.Sock == 0)
		return;

	MSG_PartyEvocation sm_cap;
	memset(&sm_cap, 0, sizeof(MSG_PartyEvocation));

	sm_cap.Size = sizeof(MSG_PartyEvocation);
	sm_cap.Type = _MSG_PartyEvocation;
	sm_cap.ID = ESCENE_FIELD;

	sm_cap.Leader = Leaderconn;

	memcpy(&sm_cap.EvocationList, &pMob[Leaderconn].Evocations, sizeof(pMob[Leaderconn].Evocations));

	sm_cap.Unknown[0] = 0xCC;
	sm_cap.Unknown[1] = 0xCC;

	if (!pUser[Leaderconn].cSock.SendOneMessage((char*)&sm_cap, sizeof(MSG_PartyEvocation)))
		CloseUser(Leaderconn);
}

bool IsVip(int conn)
{
	for (int i = 0; i < MAX_AFFECT; i++)
	{
		if (pMob[conn].Affect[i].Type == 34)
		{
			return TRUE;
		}
	}
	return FALSE;
}

void SendRemoveParty(int conn, int connExit)
{
	if (conn <= 0 || conn >= MAX_USER)
		return;

	if (pUser[conn].Mode != USER_PLAY)
		return;

	if (pUser[conn].cSock.Sock == 0)
		return;


	MSG_RemoveParty sm_rp;
	memset(&sm_rp, 0, sizeof(MSG_RemoveParty));

	sm_rp.ID = ESCENE_FIELD;
	sm_rp.Type = _MSG_RemoveParty;
	sm_rp.Size = sizeof(MSG_RemoveParty);

	sm_rp.Leaderconn = connExit;
	sm_rp.unk = 0;

	int Size = sm_rp.Size;

	if (Size > sizeof(MSG_RemoveParty))
	{
		sm_rp.Size = 0;
		return;
	}

	if (conn && conn < MAX_USER && pUser[conn].Mode != 0)
	{
		pUser[conn].cSock.AddMessage((char*)&sm_rp, sizeof(MSG_RemoveParty));
	}
}

void SendCarry(int conn)
{
	if (conn <= 0 || conn >= MAX_USER)
		return;

	if (pUser[conn].Mode != USER_PLAY)
		return;

	if (pUser[conn].cSock.Sock == 0)
		return;

	MSG_UpdateCarry sm;

	memset(&sm, 0, sizeof(MSG_UpdateCarry));

	sm.ID = conn;
	sm.Type = _MSG_UpdateCarry;
	sm.Size = sizeof(MSG_UpdateCarry);

	memcpy(&sm.Carry, pMob[conn].MOB.Carry, sizeof(STRUCT_ITEM)*MAX_CARRY);

	sm.Coin = pMob[conn].MOB.Coin;

	int Size = sm.Size;

	if (Size > sizeof(MSG_UpdateCarry))
	{
		sm.Size = 0;
		return;
	}

	if (conn && conn < MAX_USER && pUser[conn].Mode != 0)
	{
		if (!pUser[conn].cSock.AddMessage((char*)&sm, sizeof(MSG_UpdateCarry)))
			CloseUser(conn);
	}
}

void SendWeather()
{
	MSG_UpdateWeather sm_uw;
	memset(&sm_uw, 0, sizeof(MSG_UpdateWeather));

	sm_uw.Type = _MSG_UpdateWeather;
	sm_uw.Size = sizeof(MSG_UpdateWeather);

	sm_uw.ID = ESCENE_FIELD;

	sm_uw.CurrentWeather = CurrentWeather;

	for (int i = 0; i < MAX_USER; i++)
	{
		if (pUser[i].Mode != USER_PLAY)
			continue;

		if (!pUser[i].cSock.Sock)
			continue;


		//		if ((pMob[i].TargetX / 128) < 12 && (pMob[i].TargetY / 128) > 25)
		
		if (!pUser[i].cSock.AddMessage((char*)&sm_uw, sizeof(MSG_UpdateWeather)))
			CloseUser(i);
		
	}
}

void SendSetHpMp(int conn)
{
	if (conn <= 0 || conn >= MAX_USER)
		return;

	if (pUser[conn].Mode != USER_PLAY)
		return;

	if (pUser[conn].cSock.Sock == 0)
		return;

	MSG_SetHpMp sm_shm;
	memset(&sm_shm, 0, sizeof(MSG_SetHpMp));

	sm_shm.Type = _MSG_SetHpMp;
	sm_shm.Size = sizeof(MSG_SetHpMp);
	sm_shm.ID = conn;

	sm_shm.Hp = pMob[conn].MOB.CurrentScore.Hp;
	sm_shm.Mp = pMob[conn].MOB.CurrentScore.Mp;

	SetReqHp(conn);
	SetReqMp(conn);

	sm_shm.ReqHp = pUser[conn].ReqHp;
	sm_shm.ReqMp = pUser[conn].ReqMp;

	int Size = sm_shm.Size;

	if (Size > sizeof(MSG_SetHpMp))
	{
		sm_shm.Size = 0;
		return;
	}

	if (conn && conn < MAX_USER && pUser[conn].Mode != 0)
	{
		if (!pUser[conn].cSock.AddMessage((char*)&sm_shm, sizeof(MSG_SetHpMp)))
			CloseUser(conn);
	}
}

void SendHpMode(int conn)
{
	if (conn <= 0 || conn >= MAX_USER)
		return;

	if (pUser[conn].Mode != USER_PLAY)
		return;

	if (pUser[conn].cSock.Sock == 0)
		return;

	MSG_SetHpMode sm_shmd;
	memset(&sm_shmd, 0, sizeof(MSG_SetHpMode));

	sm_shmd.Type = _MSG_SetHpMode;
	sm_shmd.Size = sizeof(MSG_SetHpMode);
	sm_shmd.ID = conn;

	sm_shmd.Hp = pMob[conn].MOB.CurrentScore.Hp;
	sm_shmd.Mode = pUser[conn].Mode;

	int Size = sm_shmd.Size;

	if (Size > sizeof(MSG_SetHpMode))
	{
		sm_shmd.Size = 0;
		return;
	}

	if (conn && conn < MAX_USER && pUser[conn].Mode != 0)
	{
		if (!pUser[conn].cSock.AddMessage((char*)&sm_shmd, sizeof(MSG_SetHpMode)))
			CloseUser(conn);
	}
}

//aqui
void SendSay(int mob, char *Message)
{
	MSG_MessageChat sm_mc;
	memset(&sm_mc, 0, sizeof(MSG_MessageChat));

	sm_mc.Type = _MSG_MessageChat;
	sm_mc.Size = sizeof(MSG_MessageChat);
	sm_mc.ID = mob;

	memcpy(sm_mc.String, Message, MESSAGE_LENGTH);

	GridMulticast(pMob[mob].TargetX, pMob[mob].TargetY, (MSG_STANDARD*)&sm_mc, 0);
}

void MapaMulticastArea(int x1, int y1, int x2, int y2, MSG_STANDARD *m, int bSend)
{
	for (int i = 0; i < MAX_USER; i++)
	{
		if (pUser[i].Mode == USER_PLAY && (pMob[i].TargetX >= x1 && pMob[i].TargetX <= x2 && pMob[i].TargetY >= y1 && pMob[i].TargetY <= y2))
		{
			if (!pUser[i].cSock.AddMessage((char*)m, m->Size))
				CloseUser(i);

			/*if (bSend)
				pUser[i].cSock.SendMessageA();*/
		}
	}
}

void MapaMulticast(int tx, int ty, MSG_STANDARD *m, int bSend)
{
	for (int i = 1; i < MAX_USER; i++)
	{
		if (pUser[i].Mode == USER_PLAY && (pMob[i].TargetX / 128) == tx && (pMob[i].TargetY / 128) == ty)
		{
			if (!pUser[i].cSock.AddMessage((char*)m, m->Size))
				CloseUser(i);

			if (bSend)
				pUser[i].cSock.SendMessageA();
		}
	}
}

void SendMessageArea(int x1, int y1, int x2, int y2, MSG_STANDARD *m, int bSend)
{
	for (int i = 0; i < MAX_USER; i++)
	{
		if (pUser[i].Mode != USER_PLAY)
			continue;

		if (pMob[i].TargetX >= x1 && pMob[i].TargetY <= x2 && pMob[i].TargetY >= y1 && pMob[i].TargetY <= y2)
		{
			if (!pUser[i].cSock.AddMessage((char*)m, m->Size))
				CloseUser(i);

			if (bSend)
				pUser[i].cSock.SendMessageA();
		}
	}
}

void SendSignalParmArea(int x1, int y1, int x2, int y2, int id, unsigned short signal, int parm)
{
	for (int x = x1; x < x2; x++)
	{
		for (int y = y1; y < y2; y++)
		{
			if (x < 0 || x >= MAX_GRIDX || y < 0 || y >= MAX_GRIDY)
				continue;

			int tmob = pMobGrid[y][x];

			if (tmob >= MAX_USER || tmob == 0)
				continue;

			if (pUser[tmob].Mode != USER_PLAY)
				continue;

			SendClientSignalParm(tmob, id, signal, parm);
		}
	}
}

void SendShortSignalParm2Area(int x1, int y1, int x2, int y2, int id, unsigned short signal, int parm1, int parm2)
{
	for (int x = x1; x < x2; x++)
	{
		for (int y = y1; y < y2; y++)
		{
			if (x < 0 || x >= MAX_GRIDX || y < 0 || y >= MAX_GRIDY)
				continue;

			int tmob = pMobGrid[y][x];

			if (tmob >= MAX_USER || tmob == 0)
				continue;

			if (pUser[tmob].Mode != USER_PLAY)
				continue;

			SendClientSignalShortParm2(tmob, id, signal, parm1, parm2);
		}
	}
}

void SendPKInfo(int conn, int target)
{
	if (conn <= 0 || conn >= MAX_USER)
		return;

	if (target <= 0 || target >= MAX_USER)
		return;

	MSG_STANDARDPARM sm;
	memset(&sm, 0, sizeof(MSG_STANDARDPARM));

	sm.Size = sizeof(MSG_STANDARDPARM);
	sm.Type = _MSG_PKInfo;
	sm.ID = target;

	if (NewbieEventServer == 0)
	{
		int guilty = GetGuilty(target);

		int state = 0;

		if (guilty || pUser[target].PKMode || RvRState || CastleState || GTorreState)
			state = 1;

		sm.Parm = state;
	}
	else
		sm.Parm = 1;

	int Size = sm.Size;

	if (Size > sizeof(MSG_STANDARDPARM))
	{
		sm.Size = 0;
		return;
	}
	if (conn && conn < MAX_USER && pUser[conn].Mode != 0)
		if (!pUser[conn].cSock.AddMessage((char*)&sm, sizeof(MSG_STANDARDPARM)))
			CloseUser(conn);
}

void SendAffect(int conn)
{
	if (conn <= 0 || conn >= MAX_USER)
		return;

	MSG_SendAffect sm;

	memset(&sm, 0, sizeof(MSG_SendAffect));

	sm.Type = _MSG_SendAffect;
	sm.Size = sizeof(MSG_SendAffect);
	sm.ID = conn;

	for (int i = 0; i < MAX_AFFECT; i++) // i = 0;
	{
		if (pMob[conn].Affect[i].Type == 34 && pMob[conn].Affect[i].Time >= 32000000)
		{
			time_t now;

			time(&now);

			if ((pMob[conn].extra.DivineEnd - now) <= 86400) // 3600
			{
				pMob[conn].Affect[i].Time = 10800; // 450

				sm.Affect[i].Type = pMob[conn].Affect[i].Type;
				sm.Affect[i].Value = pMob[conn].Affect[i].Value;
				sm.Affect[i].Level = pMob[conn].Affect[i].Level;
				sm.Affect[i].Time = pMob[conn].Affect[i].Time;

				continue;
			}

			sm.Affect[i].Type = pMob[conn].Affect[i].Type;
			sm.Affect[i].Value = pMob[conn].Affect[i].Value;
			sm.Affect[i].Level = pMob[conn].Affect[i].Level;
			sm.Affect[i].Time = (int)(((pMob[conn].extra.DivineEnd - now) / 60 / 60 / 24 * AFFECT_1D) - 1);
		}
		else if (pMob[conn].Affect[i].Type >= 1)
		{
			sm.Affect[i].Type = pMob[conn].Affect[i].Type;
			sm.Affect[i].Value = pMob[conn].Affect[i].Value;
			sm.Affect[i].Level = pMob[conn].Affect[i].Level;
			sm.Affect[i].Time = pMob[conn].Affect[i].Time;
		}
	}
	int Size = sm.Size;

	if (Size > sizeof(MSG_SendAffect))
	{
		sm.Size = 0;
		return;
	}
	if (conn && conn < MAX_USER && pUser[conn].Mode != 0)
		if (!pUser[conn].cSock.AddMessage((char*)&sm, sizeof(MSG_SendAffect)))
			CloseUser(conn);
}

void SendRecycle(int conn)
{
	if (pUser[conn].Mode != USER_PLAY)
		return;

	MSG_Rebuy m;
	memset(&m, 0, sizeof(MSG_Rebuy));
	m.ID = conn;
	m.Type = 0x3E8;
	m.Size = sizeof(MSG_Rebuy);

	for (int i = 0; i < MAX_ITEM_REBUY; i++)
		m.Rebuy[i] = pMob[conn].Rebuy[i];

	int Size = m.Size;

	if (Size > sizeof(MSG_Rebuy))
	{
		m.Size = 0;
		return;
	}
	
	if (conn && conn < MAX_USER && pUser[conn].Mode != 0)
	{
		if (!pUser[conn].cSock.AddMessage((char*)&m, sizeof(MSG_Rebuy)))
			CloseUser(conn);
	}
}

//BOSS LAN N PINHEIRO
void SendLanCount(int conn)
{
	if (g_LanNBoss == FALSE) {
		if (g_LanNBossCount >= 1000) //EDITAR QUANTIDADE DE MOB QUE PRECISA MATAR NA LAN PARA NACER O BOSS
		{
			int Index = 4891; // INDEX DELE NO NPC GERNE PARA SUMMON
			GenerateMob(Index, 3640, 3639);
			SendNoticeArea("*** O Guardião do Território Apareceu ***", 3604, 3601, 3690, 3690); //AVISO QUE BOSS NACEU PARA JOGADORES
			g_LanNBoss = TRUE;
			g_LanNBossCount = 0;
			return;
		}
		g_LanNBossCount += 1;
		SendClientSignalShortParm2(conn, ESCENE_FIELD, _MSG_MobCount, g_LanNBossCount, 1000); //EDITAR QUANTIDADE DE MOB QUE PRECISA MATAR NA LAN PARA NACER O BOSS
	}
}

void SendEventCount(int conn)
{
	MSG_STANDARDPARM2 w;
	memset(&w, 0, sizeof(MSG_STANDARDPARM2));

	int npcIndex = w.Parm1;
	int confirm = w.Parm2;


	if (pUser[conn].EventDelay != 0)
	{
		int isTime = GetTickCount64() - pUser[conn].EventDelay;
		if (isTime < 600)
			return;
	}
	pUser[conn].EventDelay = GetTickCount64();

	STRUCT_ITEM item;
	memset(&item, 0, sizeof(STRUCT_ITEM));

	item.sIndex = 475;
	
	if (wUser[conn].CounterHist > 250)
	{
		SendItemagrupar(conn, item.sIndex);
		SendCarry(conn);
		SaveUser(conn, 0);
		wUser[conn].CounterHist = 0;								
	}
	if (pUser[conn].Keys[49] == 1) {
		wUser[conn].CounterHist++;
	}
	wUser[conn].CounterHist++;
	SendClientSignalShortParm2(conn, ESCENE_FIELD, _MSG_MobCount, wUser[conn].CounterHist, 250);
}

void SendEventCount2(int conn)
{
	MSG_STANDARDPARM2 w;
	memset(&w, 0, sizeof(MSG_STANDARDPARM2));

	int npcIndex = w.Parm1;
	int confirm = w.Parm2;

	int npcMerc = pMob[npcIndex].MOB.Merchant;
	int npcGrade = BASE_GetItemAbilityNosanc(&pMob[npcIndex].MOB.Equip[0], 400);

	/*if (pUser[conn].Atraso != 0)
	{
		int isTime = GetTickCount64() - pUser[conn].Atraso;

		if (isTime < 1000)
		{
			return;
		}

	}*/

	//pUser[conn].Atraso = GetTickCount64();

	bool premium = false;
	int slotsInv = 30;

	if (pMob[conn].MOB.Carry[60].sIndex == 3467) {
		slotsInv += 15;
	}

	if (pMob[conn].MOB.Carry[61].sIndex == 3467) {
		slotsInv += 15;
	}

	for (int j = 0; j < slotsInv; j++) {
		if (pMob[conn].MOB.Carry[j].sIndex == 5666)
			premium = true;
	}

	//contador de tempo pesca
	if (premium == false) {
		if (wUser[conn].CounterHist > 360)
		{
			STRUCT_ITEM item;
			memset(&item, 0, sizeof(STRUCT_ITEM));

			std::mt19937 generator;
			generator.seed((unsigned int)std::time(0));
			std::uniform_int_distribution<uint32_t> dice(1, 100);
			int random = dice(generator);

			//sprintf(temp, "Dice: %d/100", random);
			//SendClientMessage(conn, temp);

			bool entrega = true;
			//5 %
			if (random <= 5 && entrega == true) {

				item.sIndex = 5671;
				entrega = false;
			}
			//15 %
			if (random <= 20 && entrega == true) {
				item.sIndex = 5670;
				entrega = false;
			}
			//30 %
			if (random <= 50 && entrega == true) {
				item.sIndex = 5669;
				entrega = false;
			}
			//50 %
			if (random <= 100 && entrega == true) {
				item.sIndex = 5668;
				entrega = false;
			}

			int IdItem = item.sIndex;
			int cont = 0;
			for (int i = 0; i < slotsInv; i++)
			{
				if (pMob[conn].MOB.Carry[i].sIndex == IdItem)
					cont += pMob[conn].MOB.Carry[i].stEffect[0].cEffect == 61 ? pMob[conn].MOB.Carry[i].stEffect[0].cValue : 1;
			}

			if (cont <= 250) {
				RemoveItem(conn, IdItem, cont);
				item.stEffect[0].cEffect = 61;
				item.stEffect[0].cValue = cont + 1;
				PutItem(conn, &item);
			}

			if (cont > 250 && cont < 500) {
				RemoveItem(conn, IdItem, cont);
				item.stEffect[0].cEffect = 61;
				item.stEffect[0].cValue = 250;
				PutItem(conn, &item);

				item.stEffect[0].cEffect = 61;
				item.stEffect[0].cValue = (cont - 250) + 1;
				PutItem(conn, &item);
			}

			if (cont >= 500)
				SendClientMessage(conn, "Limite máximo de recompensa alcançado");

			wUser[conn].CounterHist = 0;
			return;
		}

		wUser[conn].CounterHist++;
		SendClientSignalShortParm2(conn, ESCENE_FIELD, _MSG_MobCount, wUser[conn].CounterHist, 360);
	}

	if (premium == true) {
		if (wUser[conn].CounterHist > 360)
		{

			STRUCT_ITEM item;
			memset(&item, 0, sizeof(STRUCT_ITEM));

			std::mt19937 generator;
			generator.seed((unsigned int)std::time(0));
			std::uniform_int_distribution<uint32_t> dice(1, 100);
			int random = dice(generator);

			bool entrega = true;

			//15 %
			if (random <= 15 && entrega == true) {

				item.sIndex = 5671;
				item.stEffect[0].cEffect = 0;
				item.stEffect[0].cValue = 0;
				entrega = false;
			}
			//25 %
			if (random <= 40 && entrega == true) {
				item.sIndex = 5670;
				item.stEffect[0].cEffect = 0;
				item.stEffect[0].cValue = 0;
				entrega = false;
			}
			//30 %
			if (random <= 70 && entrega == true) {
				item.sIndex = 5669;
				item.stEffect[0].cEffect = 61;
				item.stEffect[0].cValue = 30;
				entrega = false;
			}
			//30 %
			if (random <= 100 && entrega == true) {
				item.sIndex = 5668;
				item.stEffect[0].cEffect = 0;
				item.stEffect[0].cValue = 0;
				entrega = false;
			}
			

			int IdItem = item.sIndex;
			int cont = 0;
			for (int i = 0; i < slotsInv; i++)
			{
				if (pMob[conn].MOB.Carry[i].sIndex == IdItem)
					cont += pMob[conn].MOB.Carry[i].stEffect[0].cEffect == 61 ? pMob[conn].MOB.Carry[i].stEffect[0].cValue : 1;
			}

			if (cont <= 250) {
				RemoveItem(conn, IdItem, cont);
				item.stEffect[0].cEffect = 61;
				item.stEffect[0].cValue = cont + 1;
				PutItem(conn, &item);
			}

			if (cont > 250 && cont < 500) {
				RemoveItem(conn, IdItem, cont);
				item.stEffect[0].cEffect = 61;
				item.stEffect[0].cValue = 250;
				PutItem(conn, &item);

				item.stEffect[0].cEffect = 61;
				item.stEffect[0].cValue = (cont - 250) + 1;
				PutItem(conn, &item);
			}

			if (cont >= 500)
				SendClientMessage(conn, "Limite máximo de recompensa alcançado");


			wUser[conn].CounterHist = 0;
			RemoveItem(conn, 5666, 1);
			return;
		}
		wUser[conn].CounterHist++;
		SendClientSignalShortParm2(conn, ESCENE_FIELD, _MSG_MobCount, wUser[conn].CounterHist, 360);
	}
}

void SendClientSignalParmCoord(int conn, int id, unsigned short signal, int parm, int x1, int y1, int x2, int y2)
{
	if (conn <= 0 || conn >= MAX_USER)
		return;


	if (pUser[conn].cSock.Sock == 0)
		return;

	if (pMob[conn].TargetX >= x1 && pMob[conn].TargetX <= x2 && pMob[conn].TargetY >= y1 && pMob[conn].TargetY <= y2)
	{

		MSG_STANDARDPARM sm;
		memset(&sm, 0, sizeof(MSG_STANDARDPARM));

		sm.Type = signal;
		sm.ID = id;
		sm.Parm = parm;

		int Size = sm.Size;

		if (Size > sizeof(MSG_STANDARDPARM))
		{
			sm.Size = 0;
			return;
		}

		if (!pUser[conn].cSock.AddMessage((char*)&sm, sizeof(sm)))
			CloseUser(conn);
	}
}

//int Limitadordelojinha(char* Mac)
//{
//	int retn = 0;
//
//	if (!strcmp(Mac, ""))
//		return 0;
//
//	for (int i = 0; i < MAX_USER; i++)
//
//		if (pUser[i].TradeMode == 1)
//		{
//			if (pUser[i].Mode == 22)
//				if (!strcmp(Mac, pUser[i].MacAddress))
//					retn++;
//		}
//
//	return retn;
//}

int Limitadordelojinha(char* Mac)
{
	int retn = 0;

	if (!strcmp(Mac, ""))
		return 0;

	for (int i = 0; i < MAX_USER; i++)
	{
		if (pUser[i].Mode != USER_PLAY)
			continue;

		if (!pUser[i].cSock.Sock)
			continue;
		if (pUser[i].TradeMode == 1)
		{
			if (!strcmp(Mac, pUser[i].MacAddress))
				retn++;

		}
	}

	return retn;
}

int Limitadordeconexoes(char* Mac)
{
	int retn = 0;

	if (!strcmp(Mac, ""))
		return 0;

	for (int i = 0; i < MAX_USER; i++)

		if (pUser[i].Mode == 22)
			if (!strcmp(Mac, pUser[i].MacAddress))
				retn++;

	return retn;
}

//int Limitadordeconexoes(char* Mac)
//{
//	int retn = 0;
//
//	if (!strcmp(Mac, ""))
//		return 0;
//
//	for (int i = 0; i < MAX_USER; i++)
//
//		if (pUser[i].Mode == 22)
//			if (!strcmp(Mac, pUser[i].MacAddress))
//				retn++;
//
//	return retn;
//}

void SendReqParty(int Leaderconn, int conn, int PartyID)
{
	if (Leaderconn <= 0 || Leaderconn >= MAX_USER)
		return;

	if (pUser[Leaderconn].Mode != USER_PLAY)
		return;

	if (pUser[Leaderconn].cSock.Sock == 0)
		return;

	MSG_SendReqParty sm_cap;
	memset(&sm_cap, 0, sizeof(MSG_SendReqParty));

	sm_cap.ID = ESCENE_FIELD;
	sm_cap.Type = _MSG_SendReqParty;
	sm_cap.Size = sizeof(MSG_SendReqParty);

	if (PartyID == 0)
		sm_cap.Target = conn;
	else
		sm_cap.Target = 30000;

	sm_cap.Level = pMob[conn].MOB.CurrentScore.Level;
	sm_cap.MaxHp = pMob[conn].MOB.CurrentScore.MaxHp > 32000 ? ((pMob[conn].MOB.CurrentScore.MaxHp + 1) / 100) : pMob[conn].MOB.CurrentScore.MaxHp;
	sm_cap.Hp = pMob[conn].MOB.CurrentScore.Hp > 32000 ? ((pMob[conn].MOB.CurrentScore.Hp + 1) / 100) : pMob[conn].MOB.CurrentScore.Hp;

	sm_cap.PartyID = conn;//Check:
	sm_cap.Target = (short)52428;

	strncpy(sm_cap.MobName, pMob[conn].MOB.MobName, sizeof(sm_cap.MobName));

	if (!pUser[Leaderconn].cSock.SendOneMessage((char*)&sm_cap, sizeof(MSG_SendReqParty)))
		CloseUser(Leaderconn);
}

# -------------------- SendFunc.h --------------------

/*
*   Copyright (C) {2015}  {Victor Klafke, Charles TheHouse}
*
*   This program is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program.  If not, see [http://www.gnu.org/licenses/].
*
*   Contact at: victor.klafke@ecomp.ufsm.br
*/
#ifndef __SENDFUNC__
#define __SENDFUNC__

INT32 CreateMobLeilaoStore(int posX, int posY, int seller);
void RemoveMobLeilaoStore(int clientId); 
void goResetLeilao(int clientId);
void SendLeilaoStoreInfos(int clientId, int targetItemType);
void SendLeilaoStoreAlvoInfos(int clientId, int Dono);
void SendLeilaoStoreAllInfos(int clientId, int type, int requestedPage);
void SendLeilaoStoreMyInfos(int clientId);
 
INT32 GetFirstSlot(int clientId, int itemId);
float TimeRemaining(int dia, int mes, int ano);
INT32 GetItemAmount(STRUCT_ITEM* item);
void AmountMinusPlus(STRUCT_ITEM* item, int qtd);

int checkCord(int conn, int cX, int cY, int cX2, int cY2);
BOOL bFile_exists(const char *filename);
void SendClientMsg(int conn, char* Message);
void SendClientMessage(int conn, char *Message);
void SendDerrubarCliente(int conn, short Modelo);
void SendMessageBox(int conn, char *Message);
void SendNotice(char *Message);
void SendNoticeChief(char *Message);
void SendSummonChief();
void SendNoticeArea(char *Message, int x1, int y1, int x2, int y2);
void SendGuildNotice(int Guild, char *Message);
void SendClientMessageOk(int conn, char *Message, int Useless1, int Useless2);
void SendWindowMessage(int conn, char *Message);
void SendClientSignal(int conn, int id, unsigned short signal);
void SendClientSignalParm(int conn, int id, unsigned short signal, int parm);
void SendClientSignalParm2(int conn, int id, unsigned short signal, int parm, int parm2);
void SendClientSignalParm3(int conn, int id, unsigned short signal, int parm, int parm2, int parm3);
void SyncMulticast(int conn, MSG_STANDARD *m, int bSend);
void SyncKingdomMulticast(int conn, int Kingdom, MSG_STANDARD *m, int bSend);
void SendCreateMob(int conn, int otherconn, int bSend);
void SendCreateItem(int conn, int item, int bSend);
void SendChat(int conn, char *Message);
void SendEnvEffect(int x1, int y1, int x2, int y2, int Effect, int EffectParm);
void SendEnvEffectKingdom(int x1, int y1, int x2, int y2, int Effect, int EffectParm, int Clan);
void SendEnvEffectLeader(int x1, int y1, int x2, int y2, int Effect, int EffectParm);
void SendRemoveMob(int dest, int sour, int Type, int bSend);
void SendRemoveItem(int dest, int itemid, int bSend);
void SendAutoTrade(int conn, int otherconn);
void SendGridMob(int conn);

//void GridMulticast(int conn, int tx, int ty, MSG_STANDARD *msg);
void GridMulticast(int Index, unsigned int posX, unsigned int posY, MSG_STANDARD* msg);
void SendEmotion(int conn, int Motion, int Parm);
//void GridMulticast(int tx, int ty, MSG_STANDARD *msg, int skip);
void GridMulticast(int posX, int posY, MSG_STANDARD* sendPak, int Index);
void PartyGridMulticast(int tx, int ty, MSG_STANDARD *msg, int skip, int Leaderconn);
void SendItem(int conn, int Type, int Slot, STRUCT_ITEM *item);
void SendEquip(int conn, int skip);
void SendScore(int conn);
void SendGuildChat(int conn, char *Message);
void SendClientChat(int conn, char *pMsg, int color);
void SendEtc(int conn);
void SendKeys(int conn);
void SendJoias(int conn);
void SendItemLevel(int conn);
void SendServerInfo(int conn);
void UpdateDonate(int conn);
void UpdateLeilaoSaldo(int conn);
void SendCargoCoin(int conn);
void SendGuildList(int conn);
void SendShopList(int conn, int MobIndex, int ShopType);
void SendDonateShop(int conn, int MobIndex, int ShopType);
void SendItemList(int conn, int MobIndex, int ShopType);
void SendWarInfo(int conn, int Clan);
void SendAddParty(int Leaderconn, int conn, int PartyID);
void SendAddPartyEvocation(int Leaderconn);
void SendRemoveParty(int conn, int connExit);
bool IsVip(int conn);
void SendCarry(int conn);
void SendWeather();
void SendSetHpMp(int conn);
void SendHpMode(int conn);
void SendSay(int mob, char *Message);
void MapaMulticastArea(int x1, int y1, int x2, int y2, MSG_STANDARD *m, int bSend);
void MapaMulticast(int tx, int ty, MSG_STANDARD *m, int bSend);
void SendMessageArea(int x1, int y1, int x2, int y2, MSG_STANDARD *m, int bSend);
void SendSignalParmArea(int x1, int y1, int x2, int y2, int id, unsigned short signal, int parm);
void SendClientSignalShortParm2(int conn, int id, unsigned short signal, int parm, int parm2);
void SendShortSignalParm2Area(int x1, int y1, int x2, int y2, int id, unsigned short signal, int parm1, int parm2);
void SendPKInfo(int conn, int target);
void SendAffect(int conn);
void SendQuizMessage(int conn, char* Title, char* Answer0, char* Answer1, char* Answer2, char* Answer3, char correct);
void SendQuizLanN(int conn, char* Title, char* Answer0, char* Answer1, char* Answer2, char* Answer3, char correct);
void SendQuizLanM(int conn, char* Title, char* Answer0, char* Answer1, char* Answer2, char* Answer3, char correct);
void SendQuizLanA(int conn, char* Title, char* Answer0, char* Answer1, char* Answer2, char* Answer3, char correct);
void SendRecycle(int conn);
char* strFmt(const char* str, ...);
void SendClientSignalParmCoord(int conn, int id, unsigned short signal, int parm, int x1, int y1, int x2, int y2);
void SendBigMessage(int conn, char *Title, char *String); 
bool SendSaveBanned(int conn);
void SendBanAccount(int conn, int type);
char* strFmt(const char* str, ...);
void SendEventCount(int conn);//evento hit evento
void SendEventCount2(int conn);//evento hit pesca
void SendLanCount(int conn);

int DamageBalancing(int conn, int idx, int tDamage);
int DamageCalc(int signal, int pValue, int iValue);
void BalanceioPvP();
int Limitadordelojinha(char* Mac);
int Limitadordeconexoes(char* Mac);
void SendReqParty(int Leaderconn, int conn, int PartyID);
#endif

# -------------------- Server.cpp --------------------


#include <Windows.h>
#include <stdio.h>
#include <fcntl.h>
#include <time.h>
#include <math.h>
#include <io.h>
#include <errno.h>
#include <fstream>

#include "..\Basedef.h"
#include "..\CPSock.h"
#include "..\ItemEffect.h"
#include "Language.h"

#include "CItem.h"
#include "Server.h"
#include "GetFunc.h"
#include "SendFunc.h"
#include "ProcessClientMessage.h"
#include "ProcessDBMessage.h"
#include "CReadFiles.h"
#include "CWarTower.h"
#include "CColiseu.h"
#include "CCubo.h"
#include "IPControl.h"
#include <vector> 
#include "wMySQL.h"
#include "Functions.h"

#pragma region Defines


int FREEEXP = 40;
int PARTY_DIF = 400;

int FreyjaGoldAposta = 0;

int ServerDown = -1000;

int g_EmptyMob = MAX_USER;

int ServerIndex = -1;
int Sapphire = 8;
int ServerGroup = -1;
int GuildCounter = 1;

int ApostaPista = 0;
STRUCT_USER   wUser[MAX_USER];

AccountBanned BannedUser[MAX_USER];

//recaptcha
int random_words;

char Keywords[30][7] = {
	"BIKE", "AVIÃO", "BIKE", "CARRO", "NAVIO",
	"CARRO", "BIKE", "AVIÃO", "MOTO", "MOTO",
	"BIKE", "BIKE", "AVIÃO", "TREM", "BIKE",
	"AVIÃO", "BIKE", "CARRO", "NAVIO", "NAVIO",
	"NAVIO", "MOTO", "TREM", "TREM", "AVIÃO",
	"TREM", "NAVIO", "AVIÃO", "NAVIO", "MOTO"
};

char Keywords1[30][7] = {
	"TREM", "BIKE", "CARRO", "BIKE", "AVIÃO",
	"TREM", "BIKE", "NAVIO", "MOTO", "BIKE",
	"CARRO", "MOTO", "NAVIO", "AVIÃO", "BIKE",
	"AVIÃO", "CARRO", "MOTO", "TREM", "MOTO",
	"BIKE", "AVIÃO", "BIKE", "NAVIO", "NAVIO",
	"AVIÃO", "NAVIO", "AVIÃO", "NAVIO", "NAVIO"
};

char Keywords2[30][7] = {
	"BIKE", "MOTO", "AVIÃO", "BIKE", "AVIÃO",
	"AVIÃO", "MOTO", "TREM", "NAVIO", "MOTO",
	"CARRO", "TREM", "CARRO", "BIKE", "CARRO",
	"NAVIO", "AVIÃO", "AVIÃO", "BIKE", "BIKE",
	"MOTO", "BIKE", "BIKE", "NAVIO", "MOTO",
	"NAVIO", "NAVIO", "AVIÃO", "TREM", "AVIÃO"
};

// Donate Store

int cStoreItens[3][5][15][3] = {};

extern int ExpBaseN[12] = {};
extern int ExpBaseM[12] = {};
extern int ExpCele[24] = {};
int ArchDiv;
int CeleDiv;

//////////////////////////////
///// STATUS DOS BOSS//
bool g_BSombraNegra = FALSE;
bool g_BVerid = FALSE;
bool g_SombraP = FALSE;
bool g_LanNBoss = FALSE;
bool g_RainhaG = FALSE;
int g_LanNBossCount = 0;

bool g_QBoss1 = FALSE;
bool g_QBoss2 = FALSE;
bool g_QBoss3 = FALSE;
bool g_QBoss4 = FALSE;
bool g_QBoss5 = FALSE;

bool PistaPlaying;

bool g_BFDarkShadow = FALSE;

STRUCT_QUEST QuestDiaria[36];

////////
bool TarantulaKilled = FALSE;
bool MsgArea = FALSE;
bool MsgArea2 = FALSE;
int BigCubo = 1; 

char ACCOUNT_DIRECTORY[MESSAGECHAT_LENGTH];

int ItemDropControl[MAX_ITEMLIST] = {};

char RankName[50][16];
int RankLevel[50];
char RankClasse[50][4];
char RankClass[50][4];

//DROPLIST

int dListItem[170][64];
char dListMobName[170][16];

///////////////////////////////

int ValidGuild = MAX_GUILDZONE; 
int WaterScrollPosition[3][10][2] =
{
	{//N
		{ 1121, 3554 },//LV1
		{ 1085, 3554 },//2
		{ 1049, 3554 },//3
		{ 1049, 3518 },//4
		{ 1049, 3482 },//5
		{ 1085, 3482 },//6
		{ 1121, 3482 },//7
		{ 1121, 3518 },//8
		{ 1085, 3518 },
		{ 1085, 3518 }
	},
	{//M
		{ 1250, 3682 },//LV1
		{ 1214, 3682 },//2
		{ 1178, 3682 },//3
		{ 1178, 3646 },//4
		{ 1178, 3610 },//5
		{ 1214, 3610 },//6
		{ 1250, 3610 },//7
		{ 1250, 3646 },//8
		{ 1214, 3646 },
		{ 1214, 3646 }
	},
	{//A
		{ 1379, 3554 },//LV1
		{ 1340, 3554 },//2
		{ 1305, 3554 },//3
		{ 1305, 3518 },//4
		{ 1305, 3482 },//5
		{ 1341, 3482 },//6
		{ 1377, 3482 },//7
		{ 1377, 3518 },//8
		{ 1343, 3518 },
		{ 1343, 3518 }
	}
};
int PesaNPosStandard[13][2] =
{
	{ 1304, 335 },
	{ 1304, 335 },
	{ 1304, 335 },
	{ 1304, 335 },
	{ 1304, 335 },
	{ 1304, 335 },
	{ 1304, 335 },
	{ 1304, 335 },
	{ 1304, 335 },
	{ 1304, 335 },
	{ 1304, 335 },
	{ 1304, 335 },
	{ 1304, 335 }
};

int PesaMPosStandard[13][2] =
{
	{ 1083, 308 },
	{ 1083, 308 },
	{ 1083, 308 },
	{ 1083, 308 },
	{ 1083, 308 },
	{ 1083, 308 },
	{ 1083, 308 },
	{ 1083, 308 },
	{ 1083, 308 },
	{ 1083, 308 },
	{ 1083, 308 },
	{ 1083, 308 },
	{ 1083, 308 }
};

int PesaAPosStandard[13][2] =
{
	{ 1204, 152 },
	{ 1217, 155 },
	{ 1195, 175 },
	{ 1182, 174 },
	{ 1171, 190 },
	{ 1189, 196 },
	{ 1209, 182 },
	{ 1226, 190 },
	{ 1230, 174 },
	{ 1247, 184 },
	{ 1224, 190 },
	{ 1211, 165 },
	{ 1209, 174 }
};

int CartaPos[4][2] =
{
	{ 786, 3688 },
	{ 843, 3688 },
	{ 843, 3632 },
	{ 786, 3640 }
};

int CTarantulaPos[4][2] =
{	// Tarantula Liberadora
	{ 1754, 3674 },
	{ 1728, 3646 },
	{ 1703, 3635 },
	{ 1752, 3618 }
};

int TarantulaPos[2][2][2] =
{
	{//Tarantula Normal = 1
		{ 1752, 3645 }, // = 2 , 3
		{ 1700, 3646 }
	},
	{//Tarantula Normal
		{ 1683, 3632 },
		{ 1724, 3673 }
	}
};

int PistaPos[7][3][2] =
{
	{//Sala 1 Lich
		{ 3350, 1622 }, //Grupo 1
		{ 3431, 1634 }, //Grupo 2
		{ 0, 0 }  //Grupo 3
	},
	{//Sala 2 Torre
		{ 3362, 1574 }, //Grupo 1
		{ 3385, 1555 }, //Grupo 2
		{ 3414, 1575 }  //Grupo 3
	},
	{//Sala 3 Amon
		{ 3410, 1453 }, //Grupo 1
		{ 3419, 1426 }, //Grupo 2
		{ 3358, 1436 }  //Grupo 3
	},
	{//Sala 4 Sulrang
		{ 3376, 1096 }, //Grupo 1
		{ 3400, 1089 }, //Grupo 2
		{ 3392, 1073 }  //Grupo 3
	},
	{//Sala 5 Labirinto
		{ 3342, 1394 }, //Grupo 1
		{ 3444, 1394 }, //Grupo 2
		{ 3442, 1293 }  //Grupo 3
	},
	{//Sala 6 Balrog
		{ 3421, 1217 }, //Grupo 1
		{ 3426, 1211 }, //Grupo 2
		{ 3424, 1226 }  //Grupo 3
	},
	{//Sala 7 Coelho
		{ 3404, 1517 }, //Grupo 1
		{ 3392, 1479 }, //Grupo 2
		{ 3383, 1501 }  //Grupo 3
	}
};

int PistaBalrogPos[5][2] =
{
	{3421, 1217}, //Sala1
	{3428, 1180}, //Sala2
	{3357, 1186}, //Sala3
	{3393, 1255}, //Sala4
	{3385, 1204} //Sala Boss
};

int PistaBalrogPortalPos[5][5][2] =
{
	//Sala1
	{
		{3428, 1196},
		{0, 0},
		{0, 0},
		{0, 0}
	},

	//Sala2
	{
		{3380, 1176},
		{3380, 1164},
		{0, 0},
		{0, 0}
	},

	//Sala3
	{
		{3360, 1224},
		{3352, 1224},
		{3340, 1224},
		{0, 0}
	},

	//Sala4
	{
		{3400, 1236},
		{3392, 1236},
		{3384, 1236},
		{3376, 1236}
	},

	//Sala5
	{
		{0, 0},
		{0, 0},
		{0, 0},
		{0, 0}
	}
};

int CartaTime = 0;
int CartaSala = 0;

short weapon[32][9];

CPSock BillServerSocket;
char   BillServerAddress[32] = { 0, };
int	   BillServerPort = 0;

HWND  hWndMain;
HMENU hMainMenu;
HFONT hFont = NULL;


std::unique_ptr<std::ofstream> fLogFile;
std::string fLogFile_Dir;

std::unique_ptr<LogControl> g_pChatLog; //

std::unique_ptr<LogControl> g_phackLog;

std::unique_ptr<LogControl> g_pMobdropLog;

std::unique_ptr<LogControl> g_pCompositorLog;

std::unique_ptr<LogControl> g_pItemLog;

std::unique_ptr<LogControl> g_pSystemLog;

std::unique_ptr<LogControl> g_pItradeLog;

FILE *fLogFile1 = NULL;

//FILE *fChatLogFile = NULL;
//FILE *fItemLogFile = NULL;
//FILE* fICompositorLogsFile = NULL;
//FILE* fIMobDropLogLogsFile = NULL;
//FILE* trade_itemLogsFile = NULL;

FILE *fReadDir = NULL;

CPSock DBServerSocket;

unsigned int pAdminIP[MAX_ADMIN] = { 1, };

CNPCGenerator mNPCGen;
CNPCSummon mSummon;

CUser pUser[MAX_USER];
CMob pMob[MAX_MOB];
STRUCT_BLOCKMAC pMac[MAX_MAC];
 
STRUCT_TREASURE g_pTreasure[8];

STRUCT_ITEM LevelItem[4][4][400];

char temp[4096];
char logQuery[256];

CItem pItem[MAX_ITEM];

unsigned int CurrentTime = 0;
unsigned int LastSendTime = 0;


QuizInfo SendQuiz[1000];
char QuizLineCounter;
MSG_Quiz QuizList[50];

MSG_BigQuiz CuboList[50];
char CuboQuizLine;

int BillCounter = 0;

int	g_Week = 0;
int	g_Hour = 0;

int LastLogDay = 0;
int LastChatLogDay = 0;
int LasthackLogDay = 0;
int LastItemLogDay = 0;
int LastSystemLogDay = 0;
int LastCompositorLogsDay = 0;
int trade_itemLogsFileDay = 0;
int fIMobDropLogFileDay = 0;

int GTorrePoints[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
int GTorreGuildID[10];

int GShopItens[30][2];
int GuildPoints[100][2];

int EvItemId[5][4];
int EvItemQt[5][4];

int EvItemId2[5][4];
int EvItemQt2[5][4];

int ConfigReady = 0;

///////////////////////////////////////
//Config for Event
//////////////////////////////////////
int evNotice = 1;
int evStartIndex = 0;
int evEndIndex = 0;
int evCurrentIndex = 0;
int evRate = 0;
int evItem = 0;
int evIndex = 0;
int evOn = 0;
int evDelete = 0;
////////////////////////////////////
// New Server Stats
////////////////////////////////////

int EventStatus;
int DOUBLEMODE;
int AUTODOUBLE;
int GlobalExp;
int GTorreHour;
int GTorreStatus;
int RvRHour;
int RvRStatus;
int RvRBonus;
int BatalhaRealStatus;
int BatalhaRealHour;
int PistaStatus;
int EvolutionStatus;
int PesaStatus;
int PergaStatus;

////////////////////////////////////

int NewbieEventServer = 0;
int CastleServer = 0;

int DUNGEONEVENT = 1;
int DEADPOINT = 1;
int StatSapphire = 30;
 

MSG_BattleReal p_BatalhaReal;


int BRItem = 518;
int BRHour = 17;

int BILLING = 3;
int CHARSELBILL = 0;
int POTIONCOUNT = 10;
int PARTYBONUS = 100;
int GUILDBOARD = 0;

int UserCount = 1;
int SaveCount = 1;
int ItemCount = 100;

int ForceWeather = -1;

int WeekMode = 4;
int ForceWeekMode = -1;
int GuildDay = 0;
int GuildHour = 20;

int NumGuildBattle = 26;
int PotionReady = 0;

int PotionDelay = 100;

int RvRState = 0;
int AltarSta = 0;
//int RvRHour = 0;
//int RvRBonus = 0;

int GTorreState = 0;
//int GTorreHour = 21;
int GTorreGuild = 0;

int NewbieHour = 20;

int ColoStateN = 0;
int ColoHourN = 4; //HORARIO COLISEU N

int ColoStateM = 0;
int ColoHourM = 2;  //horario coliseu M
int WTowerState = 0;
int ColoStateA = 0;
int ColoHourA = 3;  //horario coliseu A

//int BatalhaRealHour = 22; 
int NumServerInGroup = 0;

int LiveTower[3];

int pChallangerMoney[6];

unsigned short g_pGuildWar[65536];
unsigned short g_pGuildAlly[65536];
STRUCT_GUILDINFO GuildInfo[65536];

unsigned short pMobGrid[MAX_GRIDY][MAX_GRIDX];
unsigned short pItemGrid[MAX_GRIDY][MAX_GRIDX];
char pHeightGrid[MAX_GRIDY][MAX_GRIDX];

unsigned char LocalIP[4] = { 0, };

char FailAccount[16][16];

CPSock ListenSocket;

char DBServerAddress[32] = { 0, };
int DBServerPort = 0;

int isDropItem = 0;
int isHardCore = 0;
int maxNightmare = 3;
int maxPortaoInfernal = 3;
int CurrentWeather = 0;
int TESTSERVER = 0;
int LOCALSERVER = 0;

int TransperCharacter = 0;

unsigned int SecCounter = 0;
unsigned int MinCounter = 0;

int GuildImpostoID[MAX_GUILDZONE];

int BrTime = 0;
int BrState = 0;
int BrMod = 0;
int BrGrid = 0;
int CastleState = 0;
int ColoLevelN = 0;
int ColoLevelM = 0;
int ColoLevelA = 0;
int KefraLive = 1;
int EspelhoLive = 0;
int RandBoss = 0;
int Lich_1 = 0;
int Lich_2 = 0;
int Lich_3 = 0;
int Lich_4 = 0;
char KefraKiller[32] = "LOCALSERVER";

int g_dLevel = 0;
int g_dLevel1 = 0;
int g_dLevel2 = 0;

int Kingdom1Clear = 0;
int Kingdom2Clear = 0;

int GuildNameInitialized = 0;

///////////////////////////////////////
//Config for Duel: 1:1 5:5 10:10 All:All
//////////////////////////////////////
char nRanking1[32] = { "unnamed" };
char nRanking2[32] = { "unnamed" };
char nTitle1[32] = { "unnamed" };
char nTitle2[32] = { "unnamed" };

int RankingProgress = 0;
int Ranking1 = 0;
int Ranking2 = 0;
int lTitle1 = 0;
int lTitle2 = 0;
int RankingTime = 0;

int Ranking1X = 147;
int Ranking1Y = 4044;
int Ranking2X = 189;
int Ranking2Y = 4044;

int cRanking1X = 2564;
int cRanking1Y = 1688;
int cRanking2X = 2579;
int cRanking2Y = 1714;

int kRanking1X = 142;
int kRanking1Y = 4007;
int kRanking2X = 195;
int kRanking2Y = 4082;

int TaxChanged[MAX_GUILDZONE] = { 0, 0, 0, 0, 0 };

HDC hDC;

//////////////////////////////////////

int WaterClear1[3][10] = { 0, 0, 0, 0, 0, };
int PartyPesa[3] = { 0, 0, 0 };
int PartyPortao[3] = { 0, 0, 0 };

int RvRBluePoint = 0;
int RvRRedPoint = 0;

STRUCT_PISTA Pista[7] = { 0, 0, 0, 0, 0, };

STRUCT_PVP Desafio[1] = { 0 };

STRUCT_QUESTS g_quests;

STRUCT_MERC pMobMerc[MAX_MOB_MERC];

int PistaRune[7][10] =
{
	// Lich
	{
		5110, 5112, 5115, 5113, 5111, 0, 0, 0, 0, 0
	},

	// Torre
	{
		5114, 5113, 5117, 5111, 5115, 5112, 0, 0, 0, 0
	},

	// Amon
	{
		5118, 5121, 5122, 5116, 5130, 5119, 0, 0, 0, 0
	},

	// Sulrang
	{
		5122, 5126, 5121, 5116, 5119, 0, 0, 0, 0, 0
	},

	// Labirinto
	{
		5125, 5126, 5124, 5127, 0, 0, 0, 0, 0, 0
	},

	// Balrog
	{
		5120, 5131, 5118, 5119, 5123, 5132, 5121, 0, 0, 0
	},

	//Coelho
	{
		5130, 5131, 5119, 5133, 5120, 5123, 5132, 5129, 5128, 0
	}
};

std::vector<TMP_BLOCKIP> g_pBlockIP;
//////////////////////////////////////
extern STRUCT_GUILDZONE g_pGuildZone[MAX_GUILDZONE];

#pragma endregion

void LimiteBsWepom(int conn)
{
	if (conn <= 0 || conn >= MAX_USER)
		return;

	if (pUser[conn].Mode != USER_PLAY)
		return;

	if (pUser[conn].cSock.Sock == 0)
		return;

	int i = 0;
	int iss = 0;

	int MaxMG = 28;
	int MaxDM = 63;
	int MaxAc = 30;
	int MaxDMSet = 30;
	int MaxMGSet = 12;	

	for (int i = 0; i < 64; i++) {
		int Pos = BASE_GetItemAbility(&pMob[conn].MOB.Carry[i], EF_POS);

		if (Pos == 2 || Pos == 4 || Pos == 8 || Pos == 16 || Pos == 32) {			
			for (int z = 0; z < 3; z++) {
				if (pMob[conn].MOB.Carry[i].stEffect[z].cEffect == EF_MAGIC && pMob[conn].MOB.Carry[i].stEffect[z].cValue > MaxMGSet) {
					pMob[conn].MOB.Carry[i].stEffect[z].cValue = MaxMGSet;
					SendItem(conn, ITEM_PLACE_CARRY, i, &pMob[conn].MOB.Carry[i]);
				}
				if (pMob[conn].MOB.Carry[i].stEffect[z].cEffect == EF_MAGICADD) {
					int max = pMob[conn].MOB.Carry[i].stEffect[z].cValue;
					pMob[conn].MOB.Carry[i].stEffect[z].cEffect = 0;
					pMob[conn].MOB.Carry[i].stEffect[z].cValue = 0;

					for (int y = 0; y < 3; y++) {
						if (pMob[conn].MOB.Carry[i].stEffect[y].cEffect == EF_MAGIC) {
							pMob[conn].MOB.Carry[i].stEffect[y].cValue += max;
						}
					}
					SendItem(conn, ITEM_PLACE_CARRY, i, &pMob[conn].MOB.Carry[i]);
				}
				if (pMob[conn].MOB.Carry[i].stEffect[z].cEffect == EF_DAMAGE && pMob[conn].MOB.Carry[i].stEffect[z].cValue > MaxDMSet) {
					pMob[conn].MOB.Carry[i].stEffect[z].cValue = MaxDMSet;
					SendItem(conn, ITEM_PLACE_CARRY, i, &pMob[conn].MOB.Carry[i]);
				}
				if (pMob[conn].MOB.Carry[i].stEffect[z].cEffect == EF_DAMAGE2 && Pos != 32) {
					int max = pMob[conn].MOB.Carry[i].stEffect[z].cValue;
					pMob[conn].MOB.Carry[i].stEffect[z].cEffect = 0;
					pMob[conn].MOB.Carry[i].stEffect[z].cValue = 0;

					for (int y = 0; y < 3; y++) {
						if (pMob[conn].MOB.Carry[i].stEffect[y].cEffect == EF_DAMAGE) {
							pMob[conn].MOB.Carry[i].stEffect[y].cValue += max;
						}
					}
					SendItem(conn, ITEM_PLACE_CARRY, i, &pMob[conn].MOB.Carry[i]);
				}
			}
		}
		if (Pos == 64 || Pos == 192) {
			for (int z = 0; z < 3; z++) {
				if (pMob[conn].MOB.Carry[i].stEffect[z].cEffect == EF_MAGIC && pMob[conn].MOB.Carry[i].stEffect[z].cValue > MaxMG) {
					pMob[conn].MOB.Carry[i].stEffect[z].cValue = MaxMG;
					SendItem(conn, ITEM_PLACE_CARRY, i, &pMob[conn].MOB.Carry[i]);
				}
				if (pMob[conn].MOB.Carry[i].stEffect[z].cEffect == EF_MAGICADD) {
					int max = pMob[conn].MOB.Carry[i].stEffect[z].cValue;
					pMob[conn].MOB.Carry[i].stEffect[z].cEffect = 0;
					pMob[conn].MOB.Carry[i].stEffect[z].cValue = 0;

					for (int y = 0; y < 3; y++) {
						if (pMob[conn].MOB.Carry[i].stEffect[y].cEffect == EF_MAGIC) {
							pMob[conn].MOB.Carry[i].stEffect[y].cValue += max;
						}
					}
					SendItem(conn, ITEM_PLACE_CARRY, i, &pMob[conn].MOB.Carry[i]);
				}	
				if (pMob[conn].MOB.Carry[i].stEffect[z].cEffect == EF_DAMAGE && pMob[conn].MOB.Carry[i].stEffect[z].cValue > MaxDM) {
					pMob[conn].MOB.Carry[i].stEffect[z].cValue = MaxDM;
					SendItem(conn, ITEM_PLACE_CARRY, i, &pMob[conn].MOB.Carry[i]);
				}
				if (pMob[conn].MOB.Carry[i].stEffect[z].cEffect == EF_DAMAGE2) {
					int max = pMob[conn].MOB.Carry[i].stEffect[z].cValue;
					pMob[conn].MOB.Carry[i].stEffect[z].cEffect = 0;
					pMob[conn].MOB.Carry[i].stEffect[z].cValue = 0;

					for (int y = 0; y < 3; y++) {
						if (pMob[conn].MOB.Carry[i].stEffect[y].cEffect == EF_DAMAGE) {
							pMob[conn].MOB.Carry[i].stEffect[y].cValue += max;
						}
					}
					SendItem(conn, ITEM_PLACE_CARRY, i, &pMob[conn].MOB.Carry[i]);
				}
			}
		}
	}
	for (int i = 0; i < 16; i++) {
		int Pos = BASE_GetItemAbility(&pMob[conn].MOB.Equip[i], EF_POS);

		if (Pos == 2 || Pos == 4 || Pos == 8 || Pos == 16 || Pos == 32) {
			for (int z = 0; z < 3; z++) {
				if (pMob[conn].MOB.Equip[i].stEffect[z].cEffect == EF_MAGIC && pMob[conn].MOB.Equip[i].stEffect[z].cValue > MaxMGSet) {
					pMob[conn].MOB.Equip[i].stEffect[z].cValue = MaxMGSet;
					SendItem(conn, ITEM_PLACE_EQUIP, i, &pMob[conn].MOB.Equip[i]);
				}
				if (pMob[conn].MOB.Equip[i].stEffect[z].cEffect == EF_MAGICADD) {
					int max = pMob[conn].MOB.Equip[i].stEffect[z].cValue;
					pMob[conn].MOB.Equip[i].stEffect[z].cEffect = 0;
					pMob[conn].MOB.Equip[i].stEffect[z].cValue = 0;

					for (int y = 0; y < 3; y++) {
						if (pMob[conn].MOB.Equip[i].stEffect[y].cEffect == EF_MAGIC) {
							pMob[conn].MOB.Equip[i].stEffect[y].cValue += max;
						}
					}
					SendItem(conn, ITEM_PLACE_EQUIP, i, &pMob[conn].MOB.Equip[i]);
				}
				if (pMob[conn].MOB.Equip[i].stEffect[z].cEffect == EF_DAMAGE && pMob[conn].MOB.Equip[i].stEffect[z].cValue > MaxDMSet) {
					pMob[conn].MOB.Equip[i].stEffect[z].cValue = MaxDMSet;
					SendItem(conn, ITEM_PLACE_EQUIP, i, &pMob[conn].MOB.Equip[i]);
				}
				if (pMob[conn].MOB.Equip[i].stEffect[z].cEffect == EF_DAMAGE2 && Pos != 32) {
					int max = pMob[conn].MOB.Equip[i].stEffect[z].cValue;
					pMob[conn].MOB.Equip[i].stEffect[z].cEffect = 0;
					pMob[conn].MOB.Equip[i].stEffect[z].cValue = 0;

					for (int y = 0; y < 3; y++) {
						if (pMob[conn].MOB.Equip[i].stEffect[y].cEffect == EF_DAMAGE) {
							pMob[conn].MOB.Equip[i].stEffect[y].cValue += max;
						}
					}
					SendItem(conn, ITEM_PLACE_EQUIP, i, &pMob[conn].MOB.Equip[i]);
				}
			}
		}
		if (Pos == 64 || Pos == 192) {
			for (int z = 0; z < 3; z++) {
				if (pMob[conn].MOB.Equip[i].stEffect[z].cEffect == EF_MAGIC && pMob[conn].MOB.Equip[i].stEffect[z].cValue > MaxMG) {
					pMob[conn].MOB.Equip[i].stEffect[z].cValue = MaxMG;
					SendItem(conn, ITEM_PLACE_EQUIP, i, &pMob[conn].MOB.Equip[i]);
				}
				if (pMob[conn].MOB.Equip[i].stEffect[z].cEffect == EF_MAGICADD) {
					int max = pMob[conn].MOB.Equip[i].stEffect[z].cValue;
					pMob[conn].MOB.Equip[i].stEffect[z].cEffect = 0;
					pMob[conn].MOB.Equip[i].stEffect[z].cValue = 0;

					for (int y = 0; y < 3; y++) {
						if (pMob[conn].MOB.Equip[i].stEffect[y].cEffect == EF_MAGIC) {
							pMob[conn].MOB.Equip[i].stEffect[y].cValue += max;
						}
					}
					SendItem(conn, ITEM_PLACE_EQUIP, i, &pMob[conn].MOB.Equip[i]);
				}
				if (pMob[conn].MOB.Equip[i].stEffect[z].cEffect == EF_DAMAGE && pMob[conn].MOB.Equip[i].stEffect[z].cValue > MaxDM) {
					pMob[conn].MOB.Equip[i].stEffect[z].cValue = MaxDM;
					SendItem(conn, ITEM_PLACE_EQUIP, i, &pMob[conn].MOB.Equip[i]);
				}
				if (pMob[conn].MOB.Equip[i].stEffect[z].cEffect == EF_DAMAGE2) {
					int max = pMob[conn].MOB.Equip[i].stEffect[z].cValue;
					pMob[conn].MOB.Equip[i].stEffect[z].cEffect = 0;
					pMob[conn].MOB.Equip[i].stEffect[z].cValue = 0;

					for (int y = 0; y < 3; y++) {
						if (pMob[conn].MOB.Equip[i].stEffect[y].cEffect == EF_DAMAGE) {
							pMob[conn].MOB.Equip[i].stEffect[y].cValue += max;
						}
					}
					SendItem(conn, ITEM_PLACE_EQUIP, i, &pMob[conn].MOB.Equip[i]);
				}
			}
		}
	}
}
void ClearCrown(int conn)
{
	if (pUser[conn].Mode != USER_PLAY)
		return;

	int GLevel = pMob[conn].MOB.GuildLevel;
	int Guild = pMob[conn].MOB.Guild;

	int IsCrownGuild = FALSE;

	int i = 0;

	for (i = 0; i < MAX_SERVER; i++)
	{
		int CrownGuild = ChargedGuildList[i][4];

		if ((Guild != 0) && (CrownGuild != 0) && (CrownGuild == Guild && GLevel == 9))
		{
			IsCrownGuild = TRUE;

			break;
		}
	}

	if (IsCrownGuild == 1)
	{
		int HaveCrow = 0;
		int HaveDrag = 0;

		for (i = 0; i < MAX_EQUIP; i++)
		{
			if (pMob[conn].MOB.Equip[i].sIndex == 747)
				HaveCrow = 1;

			if (pMob[conn].MOB.Equip[i].sIndex != 3993 && pMob[conn].MOB.Equip[i].sIndex != 3994) // 747 = Crown on itemlist
				continue;

			HaveDrag = 1;

			if (pMob[conn].MOB.Equip[i].sIndex == 3993 && pMob[conn].MOB.Clan == 7)
			{
				sprintf_s(temp, "etc,crown guild:%d level:%d charge:%d name:%s", Guild, GLevel, ChargedGuildList[ServerIndex][4], pMob[conn].MOB.MobName);
				SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);

				pMob[conn].MOB.Equip[i].sIndex = 3994;

				SendItem(conn, ITEM_PLACE_EQUIP, i, &pMob[conn].MOB.Equip[i]);
			}
			else if (pMob[conn].MOB.Equip[i].sIndex == 3994 && pMob[conn].MOB.Clan == 8)
			{
				sprintf_s(temp, "etc,crown guild:%d level:%d charge:%d name:%s", Guild, GLevel, ChargedGuildList[ServerIndex][4], pMob[conn].MOB.MobName);
				SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);

				pMob[conn].MOB.Equip[i].sIndex = 3993;

				SendItem(conn, ITEM_PLACE_EQUIP, i, &pMob[conn].MOB.Equip[i]);
			}
		}

		for (i = 0; i < MAX_CARRY; i++)
		{
			if (pMob[conn].MOB.Carry[i].sIndex == 747)
				HaveCrow = 1;

			if (pMob[conn].MOB.Carry[i].sIndex != 3993 && pMob[conn].MOB.Carry[i].sIndex != 3994) // 747 = Crown on itemlist
				continue;

			HaveDrag = 1;

			if (pMob[conn].MOB.Carry[i].sIndex == 3993 && pMob[conn].MOB.Clan == 7)
			{
				sprintf_s(temp, "etc,crown guild:%d level:%d charge:%d name:%s", Guild, GLevel, ChargedGuildList[ServerIndex][4], pMob[conn].MOB.MobName);
				SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);

				pMob[conn].MOB.Carry[i].sIndex = 3994;

				SendItem(conn, ITEM_PLACE_CARRY, i, &pMob[conn].MOB.Carry[i]);
			}

			if (pMob[conn].MOB.Carry[i].sIndex == 3994 && pMob[conn].MOB.Clan == 8)
			{
				sprintf_s(temp, "etc,crown guild:%d level:%d charge:%d name:%s", Guild, GLevel, ChargedGuildList[ServerIndex][4], pMob[conn].MOB.MobName);
				SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);

				pMob[conn].MOB.Carry[i].sIndex = 3993;

				SendItem(conn, ITEM_PLACE_CARRY, i, &pMob[conn].MOB.Carry[i]);
			}
		}

		for (i = 0; i < MAX_CARGO; i++)
		{
			if (pUser[conn].Cargo[i].sIndex == 747)
				HaveCrow = 1;

			if (pUser[conn].Cargo[i].sIndex != 3993 && pUser[conn].Cargo[i].sIndex != 3994) // 747 = Crown on itemlist
				continue;

			HaveDrag = 1;

			if (pUser[conn].Cargo[i].sIndex == 3993 && pMob[conn].MOB.Clan == 7)
			{
				sprintf_s(temp, "etc,crown guild:%d level:%d charge:%d name:%s", Guild, GLevel, ChargedGuildList[ServerIndex][4], pMob[conn].MOB.MobName);
				SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);

				pUser[conn].Cargo[i].sIndex = 3994;

				SendItem(conn, ITEM_PLACE_CARGO, i, &pUser[conn].Cargo[i]);
			}
			else if (pUser[conn].Cargo[i].sIndex == 3994 && pMob[conn].MOB.Clan == 8)
			{
				sprintf_s(temp, "etc,crown guild:%d level:%d charge:%d name:%s", Guild, GLevel, ChargedGuildList[ServerIndex][4], pMob[conn].MOB.MobName);
				SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);

				pUser[conn].Cargo[i].sIndex = 3993;

				SendItem(conn, ITEM_PLACE_CARGO, i, &pUser[conn].Cargo[i]);
			}
		}

		if (HaveCrow == 0)
		{
			STRUCT_ITEM Item;
			memset(&Item, 0, sizeof(STRUCT_ITEM));

			Item.sIndex = 747;
			Item.stEffect[0].cEffect = 43;
			Item.stEffect[0].cValue = 9;

			PutItem(conn, &Item);
		}

		if (HaveDrag == 0)
		{
			STRUCT_ITEM Item;
			memset(&Item, 0, sizeof(STRUCT_ITEM));

			if (pMob[conn].MOB.Clan == 8)
				Item.sIndex = 3993;

			else if (pMob[conn].MOB.Clan == 7)
				Item.sIndex = 3994;


			PutItem(conn, &Item);
		}

		return;
	}

	for (i = 0; i < MAX_EQUIP; i++)
	{
		if (pMob[conn].MOB.Equip[i].sIndex != 747 && pMob[conn].MOB.Equip[i].sIndex != 3993 && pMob[conn].MOB.Equip[i].sIndex != 3994) // 747 = Crown on itemlist
			continue;

		sprintf_s(temp, "etc,crown guild:%d level:%d charge:%d name:%s", Guild, GLevel, ChargedGuildList[ServerIndex][4], pMob[conn].MOB.MobName);
		SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);

		memset(&pMob[conn].MOB.Equip[i], 0, sizeof(STRUCT_ITEM));

		SendItem(conn, ITEM_PLACE_EQUIP, i, &pMob[conn].MOB.Equip[i]);
	}

	for (i = 0; i < MAX_CARRY; i++)
	{
		if (pMob[conn].MOB.Carry[i].sIndex != 747 && pMob[conn].MOB.Carry[i].sIndex != 3993 && pMob[conn].MOB.Carry[i].sIndex != 3994) // 747 = Crown on itemlist
			continue;

		sprintf_s(temp, "etc,crown guild:%d level:%d charge:%d name:%s", Guild, GLevel, ChargedGuildList[ServerIndex][4], pMob[conn].MOB.MobName);
		SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);

		memset(&pMob[conn].MOB.Carry[i], 0, sizeof(STRUCT_ITEM));

		SendItem(conn, ITEM_PLACE_CARRY, i, &pMob[conn].MOB.Carry[i]);
	}

	for (i = 0; i < MAX_CARGO; i++)
	{
		if (pUser[conn].Cargo[i].sIndex != 747 && pUser[conn].Cargo[i].sIndex != 3993 && pUser[conn].Cargo[i].sIndex != 3994) // 747 = Crown on itemlist
			continue;

		sprintf_s(temp, "etc,crown guild:%d level:%d charge:%d name:%s", Guild, GLevel, ChargedGuildList[ServerIndex][4], pMob[conn].MOB.MobName);
		SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);

		memset(&pUser[conn].Cargo[i], 0, sizeof(STRUCT_ITEM));

		SendItem(conn, ITEM_PLACE_CARGO, i, &pUser[conn].Cargo[i]);
	}
}

BOOL AddCrackError(int conn, int val, int Type)
{
	if (Type != 3 && Type != 8 && Type != 15)
	{
		//sprintf(temp, "cra point: %d  type: %d", val, Type);
		//Log(temp, pUser[conn].AccountName, pUser[conn].IP);
	}

	pUser[conn].NumError = pUser[conn].NumError + val;

	if (pUser[conn].NumError >= 2000000000)
	{
		 
		SendMsgExp(conn, g_pMessageStringTable[_NN_Bad_Network_Packets], TNColor::Default, false);
		CharLogOut(conn);

		//sprintf(temp, "cra char logout type: %d", Type);
		//Log(temp, pUser[conn].AccountName, pUser[conn].IP);

		return TRUE;
	}

	return FALSE;
}

BOOL PutItemArea(STRUCT_ITEM *item, int x1, int y1, int x2, int y2)
{
	for (int i = 0; i < MAX_USER; i++)
	{
		if (i <= 0 || i >= MAX_USER)
			return FALSE;

		if (pUser[i].Mode != USER_PLAY)
			return FALSE;

		int pos = 0;

		if (pMob[i].TargetX >= x1 && pMob[i].TargetX <= x2 && pMob[i].TargetY >= y1 && pMob[i].TargetY <= y2)
		{
			for (pos = 0; pos < pMob[i].MaxCarry && pos < MAX_CARRY; pos++)
			{
				if (pMob[i].MOB.Carry[pos].sIndex == 0)
					break;
			}

			if (pos >= 0 && pos < pMob[i].MaxCarry && pos < MAX_CARRY)
			{
				memcpy(&pMob[i].MOB.Carry[pos], item, sizeof(STRUCT_ITEM));

				SendItem(i, ITEM_PLACE_CARRY, pos, &pMob[i].MOB.Carry[pos]);
			}
			else
			{ 
				SendMsgExp(i, g_pMessageStringTable[_NN_You_Have_No_Space_To_Trade], TNColor::Red, false);
				return FALSE;
			}
		}
	}
	return TRUE;
}

BOOL PutItem(int conn, STRUCT_ITEM *item)
{
	if (conn <= 0 || conn >= MAX_USER)
		return FALSE;

	if (pUser[conn].Mode != USER_PLAY)
		return FALSE;

	int pos = 0;

	for (pos = 0; pos < pMob[conn].MaxCarry && pos < MAX_CARRY; pos++)
	{
		if (pMob[conn].MOB.Carry[pos].sIndex == 0)
			break;
	}

	if (pos >= 0 && pos < pMob[conn].MaxCarry && pos < MAX_CARRY)
	{
		memcpy(&pMob[conn].MOB.Carry[pos], item, sizeof(STRUCT_ITEM));

		SendItem(conn, ITEM_PLACE_CARRY, pos, &pMob[conn].MOB.Carry[pos]);
	}
	else
	{ 
		SendMsgExp(conn, g_pMessageStringTable[_NN_You_Have_No_Space_To_Trade], TNColor::Red, false);
		return FALSE;
	}
	return TRUE;
}

void GuildZoneReport(void)
{
	MSG_GuildZoneReport sm;
	memset(&sm, 0, sizeof(MSG_GuildZoneReport));

	sm.Type = _MSG_GuildZoneReport;
	sm.Size = sizeof(sm);
	sm.ID = ServerIndex;

	for (int i = 0; i < MAX_GUILDZONE; i++)
	{
		sm.Guild[i] = g_pGuildZone[i].ChargeGuild;
	}

	DBServerSocket.SendOneMessage((char*)&sm, sizeof(sm));
}

HFONT__ *GetAFont()
{
	return 0;
}

void ReadConfig(void) // TODO : EVERYTHING
{
	FILE *fp = NULL;
	fp = fopen("gameconfig.txt", "rt");

	if (fp == NULL)
	{
		MessageBox(hWndMain, "no gameconfig.txt, server will generate default setting.", "Error", MB_OK | MB_SYSTEMMODAL);

		ConfigReady = 1;

		DrawConfig(TRUE);

		return;
	}

	char tmp[512];
	char parm[16][32];
	int  value[26];

	fgets(tmp, 511, fp);

	if (strcmp(tmp, "Drop Item Event Settings:\n"))
	{
		MessageBox(hWndMain, "not game-server generated gameconfig.txt - Line1", "Error", MB_OK | MB_SYSTEMMODAL);

		fclose(fp);

		return;
	}

	for (int i = 0; i < 16; i++)
	{
		value[i] = -1;

		memset(parm[i], 0, 32);
	}

	fgets(tmp, 511, fp);

	sscanf(tmp, "%s %d %s %d %s %d %s %d %s %d %s %d %d %d %d", parm[0], &value[0], parm[1], &value[1], parm[2], &value[2], parm[3], &value[3], parm[4], &value[4], parm[5], &value[5], &value[6], &value[7], &value[8]);

	if (strcmp(parm[0], "evindex") || strcmp(parm[1], "evdelete") || strcmp(parm[2], "evon") || strcmp(parm[3], "evitem") || strcmp(parm[4], "evrate") || strcmp(parm[5], "evstart"))
	{
		MessageBox(hWndMain, "not game-server generated gameconfig.txt - Line2", "Error", MB_OK | MB_SYSTEMMODAL);

		fclose(fp);

		return;
	}

	if (value[0] == -1 || value[1] == -1 || value[2] == -1 || value[3] == -1 || value[4] == -1 || value[5] == -1 || value[6] == -1 || value[7] == -1)
	{
		MessageBox(hWndMain, "not game-server generated gameconfig.txt - Line2", "Error", MB_OK | MB_SYSTEMMODAL);

		fclose(fp);

		return;
	}

	evIndex = value[0];
	evDelete = value[1];
	evOn = value[2];
	evItem = value[3];
	evRate = value[4];
	evStartIndex = value[5];
	evCurrentIndex = value[6];
	evEndIndex = value[7];
	evNotice = value[8];

	fgets(tmp, 511, fp);

	if (strcmp(tmp, "Etc Event Settings:\n"))
	{
		MessageBox(hWndMain, "not game server generated gameconfig.txt - Line3", "Error", MB_OK | MB_SYSTEMMODAL);

		fclose(fp);

		return;
	}

	for (int i = 0; i < 16; i++)
	{
		value[i] = -1;

		memset(parm[i], 0, 32);
	}

	fgets(tmp, 511, fp);

	sscanf(tmp, "%s %d %s %d %s %d %s %d %s %d", parm[0], &value[0], parm[1], &value[1], parm[2], &value[2], parm[3], &value[3], parm[4], &value[4]);

	if (strcmp(parm[0], "double") || strcmp(parm[1], "deadpoint") || strcmp(parm[2], "dungeonevent") || strcmp(parm[3], "statsapphire"))
	{
		MessageBox(hWndMain, "not game-server generated gameconfig.txt - Line4", "Error", MB_OK | MB_SYSTEMMODAL);

		fclose(fp);

		return;
	}

	if (value[0] == -1 || value[1] == -1 || value[2] == -1 || value[3] == -1)
	{
		MessageBox(hWndMain, "not game-server generated gameconfig.txt - Line4", "Error", MB_OK | MB_SYSTEMMODAL);

		fclose(fp);

		return;
	}

	DOUBLEMODE = value[0];
	DUNGEONEVENT = value[1];
	DEADPOINT = value[2];
	StatSapphire = value[3];
	BRItem = value[4];

	fgets(tmp, 511, fp);

	if (strcmp(tmp, "Billing Settings:\n"))
	{
		MessageBox(hWndMain, "not game server generated gameconfig.txt - Line5", "Error", MB_OK | MB_SYSTEMMODAL);

		fclose(fp);

		return;
	}

	for (int i = 0; i < 16; i++)
	{
		value[i] = -1;

		memset(parm[i], 0, 32);
	}

	fgets(tmp, 511, fp);

	sscanf(tmp, "%s %d %s %d %s %d %s %d %s %d %s %d", parm[0], &value[0], parm[1], &value[1], parm[2], &value[2], parm[3], &value[3], parm[4], &value[4], parm[5], &value[5]);

	if (strcmp(parm[0], "billmode") || strcmp(parm[1], "freeexp"))
	{
		MessageBox(hWndMain, "not game-server generated gameconfig.txt - Line6", "Error", MB_OK | MB_SYSTEMMODAL);

		fclose(fp);

		return;
	}

	if (value[0] == -1 || value[1] == -1)
	{
		MessageBox(hWndMain, "not game-server generated gameconfig.txt - Line6", "Error", MB_OK | MB_SYSTEMMODAL);

		fclose(fp);

		return;
	}

	BILLING = value[0];
	FREEEXP = value[1];
	CHARSELBILL = value[2];
	POTIONCOUNT = value[3];
	PARTYBONUS = value[4];
	GUILDBOARD = value[5];

	if (PARTYBONUS < 50 || PARTYBONUS > 200)
		PARTYBONUS = 100;

	fgets(tmp, 511, fp);

	if (strcmp(tmp, "Item Drop Bonus Settings:\n"))
	{
		MessageBox(hWndMain, "not game server generated gameconfig.txt - Line7", "Error", MB_OK | MB_SYSTEMMODAL);

		return;
	}

	fgets(tmp, 511, fp);

	sscanf(tmp, "%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d", &value[0], &value[1], &value[2], &value[3], &value[4], &value[5], &value[6], &value[7], &value[8], &value[9], &value[10], &value[11], &value[12], &value[13], &value[14], &value[15]);

	for (int k = 0; k < 16; k++)
	{
		if (value[k] < 0 || value[k] > 9999)
		{
			MessageBox(hWndMain, "not game-server generated gameconfig.txt - Line8", "Error", MB_OK | MB_SYSTEMMODAL);

			fclose(fp);

			return;
		}

		g_pDropBonus[k] = value[k];
		value[k] = -1;
	}

	fgets(tmp, 511, fp);

	sscanf(tmp, "%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d", &value[0], &value[1], &value[2], &value[3], &value[4], &value[5], &value[6], &value[7], &value[8], &value[9], &value[10], &value[11], &value[12], &value[13], &value[14], &value[15]);

	for (int k = 0; k < 16; k++)
	{
		if (value[k] < 0 || value[k] > 9999)
		{
			MessageBox(hWndMain, "not game-server generated gameconfig.txt - Line9", "Error", MB_OK | MB_SYSTEMMODAL);

			fclose(fp);

			return;

		}

		g_pDropBonus[k + 16] = value[k];

		value[k] = -1;
	}

	fgets(tmp, 511, fp);

	sscanf(tmp, "%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d", &value[0], &value[1], &value[2], &value[3], &value[4], &value[5], &value[6], &value[7], &value[8], &value[9], &value[10], &value[11], &value[12], &value[13], &value[14], &value[15]);

	for (int k = 0; k < 16; k++)
	{
		if (value[k] < 0 || value[k] > 9999)
		{
			MessageBox(hWndMain, "not game-server generated gameconfig.txt - Line10", "Error", MB_OK | MB_SYSTEMMODAL);

			fclose(fp);

			return;
		}

		g_pDropBonus[k + 32] = value[k];

		value[k] = -1;
	}

	fgets(tmp, 511, fp);

	sscanf(tmp, "%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d", &value[0], &value[1], &value[2], &value[3], &value[4], &value[5], &value[6], &value[7], &value[8], &value[9], &value[10], &value[11], &value[12], &value[13], &value[14], &value[15]);

	for (int k = 0; k < 16; k++)
	{
		if (value[k] < 0 || value[k] > 9999)
		{
			MessageBox(hWndMain, "not game-server generated gameconfig.txt - Line11", "Error", MB_OK | MB_SYSTEMMODAL);

			fclose(fp);

			return;
		}

		g_pDropBonus[k + 48] = value[k];

		value[k] = -1;
	}

	fgets(tmp, 511, fp);

	if (strcmp(tmp, "Treasure Settings:\n"))
	{
		MessageBox(hWndMain, "not game server generated gameconfig.txt - Line12", "Error", MB_OK | MB_SYSTEMMODAL);

		fclose(fp);

		return;
	}

	for (int k = 0; k < 8; k++)
	{
		STRUCT_TREASURE *t = &g_pTreasure[k];

		memset(t, 0, sizeof(*t));

		for (int i = 0; i < 26; i++)
			value[i] = -1;

		fgets(tmp, 511, fp);

		sscanf(tmp, "%d  %d %d %d %d %d  %d %d %d %d %d  %d %d %d %d %d  %d %d %d %d %d  %d %d %d %d %d",
			&value[0], &value[1], &value[2], &value[3], &value[4], &value[5], &value[6], &value[7], &value[8], &value[9],
			&value[10], &value[11], &value[12], &value[13], &value[14], &value[15], &value[16], &value[17], &value[18], &value[19],
			&value[20], &value[21], &value[22], &value[23], &value[24], &value[25]);

		t->Source = value[0];

		for (int i = 0; i < 5; i++)
		{
			STRUCT_ITEM *it = &t->Target[i];

			it->sIndex = value[1 + i * 5];
			it->stEffect[0].cEffect = value[2 + i * 5];
			it->stEffect[0].cValue = value[3 + i * 5];
			it->stEffect[1].cEffect = value[4 + i * 5];
			it->stEffect[1].cValue = value[5 + i * 5];

		}

		fgets(tmp, 511, fp);

		sscanf(tmp, "%d %d %d %d %d", &value[0], &value[1], &value[2], &value[3], &value[4]);

		for (int i = 0; i < 5; i++)
			t->Rate[i] = value[i];
	}

	fgets(tmp, 511, fp);

	if (strcmp(tmp, "Etc Settings:\n"))
	{
		MessageBox(hWndMain, "not game server generated gameconfig.txt - Line13", "Error", MB_OK | MB_SYSTEMMODAL);

		fclose(fp);

		return;
	}

	for (int i = 0; i < 16; i++)
	{
		value[i] = -1;

		memset(parm[i], 0, 32);
	}

	fgets(tmp, 511, fp);

	sscanf(tmp, "%s %3d %s %3d %s %3d %s %3d %s %3d %s %3d %s %3d %s %3d %s %3d", parm[0], &value[0], parm[1], &value[1], parm[2], &value[2], parm[3], &value[3], parm[4], &value[4], parm[5], &value[5], parm[6], &value[6], parm[7], &value[7], parm[8], &value[8]);

	if (strcmp(parm[0], "partydif") || strcmp(parm[1], "kefrastatus") || strcmp(parm[2], "GTorreHour") || strcmp(parm[3], "RVRHour") || strcmp(parm[4], "DropItem") || strcmp(parm[5], "BRHour") || strcmp(parm[6], "maxNightmare") || strcmp(parm[7], "PotionDelay") || strcmp(parm[8], "HardCore"))
	{
		MessageBox(hWndMain, "not game-server generated gameconfig.txt - Line13", "Error", MB_OK | MB_SYSTEMMODAL);

		fclose(fp);

		return;
	}

	if (value[0] == -1 || value[1] == -1 || value[2] == -1 || value[3] == -1 || value[4] == -1 || value[5] == -1 || value[6] == -1 || value[7] == -1 || value[8] == -1)
	{
		MessageBox(hWndMain, "not game-server generated gameconfig.txt - Line13", "Error", MB_OK | MB_SYSTEMMODAL);

		fclose(fp);

		return;
	}

	PARTY_DIF = value[0];
	KefraLive = value[1];
	GTorreHour = value[2];
	RvRHour = value[3];
	isDropItem = value[4];
	BRHour = value[5];
	maxNightmare = value[6];
	PotionDelay = value[7];
	isHardCore = value[8];

	fclose(fp);
}

void BASE_ReadQuestDiaria()
{
	FILE* fp = fopen("QuestDiaria.txt", "rb");

	if (fp == NULL)
	{
		MessageBoxA(NULL, "Não foi possível carregar o arquivo 'QuestDiaria.txt'", "TMSRV", MB_OK);

		return;
	}

	int count = 0;

	while (fscanf(fp, "%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d",
		&QuestDiaria[count].IndexQuest,
		&QuestDiaria[count].Nivel,
		&QuestDiaria[count].IdMob1, &QuestDiaria[count].QtdMob1,
		&QuestDiaria[count].IdMob2, &QuestDiaria[count].QtdMob2,
		&QuestDiaria[count].IdMob3, &QuestDiaria[count].QtdMob3,
		&QuestDiaria[count].ExpReward,
		&QuestDiaria[count].GoldReward,
		&QuestDiaria[count].Item->sIndex,
		&QuestDiaria[count].Item->stEffect[0].cEffect,
		&QuestDiaria[count].Item->stEffect[0].cValue,
		&QuestDiaria[count].Item->stEffect[1].cEffect,
		&QuestDiaria[count].Item->stEffect[1].cValue,
		&QuestDiaria[count].Item->stEffect[2].cEffect,
		&QuestDiaria[count].Item->stEffect[2].cValue) != EOF && count < 7)
		count++;

	fclose(fp);
}

void DrawConfig(int wb)
{
	if (ConfigReady == 0)
		return;

	int x = 0;
	int y = 0;
	HFONT h = 0;

	int color = 255;
	int backcolor = 0;

	char String[4096];
	int len = 0;

	hDC = GetDC(hWndMain);

	if (hDC == NULL)
		return;

	if (hFont == 0)
		return;

	if (SelectObject(hDC, hFont) != 0)
		h = (HFONT)SelectObject(hDC, hFont);

	FILE *fp = NULL;

	if (wb)
		fp = fopen("gameconfig.txt", "w+");

	SetTextColor(hDC, color);

	sprintf_s(String, "Drop Item Event Settings:");
	len = strlen(String);

	TextOutA(hDC, x, y, String, len);

	y += 16;

	if (wb)
		fprintf(fp, "%s\n", String);

	SetTextColor(hDC, backcolor);

	sprintf_s(String, "   evindex %d   evdelete %d   evon %d   evitem %d   evrate %d   evstart %d %d %d %d",
		evIndex, evDelete, evOn, evItem, evRate, evStartIndex, evCurrentIndex, evEndIndex, evNotice);

	len = strlen(String);

	TextOutA(hDC, x, y, String, len);

	y += 16;

	if (wb)
		fprintf(fp, "%s\n", String);

	SetTextColor(hDC, color);

	sprintf_s(String, "Etc Event Settings:");

	len = strlen(String);
	TextOutA(hDC, x, y, String, len);

	y += 16;

	if (wb)
		fprintf(fp, "%s\n", String);

	SetTextColor(hDC, backcolor);
	sprintf_s(String, "   double %d   deadpoint %d   dungeonevent %d   statsapphire %d    battleroyal %d",
		DOUBLEMODE, DEADPOINT, DUNGEONEVENT, StatSapphire, BRItem);

	len = strlen(String);

	TextOutA(hDC, x, y, String, len);

	y += 16;

	if (wb)
		fprintf(fp, "%s\n", String);

	SetTextColor(hDC, color);

	sprintf_s(String, "Billing Settings:");

	len = strlen(String);
	TextOutA(hDC, x, y, String, len);

	y += 16;

	if (wb)
		fprintf(fp, "%s\n", String);

	SetTextColor(hDC, backcolor);

	sprintf_s(String, "   billmode %d   freeexp %d   charselbill %d    potioncount %d   partybonus %d   guildboard %d",
		BILLING, FREEEXP, CHARSELBILL, POTIONCOUNT, PARTYBONUS, GUILDBOARD);

	len = strlen(String);
	TextOutA(hDC, x, y, String, len);

	y += 16;

	if (wb)
		fprintf(fp, "%s\n", String);

	SetTextColor(hDC, color);

	sprintf_s(String, "Item Drop Bonus Settings:");

	len = strlen(String);
	TextOutA(hDC, x, y, String, len);

	y += 16;

	if (wb)
		fprintf(fp, "%s\n", String);

	SetTextColor(hDC, backcolor);

	for (int i = 0; i < 4; i++)
	{
		int pos = 16 * i;
		sprintf(String, "   %3d %3d %3d %3d %3d %3d %3d %3d   %3d %3d %3d %3d %3d %3d %3d %3d",
			g_pDropBonus[0 + pos], g_pDropBonus[1 + pos], g_pDropBonus[2 + pos], g_pDropBonus[3 + pos],
			g_pDropBonus[4 + pos], g_pDropBonus[5 + pos], g_pDropBonus[6 + pos], g_pDropBonus[7 + pos],
			g_pDropBonus[8 + pos], g_pDropBonus[9 + pos], g_pDropBonus[10 + pos], g_pDropBonus[11 + pos],
			g_pDropBonus[12 + pos], g_pDropBonus[13 + pos], g_pDropBonus[14 + pos], g_pDropBonus[15 + pos]);

		len = strlen(String);
		TextOutA(hDC, x, y, String, len);

		y += 16;

		if (wb)
			fprintf(fp, "%s\n", String);
	}

	SetTextColor(hDC, color);

	sprintf_s(String, "Treasure Settings:");
	len = strlen(String);

	TextOutA(hDC, x, y, String, len);
	y += 16;

	if (wb)
		fprintf(fp, "%s\n", String);

	SetTextColor(hDC, backcolor);

	for (int j = 0; j < 8; j++)
	{
		STRUCT_TREASURE *tr = &g_pTreasure[j];

		sprintf_s(String, "%-4d ", g_pTreasure[j].Source);

		for (int k = 0; k < 5; ++k)
		{
			STRUCT_ITEM *item = &tr->Target[k];

			sprintf_s(String, "%s  %-4d %2d %2d %2d %2d   ",
				String, item->sIndex, item->stEffect[0].cEffect, item->stEffect[0].cValue, item->stEffect[1].cEffect, item->stEffect[1].cValue);
		}
		len = strlen(String);

		TextOutA(hDC, x, y, String, len);
		y += 16;

		if (wb)
			fprintf(fp, "%s\n", String);

		sprintf_s(String, "       %-5d                %-5d                %-5d                %-5d                %-5d",
			tr->Rate[0], tr->Rate[1], tr->Rate[2], tr->Rate[3], tr->Rate[4]);

		len = strlen(String);
		TextOutA(hDC, x, y, String, len);
		y += 16;
		if (wb)
			fprintf(fp, "%s\n", String);
	}

	SetTextColor(hDC, color);

	sprintf_s(String, "Etc Settings:");

	len = strlen(String);
	TextOutA(hDC, x, y, String, len);

	y += 16;

	if (wb)
		fprintf(fp, "%s\n", String);

	SetTextColor(hDC, backcolor);
	sprintf_s(String, "   partydif %d   kefrastatus %d   GTorreHour %d    RVRHour %d    DropItem %d   BRHour %d   maxNightmare %d   PotionDelay %d   HardCore %d",
		PARTY_DIF, KefraLive, GTorreHour, RvRHour, isDropItem, BRHour, maxNightmare, PotionDelay, isHardCore);

	len = strlen(String);

	TextOutA(hDC, x, y, String, len);

	y += 16;

	if (wb)
		fprintf(fp, "%s\n", String);

	if (hFont && h)
		h = (HFONT)SelectObject(hDC, h);

	ReleaseDC(hWndMain, hDC);

	if (wb)
		fclose(fp);
}

void AddFailAccount(char *Account)
{
	for (int i = 0; i < 16; i++)
	{
		if (FailAccount[i][0] == 0)
		{
			strncpy(FailAccount[i], Account, sizeof(FailAccount[i]));

			return;
		}
	}
}

int  CheckFailAccount(char *Account)
{
	int Num = 0;

	for (int i = 0; i < 16; i++)
	{
		if (FailAccount[i][0] != 0)
		{
			if (strcmp(FailAccount[i], Account) == 0)
				Num++;
		}
	}

	return Num;
}

int  IsFree(STRUCT_SELCHAR *sel)
{
	if (FREEEXP <= 0)
		return 1;

	for (int i = 0; i < MOB_PER_ACCOUNT; i++)
	{
		if (sel->Name[i][0] != 0 && sel->Score[i].Level >= FREEEXP && sel->Score[i].Level < 999)
			return 1;
	}

	return 0;
}

int  SendBilling(int a1, char *a2, int a3, int a4)
{
	return TRUE;
}

int  SendBilling2(_AUTH_GAME *m, int hostlong)
{
	*(u_long*)&m->Unk = htonl(hostlong);

	sprintf_s(m->Unk, "%d", ServerIndex + 10 * ServerGroup);

	BillServerSocket.SendBillMessage((char*)m);

	return 0;
}

void SetItemBonus(STRUCT_ITEM *Dest, int Level, int a3, int DropBonus)
{
	int addDropBonus = DropBonus / 8;

	if (DropBonus / 8 < 0)
		addDropBonus = 0;

	if (addDropBonus > 2)
		addDropBonus = 2;

	int add1 = -1;
	int add2 = -1;

	if (Dest->stEffect[0].cEffect >= EF_GRADE0 && Dest->stEffect[0].cEffect <= EF_GRADE5)
	{
		add1 = Dest->stEffect[0].cEffect - EF_GRADE0;
		add2 = Dest->stEffect[0].cValue;

		Dest->stEffect[0].cEffect = 0;
		Dest->stEffect[0].cValue = 0;
	}

	g_dLevel1 = 0;
	g_dLevel2 = 0;

	if (!a3 && Level >= 210)
		Level -= 47;

	int ItemId = Dest->sIndex;
	int nUnique = g_pItemList[ItemId].nUnique;
	int nReqLv = g_pItemList[ItemId].ReqLvl;
	int nPos = g_pItemList[ItemId].nPos;

	int lvdif = (Level - nReqLv + 1) / 25;

	if (add1 != -1)
		lvdif = add1;

	g_dLevel = lvdif;

	int pForc = 0;

	if (lvdif >= 4)
		pForc = 1;

	if (lvdif < 0)
		lvdif = 0;

	if (lvdif > 3)
		lvdif = 3;

	if (a3 && lvdif >= 3)
		lvdif = 2;

	if (nPos & 0xFE && !LOBYTE(Dest->stEffect[0].sValue) && nPos != 128)
	{

		int v38 = 59;
		int v37 = 0;
		int v36 = 0;
		int v35 = rand() % 101;
		int v34 = 100;

		if (a3)
		{
			v34 = v35 % 3;
		}
		else
		{
			if (lvdif)
			{
				if (lvdif == 1)
				{
					v34 = v35 % (6 - addDropBonus);
				}
				else
				{
					if (lvdif == 2)
					{
						v34 = v35 % (6 - addDropBonus);
					}
					else
					{
						if (lvdif >= 3)
							v34 = v35 % 4;
					}
				}
			}
			else
			{
				v34 = v35 % (8 - addDropBonus);
			}
		}
		switch (nPos)
		{
		case 2:
			if (v34)
			{
				if (v34 == 1)
				{
					v38 = 60;
					v36 = 2;
				}
			}
			else
			{
				v38 = 26;
				v36 = 3;
			}
			break;
		case 4:
			v38 = 71;
			v36 = 10;
			v37 = 1;
			break;
		case 8:
			v38 = 71;
			v36 = 10;
			v37 = 1;
			break;
		case 16:
			v38 = 72;
			v36 = 5;
			break;
		case 32:
			v38 = 73;
			v36 = 6;
			v37 = -1;
			break;
		case 64:
		case 192:
			if (nUnique != 44 && nUnique != 47)
			{
				if (v34)
				{
					if (v34 == 1)
					{
						v38 = 2;
						v36 = 9;
						v37 = -1;
					}
					else
					{
						if (v34 == 2)
						{
							v38 = 74;
							v36 = 3;
						}
					}
				}
				else
				{
					v38 = 26;
					v36 = 3;
					v37 = 1;
				}
			}
			else
			{
				if (v34)
				{
					if (v34 == 1)
					{
						v38 = 74;
						v36 = 3;
						v37 = 1;
					}
				}
				else
				{
					v38 = 60;
					v36 = 4;
					v37 = -1;
				}
			}
			break;
		}
		int v33 = rand() % 100;
		if (a3)
			v33 = 2 * v33 / 3;
		int v32 = 100;
		if (a3)
		{
			v32 = v33 % 4;
		}
		else
		{
			if (lvdif)
			{
				if (lvdif == 1)
				{
					v32 = v33 % 6;
				}
				else
				{
					if (lvdif == 2)
					{
						v32 = v33 % 6;
					}
					else
					{
						if (lvdif >= 3)
							v32 = v33 % 4;
					}
				}
			}
			else
			{
				v32 = v33 % 8;
			}
		}
		int v31 = 59;
		int v30 = 0;
		int v29 = 0;
		switch (nPos)
		{
		case 2:
			if (v32)
			{
				if (v32 == 1)
				{
					v31 = 3;
					v30 = 5;
					v29 = -1;
				}
			}
			else
			{
				v31 = 4;
				v30 = 10;
			}
			break;
		case 4:
			if (v32)
			{
				if (v32 == 1)
				{
					v31 = 2;
					v30 = 6;
					v29 = -1;
				}
				else
				{
					if (v32 == 2)
					{
						v31 = 3;
						v30 = 5;
						v29 = -1;
					}
				}
			}
			else
			{
				v31 = 60;
				v30 = 2;
				v29 = -1;
			}
			break;
		case 8:
			if (v32)
			{
				if (v32 == 1)
				{
					v31 = 2;
					v30 = 6;
					v29 = -1;
				}
				else
				{
					if (v32 == 2)
					{
						v31 = 3;
						v30 = 5;
						v29 = -1;
					}
				}
			}
			else
			{
				v31 = 60;
				v30 = 2;
				v29 = -1;
			}
			break;
		case 16:
			if (v32)
			{
				switch (v32)
				{
				case 1:
					v31 = 2;
					v30 = 6;
					v29 = -1;
					break;
				case 2:
					v31 = 74;
					v30 = 3;
					break;
				case 3:
					v31 = 54;
					v30 = 3;
					break;
				}
			}
			else
			{
				v31 = 60;
				v30 = 2;
				v29 = -1;
			}
			break;
		case 32:
			if (v32)
			{
				if (v32 == 1)
				{
					v31 = 74;
					v30 = 3;
				}
			}
			else
			{
				v31 = 60;
				v30 = 2;
				v29 = -1;
			}
			break;
		case 64:
		case 128:
		case 192:
			if (nUnique != 44 && nUnique != 47)
			{
				if (v32)
				{
					if (v32 == 1)
					{
						v31 = 2;
						v30 = 9;
						v29 = -1;
					}
					else
					{
						if (v32 == 2)
						{
							v31 = 74;
							v30 = 3;
							v29 = 1;
						}
					}
				}
				else
				{
					v31 = 26;
					v30 = 3;
					v29 = 1;
				}
			}
			else
			{
				if (v32)
				{
					if (v32 == 1)
					{
						v31 = 74;
						v30 = 3;
						v29 = 1;
					}
				}
				else
				{
					v31 = 60;
					v30 = 4;
					v29 = -1;
				}
			}
			break;
		}
		int v28 = 0;
		v35 = rand() % 100;
		if (lvdif)
		{
			switch (lvdif)
			{
			case 1:
				if (v35 >= 1)
				{
					if (v35 >= 5)
					{
						if (v35 >= 24)
						{
							if (v35 >= 65)
								v28 = 1;
							else
								v28 = 2;
						}
						else
						{
							v28 = 3;
						}
					}
					else
					{
						v28 = 4;
					}
				}
				else
				{
					v28 = 5;
				}
				break;
			case 2:
				if (v35 >= 2)
				{
					if (v35 >= 16)
					{
						if (v35 >= 60)
							v28 = 2;
						else
							v28 = 3;
					}
					else
					{
						v28 = 4;
					}
				}
				else
				{
					v28 = 5;
				}
				break;
			case 3:
				if (v35 >= 2)
				{
					if (v35 >= 9)
					{
						if (v35 >= 45)
						{
							if (v35 >= 75)
								v28 = 2;
							else
								v28 = 3;
						}
						else
						{
							v28 = 4;
						}
					}
					else
					{
						v28 = 5;
					}
				}
				else
				{
					v28 = 6;
				}
				break;
			default:
				if (lvdif >= 4)
				{
					if (v35 >= 2)
					{
						if (v35 >= 10)
						{
							if (v35 >= 30)
							{
								if (v35 >= 75)
									v28 = 3;
								else
									v28 = 4;
							}
							else
							{
								v28 = 5;
							}
						}
						else
						{
							v28 = 6;
						}
					}
					else
					{
						v28 = 7;
					}
				}
				break;
			}
		}
		else
		{
			if (v35 >= 2)
			{
				if (v35 >= 6)
				{
					if (v35 >= 24)
						v28 = v35 < 55;
					else
						v28 = 2;
				}
				else
				{
					v28 = 3;
				}
			}
			else
			{
				v28 = 4;
			}
		}
		if (pForc && v28 < 4)
			v28 = 4;
		v28 += v37;
		if (a3 && !v28)
			v28 = 1;
		if (LOBYTE(Dest->stEffect[1].sValue) || v28 <= 0)
		{
			if (LOBYTE(Dest->stEffect[1].sValue) || v28 > 0 || nPos != 32)
			{
				if (!LOBYTE(Dest->stEffect[1].sValue))
				{
					Dest->stEffect[1].cEffect = 59;
					int v4 = rand() & 0x8000007F;
					if (v4 < 0)
						v4 = ((unsigned __int8)(v4 - 1) | 0x80) + 1;
					Dest->stEffect[1].cValue = v4;
				}
			}
			else
			{
				Dest->stEffect[1].cEffect = v38;
				Dest->stEffect[1].cValue = 0;
			}
		}
		else
		{
			Dest->stEffect[1].cEffect = v38;
			Dest->stEffect[1].cValue = v36 * v28;
		}
		g_dLevel1 = v28;
		int v27 = 0;
		v33 = rand() % 100;
		if (lvdif)
		{
			switch (lvdif)
			{
			case 1:
				if (v33 >= 1)
				{
					if (v33 >= 5)
					{
						if (v33 >= 24)
						{
							if (v33 >= 65)
								v27 = 1;
							else
								v27 = 2;
						}
						else
						{
							v27 = 3;
						}
					}
					else
					{
						v27 = 4;
					}
				}
				else
				{
					v27 = 5;
				}
				break;
			case 2:
				if (v33 >= 2)
				{
					if (v33 >= 16)
					{
						if (v33 >= 60)
							v27 = 2;
						else
							v27 = 3;
					}
					else
					{
						v27 = 4;
					}
				}
				else
				{
					v27 = 5;
				}
				break;
			case 3:
				if (v33 >= 2)
				{
					if (v33 >= 9)
					{
						if (v33 >= 45)
						{
							if (v33 >= 75)
								v27 = 2;
							else
								v27 = 3;
						}
						else
						{
							v27 = 4;
						}
					}
					else
					{
						v27 = 5;
					}
				}
				else
				{
					v27 = 6;
				}
				break;
			default:
				if (lvdif >= 4)
				{
					if (v33 >= 2)
					{
						if (v33 >= 10)
						{
							if (v33 >= 30)
							{
								if (v33 >= 75)
									v27 = 3;
								else
									v27 = 4;
							}
							else
							{
								v27 = 5;
							}
						}
						else
						{
							v27 = 6;
						}
					}
					else
					{
						v27 = 7;
					}
				}
				break;
			}
		}
		else
		{
			if (v35 >= 2)
			{
				if (v33 >= 6)
				{
					if (v33 >= 24)
						v27 = v33 < 55;
					else
						v27 = 2;
				}
				else
				{
					v27 = 3;
				}
			}
			else
			{
				v28 = 4;
			}
		}
		if (pForc && v27 < 3)
			v27 = 3;
		if (a3 && v27 >= 5)
			v27 = 4;
		v27 += v29;
		if (addDropBonus && !v27)
			v27 = addDropBonus;
		if (a3 && !v27)
			v27 = 1;
		if (v27 <= 0 || LOBYTE(Dest->stEffect[2].sValue))
		{
			if (!LOBYTE(Dest->stEffect[2].sValue))
			{
				Dest->stEffect[2].cEffect = 59;
				int v5 = rand() & 0x8000007F;
				if (v5 < 0)
					v5 = ((unsigned __int8)(v5 - 1) | 0x80) + 1;
				Dest->stEffect[2].cValue = v5;
			}
		}
		else
		{
			Dest->stEffect[2].cEffect = v31;
			Dest->stEffect[2].cValue = v30 * v27;
		}
		g_dLevel2 = v27;

		if (!LOBYTE(Dest->stEffect[0].sValue))
		{
			int v26 = rand() % 100;
			if (a3)
				v26 /= 2;
			int v25 = 1;
			int v24 = 12;
			int v23 = 45;
			int v22 = 70;
			if (lvdif >= 3)
			{
				v25 = 6;
				v24 = 35;
				v23 = 85;
				v22 = 100;
			}
			if (lvdif == 2)
			{
				v25 = 6;
				v24 = 35;
				v23 = 85;
				v22 = 100;
			}
			if (lvdif == 1)
			{
				v25 = 6;
				v24 = 22;
				v23 = 75;
				v22 = 90;
			}
			if (!lvdif)
			{
				v25 = 6;
				v24 = 22;
				v23 = 75;
				v22 = 90;
			}
			if (v26 >= v25)
			{
				if (v26 >= v24)
				{
					if (v26 >= v23)
					{
						if (v26 >= v22)
						{
							Dest->stEffect[0].cEffect = 59;
							int v6 = rand() & 0x8000007F;
							if (v6 < 0)
								v6 = ((unsigned __int8)(v6 - 1) | 0x80) + 1;
							Dest->stEffect[0].cValue = v6;
						}
						else
						{
							int v20 = rand() % 10;
							int v19 = g_pBonusType[v20];
							int v18 = lvdif;
							int v17 = g_pBonusValue[v20][lvdif][0];
							int v16 = g_pBonusValue[v20][lvdif][1];
							int v15 = v16 + 1 - v17;
							int v14 = rand() % v15 + v17;
							Dest->stEffect[0].cEffect = v19;
							Dest->stEffect[0].cValue = v14;
						}
					}
					else
					{
						Dest->stEffect[0].cEffect = 43;
						Dest->stEffect[0].cValue = 0;
					}
				}
				else
				{
					Dest->stEffect[0].cEffect = 43;
					Dest->stEffect[0].cValue = 1;
				}
			}
			else
			{
				Dest->stEffect[0].cEffect = 43;
				Dest->stEffect[0].cValue = 2;
				if (add2 > 2)
				{
					int v21 = rand() % 100;
					switch (add2)
					{
					case 3:
						if (v21 < 30)
							Dest->stEffect[0].cValue = 3;
						break;
					case 4:
						if (v21 >= 10)
						{
							if (v21 < 40)
								Dest->stEffect[0].cValue = 3;
						}
						else
						{
							Dest->stEffect[0].cValue = 4;
						}
						break;
					case 5:
						if (v21 >= 10)
						{
							if (v21 >= 30)
							{
								if (v21 < 60)
									Dest->stEffect[0].cValue = 3;
							}
							else
							{
								Dest->stEffect[0].cValue = 4;
							}
						}
						else
						{
							Dest->stEffect[0].cValue = 5;
						}
						break;
					case 6:
						if (v21 >= 10)
						{
							if (v21 >= 20)
							{
								if (v21 >= 40)
								{
									if (v21 < 60)
										Dest->stEffect[0].cValue = 3;
								}
								else
								{
									Dest->stEffect[0].cValue = 4;
								}
							}
							else
							{
								Dest->stEffect[0].cValue = 5;
							}
						}
						else
						{
							Dest->stEffect[0].cValue = 6;
						}
						break;
					case 7:
						if (v21 >= 4)
						{
							if (v21 >= 10)
							{
								if (v21 >= 20)
								{
									if (v21 >= 35)
									{
										if (v21 < 60)
											Dest->stEffect[0].cValue = 3;
									}
									else
									{
										Dest->stEffect[0].cValue = 4;
									}
								}
								else
								{
									Dest->stEffect[0].cValue = 5;
								}
							}
							else
							{
								Dest->stEffect[0].cValue = 6;
							}
						}
						else
						{
							Dest->stEffect[0].cValue = 7;
						}
						break;
					}
				}
			}
		}
	}

	for (int i = 0; i < 12; ++i)
	{
		int v12 = g_pItemList[ItemId].ReqLvl;
		switch (g_pItemList[ItemId].stEffect[i].sEffect)
		{
		case 0x2B:
			Dest->stEffect[0].cEffect = 43;
			Dest->stEffect[0].cValue = (unsigned char)g_pItemList[ItemId].stEffect[i].sValue;
			break;
		case 0x3D:
			Dest->stEffect[0].cEffect = 61;
			Dest->stEffect[0].cValue = LOBYTE(g_pItemList[ItemId].stEffect[i].sValue);
			break;
		case 0x4E:
			Dest->stEffect[0].cEffect = 78;
			int v11 = rand() % 4 + g_pItemList[ItemId].stEffect[i].sValue;
			if (v11 > 9)
				v11 = 9;
			Dest->stEffect[0].cValue = v11;
			break;
		}
	}
	if (Dest->sIndex == 412 || Dest->sIndex == 413 || Dest->sIndex == 419 || Dest->sIndex == 420 || Dest->sIndex == 753)
	{
		if (!Dest->stEffect[0].cEffect)
		{
			Dest->stEffect[0].cEffect = 59;
			Dest->stEffect[0].cValue = rand();
		}
		if (!Dest->stEffect[1].cEffect)
		{
			Dest->stEffect[1].cEffect = 59;
			Dest->stEffect[01].cValue = rand();
		}
		if (!Dest->stEffect[2].cEffect)
		{
			Dest->stEffect[2].cEffect = 59;
			Dest->stEffect[2].cValue = rand();
		}
	}
	if (Dest->sIndex >= 447 && Dest->sIndex <= 450
		|| Dest->sIndex >= 692 && Dest->sIndex <= 695)
	{
		if (!Dest->stEffect[0].cEffect)
		{
			Dest->stEffect[0].cEffect = 59;
			Dest->stEffect[0].cValue = rand();
		}
		if (!Dest->stEffect[1].cEffect)
		{
			Dest->stEffect[1].cEffect = 59;
			Dest->stEffect[01].cValue = rand();
		}
		if (!Dest->stEffect[2].cEffect)
		{
			Dest->stEffect[2].cEffect = 59;
			Dest->stEffect[2].cValue = rand() % 256;
		}
	}
}

void SetItemBonus2(STRUCT_ITEM *Dest)
{
	int nPos = g_pItemList[Dest->sIndex].nPos;

	if (nPos == 2)//Elmo
	{
		int _rand = rand() % 25;

		if (Dest->stEffect[0].cEffect == EF_SANC)
		{
			int sanc = BASE_GetItemSanc(Dest);

			if (sanc < 6)
			{
				sanc += rand() % 2;

				if (sanc >= 6)
					sanc = 6;

				BASE_SetItemSanc(Dest, sanc, 0);
			}
		}
		else
		{
			Dest->stEffect[0].cEffect = EF_SANC;
			Dest->stEffect[0].cValue = rand() % 2;
		}
		Dest->stEffect[1].cEffect = g_pBonusValue3[_rand][0];
		Dest->stEffect[1].cValue = g_pBonusValue3[_rand][1];

		Dest->stEffect[2].cEffect = g_pBonusValue3[_rand][2];
		Dest->stEffect[2].cValue = g_pBonusValue3[_rand][3];
	}
	//Peito calça
	if (nPos == 4 || nPos == 8)
	{
		int _rand = rand() % 48;

		if (Dest->stEffect[0].cEffect == EF_SANC)
		{
			int sanc = BASE_GetItemSanc(Dest);

			if (sanc < 6)
			{
				sanc += rand() % 2;

				if (sanc >= 6)
					sanc = 6;

				BASE_SetItemSanc(Dest, sanc, 0);
			}
		}
		else
		{
			Dest->stEffect[0].cEffect = EF_SANC;
			Dest->stEffect[0].cValue = rand() % 2;
		}

		Dest->stEffect[1].cEffect = g_pBonusValue2[_rand][0];
		Dest->stEffect[1].cValue = g_pBonusValue2[_rand][1];

		Dest->stEffect[2].cEffect = g_pBonusValue2[_rand][2];
		Dest->stEffect[2].cValue = g_pBonusValue2[_rand][3];
	}

	//Luva
	if (nPos == 16)
	{
		int _rand = rand() % 30;

		if (Dest->stEffect[0].cEffect == EF_SANC)
		{
			int sanc = BASE_GetItemSanc(Dest);

			if (sanc < 6)
			{
				sanc += rand() % 2;

				if (sanc >= 6)
					sanc = 6;

				BASE_SetItemSanc(Dest, sanc, 0);
			}
		}
		else
		{
			Dest->stEffect[0].cEffect = EF_SANC;
			Dest->stEffect[0].cValue = rand() % 2;
		}

		Dest->stEffect[1].cEffect = g_pBonusValue4[_rand][0];
		Dest->stEffect[1].cValue = g_pBonusValue4[_rand][1];

		Dest->stEffect[2].cEffect = g_pBonusValue4[_rand][2];
		Dest->stEffect[2].cValue = g_pBonusValue4[_rand][3];
	}

	//Bota
	if (nPos == 32)
	{
		int _rand = rand() % 30;

		if (Dest->stEffect[0].cEffect == EF_SANC)
		{
			int sanc = BASE_GetItemSanc(Dest);

			if (sanc < 6)
			{
				sanc += rand() % 2;

				if (sanc >= 6)
					sanc = 6;

				BASE_SetItemSanc(Dest, sanc, 0);
			}
		}
		else
		{
			Dest->stEffect[0].cEffect = EF_SANC;
			Dest->stEffect[0].cValue = rand() % 2;
		}

		Dest->stEffect[1].cEffect = g_pBonusValue5[_rand][0];
		Dest->stEffect[1].cValue = g_pBonusValue5[_rand][1];

		Dest->stEffect[2].cEffect = g_pBonusValue5[_rand][2];
		Dest->stEffect[2].cValue = g_pBonusValue5[_rand][3];
	}
}

/*void SetItemBonus2(STRUCT_ITEM *Dest)
{
	int chance = rand()%100;

	int nPos = g_pItemList[Dest->sIndex].nPos;

	if (nPos == 2)//Elmo
	{
		int _rand = rand() % 25;

		if (Dest->stEffect[0].cEffect == EF_SANC)
		{
			int sanc = BASE_GetItemSanc(Dest);

			if (sanc < 6)
			{
				sanc += rand() % 2;

				if (sanc >= 6)
					sanc = 6;

				BASE_SetItemSanc(Dest, sanc, 0);
			}
		}
		else
		{
			Dest->stEffect[0].cEffect = EF_SANC;
			Dest->stEffect[0].cValue = rand() % 2;
		}
		Dest->stEffect[1].cEffect = g_pBonusValue3[_rand][0];
		Dest->stEffect[1].cValue = g_pBonusValue3[_rand][1];

		Dest->stEffect[2].cEffect = g_pBonusValue3[_rand][2];
		Dest->stEffect[2].cValue = g_pBonusValue3[_rand][3];
	}


	//Peito calça
	if(nPos == 4 || nPos == 8)
	{
		if(Dest->stEffect[0].cEffect == EF_SANC)
		{
			int sanc = BASE_GetItemSanc(Dest);

			if (sanc < 6)
			{
				sanc += rand() % 2;

				if (sanc >= 6)
					sanc = 6;

				BASE_SetItemSanc(Dest, sanc, 0);
			}
		}
		else
		{
			Dest->stEffect[0].cEffect = EF_SANC;
			Dest->stEffect[0].cValue = rand()%2;
		}

		if(chance < 5)
		{
			Dest->stEffect[1].cEffect = 3;
			Dest->stEffect[1].cValue = 15;
			Dest->stEffect[2].cEffect = 71;
			Dest->stEffect[2].cValue = 60;
		}
		else if(chance >= 5 && chance < 10)
		{
			Dest->stEffect[1].cEffect = 71;
			Dest->stEffect[1].cValue = 60;
			Dest->stEffect[2].cEffect = 60;
			Dest->stEffect[2].cValue = 10;
		}
		else if(chance >= 10 && chance < 15)
		{
			Dest->stEffect[1].cEffect = 2;
			Dest->stEffect[1].cValue = 24;
			Dest->stEffect[2].cEffect = 3;
			Dest->stEffect[2].cValue = 25;
		}
		else if(chance >= 15 && chance < 18)//dificil
		{
			Dest->stEffect[1].cEffect = 3;
			Dest->stEffect[1].cValue = 30;
			Dest->stEffect[2].cEffect = 60;
			Dest->stEffect[2].cValue = 10;
		}
		else if(chance >= 18 && chance < 23)
		{
			Dest->stEffect[1].cEffect = 2;
			Dest->stEffect[1].cValue = 24;
			Dest->stEffect[2].cEffect = 60;
			Dest->stEffect[2].cValue = 6;
		}
		else if(chance >= 23 && chance < 28)
		{
			Dest->stEffect[1].cEffect = 2;
			Dest->stEffect[1].cValue = 18;
			Dest->stEffect[2].cEffect = 60;
			Dest->stEffect[2].cValue = 6;
		}
		else if(chance >= 28 && chance < 33)
		{
			Dest->stEffect[1].cEffect = 2;
			Dest->stEffect[1].cValue = 24;
			Dest->stEffect[2].cEffect = 3;
			Dest->stEffect[2].cValue = 30;
		}
		else if(chance >= 33 && chance < 38)
		{
			Dest->stEffect[1].cEffect = 3;
			Dest->stEffect[1].cValue = 40;
			Dest->stEffect[2].cEffect = 0;
			Dest->stEffect[2].cValue = 0;
		}
		else if(chance >= 38 && chance < 41)//dificil
		{
			Dest->stEffect[1].cEffect = 3;
			Dest->stEffect[1].cValue = 30;
			Dest->stEffect[2].cEffect = 71;
			Dest->stEffect[2].cValue = 70;
		}
		else if(chance >= 41 && chance < 44)//dificil
		{
			Dest->stEffect[1].cEffect = 2;
			Dest->stEffect[1].cValue = 30;
			Dest->stEffect[2].cEffect = 3;
			Dest->stEffect[2].cValue = 30;
		}
		else if(chance >= 44 && chance < 49)
		{
			Dest->stEffect[1].cEffect = 71;
			Dest->stEffect[1].cValue = 60;
			Dest->stEffect[2].cEffect = 60;
			Dest->stEffect[2].cValue = 8;
		}
		else if(chance >= 49 && chance < 54)
		{
			Dest->stEffect[1].cEffect = 3;
			Dest->stEffect[1].cValue = 25;
			Dest->stEffect[2].cEffect = 60;
			Dest->stEffect[2].cValue = 8;
		}
		else if(chance >= 54 && chance < 59)
		{
			Dest->stEffect[1].cEffect = 3;
			Dest->stEffect[1].cValue = 25;
			Dest->stEffect[2].cEffect = 60;
			Dest->stEffect[2].cValue = 6;
		}
		else if(chance >= 59 && chance < 62)//dificl
		{
			Dest->stEffect[1].cEffect = 2;
			Dest->stEffect[1].cValue = 30;
			Dest->stEffect[2].cEffect = 71;
			Dest->stEffect[2].cValue = 70;
		}
		else if(chance >= 62 && chance < 67)
		{
			Dest->stEffect[1].cEffect = 3;
			Dest->stEffect[1].cValue = 25;
			Dest->stEffect[2].cEffect = 60;
			Dest->stEffect[2].cValue = 6;
		}
		else if(chance >= 67 && chance < 71)
		{
			Dest->stEffect[1].cEffect = 71;
			Dest->stEffect[1].cValue = 60;
			Dest->stEffect[2].cEffect = 60;
			Dest->stEffect[2].cValue = 6;
		}
		else if(chance >= 71 && chance < 76)
		{
			Dest->stEffect[1].cEffect = 3;
			Dest->stEffect[1].cValue = 50;
			Dest->stEffect[2].cEffect = 0;
			Dest->stEffect[2].cValue = 0;
		}
		else if(chance >= 76 && chance < 81)
		{
			Dest->stEffect[1].cEffect = 2;
			Dest->stEffect[1].cValue = 18;
			Dest->stEffect[2].cEffect = 71;
			Dest->stEffect[2].cValue = 70;
		}
		else if(chance >= 81 && chance < 86)
		{
			Dest->stEffect[1].cEffect = 3;
			Dest->stEffect[1].cValue = 20;
			Dest->stEffect[2].cEffect = 71;
			Dest->stEffect[2].cValue = 60;
		}
		else if(chance >= 86 && chance < 91)
		{
			Dest->stEffect[1].cEffect = 71;
			Dest->stEffect[1].cValue = 60;
			Dest->stEffect[2].cEffect = 60;
			Dest->stEffect[2].cValue = 10;
		}
		else if(chance >= 91 && chance < 96)
		{
			Dest->stEffect[1].cEffect = 3;
			Dest->stEffect[1].cValue = 30;
			Dest->stEffect[2].cEffect = 60;
			Dest->stEffect[2].cValue = 8;
		}
		else if(chance > 96)//dificil
		{
			Dest->stEffect[1].cEffect = 71;
			Dest->stEffect[1].cValue = 70;
			Dest->stEffect[2].cEffect = 60;
			Dest->stEffect[2].cValue = 10;
		}
	}

	//Luva
	if (nPos == 16)
	{
		int _rand = rand() % 30;

		if (Dest->stEffect[0].cEffect == EF_SANC)
		{
			int sanc = BASE_GetItemSanc(Dest);

			if (sanc < 6)
			{
				sanc += rand() % 2;

				if (sanc >= 6)
					sanc = 6;

				BASE_SetItemSanc(Dest, sanc, 0);
			}
		}
		else
		{
			Dest->stEffect[0].cEffect = EF_SANC;
			Dest->stEffect[0].cValue = rand() % 2;
		}

		Dest->stEffect[1].cEffect = g_pBonusValue4[_rand][0];
		Dest->stEffect[1].cValue = g_pBonusValue4[_rand][1];

		Dest->stEffect[2].cEffect = g_pBonusValue4[_rand][2];
		Dest->stEffect[2].cValue = g_pBonusValue4[_rand][3];
	}
	//Bota
	if(nPos == 32)
	{
		if (Dest->stEffect[0].cEffect == EF_SANC)
		{
			int sanc = BASE_GetItemSanc(Dest);

			if (sanc < 6)
			{
				sanc += rand() % 2;

				if (sanc >= 6)
					sanc = 6;

				BASE_SetItemSanc(Dest, sanc, 0);
			}
		}
		else
		{
			Dest->stEffect[0].cEffect = EF_SANC;
			Dest->stEffect[0].cValue = rand()%2;
		}
		if (chance < 2)
		{
			Dest->stEffect[1].cEffect = 2;
			Dest->stEffect[1].cValue = 6;
			Dest->stEffect[2].cEffect = 60;
			Dest->stEffect[2].cValue = 8;
		}
		else if(chance >= 2 && chance < 10)
		{
			Dest->stEffect[1].cEffect = 2;
			Dest->stEffect[1].cValue = 0;
			Dest->stEffect[2].cEffect = 60;
			Dest->stEffect[2].cValue = 8;
		}
		else if(chance >= 10 && chance < 15)
		{
			Dest->stEffect[1].cEffect = 2;
			Dest->stEffect[1].cValue = 0;
			Dest->stEffect[2].cEffect = 74;
			Dest->stEffect[2].cValue = 15;
		}
		else if(chance >= 15 && chance < 18)//dificil
		{
			Dest->stEffect[1].cEffect = 2;
			Dest->stEffect[1].cValue = 0;
			Dest->stEffect[2].cEffect = 0;
			Dest->stEffect[2].cValue = 0;
		}
		else if(chance >= 18 && chance < 23)
		{
			Dest->stEffect[1].cEffect = 2;
			Dest->stEffect[1].cValue = 0;
			Dest->stEffect[2].cEffect = 74;
			Dest->stEffect[2].cValue = 12;
		}
		else if(chance >= 23 && chance < 24)
		{
			Dest->stEffect[1].cEffect = 2;
			Dest->stEffect[1].cValue = 6;
			Dest->stEffect[2].cEffect = 0;
			Dest->stEffect[2].cValue = 0;
		}
		else if(chance >= 24 && chance < 33)
		{
			Dest->stEffect[1].cEffect = 2;
			Dest->stEffect[1].cValue = 0;
			Dest->stEffect[2].cEffect = 74;
			Dest->stEffect[2].cValue = 12;
		}
		else if(chance >= 33 && chance < 38)
		{
			Dest->stEffect[1].cEffect = 2;
			Dest->stEffect[1].cValue = 0;
			Dest->stEffect[2].cEffect = 60;
			Dest->stEffect[2].cValue = 6;
		}
		else if(chance >= 38 && chance < 39)//dificil
		{
			Dest->stEffect[1].cEffect = 2;
			Dest->stEffect[1].cValue = 6;
			Dest->stEffect[2].cEffect = 60;
			Dest->stEffect[2].cValue = 10;
		}
		else if(chance >= 39 && chance < 40)//dificil
		{
			Dest->stEffect[1].cEffect = 2;
			Dest->stEffect[1].cValue = 6;
			Dest->stEffect[2].cEffect = 74;
			Dest->stEffect[2].cValue = 18;
		}
		else if(chance >= 41 && chance < 44)
		{
			Dest->stEffect[1].cEffect = 2;
			Dest->stEffect[1].cValue = 6;
			Dest->stEffect[2].cEffect = 74;
			Dest->stEffect[2].cValue = 12;
		}
		else if(chance >= 44 && chance < 49)
		{
			Dest->stEffect[1].cEffect = 2;
			Dest->stEffect[1].cValue = 0;
			Dest->stEffect[2].cEffect = 60;
			Dest->stEffect[2].cValue = 10;
		}
		else if(chance >= 49 && chance < 55)
		{
			Dest->stEffect[1].cEffect = 74;
			Dest->stEffect[1].cValue = 18;
			Dest->stEffect[2].cEffect = 0;
			Dest->stEffect[2].cValue = 0;
		}
		else if(chance >= 55 && chance < 56)//dificl
		{
			Dest->stEffect[1].cEffect = 2;
			Dest->stEffect[1].cValue = 6;
			Dest->stEffect[2].cEffect = 74;
			Dest->stEffect[2].cValue = 18;
		}
		else if(chance >= 56 && chance < 67)
		{
			Dest->stEffect[1].cEffect = 74;
			Dest->stEffect[1].cValue = 15;
			Dest->stEffect[2].cEffect = 0;
			Dest->stEffect[2].cValue = 0;
		}
		else if(chance >= 67 && chance < 71)
		{
			Dest->stEffect[1].cEffect = 60;
			Dest->stEffect[1].cValue = 10;
			Dest->stEffect[2].cEffect = 0;
			Dest->stEffect[2].cValue = 0;
		}
		else if(chance >= 71 && chance < 76)
		{
			Dest->stEffect[1].cEffect = 2;
			Dest->stEffect[1].cValue = 6;
			Dest->stEffect[2].cEffect = 60;
			Dest->stEffect[2].cValue = 6;
		}
		else if(chance >= 76 && chance < 81)
		{
			Dest->stEffect[1].cEffect = 2;
			Dest->stEffect[1].cValue = 0;
			Dest->stEffect[2].cEffect = 60;
			Dest->stEffect[2].cValue = 6;
		}
		else if(chance >= 81 && chance < 86)
		{
			Dest->stEffect[1].cEffect = 2;
			Dest->stEffect[1].cValue = 0;
			Dest->stEffect[2].cEffect = 74;
			Dest->stEffect[2].cValue = 12;
		}
		else if(chance >= 86 && chance < 91)
		{
			Dest->stEffect[1].cEffect = 2;
			Dest->stEffect[1].cValue = 0;
			Dest->stEffect[2].cEffect = 60;
			Dest->stEffect[2].cValue = 6;
		}
		else if(chance >= 91 && chance < 96)
		{
			Dest->stEffect[1].cEffect = 74;
			Dest->stEffect[1].cValue = 18;
			Dest->stEffect[2].cEffect = 0;
			Dest->stEffect[2].cValue = 0;
		}
		else if(chance > 96)
		{
			Dest->stEffect[1].cEffect = 74;
			Dest->stEffect[1].cValue = 12;
			Dest->stEffect[2].cEffect = 0;
			Dest->stEffect[2].cValue = 0;
		}
	}
}*/

int Challange(int conn, int mob, int coin)
{
	if (mob < MAX_USER || mob >= MAX_MOB)
		return 0;

	int ZoneChall = pMob[mob].MOB.BaseScore.Level;
	int Guild = pMob[conn].MOB.Guild;

	if (ZoneChall < 0 || ZoneChall >= ValidGuild)
		return 0;

	if (ZoneChall == 4)
		return 0;


	if (pMob[conn].MOB.GuildLevel != 9)
	{
		SendSay(mob, g_pMessageStringTable[_NN_Only_Guild_Master_can]);

		return 0;
	}

	if (g_pGuildZone[ZoneChall].ChargeGuild == Guild)
	{
		SendSay(mob, g_pMessageStringTable[_NN_Champions_Cant_Challange]);

		return 0;
	}
	if (pMob[conn].extra.Citizen != (ServerIndex + 1))
	{
		SendSay(mob, g_pMessageStringTable[_DN_ANOTHER_TOWNSPEOPLE]);
		return 0;
	}

	int Group = ServerGroup;
	int Server = Guild / MAX_GUILD;
	int usGuild = Guild & MAX_GUILD - 1;

	int GuildName = 1;

	if (Group >= 0 && Group < MAX_SERVERGROUP && Server >= 0 && Server < 16 && usGuild >= 0 && usGuild < MAX_GUILD && g_pGuildName[Group][Server][usGuild][0] == 0)
		GuildName = 0;


	if (GuildName == 0)
	{
		SendSay(mob, g_pMessageStringTable[_NN_Only_Named_Guild]);

		return 0;
	}

	if (GuildInfo[Guild].Fame < 100)
	{
		sprintf_s(temp, g_pMessageStringTable[_DN_Need_1000000_For_Challange], 100);
		SendSay(mob, temp);

		return 0;
	}

	MSG_GuildInfo sm;
	memset(&sm, 0, sizeof(MSG_GuildInfo));

	sm.Type = _MSG_GuildInfo;
	sm.Size = sizeof(MSG_GuildInfo);
	sm.ID = conn;

	sm.Guild = Guild;

	coin = GuildInfo[Guild].Fame;

	GuildInfo[Guild].Fame -= 100;

	sm.GuildInfo = GuildInfo[Guild];

	auto& pc = cSQL::instance();
	sprintf(xQuery, "UPDATE `guilds` SET fame = '%d' WHERE `guild` = '%d'", GuildInfo[usGuild].Fame - 100, usGuild);
	pc.wQuery(xQuery);

	DBServerSocket.SendOneMessage((char*)&sm, sizeof(MSG_GuildInfo));
	 
	SendMsgExp(conn, g_pMessageStringTable[_NN_Challanged], TNColor::Default, false);

	//sprintf(temp, "etc,challange guild:%d fame:%d zone:%d", Guild, coin, ZoneChall);
	//Log(temp, pMob[conn].MOB.MobName, 0);

	if (pChallangerMoney[ZoneChall] < coin)
	{
		g_pGuildZone[ZoneChall].ChallangeGuild = Guild;
		pChallangerMoney[ZoneChall] = coin;

		CReadFiles::WriteChallanger();
		CReadFiles::WriteGuild();
	}

	return 1;
}
 
//int GenerateEvocation(int conn, int SummonID, STRUCT_ITEM* sItem, int Num)
//{
//	int Leader = pMob[conn].Leader;
//
//	if (Leader <= 0)
//		Leader = conn;
//
//	int MobEmpty = GetEmptyNPCMob();
//
//	if (MobEmpty == 0)
//	{
//		SendClientMessage(conn, g_pMessageStringTable[_NN_Cant_Create_More_Summons]);
//
//		return 0;
//	}
//
//	if (SummonID < 0 || SummonID >= MAX_SUMMONLIST)
//		return 0;
//
//	int sFace = mSummon.Mob[SummonID].Equip[0].sIndex;
//	int Unk = 0;
//	int SummonNum = 0;
//
//	int IsSummonOther = 0;
//
//	for (int i = 0; i < MAX_PARTY; i++)
//	{
//		int partyconn = pMob[Leader].Evocations[i];
//
//		if (partyconn == 0)
//			continue;
//
//		if (partyconn <= 0 || partyconn >= MAX_MOB)
//			continue;
//
//		for (int k = 0; k < MAX_SUMMONLIST; k++)
//		{
//			if (pMob[partyconn].MOB.Equip[0].sIndex == mSummon.Mob[k].Equip[0].sIndex && mSummon.Mob[k].Equip[0].sIndex != sFace)
//			{
//				return 0;
//			}
//		}
//
//		if (pMob[partyconn].MOB.Equip[0].sIndex != sFace || SummonID >= MAX_SUMMONLIST)
//			continue;
//
//		int posX = pMob[conn].TargetX;
//		int posY = pMob[conn].TargetY;
//		SummonNum++;
//		if (GetEmptyMobGrid(partyconn, &posX, &posY) != 0 && GetInView(conn, partyconn) == FALSE)
//		{
//			MSG_Action sm;
//			memset(&sm, 0, sizeof(MSG_Action));
//
//			GetAction(partyconn, posX, posY, &sm);
//
//			sm.Effect = 8;
//			sm.Speed = 6;
//
//			GridMulticast(partyconn, posX, posY, (MSG_STANDARD*)&sm);
//
//			if (SummonNum >= Num)
//				return 0;
//			else
//				continue;
//		}
//		else if (SummonNum >= Num)
//			return 0;
//	}
//	for (int i = SummonNum; i < Num; i++)
//	{
//		MobEmpty = GetEmptyNPCMob();
//
//		if (MobEmpty == 0)
//		{
//			SendClientMessage(conn, g_pMessageStringTable[_NN_Cant_Create_More_Summons]);
//
//			return 0;
//		}
//		int j = 0;
//
//		for (j = 0; j < MAX_PARTY; j++)
//		{
//			if (pMob[Leader].Evocations[j])
//				continue;
//
//			else
//				break;
//		}
//
//		if (j >= MAX_PARTY)
//		{
//			SendClientMessage(conn, g_pMessageStringTable[_NN_Party_Full_Cant_Summon]);
//			return 0;
//		}
//
//		memset(pMob[MobEmpty].Evocations, 0, sizeof(pMob[MobEmpty].Evocations));
//		memcpy(&pMob[MobEmpty], &mSummon.Mob[SummonID], sizeof(mSummon.Mob[SummonID]));
//
//		pMob[MobEmpty].MOB.BaseScore.Level = pMob[conn].MOB.BaseScore.Level <= MAX_LEVEL ? pMob[conn].MOB.BaseScore.Level : MAX_LEVEL;
//
//		strcat(pMob[MobEmpty].MOB.MobName, "^");
//
//		for (int k = 0; k < NAME_LENGTH; k++)
//		{
//			if (pMob[MobEmpty].MOB.MobName[k] == '_')
//				pMob[MobEmpty].MOB.MobName[k] = ' ';
//		}
//
//		memset(pMob[MobEmpty].Affect, 0, sizeof(pMob[MobEmpty].Affect));
//
//		int Con = pMob[conn].MOB.CurrentScore.Con;
//		int Evocacao = pMob[conn].MOB.CurrentScore.Special[2];
//
//		int sBase = Con * pSummonBonus[SummonID].Unk / 100;
//		int sMax = Evocacao * pSummonBonus[SummonID].Unk2 / 100;
//
//		pMob[MobEmpty].MOB.BaseScore.Damage += sMax + sBase;
//
//		sBase = Con * pSummonBonus[SummonID].Unk3 / 100;
//		sMax = Evocacao * pSummonBonus[SummonID].Unk4 / 100;
//
//		pMob[MobEmpty].MOB.BaseScore.Ac += sMax + sBase;
//
//		sBase = Con * pSummonBonus[SummonID].Unk5 / 100;
//		sMax = Evocacao * pSummonBonus[SummonID].Unk6 / 100;
//
//		pMob[MobEmpty].MOB.BaseScore.MaxHp += sMax + sBase;
//
//		pMob[MobEmpty].MOB.CurrentScore.MaxHp = pMob[MobEmpty].MOB.BaseScore.MaxHp;
//
//		pMob[MobEmpty].GenerateIndex = -1;
//
//		pMob[MobEmpty].Formation = 5;
//
//		pMob[MobEmpty].RouteType = 5;
//		pMob[MobEmpty].Mode = MOB_PEACE;
//
//		//	*(int*)&pMob[MobEmpty].Unk6[64] = 0;
//		//	*(int*)&pMob[MobEmpty].Unk6[60] = 0;
//
//		pMob[MobEmpty].SegmentProgress = 0;
//		pMob[MobEmpty].SegmentDirection = 0;
//
//		memset(&pMob[MobEmpty].SegmentX, 0, sizeof(pMob[MobEmpty].SegmentX));
//		memset(&pMob[MobEmpty].SegmentY, 0, sizeof(pMob[MobEmpty].SegmentY));
//
//		//	memset(pMob[MobEmpty].Unk6, 0, 20);
//		//	memset(&pMob[MobEmpty].Unk6[20], 0, 20);
//
//		pMob[MobEmpty].Leader = Leader;
//		pMob[MobEmpty].LastTime = CurrentTime;
//
//		if (sItem != 0)
//		{
//			int mountsanc = BASE_GetItemAbility(sItem, EF_MOUNTSANC);
//
//			if (mountsanc >= 100)
//				mountsanc = 100;
//
//			int face = pMob[MobEmpty].MOB.Equip[0].sIndex;
//			int con = 0;
//
//			if (face >= 315 && face < 345)
//			{
//				int mcon = /*0x4C7974[face]*/0; // Voltar e identificar essa var
//				int mUnk = mcon / 2 - 1000;
//				int mUnk2 = mcon - mUnk;
//
//				con = mountsanc * (mcon - mUnk) / 100 + mcon / 2 - 1000;
//			}
//
//			pMob[MobEmpty].MOB.BaseScore.Con = con;
//			pMob[MobEmpty].MOB.CurrentScore.Con = con;
//
//			pMob[MobEmpty].MOB.BaseScore.Damage += 6 * BASE_GetItemAbility(sItem, EF_MOUNTSANC);
//			pMob[MobEmpty].MOB.CurrentScore.Damage = pMob[MobEmpty].MOB.BaseScore.Damage;
//		}
//
//		if (pMob[conn].GuildDisable == 0)
//		{
//			pMob[MobEmpty].MOB.Guild = pMob[MobEmpty].MOB.Guild;
//			pMob[MobEmpty].MOB.GuildLevel = 0;
//		}
//
//		GetGuild(MobEmpty);
//
//
//		pMob[MobEmpty].MOB.CurrentScore.Hp = pMob[MobEmpty].MOB.CurrentScore.MaxHp;
//
//		if (pMob[conn].MOB.Equip[15].sIndex == 543 || pMob[conn].MOB.Equip[15].sIndex == 545)
//		{
//			memset(&pMob[MobEmpty].MOB.Equip[15], 0, sizeof(STRUCT_ITEM));
//			pMob[MobEmpty].MOB.Equip[15].sIndex = 734;
//		}
//
//		if (pMob[conn].MOB.Equip[15].sIndex == 544 || pMob[conn].MOB.Equip[15].sIndex == 546)
//		{
//			memset(&pMob[MobEmpty].MOB.Equip[15], 0, sizeof(STRUCT_ITEM));
//			pMob[MobEmpty].MOB.Equip[15].sIndex = 735;
//		}
//
//		if (pMob[conn].MOB.Equip[15].sIndex == 548 || pMob[conn].MOB.Equip[15].sIndex == 549)
//		{
//			memset(&pMob[MobEmpty].MOB.Equip[15], 0, sizeof(STRUCT_ITEM));
//			pMob[MobEmpty].MOB.Equip[15].sIndex = 550;
//		}
//
//		pMob[MobEmpty].MOB.Clan = 4;
//
//		pMob[MobEmpty].GetCurrentScore(MAX_USER);
//
//		memset(pMob[MobEmpty].EnemyList, 0, sizeof(pMob[MobEmpty].EnemyList));
//
//		int posX = pMob[conn].TargetX;
//		int posY = pMob[conn].TargetY;
//
//		int tmob = GetEmptyMobGrid(MobEmpty, &posX, &posY);
//
//		if (tmob == 0)
//		{
//			pMob[MobEmpty].Mode = MOB_EMPTY;
//
//			return 0;
//		}
//
//		pMob[MobEmpty].TargetX = posX;
//		pMob[MobEmpty].LastX = posX;
//		pMob[MobEmpty].TargetY = posY;
//		pMob[MobEmpty].LastY = posY;
//
//		if (sItem == 0)
//		{
//			pMob[MobEmpty].Affect[0].Type = 24;
//			pMob[MobEmpty].Affect[0].Value = 0;
//			pMob[MobEmpty].Affect[0].Level = 0;
//			pMob[MobEmpty].Affect[0].Time = 20;
//
//			if (SummonID >= 28 && SummonID <= 37)
//				pMob[MobEmpty].Affect[0].Time = 2000000000;
//		}
//
//		if (sItem != 0)
//		{
//			if (sItem->stEffect[0].sValue > pMob[MobEmpty].MOB.CurrentScore.MaxHp)
//				sItem->stEffect[0].sValue = pMob[MobEmpty].MOB.CurrentScore.MaxHp;
//
//			pMob[MobEmpty].MOB.BaseScore.Hp = sItem->stEffect[0].sValue;
//			pMob[MobEmpty].MOB.CurrentScore.Hp = pMob[MobEmpty].MOB.BaseScore.Hp;
//		}
//		MSG_CreateMob sm;
//		memset(&sm, 0, sizeof(MSG_CreateMob));
//
//		GetCreateMob(MobEmpty, &sm);
//
//		sm.CreateType |= 3u;
//		pMobGrid[posY][posX] = MobEmpty;
//
//		GridMulticast(posX, posY, (MSG_STANDARD*)&sm, 0);
//
//		pMob[Leader].Evocations[j] = MobEmpty;
//		pMob[MobEmpty].Leader = Leader;
//
//		/*if (SummonNum == 0)
//			SendAddParty(Leader, Leader, 0);
//
//		SendAddParty(MobEmpty, Leader, 0);
//
//		if (SummonNum == 0)
//			SendAddParty(MobEmpty, MobEmpty, j + 1);
//
//		SendAddParty(Leader, MobEmpty, j + 1);*/
//
//		if (SummonNum == 0)
//			SendAddPartyEvocation(Leader);
//		if (SummonNum == 0)
//			 SendAddPartyEvocation(MobEmpty);
//		for (int l = 0; l < MAX_PARTY; l++)
//		{
//			if (pMob[Leader].Evocations[l] == 0)
//				continue;
//
//			if (pMob[Leader].Evocations[l] != MobEmpty)
//				SendAddPartyEvocation(pMob[Leader].Evocations[l]), SendAddPartyEvocation(MobEmpty);
//
//		}
//
//		pMob[MobEmpty].Summoner = conn;
//	}
//	return 1;
//}

int GenerateSummon(int conn, int SummonID, STRUCT_ITEM* sItem, int Num)
{
	int Leader = pMob[conn].Leader;

	if (Leader <= 0)
		Leader = conn;

	int MobEmpty = GetEmptyNPCMob();

	if (MobEmpty == 0)
	{
		SendClientMessage(conn, g_pMessageStringTable[_NN_Cant_Create_More_Summons]);

		return 0;
	}

	if (SummonID < 0 || SummonID >= MAX_SUMMONLIST)
		return 0;

	int sFace = mSummon.Mob[SummonID].Equip[0].sIndex;
	int Unk = 0;
	int SummonNum = 0;

	int IsSummonOther = 0;

	for (int i = 0; i < MAX_PARTY; i++)
	{
		int partyconn = pMob[Leader].PartyList[i];

		if (partyconn == 0)
			continue;

		if (partyconn <= 0 || partyconn >= MAX_MOB)
			continue;

		for (int k = 0; k < MAX_SUMMONLIST; k++)
		{
			if (pMob[partyconn].MOB.Equip[0].sIndex == mSummon.Mob[k].Equip[0].sIndex && mSummon.Mob[k].Equip[0].sIndex != sFace)
			{
				return 0;
			}
		}

		if (pMob[partyconn].MOB.Equip[0].sIndex != sFace || SummonID >= MAX_SUMMONLIST)
			continue;

		int posX = pMob[conn].TargetX;
		int posY = pMob[conn].TargetY;

		SummonNum++;


		if (GetEmptyMobGrid(partyconn, &posX, &posY) != 0 && GetInView(conn, partyconn) == FALSE)
		{
			MSG_Action sm;
			memset(&sm, 0, sizeof(MSG_Action));

			GetAction(partyconn, posX, posY, &sm);

			sm.Effect = 8;
			sm.Speed = 6;

			GridMulticast(partyconn, posX, posY, (MSG_STANDARD*)&sm);

			if (SummonNum >= Num)
				return 0;
			else
				continue;
		}
		else if (SummonNum >= Num)
			return 0;
	}
	for (int i = SummonNum; i < Num; i++)
	{
		MobEmpty = GetEmptyNPCMob();

		if (MobEmpty == 0)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Cant_Create_More_Summons]);

			return 0;
		}
		int j = 0;

		for (j = 0; j < MAX_PARTY; j++)
		{
			if (pMob[Leader].PartyList[j])
				continue;

			else
				break;
		}

		if (j >= MAX_PARTY)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Party_Full_Cant_Summon]);

			return 0;
		}

		memset(pMob[MobEmpty].PartyList, 0, sizeof(pMob[MobEmpty].PartyList));
		memcpy(&pMob[MobEmpty], &mSummon.Mob[SummonID], sizeof(mSummon.Mob[SummonID]));

		pMob[MobEmpty].MOB.BaseScore.Level = pMob[conn].MOB.BaseScore.Level <= MAX_LEVEL ? pMob[conn].MOB.BaseScore.Level : MAX_LEVEL;

		strcat(pMob[MobEmpty].MOB.MobName, "^");

		for (int k = 0; k < NAME_LENGTH; k++)
		{
			if (pMob[MobEmpty].MOB.MobName[k] == '_')
				pMob[MobEmpty].MOB.MobName[k] = ' ';
		}

		memset(pMob[MobEmpty].Affect, 0, sizeof(pMob[MobEmpty].Affect));

		//Escalonamento de evocações
		int Int = pMob[conn].MOB.CurrentScore.Int;
		int Con = pMob[conn].MOB.CurrentScore.Con;
		int Evocacao = pMob[conn].MOB.CurrentScore.Special[2];

		int sBase = (Con + Int) * pSummonBonus[SummonID].Unk / 60;
		int sMax = Evocacao * pSummonBonus[SummonID].Unk2 / 60;

		pMob[MobEmpty].MOB.BaseScore.Damage += sMax + sBase;

		sBase = (Con + Int) * pSummonBonus[SummonID].Unk3 / 100;
		sMax = Evocacao * pSummonBonus[SummonID].Unk4 / 100;

		pMob[MobEmpty].MOB.BaseScore.Ac += sMax + sBase;

		sBase = (Con + Int) * pSummonBonus[SummonID].Unk5 / 70;
		sMax = Evocacao * pSummonBonus[SummonID].Unk6 / 70;

		pMob[MobEmpty].MOB.BaseScore.MaxHp += sMax + sBase;

		pMob[MobEmpty].MOB.CurrentScore.MaxHp = pMob[MobEmpty].MOB.BaseScore.MaxHp;

		pMob[MobEmpty].GenerateIndex = -1;

		pMob[MobEmpty].Formation = 5;

		pMob[MobEmpty].RouteType = 5;
		pMob[MobEmpty].Mode = MOB_PEACE;

		//	*(int*)&pMob[MobEmpty].Unk6[64] = 0;
		//	*(int*)&pMob[MobEmpty].Unk6[60] = 0;

		pMob[MobEmpty].SegmentProgress = 0;
		pMob[MobEmpty].SegmentDirection = 0;

		memset(&pMob[MobEmpty].SegmentX, 0, sizeof(pMob[MobEmpty].SegmentX));
		memset(&pMob[MobEmpty].SegmentY, 0, sizeof(pMob[MobEmpty].SegmentY));

		//	memset(pMob[MobEmpty].Unk6, 0, 20);
		//	memset(&pMob[MobEmpty].Unk6[20], 0, 20);

		pMob[MobEmpty].Leader = Leader;
		pMob[MobEmpty].LastTime = CurrentTime;

		if (sItem != 0)
		{
			int mountsanc = BASE_GetItemAbility(sItem, EF_MOUNTSANC);

			if (mountsanc >= 100)
				mountsanc = 100;

			int face = pMob[MobEmpty].MOB.Equip[0].sIndex;
			int con = 0;

			if (face >= 315 && face < 345)
			{
				int mcon = /*0x4C7974[face]*/0; // Voltar e identificar essa var
				int mUnk = mcon / 2 - 1000;
				int mUnk2 = mcon - mUnk;

				con = mountsanc * (mcon - mUnk) / 100 + mcon / 2 - 1000;
			}

			pMob[MobEmpty].MOB.BaseScore.Con = con;
			pMob[MobEmpty].MOB.CurrentScore.Con = con;

			pMob[MobEmpty].MOB.BaseScore.Damage += 6 * BASE_GetItemAbility(sItem, EF_MOUNTSANC);
			pMob[MobEmpty].MOB.CurrentScore.Damage = pMob[MobEmpty].MOB.BaseScore.Damage;
		}

		if (pMob[conn].GuildDisable == 0)
		{
			pMob[MobEmpty].MOB.Guild = pMob[MobEmpty].MOB.Guild;
			pMob[MobEmpty].MOB.GuildLevel = 0;
		}

		GetGuild(MobEmpty);


		pMob[MobEmpty].MOB.CurrentScore.Hp = pMob[MobEmpty].MOB.CurrentScore.MaxHp;

		if (pMob[conn].MOB.Equip[15].sIndex == 543 || pMob[conn].MOB.Equip[15].sIndex == 545)
		{
			memset(&pMob[MobEmpty].MOB.Equip[15], 0, sizeof(STRUCT_ITEM));
			pMob[MobEmpty].MOB.Equip[15].sIndex = 734;
		}

		if (pMob[conn].MOB.Equip[15].sIndex == 544 || pMob[conn].MOB.Equip[15].sIndex == 546)
		{
			memset(&pMob[MobEmpty].MOB.Equip[15], 0, sizeof(STRUCT_ITEM));
			pMob[MobEmpty].MOB.Equip[15].sIndex = 735;
		}

		if (pMob[conn].MOB.Equip[15].sIndex == 548 || pMob[conn].MOB.Equip[15].sIndex == 549)
		{
			memset(&pMob[MobEmpty].MOB.Equip[15], 0, sizeof(STRUCT_ITEM));
			pMob[MobEmpty].MOB.Equip[15].sIndex = 550;
		}

		pMob[MobEmpty].MOB.Clan = 4;

		pMob[MobEmpty].GetCurrentScore(MAX_USER);

		memset(pMob[MobEmpty].EnemyList, 0, sizeof(pMob[MobEmpty].EnemyList));

		int posX = pMob[conn].TargetX;
		int posY = pMob[conn].TargetY;

		int tmob = GetEmptyMobGrid(MobEmpty, &posX, &posY);

		if (tmob == 0)
		{
			pMob[MobEmpty].Mode = MOB_EMPTY;

			return 0;
		}

		pMob[MobEmpty].TargetX = posX;
		pMob[MobEmpty].LastX = posX;
		pMob[MobEmpty].TargetY = posY;
		pMob[MobEmpty].LastY = posY;

		if (sItem == 0)
		{
			pMob[MobEmpty].Affect[0].Type = 24;
			pMob[MobEmpty].Affect[0].Value = 0;
			pMob[MobEmpty].Affect[0].Level = 0;
			pMob[MobEmpty].Affect[0].Time = 20;

			if (SummonID >= 28 && SummonID <= 37)
				pMob[MobEmpty].Affect[0].Time = 2000000000;
		}

		if (sItem != 0)
		{
			if (sItem->stEffect[0].sValue > pMob[MobEmpty].MOB.CurrentScore.MaxHp)
				sItem->stEffect[0].sValue = pMob[MobEmpty].MOB.CurrentScore.MaxHp;

			pMob[MobEmpty].MOB.BaseScore.Hp = sItem->stEffect[0].sValue;
			pMob[MobEmpty].MOB.CurrentScore.Hp = pMob[MobEmpty].MOB.BaseScore.Hp;
		}
		MSG_CreateMob sm;
		memset(&sm, 0, sizeof(MSG_CreateMob));

		GetCreateMob(MobEmpty, &sm);

		sm.CreateType |= 3u;
		pMobGrid[posY][posX] = MobEmpty;

		GridMulticast(posX, posY, (MSG_STANDARD*)&sm, 0);

		pMob[Leader].PartyList[j] = MobEmpty;
		pMob[MobEmpty].Leader = Leader;

		if (SummonNum == 0)
			SendAddParty(Leader, Leader, 0);

		SendAddParty(MobEmpty, Leader, 0);

		if (SummonNum == 0)
			SendAddParty(MobEmpty, MobEmpty, j + 1);

		SendAddParty(Leader, MobEmpty, j + 1);

		for (int l = 0; l < MAX_PARTY; l++) //09/03
		{
			if (pMob[Leader].PartyList[l] == 0)
				continue;

			if (pMob[Leader].PartyList[l] != MobEmpty)
				SendAddParty(pMob[Leader].PartyList[l], MobEmpty, l + 1);

			SendAddParty(MobEmpty, pMob[Leader].PartyList[l], l + 1);
		}

		pMob[MobEmpty].Summoner = conn;
		pMob[MobEmpty].IsSummon = 1; // Crias/Outros

		if (SummonID >= 0 && SummonID <= 7)
			pMob[MobEmpty].IsSummon = 2; // Evocações
	}
	return 1;
}

int CreateMob(char* MobName, int PosX, int PosY, char* folder, int Type)
{
	int tmob = GetEmptyNPCMob();

	if (tmob == 0)
	{
		sprintf_s(temp, "err,no emptymob create %s", MobName);
		SystemLog("-system", "-", 0, temp);

		return -1;
	}

	strncpy(pMob[tmob].MOB.MobName, MobName, NAME_LENGTH);

	memset(&pMob[tmob].PartyList, 0, sizeof(pMob[tmob].PartyList));

	int read = ReadMob(&pMob[tmob].MOB, folder);

	if (read == 0)
		return 0;

	pMob[tmob].MOB.MobName[NAME_LENGTH - 1] = 0;
	pMob[tmob].MOB.BaseScore.Merchant = 0;


	for (int i = 0; i < NAME_LENGTH; i++)
	{
		if (pMob[tmob].MOB.MobName[i] == 95)
			pMob[tmob].MOB.MobName[i] = 32;

		if (pMob[tmob].MOB.MobName[i] == '@')
			pMob[tmob].MOB.MobName[i] = 0;
	}
	memset(pMob[tmob].Affect, 0, sizeof(pMob[tmob].Affect));


	for (int i = 0; i < MAX_SEGMENT; i++)
	{
		if (pMob[tmob].MOB.Equip[0].sIndex != 220 && pMob[tmob].MOB.Equip[0].sIndex != 219 && pMob[tmob].MOB.Equip[0].sIndex != 358)
		{
			pMob[tmob].SegmentListX[i] = PosX + rand() % 5 - 2;
			pMob[tmob].SegmentListY[i] = PosY + rand() % 5 - 2;
		}

		else
		{
			pMob[tmob].SegmentListX[i] = PosX;
			pMob[tmob].SegmentListY[i] = PosY;
		}
	}


	if (pMob[tmob].MOB.Equip[0].sIndex == 220 || pMob[tmob].MOB.Equip[0].sIndex == 219)
	{
		if (pMob[tmob].MOB.Equip[0].sIndex == 219)
		{
			pMob[tmob].MOB.Guild = g_pGuildZone[4].ChargeGuild;
			pMob[tmob].MOB.GuildLevel = 0;
		}
	}

	pMob[tmob].GenerateIndex = -1;

	pMob[tmob].Formation = 0;

	pMob[tmob].RouteType = Type;
	pMob[tmob].Mode = MOB_PEACE;

	pMob[tmob].SegmentDirection = 0;

	pMob[tmob].Leader = 0;
	pMob[tmob].WaitSec = Type == 0 ? 10 : 40;
	pMob[tmob].LastTime = CurrentTime;

	pMob[tmob].GetCurrentScore(MAX_USER);
	pMob[tmob].MOB.CurrentScore.Hp = pMob[tmob].MOB.CurrentScore.MaxHp;

	if (NewbieEventServer && pMob[tmob].MOB.CurrentScore.Level < 120)
		pMob[tmob].MOB.CurrentScore.Hp = 3 * pMob[tmob].MOB.CurrentScore.Hp / 4;

	pMob[tmob].SegmentProgress = Type == 0 ? 0 : 4;

	memset(pMob[tmob].EnemyList, 0, sizeof(pMob[tmob].EnemyList));

	int px = pMob[tmob].SegmentListX[0];
	int py = pMob[tmob].SegmentListY[0];

	int mobslot = GetEmptyMobGrid(tmob, &px, &py);

	if (mobslot == 0)
	{
		sprintf_s(temp, "err,No empty mobgrid:%s x:%d y:%d", MobName, px, py);
		SystemLog("-system", "-", 0, temp);

		pMob[tmob].Mode = 0;
		pMob[tmob].MOB.MobName[0] = 0;
		pMob[tmob].GenerateIndex = -1;

		return -2;
	}

	pMob[tmob].SegmentX = px;
	pMob[tmob].TargetX = px;
	pMob[tmob].LastX = px;
	pMob[tmob].SegmentY = py;
	pMob[tmob].TargetY = py;
	pMob[tmob].LastY = py;

	int skillnum = pMob[tmob].MOB.BaseScore.MaxMp;

	if (skillnum)
	{
		SetAffect(tmob, skillnum, 30000, 200);
		SetTick(tmob, skillnum, 30000, 200);
	}

	MSG_CreateMob sm;
	memset(&sm, 0, sizeof(MSG_CreateMob));

	GetCreateMob(tmob, &sm);

	sm.CreateType |= 2;

	pMobGrid[py][px] = tmob;

	GridMulticast(px, py, (MSG_STANDARD*)&sm, 0);

	return TRUE;
}

void GenerateMob(int index, int PosX, int PosY)
{
	int GenerateMin = mNPCGen.pList[index].MinuteGenerate;

	int nindex = index;

	for (int i = 0; i < MAX_MOB_MERC; i++)
	{
		if (index != pMobMerc[i].GenerateIndex || index == 0)
			continue;

		memcpy(mNPCGen.pList[index].Leader.Carry, pMobMerc[i].Carry, sizeof(mNPCGen.pList[index].Leader.Carry));
		break;
	}

	if (GenerateMin >= 500)
	{
		int segx = mNPCGen.pList[index].SegmentListX[0];
		int segy = mNPCGen.pList[index].SegmentListY[0];

		int res = segx - segy;

		if ((segx - segy) <= 0)
		{
			Log("err,end index < start index", "-system", 0);
			printf("Index Error. Index %d, PosX %d, PosY %d", index, PosX, PosY);  //monitor console
			return;
		}

		int reloc = rand() % segx + segy;
		if (reloc < 0 || reloc >= mNPCGen.NumList)
			Log("err,wrong index relocation", "-system", 0);

		index = reloc;
	}

	int Formation = mNPCGen.pList[nindex].Formation;
	int MinGroup = mNPCGen.pList[nindex].MinGroup;

	int qmob = mNPCGen.pList[nindex].MaxGroup - mNPCGen.pList[nindex].MinGroup + 1;

	if (qmob <= 0)
	{
		sprintf_s(temp, "err,zero divide : %d", index);
		SystemLog("-system", "-", 0, temp);
		qmob = 1;
	}

	MinGroup += rand() % qmob;

	if (mNPCGen.pList[nindex].CurrentNumMob >= mNPCGen.pList[nindex].MaxNumMob)
		return;

	if (mNPCGen.pList[nindex].CurrentNumMob + MinGroup > mNPCGen.pList[nindex].MaxNumMob)
		MinGroup = mNPCGen.pList[nindex].MaxNumMob - mNPCGen.pList[nindex].CurrentNumMob;

	int tmob = GetEmptyNPCMob();

	if (tmob == 0)
	{
		//sprintf_s(temp, "err,no emptymob leader: %d", index);
		//SystemLog("-system", "-", 0, temp);

		return;
	}

	if (mNPCGen.pList[index].Leader.Equip[0].sIndex != 219 && mNPCGen.pList[index].SegmentListX[0] >= 2440 && mNPCGen.pList[index].SegmentListX[0] <= 2545 && mNPCGen.pList[index].SegmentListY[0] >= 1845 && mNPCGen.pList[index].SegmentListY[0] <= 1921)
	{
		mNPCGen.pList[index].MinuteGenerate = -1;
		return;
	}

	int tmob2 = tmob;

	memset(&pMob[tmob].PartyList, 0, sizeof(pMob[tmob].PartyList));
	memcpy(&pMob[tmob].MOB, &mNPCGen.pList[nindex].Leader, sizeof(STRUCT_MOB));

	pMob[tmob].MOB.MobName[NAME_LENGTH - 1] = 0;
	pMob[tmob].MOB.BaseScore.Merchant = 0;

	strncpy(pMob[tmob].MOB.MobName, mNPCGen.pList[nindex].Leader.MobName, NAME_LENGTH);

	if (strcmp(pMob[tmob].MOB.MobName, mNPCGen.pList[nindex].Leader.MobName) != 0)
		memcpy(pMob[tmob].MOB.MobName, mNPCGen.pList[nindex].Leader.MobName, NAME_LENGTH);

	for (int i = 0; i < NAME_LENGTH; i++)
	{
		if (pMob[tmob].MOB.MobName[i] == 95)
			pMob[tmob].MOB.MobName[i] = 32;

		if (pMob[tmob].MOB.MobName[i] == 64)
			pMob[tmob].MOB.MobName[i] = 32;
	}
	memset(pMob[tmob].Affect, 0, sizeof(pMob[tmob].Affect));

	for (int i = 0; i < MAX_SEGMENT; i++)
	{
		if (mNPCGen.pList[index].SegmentListX[i])
		{
			if (mNPCGen.pList[index].SegmentRange[i])
			{
				pMob[tmob].SegmentListX[i] = mNPCGen.pList[index].SegmentListX[i]
					- mNPCGen.pList[index].SegmentRange[i] + (rand() % (mNPCGen.pList[index].SegmentRange[i] + 1));

				pMob[tmob].SegmentListY[i] = mNPCGen.pList[index].SegmentListY[i]
					- mNPCGen.pList[index].SegmentRange[i] + (rand() % (mNPCGen.pList[index].SegmentRange[i] + 1));
			}
			else
			{
				pMob[tmob].SegmentListX[i] = mNPCGen.pList[index].SegmentListX[i];
				pMob[tmob].SegmentListY[i] = mNPCGen.pList[index].SegmentListY[i];
			}
			pMob[tmob].SegmentWait[i] = mNPCGen.pList[index].SegmentWait[i];
		}
		else
		{
			pMob[tmob].SegmentListX[i] = 0;
			pMob[tmob].SegmentListY[i] = 0;
		}
	}

	if (PosX && PosY)
	{
		for (int i = 0; i < MAX_SEGMENT; i++)
		{
			pMob[tmob].SegmentListX[i] = PosX;
			pMob[tmob].SegmentListY[i] = PosY;
		}
	}

	if (pMob[tmob].MOB.Equip[0].sIndex == 220 || pMob[tmob].MOB.Equip[0].sIndex == 219)
	{
		int br = BrState;
		if (BrState > 0 && br < MAX_USER)
		{
			if (pUser[br].Mode == USER_PLAY && RvRState == 0 && GTorreState == 0)
			{
				*(int*)&pMob[tmob].MOB.Equip[15] = *(int*)&pMob[br].MOB.Equip[15];
				*(int*)(&pMob[tmob].MOB.Equip[15] + 4) = *(int*)(&pMob[br].MOB.Equip[15] + 4);

				if (pMob[tmob].MOB.Equip[0].sIndex == 219)
				{
					pMob[tmob].MOB.Guild = pMob[br].MOB.Guild;

					GetGuild(tmob);

					if (pMob[br].MOB.GuildLevel == 9)
						pMob[tmob].MOB.GuildLevel = 0;
				}
			}
		}
	}

	CWarTower::GGenerateMob(index, PosX, PosY, tmob);
 

	pMob[tmob].GenerateIndex = index;
	pMob[tmob].IsSummon = 0;

	pMob[tmob].Formation = mNPCGen.pList[nindex].Formation;

	pMob[tmob].RouteType = mNPCGen.pList[nindex].RouteType;
	pMob[tmob].Mode = MOB_PEACE;

	pMob[tmob].SegmentDirection = 0;

	pMob[tmob].Leader = 0;
	pMob[tmob].WaitSec = pMob[tmob].SegmentWait[0];
	pMob[tmob].LastTime = CurrentTime;

	pMob[tmob].GetCurrentScore(MAX_USER);
	pMob[tmob].MOB.CurrentScore.Hp = pMob[tmob].MOB.CurrentScore.MaxHp;

	if (NewbieEventServer && pMob[tmob].MOB.CurrentScore.Level < 120)
		pMob[tmob].MOB.CurrentScore.Hp = 3 * pMob[tmob].MOB.CurrentScore.Hp / 4;

	pMob[tmob].SegmentProgress = 0;

	memset(pMob[tmob].EnemyList, 0, sizeof(pMob[tmob].EnemyList));

	if (pMob[tmob].MOB.Clan == 1 && rand() % 10 == 1)
		pMob[tmob].MOB.Clan = 2;

	int mobslot = GetEmptyMobGrid(tmob, &pMob[tmob].SegmentListX[0], &pMob[tmob].SegmentListY[0]);

	if (mobslot == 0)
	{
		sprintf_s(temp, "err,No empty mobgrid(1): %d %d %d", index, pMob[tmob].SegmentListX[0], pMob[tmob].SegmentListY[0]);
		SystemLog("-system", "-", 0, temp);

		pMob[tmob].Mode = 0;
		pMob[tmob].MOB.MobName[0] = 0;
		pMob[tmob].GenerateIndex = -1;

		return;
	}

	//Imposto
	if (pMob[tmob].MOB.Merchant == 6 && tmob >= MAX_USER)
	{
		int level = pMob[tmob].MOB.CurrentScore.Level;

		GuildImpostoID[level] = tmob;
		pMob[tmob].MOB.Guild = g_pGuildZone[level].ChargeGuild;
	}


	pMob[tmob].SegmentX = pMob[tmob].SegmentListX[0];
	pMob[tmob].TargetX = pMob[tmob].SegmentListX[0];
	pMob[tmob].LastX = pMob[tmob].SegmentListX[0];
	pMob[tmob].SegmentY = pMob[tmob].SegmentListY[0];
	pMob[tmob].TargetY = pMob[tmob].SegmentListY[0];
	pMob[tmob].LastY = pMob[tmob].SegmentListY[0];

	if (mNPCGen.pList[nindex].CurrentNumMob < 0)
		mNPCGen.pList[nindex].CurrentNumMob = 0;

	mNPCGen.pList[nindex].CurrentNumMob++;

	int skillnum = mNPCGen.pList[nindex].Leader.BaseScore.MaxMp;

	if (skillnum)
	{
		SetAffect(tmob, skillnum, 30000, 200);
		SetTick(tmob, skillnum, 30000, 200);
	}

	MSG_CreateMob sm;
	memset(&sm, 0, sizeof(MSG_CreateMob));
	GetCreateMob(tmob, &sm);

	sm.CreateType |= 2;

	pMobGrid[pMob[tmob].SegmentListY[0]][pMob[tmob].SegmentListX[0]] = tmob;

	GridMulticast(pMob[tmob].SegmentListX[0], pMob[tmob].SegmentListY[0], (MSG_STANDARD*)&sm, 0);

	for (int i = 0; i < MinGroup && i < MAX_PARTY; i++)
	{
		int tempmob = GetEmptyNPCMob();

		if (tempmob == 0)
		{
			pMob[tmob2].PartyList[i] = 0;

			sprintf_s(temp, "err,no empty mob: %d", index);

			SystemLog("-system", "-", 0, temp);
			continue;
		}

		memset(&pMob[tempmob].PartyList, 0, sizeof(pMob[tempmob].PartyList));

		pMob[tmob2].PartyList[i] = tempmob;

		memcpy(&pMob[tempmob], &mNPCGen.pList[nindex].Follower, sizeof(STRUCT_MOB));

		pMob[tempmob].MOB.BaseScore.Merchant = 0;

		strncpy(pMob[tempmob].MOB.MobName, mNPCGen.pList[nindex].Follower.MobName, NAME_LENGTH);

		for (int j = 0; j < NAME_LENGTH; ++j)
		{
			if (pMob[tempmob].MOB.MobName[j] == 95)
				pMob[tempmob].MOB.MobName[j] = 32;

			if (pMob[tempmob].MOB.MobName[j] == '@')
				pMob[tempmob].MOB.MobName[j] = 0;
		}
		memset(pMob[tempmob].Affect, 0, sizeof(pMob[tempmob].Affect));

		for (int j = 0; j < MAX_SEGMENT; j++)
		{
			if (mNPCGen.pList[index].SegmentRange[j])
			{
				pMob[tempmob].SegmentListX[j] = g_pFormation[i][j][Formation] + pMob[tmob].SegmentListX[j];

				pMob[tempmob].SegmentListY[j] = g_pFormation[i][j][Formation] + pMob[tmob].SegmentListY[j];


				pMob[tempmob].SegmentWait[j] = mNPCGen.pList[index].SegmentWait[j];
			}
			else
			{
				pMob[tempmob].SegmentListX[j] = mNPCGen.pList[index].SegmentListX[j];
				pMob[tempmob].SegmentListY[j] = mNPCGen.pList[index].SegmentListY[j];
			}
		}
		if (PosX && PosY)
		{
			for (int k = 0; k < MAX_SEGMENT; k++)
			{
				pMob[tempmob].SegmentListX[k] = PosX + rand() % 5 - 2;
				pMob[tempmob].SegmentListY[k] = PosY + rand() % 5 - 2;
			}
		}

		pMob[tempmob].GenerateIndex = index;

		pMob[tempmob].Formation = mNPCGen.pList[nindex].Formation;

		pMob[tempmob].RouteType = mNPCGen.pList[nindex].RouteType;
		pMob[tempmob].Mode = MOB_PEACE;

		pMob[tempmob].SegmentProgress = 0;

		pMob[tempmob].Leader = tmob2;
		pMob[tempmob].LastTime = CurrentTime;

		pMob[tempmob].GetCurrentScore(MAX_USER);
		pMob[tempmob].MOB.CurrentScore.Hp = pMob[tempmob].MOB.CurrentScore.MaxHp;

		if (NewbieEventServer && pMob[tempmob].MOB.CurrentScore.Level < 120)
			pMob[tempmob].MOB.CurrentScore.Hp = 3 * pMob[tempmob].MOB.CurrentScore.Hp / 4;

		pMob[tempmob].WaitSec = pMob[tempmob].SegmentWait[0];
		pMob[tempmob].SegmentDirection = 0;

		memset(pMob[tempmob].EnemyList, 0, sizeof(pMob[tempmob].EnemyList));

		if (pMob[tempmob].MOB.Clan == 1 && rand() % 10 == 1)
			pMob[tempmob].MOB.Clan = 2;

		int mslot = GetEmptyMobGrid(tempmob, &pMob[tempmob].SegmentListX[0], &pMob[tempmob].SegmentListY[0]);

		if (mslot == 0)
		{
			sprintf_s(temp, "err,No empty mobgrid: %d %d %d", index, pMob[tempmob].SegmentListX[0], pMob[tempmob].SegmentListY[0]);
			SystemLog("-system", "-", 0, temp);

			pMob[tempmob].Mode = 0;
			pMob[tempmob].MOB.MobName[0] = 0;
			pMob[tempmob].GenerateIndex = -1;
			pMob[tmob2].PartyList[i] = 0;

			return;
		}


		pMob[tempmob].SegmentX = pMob[tempmob].SegmentListX[0];
		pMob[tempmob].TargetX = pMob[tempmob].SegmentListX[0];
		pMob[tempmob].LastX = pMob[tempmob].SegmentListX[0];
		pMob[tempmob].SegmentY = pMob[tempmob].SegmentListY[0];
		pMob[tempmob].TargetY = pMob[tempmob].SegmentListY[0];
		pMob[tempmob].LastY = pMob[tempmob].SegmentListY[0];

		skillnum = mNPCGen.pList[nindex].Leader.BaseScore.MaxMp;

		if (skillnum)
		{
			SetAffect(tempmob, skillnum, 30000, 200);
			SetTick(tempmob, skillnum, 30000, 200);
		}

		MSG_CreateMob sm2;
		memset(&sm2, 0, sizeof(MSG_CreateMob));
		GetCreateMob(tempmob, &sm2);

		sm2.CreateType |= 2;

		pMobGrid[pMob[tempmob].SegmentListY[0]][pMob[tempmob].SegmentListX[0]] = tempmob;

		GridMulticast(pMob[tempmob].SegmentListX[0], pMob[tempmob].SegmentListY[0], (MSG_STANDARD*)&sm2, 0);

		if (mNPCGen.pList[nindex].CurrentNumMob < 0)
			mNPCGen.pList[nindex].CurrentNumMob = 0;

		mNPCGen.pList[nindex].CurrentNumMob++;
	}
}

 


void RebuildGenerator()
{
	for (int i = 0; i < mNPCGen.NumList; i++)
		mNPCGen.NumOld[i] = 0;

	for (int i = MAX_USER; i < MAX_MOB; i++)
	{
		if (pMob[i].Mode == 0)
			continue;

		int GenerateIndex = pMob[i].GenerateIndex;

		if (GenerateIndex >= 0 && GenerateIndex < mNPCGen.NumList)
			mNPCGen.NumOld[GenerateIndex]++;
	}

	for (int i = MAX_USER; i < mNPCGen.NumList; i++)
	{
		if (mNPCGen.pList[i].CurrentNumMob == mNPCGen.NumOld[i])
			continue;

		//sprintf(temp, "Idx:%d Name:%s Old:%d New:%d", i, mNPCGen.pList[i].Leader.MobName, mNPCGen.pList[i].CurrentNumMob, mNPCGen.NumOld[i]);

		//Log(temp, "-system", 0);

		mNPCGen.pList[i].CurrentNumMob = mNPCGen.NumOld[i];
	}
}

bool FileExist(const char* Name)
{
	if (FILE* file = fopen(Name, "r"))
	{
		fclose(file);
		return true;
	}
	return false;
}
BOOL InitApplication(HANDLE hInstance)
{
	WNDCLASS  wc;

	wc.style = CS_VREDRAW | CS_HREDRAW | CS_DBLCLKS;

	wc.lpfnWndProc = (WNDPROC)MainWndProc;
	wc.cbClsExtra = 0;
	wc.cbWndExtra = 0;
	wc.hIcon = (HICON)LoadIcon((HINSTANCE)hInstance, "MAINICON");
	wc.hInstance = (HINSTANCE)hInstance;
	wc.hCursor = LoadCursor(NULL, IDC_ARROW);
	wc.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
	wc.lpszMenuName = NULL;
	wc.lpszClassName = "MainClass";

	if (!RegisterClass(&wc))
		return RegisterClass(&wc);

	return TRUE;
}

BOOL InitInstance(HANDLE hInstance, int nCmdShow)
{
	hMainMenu = CreateMenu();
	hWndMain = CreateWindow("MainClass", "WYD v7.59",
		WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN,  
		CW_USEDEFAULT, CW_USEDEFAULT, 900, 600,  
		NULL, hMainMenu, (HINSTANCE)hInstance, NULL);

	if (!hWndMain)
		return (FALSE);

	ShowWindow(hWndMain, nCmdShow);
	UpdateWindow(hWndMain);

	return TRUE;
}

FILE*  WriteHeader(char *fileName)
{
	FILE *fp = NULL;

	fp = fopen(fileName, "wt");

	fprintf(fp, "<script>\n");
	fprintf(fp, "function f_show(idx) \n");
	fprintf(fp, "{\n");
	fprintf(fp, "opener.document.frmRegist.item_code.value=idx;\n");
	fprintf(fp, "self.close();\n");
	fprintf(fp, "}\n");
	fprintf(fp, "</script>\n");
	fprintf(fp, "<style><!--\n");
	fprintf(fp, "A:link {color:#111111;font-size:9pt;text-decoration:none}\n");
	fprintf(fp, "A:visited {color:#333333;font-size:9pt;text-decoration:none}\n");
	fprintf(fp, "A:active {color:red;font-size:9pt}\n");
	fprintf(fp, "A:hover {text-color:red;text-decoration:underline}\n");
	fprintf(fp, "BODY,TD,TH {font-size: 9pt}\n");
	fprintf(fp, "--></style>\n");

	return fp;
}

inline void FixIOHandles()
{
	int outParam = _open_osfhandle((long)GetStdHandle(STD_OUTPUT_HANDLE), _O_TEXT);
	FILE *stdout_stream = _fdopen(outParam, "w");
	*stdout = *stdout_stream;
	int inParam = _open_osfhandle((long)GetStdHandle(STD_INPUT_HANDLE), _O_TEXT);
	FILE *stdin_stream = _fdopen(inParam, "r");
	*stdin = *stdin_stream;
}

inline void CreateConsole()
{
	AllocConsole();
	FixIOHandles();
}

void  WriteArmor(FILE *fp)
{
}

BOOL WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
	MSG msg;

	g_pBlockIP.clear();
	UNREFERENCED_PARAMETER(lpCmdLine);

	if (!hPrevInstance)
		if (!InitApplication(hInstance))
			return FALSE;

	if (!InitInstance(hInstance, nCmdShow))
		return FALSE;

	hFont = CreateFont(12, 0, 0, 0, FW_LIGHT, FALSE, FALSE, FALSE, DEFAULT_CHARSET, OUT_DEVICE_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY, DEFAULT_PITCH, "Fixedsys"); // |FF_DECORATIVE

	BASE_InitModuleDir();
	BASE_InitializeHitRate();

	/*StartLog();
	StartChatLog();*/

	memset(&g_pTreasure, 0, sizeof(g_pTreasure));

	ReadDirectory();
	BASE_ReadQuestDiaria();
	ReadConfig();
	ReadLevelItemConfig();
	// Leitura de txt ao iniciar
	//ReadMarket();
	//ReadGuildPoints();
	//ReadEvent();
	//ReadEvent2();
	//ReadGItens();

	ConfigReady = 1;

	DrawConfig(0);

	memset(g_pGuildWar, 0, sizeof(g_pGuildWar));
	memset(g_pGuildAlly, 0, sizeof(g_pGuildAlly));
	memset(GuildInfo, 0, sizeof(GuildInfo));
	memset(pMac, 0, sizeof(pMac));
	memset(pMobMerc, 0, sizeof(pMobMerc));

	int ret = ListenSocket.WSAInitialize();

	if (!ret)
	{
		//Log("erro,não foi possivel iniciar a seguinte função : WSAInitialize", "-system", 0);

		return FALSE;
	}

	Reboot();
	ReadQuiz();

	StartSystemLog();
	StartChatLog();
	StartItemLog();
	CompositorLog(); // 23/02
	trade_item(); // 23/02
	MobDropLogs();

	SetCastleDoor(1);

	char name[255];

	FILE* fp = fopen("localip.txt", "rt");

	if (fp)
	{
		fscanf(fp, "%s", name);

		fclose(fp);
	}
	else
		MessageBox(hWndMain, "Não foi possivel encontrar o arquivo LocalIP.txt", "Erro ao iniciar", NULL);

	int r1 = 0, r2 = 0, r3 = 0, r4 = 0;

	sscanf(name, "%d.%d.%d.%d", &r1, &r2, &r3, &r4);

	LocalIP[0] = r1;
	LocalIP[1] = r2;
	LocalIP[2] = r3;
	LocalIP[3] = r4;
	DBServerAddress[0] = 0;

	for (int i = 0; i < MAX_SERVERGROUP; i++)
	{
		for (int j = 1; j < MAX_SERVERNUMBER; j++)
		{
			if (!strcmp(g_pServerList[i][j], name))
			{
				strncpy(DBServerAddress, g_pServerList[i][0], sizeof(DBServerAddress));

				ServerGroup = i;
				ServerIndex = j - 1;

				break;
			}
		}

		if (DBServerAddress[0] == 0)
			continue;
	}

	if (DBServerAddress[0] == 0)
	{
		MessageBox(hWndMain, "Não foi possivel pegar o ServerGroup. LocalIP.txt / ServerList.txt", "Erro ao iniciar", MB_OK | MB_SYSTEMMODAL);

		return TRUE;
	}

	DBServerPort = 7514;

	int *pip = (int*)LocalIP;

	ret = DBServerSocket.ConnectServer(DBServerAddress, 7514, *pip, WSA_READDB);

	if (ret == NULL)
	{
		Log("erro, Não foi possivel se conectar a DBServer", "-system", 0);
		MessageBox(hWndMain, "Não foi possivel se conectar a DBServer", "Erro ao iniciar", NULL);

		return FALSE;
	}

	for (int i = 1; i < MAX_SERVERNUMBER; i++)
	{
		if (g_pServerList[ServerGroup][i][0] != 0)
			NumServerInGroup++;
	}

	if (NumServerInGroup <= 0)
		NumServerInGroup = 1;

	if (NumServerInGroup > 10)
		NumServerInGroup = 10;

	//IP ERRADO
	//if (!strcmp(DBServerAddress, "")) 
		//TESTSERVER = 1;

	//IP ERRADO
	//if (!strcmp(DBServerAddress, ""))  
		//LOCALSERVER = 1;

	fp = fopen("biserver.txt", "rt");

	if (fp)
	{
		fscanf(fp, "%s %d", BillServerAddress, &BillServerPort);

		fclose(fp);
	}

	if (BILLING > 0)
	{
		int *pip2 = (int*)LocalIP;

		ret = BillServerSocket.ConnectBillServer(BillServerAddress, BillServerPort, *pip2, WSA_READBILL);

		if (ret == NULL)
		{
			Log("erro, Não foi possivel se conectar na BIServer", "-system", 0);
			BILLING = 0;
		}
		else
		{
			_AUTH_GAME sm;

			memset(&sm, 0, sizeof(sm));

			SendBilling2(&sm, 4); // MSG_BillLogin ?
		}
	}

	SetColoseumDoor(1);
	SetColoseumDoor2(3);

	memset(FailAccount, 0, sizeof(FailAccount));

	CurrentTime = timeGetTime();

	CReadFiles::CReadFiles();
	// CEncampment::ReadCamp();
	CCastleZakum::ReadCastleQuest();
	//CCubo::Initialize();

	SetTimer(hWndMain, TIMER_SEC, 500, NULL);
	SetTimer(hWndMain, TIMER_MIN, 12000, NULL);

	ListenSocket.StartListen(hWndMain, *pip, GAME_PORT, WSA_ACCEPT);

	GuildZoneReport();

	if (KefraLive == 0)
	{
		for (int k = KEFRA_MOB_INITIAL; k < KEFRA_MOB_END; k++)
			GenerateMob(k, 0, 0);

		GenerateMob(KEFRA_BOSS, 0, 0);
	}

	UpdateShopDonate1();
	UpdateShopDonate2();
	UpdateShopDonate3();
	LoadEvent();
	BalanceioPvP();
	ReadServerConfigs();
	ReadExpTableN();
	ReadExpTableM();

	while (GetMessage(&msg, NULL, 0, 0))
	{
		TranslateMessage(&msg);
		DispatchMessage(&msg);
	}

	return	msg.wParam;
}

void WriteWeapon(FILE *fp)
{
	fprintf(fp, "<body leftmargin=0 topmargin=0 marginwidth=0 marginheight=0><table>\n");

	for (int i = 0; i < 32; i++)
	{
		fprintf(fp, "<tr  height=10>");

		for (int j = 0; j < 9; j++)
		{
			char dest[256];

			int item = weapon[i][j];

			if (j == 0)
				strncpy(dest, "#F6EED9", sizeof(dest));
			if (j == 1)
				strncpy(dest, "#DFDFDF", sizeof(dest));
			if (j == 2)
				strncpy(dest, "#D9EAF6", sizeof(dest));
			if (j == 3)
				strncpy(dest, "#DFE9D0", sizeof(dest));
			if (j == 4)
				strncpy(dest, "#F6D9E0", sizeof(dest));
			if (j == 5)
				strncpy(dest, "#F6EED9", sizeof(dest));
			if (j == 6)
				strncpy(dest, "#DFDFDF", sizeof(dest));
			if (j == 7)
				strncpy(dest, "#D9EAF6", sizeof(dest));
			if (j == 8)
				strncpy(dest, "#DFE9D0", sizeof(dest));

			int reqlv = g_pItemList[item].ReqLvl;
			int reqstatus = g_pItemList[item].ReqCon + g_pItemList[item].ReqDex + g_pItemList[item].ReqInt + g_pItemList[item].ReqStr;

			if (reqlv || reqstatus <= 75)
			{
				if (reqlv || reqstatus <= 20)
					strncpy(temp, "#000000", sizeof(temp));
				else
					strncpy(temp, "#00BF00", sizeof(temp));
			}
			else
				strncpy(temp, "#FF00FF", sizeof(temp));

			fprintf(fp, "<td width=140 height=16 bgcolor='%s'><a href=\"javascript:f_show(%d); title='%d'><font color='%s'>%16.16s</font></a></td>",
				&dest, item, item, &temp, &g_pItemList[item].Name);
		}
		fprintf(fp, "</tr>\n");
	}
	fprintf(fp, "</table></body>\n");
}

void BuildList()
{

}

LONG APIENTRY MainWndProc(HWND hWnd, UINT message, UINT wParam, LONG lParam)
{
	switch (message)
	{

	case WM_TIMER:
	{
		if (wParam == TIMER_SEC)
			ProcessSecTimer();
		else if (wParam == TIMER_MIN)
			ProcessMinTimer();
	} break;

	case WSA_READBILL:
	{
		if (WSAGETSELECTEVENT(lParam) != FD_READ)
		{
			Log("err Billing Connection lost.", "-system", 0);

			BillServerSocket.CloseSocket();
			BillCounter = 360;

			Log("err,billing disconnected.", "-system", 0);

			return TRUE;
		}

		int ret = BillServerSocket.Receive();

		if (ret != TRUE)
		{
			Log("err bill receive fail", "-system", 0);

			BillServerSocket.CloseSocket();
			BillCounter = 360;

			return TRUE;
		}

		if (ret == FALSE)
		{
			ret = WSAGetLastError();

			sprintf_s(temp, "err,socket %d %d-%d-%d", ret, BillServerSocket.nRecvPosition, BillServerSocket.nProcPosition, BillServerSocket.nSendPosition);

			ret = BillServerSocket.Receive();

			if (ret != TRUE)
			{
				//Log("err,bill receive retry_recv fail", "-system", 0);

				BillServerSocket.CloseSocket();
				BillCounter = 360;

				break;
			}
		}
		else if (ret == -1)
		{
			//sprintf_s(temp, "clo,bill receive %d-%d-%d", BillServerSocket.nRecvPosition, BillServerSocket.nProcPosition, BillServerSocket.nSendPosition);
			//Log(temp, "-system", 0);

			ret = recv(BillServerSocket.Sock, BillServerSocket.pRecvBuffer, RECV_BUFFER_SIZE, NULL);

			BillServerSocket.CloseSocket();
			BillCounter = 360;

			break;
		}

		int Error = 0;
		int ErrorCode = 0;

		while (1)
		{
			char *Msg = BillServerSocket.ReadBillMessage(&Error, &ErrorCode);

			if (Msg == NULL)
				break;

			if (Error == 1 || Error == 2)
			{
				//sprintf_s(temp, "err readbill (%d),%d", Error, ErrorCode);
				//Log(temp, "-system", 0);

				break;
			}

			ProcessBILLMessage(Msg);

		};

	}  break;

	case WSA_READDB:
	{
		int t = WSAGETSELECTEVENT(lParam);
		if (WSAGETSELECTEVENT(lParam) != FD_READ)
		{
			Log("err wsareaddb fail", "-system", 0);

			DBServerSocket.CloseSocket();

			int ret = 0;

			for (int i = 0; i < 2; i++)
			{
				int *pip = (int*)LocalIP;

				ret = DBServerSocket.ConnectServer(DBServerAddress, DBServerPort, *pip, WSA_READDB);

				if (ret != NULL)
					break;

				Sleep(200);
			}

			if (ret == 0)
			{
				Log("reconnect DB fail.", "-system", 0);

				PostQuitMessage(NULL);

				return TRUE;

			}

			Sleep(200);
			PostQuitMessage(NULL);
			return TRUE;
		}

		if (DBServerSocket.Receive() == FALSE)
		{
			Log("err wsareaddb fail", "-system", 0);

			DBServerSocket.CloseSocket();

			int ret = 0;

			for (int i = 0; i < 2; i++)
			{
				int *pip = (int*)LocalIP;

				ret = DBServerSocket.ConnectServer(DBServerAddress, DBServerPort, *pip, WSA_READDB);

				if (ret != NULL)
					break;

				Sleep(200);
			}

			if (ret == 0)
			{
				Log("reconnect DB fail.", "-system", 0);

				PostQuitMessage(NULL);

				return TRUE;

			}
			PostQuitMessage(NULL);
			return TRUE;

		}

		int Error = 0;
		int ErrorCode = 0;

		while (1)
		{
			char *Msg = DBServerSocket.ReadMessage(&Error, &ErrorCode);

			if (Msg == NULL)
				break;


#ifdef  _PACKET_DEBUG
			MSG_STANDARD *debug = (MSG_STANDARD*)Msg;

			if (BASE_CheckPacket(debug))
			{
				//sprintf(temp, "**PACKET_DEBUG** Type:%d Size:%d", debug->Type, debug->Size);
				//Log(temp, "-system", 0);

				break;
			}
#endif

			if (Error == 1 || Error == 2)
			{
				//sprintf(temp, "err readdb (%d),%d", Error, ErrorCode);
				//Log(temp, "-system", 0);
				break;
			}

			ProcessDBMessage(Msg);
		};

	} break;

	case  WSA_READ:
	{
		int User = GetUserFromSocket(wParam);
		if (User == 0)
		{
			closesocket(wParam);

			break;
		}

		if (WSAGETSELECTEVENT(lParam) != FD_READ)
		{
			//sprintf(temp, "clo,fd %d-%d", pUser[User].Mode, pMob[User].Mode);
			//Log(temp, pUser[User].AccountName, pUser[User].IP);

			CloseUser(User);
			break;
		}

		int ret = pUser[User].cSock.Receive();

		if (ret == FALSE)
		{
			ret = WSAGetLastError();

			//sprintf(temp, "err,socket %d %d-%d-%d %d-%d", ret, pUser[User].cSock.nRecvPosition, pUser[User].cSock.nProcPosition, pUser[User].cSock.nSendPosition, pUser[User].Mode, pMob[User].Mode);

			ret = pUser[User].cSock.Receive();

			if (ret == FALSE)
			{
				//Log("err,retry_recv fail", pUser[User].AccountName, pUser[User].IP);

				CloseUser(User);

				break;
			}
		}
		else if (ret == -1)
		{
			//sprintf(temp, "clo,receive %d-%d-%d %d-%d", pUser[User].cSock.nRecvPosition, pUser[User].cSock.nProcPosition, pUser[User].cSock.nSendPosition, pUser[User].Mode, pMob[User].Mode);

			//Log("clo,receive %d-%d-%d", pUser[User].AccountName, pUser[User].IP);

			ret = recv(pUser[User].cSock.Sock, pUser[User].cSock.pRecvBuffer, RECV_BUFFER_SIZE, NULL);

			CloseUser(User);

			break;
		}

		int Error = 0;
		int ErrorCode = 0;

		while (1)
		{
			char *Msg = pUser[User].cSock.ReadMessage(&Error, &ErrorCode);

			if (Msg == NULL)
				break;

#ifdef  _PACKET_DEBUG
			MSG_STANDARD *debug = (MSG_STANDARD*)Msg;

			if (Msg != NULL && BASE_CheckPacket(debug))
			{
				//sprintf(temp, "**PACKET_DEBUG** Type:%d Size:%d", debug->Type, debug->Size);
				//Log(temp, "-system", 0);
			}
#endif

			if (Error == 1 || Error == 2)
			{
				pUser[User].AccountName[ACCOUNTNAME_LENGTH - 1] = 0;
				pUser[User].AccountName[ACCOUNTNAME_LENGTH - 2] = 0;

				sprintf_s(temp, "err,read (%d),%d", Error, ErrorCode);
				SystemLog(pUser[User].AccountName, pUser[User].MacAddress, pUser[User].IP, temp);

				break;
			}

			ProcessClientMessage(User, Msg, FALSE);
		};

	} break;

	case WSA_ACCEPT:
	{
		if (WSAGETSELECTERROR(lParam) == 0)
		{

			int User = GetEmptyUser();

			if (User == 0)
			{
				Log("err,accept fail - no empty", "-system", 0);

				break;
			}

			int ret = pUser[User].AcceptUser(ListenSocket.Sock);

#pragma region Bloqueio de excesso de tentativas por IP
			int DEFAULT_BLOCKIP = 5; // consideramos 3 segundos aqui, agora é pra ser 2 minutos
			TMP_BLOCKIP bIp = TMP_BLOCKIP(pUser[User].IP, DEFAULT_BLOCKIP);

			// verificamos se o usuário já está na lista, se ele estiver, a conexão será anulada e nada será processado pela dbsrv ou tmsrv.
			for (auto& i : g_pBlockIP)
			{
				if (i.IPAddress == bIp.IPAddress)
				{
					CloseUser(User);
					return TRUE;
				}
			}


			// adiciona o IP do usuário na lista para evitar com que requisite mais de uma conexão em um curto periodo de tempo
			g_pBlockIP.push_back(bIp);
#pragma endregion


			if (User >= MAX_USER - ADMIN_RESERV)
			{

				SendClientMessage(User, g_pMessageStringTable[_NN_Reconnect]);
				pUser[User].cSock.SendMessageA();

				CloseUser(User);

				return TRUE;
			}

			if (ServerDown != -1000)
			{
				SendClientMessage(User, g_pMessageStringTable[_NN_ServerReboot_Cant_Connect]);

				CloseUser(User);

				return TRUE;
			}

		}
		else
			Log("err,- accept - wsagetselecterror", "-system", 0);

	} break;

	case WM_PAINT:
		PAINTSTRUCT ps;
		BeginPaint(hWnd, &ps);
		DrawConfig(0);

		EndPaint(hWnd, &ps);
		break;

	case WM_CREATE:
	{ 
		HMENU hMenu, hSubMenu;
		// HICON hIcon, hIconSm;

		CreateConsole("");   //console

		hMenu = CreateMenu();

		hSubMenu = CreatePopupMenu();
		AppendMenu(hSubMenu, MF_STRING, IDC_EXIT, "&Exit");
		AppendMenu(hMenu, MF_STRING | MF_POPUP, (UINT)hSubMenu, "&File");

		hSubMenu = CreatePopupMenu();
		AppendMenu(hSubMenu, MF_STRING, IDC_MOBRELOAD, "&ReloadMob");
		AppendMenu(hMenu, MF_STRING | MF_POPUP, (UINT)hSubMenu, "&Mob");

		hSubMenu = CreatePopupMenu();
		AppendMenu(hSubMenu, MF_STRING, IDC_REBOOT, "&Reboot");
		AppendMenu(hSubMenu, MF_STRING, IDC_SAVEALL, "&SaveAll");
		AppendMenu(hSubMenu, MF_STRING, IDC_READGUILD, "&ReadGuild");
		AppendMenu(hSubMenu, MF_STRING, IDC_READGUILDNAME, "&ReadGuildName");
		AppendMenu(hSubMenu, MF_STRING, IDC_READGAMECONFIG, "&ReadGameConfig");
		AppendMenu(hSubMenu, MF_STRING, IDC_READSKILLDATA, "&ReadSkillData");
		AppendMenu(hSubMenu, MF_STRING, IDC_READITEMLIST, "&ReadItemList");
		AppendMenu(hMenu, MF_STRING | MF_POPUP, (UINT)hSubMenu, "&Sistema");

		SetMenu(hWnd, hMenu);
	} break;

	case WM_COMMAND:
	{
		switch (LOWORD(wParam))
		{
		case IDC_EXIT:
			PostMessage(hWnd, WM_CLOSE, 0, 0);
			break;

		case IDC_MOBRELOAD:
			mNPCGen.ReadNPCGenerator();
			break;

		case IDC_REBOOT:
			ServerDown = 1;
			break;

		case IDC_SAVEALL:
			SaveAll();
			break;

		case IDC_READGUILD:
			CReadFiles::ReadGuild();
			break;

		case IDC_READGUILDNAME:
			BASE_InitializeGuildName();
			break;

		case IDC_READGAMECONFIG:
		{
			ReadConfig();
			DrawConfig(0);
		} break;
		case IDC_READSKILLDATA:
		{
			BASE_InitializeSkill();
		} break;
		case IDC_READITEMLIST:
		{
			BASE_InitializeItemList();
		} break;
		  
		}
	} break;
	case WM_CLOSE:
	{
		if (MessageBox(hWndMain, "Você realmente deseja desligar o server?", "Aviso!!!", MB_ICONQUESTION | MB_YESNO) == IDNO)
			break;

		if (BILLING != 0)
		{
			_AUTH_GAME sm;
			memset(&sm, 0, sizeof(sm));
			SendBilling2(&sm, 4);

			BILLING = 0;
		}

		CReadFiles::WriteGuild();
		if (fLogFile)
		{
			fLogFile.reset(); //Reset or release?
		}

		if (hFont)
		{
			DeleteObject(hFont);
			hFont = NULL;
		}

		DefWindowProc(hWnd, message, wParam, lParam);

	} break;

	case WM_DESTROY:
		WSACleanup();
		PostQuitMessage(0);
		break;

	default:
		return DefWindowProc(hWnd, message, wParam, lParam);
	}

	return 0;
}

int  GetUserInArea(int x1, int y1, int x2, int y2, char *MobName)
{
	int userCount = 0;

	for (int i = 0; i < MAX_USER; i++)
	{
		if (pUser[i].Mode != USER_PLAY)
			continue;

		if (pMob[i].Mode == 0)
			continue;

		if (pMob[i].TargetX >= x1 && pMob[i].TargetX <= x2 && pMob[i].TargetY >= y1 && pMob[i].TargetY <= y2)
		{
			strncpy(MobName, pMob[i].MOB.MobName, NAME_LENGTH);
			userCount++;
		}
	}
	return userCount;
}

void MountProcess(int conn, STRUCT_ITEM *Mount)
{
	STRUCT_ITEM *MItem = &pMob[conn].MOB.Equip[14];

	int IsEqual = 1;

	if (Mount != NULL)
		IsEqual = memcmp(Mount, MItem, sizeof(STRUCT_ITEM));

	if (IsEqual != 0)
		return;

	int leaderid = pMob[conn].Leader;

	if (leaderid == 0)
		leaderid = conn;

	for (int i = 0; i < MAX_PARTY; i++)
	{
		int partyconn = pMob[leaderid].PartyList[i];

		if (partyconn <= 0 || partyconn > MAX_MOB)
			continue;

		int face = pMob[partyconn].MOB.Equip[0].sIndex;

		if (pMob[partyconn].Summoner == conn)
		{
			if (face >= 315 && face < 345)
				DeleteMob(partyconn, 3);
		}
	}

	int MBabyId = MItem->sIndex - 2320;


	if (MBabyId >= 10 && MBabyId < 40)
	{
		int MHp = BASE_GetItemAbility(MItem, EF_MOUNTHP);

		if (MHp > 0)
			GenerateSummon(conn, MBabyId, MItem, 1);
	}
}

int GetItemSancNew(STRUCT_ITEM* item)
{
	int value = 0;
	if (item->stEffect[0].cEffect == 43)
		value = item->stEffect[0].cValue;
	else if (item->stEffect[1].cEffect == 43)
		value = item->stEffect[1].cValue;
	else if (item->stEffect[2].cEffect == 43)
		value = item->stEffect[2].cValue;
	else
	{
		for (int i = 0; i < 3; i++)
		{
			if (item->stEffect[i].cEffect >= 116 && item->stEffect[i].cEffect <= 125)
			{
				value = item->stEffect[i].cValue;

				break;
			}
		}
	}

	if (value >= 230)
	{
		value = 10 + ((value - 230) / 4);
		if (value > 15)
			value = 15;
	}
	else
		value %= 10;

	return value;
}

void LinkMountHp(int mobConn)
{
	if (mobConn < MAX_USER || mobConn >= MAX_MOB)
		return;

	if (pMob[mobConn].MOB.Clan != 4)
		return;

	int face = pMob[mobConn].MOB.Equip[0].sIndex;

	if (face < 315 || face >= 345)
		return;

	int Summoner = pMob[mobConn].Summoner;

	if (Summoner <= 0 || Summoner >= MAX_USER)
		return;

	if (pMob[Summoner].Mode == USER_EMPTY)
		return;

	if (pUser[Summoner].Mode != USER_PLAY)
		return;

	int mountId = pMob[Summoner].MOB.Equip[14].sIndex - 2330;
	int mountFace = face - 315;

	if ((face - 315) != mountId)
		return;

	int mountHpItem = pMob[Summoner].MOB.Equip[14].stEffect[0].sValue;
	int mountHp = pMob[mobConn].MOB.CurrentScore.Hp;

	if (mountHpItem == mountHp)
		return;

	pMob[Summoner].MOB.Equip[14].stEffect[0].sValue = mountHp;
	SendItem(Summoner, ITEM_PLACE_EQUIP, 14, &pMob[Summoner].MOB.Equip[14]);
}

void ProcessAdultMount(int conn, int HpLost)
{
	STRUCT_ITEM* MItem = &pMob[conn].MOB.Equip[14];

	if (MItem->sIndex < 2360 || MItem->sIndex >= 2390)
		return;

	int midx = MItem->sIndex - 2360;
	int MMaxHp = mSummon.Mob[midx + 10].CurrentScore.MaxHp;
	int MFeed = 0;
	bool Buff = false;

	//revigorante
	for (int i = 0; i < MAX_AFFECT; i++)
	{
		if (pMob[conn].Affect[i].Type == 51)
			Buff = true;
	}

	if (Buff == true) {
		MFeed = 100;
	}
	else
		MFeed = MItem->stEffect[2].cEffect;

	if (MFeed <= 0 && MItem->stEffect[0].sValue > 0)
	{
		MItem->stEffect[0].sValue = 0;
		MFeed = 0;
	}

	int MHp = MItem->stEffect[0].sValue;
	int MHp2 = MItem->stEffect[0].sValue - HpLost;

	if (MHp2 >= MMaxHp)
		MHp2 = MMaxHp;

	int NMHp = MHp2;

	if (Buff == false)
		MItem->stEffect[0].sValue = NMHp;

	if (MHp2 <= 0)
		MItem->stEffect[2].cEffect = 0;

	if ((MHp <= 0 && MHp2 > 0) || (MHp2 <= 0 && MHp > 0))
		SendEquip(conn, 0);

	if (MHp != MHp2 && conn < MAX_USER)
		SendItem(conn, ITEM_PLACE_EQUIP, 14, &pMob[conn].MOB.Equip[14]);
}

void ProcessBILLMessage(char *pMsg)
{
}

void CheckIdle(int conn)
{
	int ser = SecCounter;
	int lst = pUser[conn].LastReceiveTime;

	if (lst > ser)
		pUser[conn].LastReceiveTime = SecCounter;

	if (lst < ser - 1440)
		pUser[conn].LastReceiveTime = SecCounter;

	if (lst < ser - 720)
	{	
		//sprintf(temp, "sys,disconnect last:%d server:%d mode:%d conn:%d", pUser[conn].LastReceiveTime, SecCounter, pUser[conn].Mode, conn);
		//Log(temp, pUser[conn].AccountName, 0);

		CloseUser(conn);
	}
}

void FinishCastleWar()
{
	SetCastleDoor(1);

	ClearAreaGuild(1036, 1672, 1144, 1764, g_pGuildZone[4].ChargeGuild);

	CastleState = 0;

	for (int i = 0; i < MAX_USER; i++)
	{
		if (pUser[i].Mode != USER_PLAY)
			continue;

		SendClientSignal(i, _MSG_SendCastleState, CastleState);
	}

	for (int i = 0; i < MAX_USER; i++)
	{
		if (pUser[i].Mode != USER_PLAY)
			continue;

		SendClientSignalParm(i, ESCENE_FIELD, _MSG_SendCastleState, CastleState);
	}

	for (int i = MAX_USER; i < MAX_MOB; i++)
	{
		if (pMob[i].Mode == MOB_EMPTY)
			continue;

		if (pMob[i].MOB.Equip[0].sIndex != 219)
			continue;

		DeleteMob(i, 2);
	}

	ClearArea(1036, 1672, 1144, 1764);
}

void RegenMob(int conn)
{
	if (conn > 0 && conn < MAX_USER)
	{
		int Guild = pMob[conn].MOB.Guild;
		if (CastleState <= 1 || pMob[conn].TargetX != 1046 || pMob[conn].TargetY != 1690 || Guild <= 0 || pMob[conn].MOB.GuildLevel != 9 || Guild == g_pGuildZone[4].ChargeGuild)
			pUser[conn].CastleStatus = 0;

		else
		{
			int Citys = 0;

			for (int i = 0; i < ValidGuild; i++)
			{
				if (g_pGuildZone[i].ChargeGuild == pMob[conn].MOB.Guild && i != 4)
					Citys++;
			}

			if (Citys != 0)
			{
				if (pUser[conn].CastleStatus == 0)
				{
					SendNotice(strFmt(g_pMessageStringTable[_SN_S_is_charging_castle], pMob[conn].MOB.MobName));
				}
				MSG_STANDARDPARM sm;
				memset(&sm, 0, sizeof(MSG_STANDARDPARM));

				sm.Type = _MSG_SendCastleState2;
				sm.Size = sizeof(MSG_STANDARDPARM);
				sm.ID = conn;
				sm.Parm = 1;

				GridMulticast(pMob[conn].TargetX, pMob[conn].TargetY, (MSG_STANDARD*)&sm, 0);

				pUser[conn].CastleStatus++;

				if (pUser[conn].CastleStatus > 22)
				{
					SendNotice(strFmt(g_pMessageStringTable[_SN_S_charge_castle], pMob[conn].MOB.MobName));

					g_pGuildZone[4].ChargeGuild = Guild;
					g_pGuildZone[4].Clan = pMob[conn].MOB.Clan;

					FinishCastleWar();

					for (int i = 0; i < MAX_USER; i++)
						ClearCrown(i);
				}
			}
		}

		pUser[conn].Unk_2736++;

		if (!(pUser[conn].Unk_2736 % 450))
		{
			int PKP = GetPKPoint(conn);
			if (PKP < 75)
			{
				PKP++;
				SetPKPoint(conn, PKP);
				SendMsgExp(conn, strFmt(g_pMessageStringTable[_DD_PKPointPlus], PKP - 75, 1), TNColor::Default, false);
			}

			STRUCT_ITEM *Mount = &pMob[conn].MOB.Equip[14];
			if (pMob[conn].MOB.Equip[14].sIndex >= 2300 && Mount->sIndex < 2330)
			{
				int Incubacao = BASE_GetBonusItemAbility(Mount, EF_INCUDELAY);
				if (Incubacao > 0)
				{
					Incubacao--;
					Mount->stEffect[2].cValue = Incubacao;
					SendItem(conn, ITEM_PLACE_EQUIP, 14, &pMob[conn].MOB.Equip[14]);
					 SendMsgExp(conn, g_pMessageStringTable[_NN_Incu_Proceed], TNColor::Default, false);
				}
			}
			if (Mount->sIndex >= 2330 && Mount->sIndex < 2390 && Mount->stEffect[0].sValue > 0)
			{
				int Feed = Mount->stEffect[2].cEffect;
				int MountDiv = Mount->sIndex - 2330 % 30;

				if (MountDiv > 15)
					Feed -= 4;
				else
					Feed -= 2;

				if (Feed > 1)
					Mount->stEffect[2].cEffect = Feed;

				else
				{
					Mount->stEffect[0].sValue = 0;
					Mount->stEffect[2].cEffect = 4;

				 
					SendMsgExp(conn, g_pMessageStringTable[_NN_Mount_died], TNColor::Default, false);
					memcpy(&pMob[conn].MOB.Equip[14], Mount, sizeof(STRUCT_ITEM));

					Mount->stEffect[2].cEffect = 0;

					if (Mount->sIndex >= 2360 && Mount->sIndex < 2390)
						ProcessAdultMount(conn, 0);

					if (Mount->sIndex >= 2360)
						pMob[conn].GetCurrentScore(conn);

					else
						MountProcess(conn, Mount);
				}
				SendItem(conn, ITEM_PLACE_EQUIP, 14, &pMob[conn].MOB.Equip[14]);
			}
		}
		int Guilty = GetGuilty(conn);

		if (Guilty > 0)
		{
			Guilty--;
			SetGuilty(conn, Guilty);

			if (!Guilty)
			{
				MSG_CreateMob CreateMob;
				GetCreateMob(conn, &CreateMob);
				GridMulticast(pMob[conn].TargetX, pMob[conn].TargetY, (MSG_STANDARD*)&CreateMob, 0);

				for (int j = MAX_USER; j < MAX_MOB; j++)
				{
					if (pMob[j].Mode == 5 && pMob[j].MOB.Clan == 4)
					{
						if (pMob[j].CurrentTarget == conn)
						{
							pMob[j].CurrentTarget = 0;
							pMob[j].Mode = 4;
						}
						for (int k = 0; k < MAX_ENEMY; k++)
						{
							if (pMob[j].EnemyList[k] == conn)
							{
								pMob[j].EnemyList[k] = 0;
								pMob[j].Mode = MOB_PEACE;
							}
						}
					}
				}
			}
		}
	}
}

int  ProcessAffect(int idx)
{
	int FadaIndex = FadaIndex = pMob[idx].MOB.Equip[13].sIndex;
	int currentTarget = pMob[idx].CurrentTarget;

	if (idx >= MAX_USER || FadaIndex != 753 && FadaIndex != 769 && FadaIndex != 1726 || currentTarget == 0)
		goto LABEL_59;

	if (currentTarget == idx)
		pMob[idx].CurrentTarget = 0;

#pragma region Fada / Chama Resistente - Attack
	else
	{
		if (currentTarget > 0 && currentTarget < MAX_MOB)
		{
			if (pMob[currentTarget].Mode)
			{
				unsigned char map_att = GetAttribute(pMob[idx].TargetX, pMob[idx].TargetY);

				if (map_att & 0x40 || currentTarget >= MAX_USER && pMob[currentTarget].MOB.Clan != 4)
				{
					if (pUser[idx].PKMode || currentTarget >= MAX_USER)
					{
						int leader = pMob[idx].Leader;
						if (!leader)
							leader = idx;

						int targetleader = pMob[currentTarget].Leader;
						if (!targetleader)
							targetleader = currentTarget;

						int guild = pMob[idx].MOB.Guild;
						if (pMob[idx].GuildDisable)
							guild = 0;

						int mobguild = pMob[currentTarget].MOB.Guild;
						if (pMob[currentTarget].GuildDisable)
							mobguild = 0;

						if (!guild && !mobguild)
							guild = -1;

						if (leader != targetleader && guild != mobguild)
						{
							if (currentTarget < MAX_USER)
							{
								unsigned char map_att2 = GetAttribute(pMob[currentTarget].TargetX, pMob[currentTarget].TargetY);

								if (!(map_att & 0x40))
								{
									pMob[idx].CurrentTarget = 0;
									goto LABEL_59;
								}
								if (pMob[currentTarget].MOB.Rsv & 0x10)
								{
									pMob[idx].CurrentTarget = 0;
									goto LABEL_59;
								}
								if (pMob[currentTarget].MOB.BaseScore.Level >= MAX_LEVEL && pMob[currentTarget].MOB.Merchant & 1)
								{
									pMob[idx].CurrentTarget = 0;
									goto LABEL_59;
								}
							}
							int sameclan = 0;
							int clan = pMob[idx].MOB.Clan;
							int mobclan = pMob[currentTarget].MOB.Clan;

							if (clan == 7 && mobclan == 7 || clan == 8 && mobclan == 8)
								sameclan = 1;

							if ((sameclan != 1 || pUser[idx].PKMode) && (sameclan != 1 || currentTarget < MAX_USER))
							{
								if (pMob[currentTarget].TargetX >= pMob[idx].TargetX - HALFGRIDX
									&& pMob[currentTarget].TargetX <= pMob[idx].TargetX + HALFGRIDX
									&& (pMob[currentTarget].TargetY >= pMob[idx].TargetY - HALFGRIDY || pMob[currentTarget].TargetY <= pMob[idx].TargetY + HALFGRIDY))
								{
									MSG_Attack sm;

									memset(&sm, 0, sizeof(MSG_AttackOne));

									sm.Type = _MSG_AttackOne;
									sm.ID = idx;
									sm.Size = sizeof(MSG_AttackOne);

									//check
									sm.ClientTick = 0xE0A1ACA;
									sm.Motion = 254;

									sm.TargetX = pMob[idx].TargetX;
									sm.TargetY = pMob[idx].TargetY;

									//check
									sm.CurrentMp = -2;
									//check
									sm.AttackerID = idx;

									//check
									sm.SkillIndex = 32;

									if (FadaIndex == 769)
										sm.SkillIndex = 34;
									if (FadaIndex == 1726)
										sm.SkillIndex = 36;

									sm.Dam[0].TargetID = currentTarget;
									sm.Dam[0].Damage = -1;

									ProcessClientMessage(idx, (char*)&sm, TRUE);
								}
								else
									pMob[idx].CurrentTarget = 0;
							}
							goto LABEL_59;
						}
						pMob[idx].CurrentTarget = 0;
					}
					else
						pMob[idx].CurrentTarget = 0;
				}
				else
					pMob[idx].CurrentTarget = 0;
			}
			else
				pMob[idx].CurrentTarget = 0;
		}
		else
			pMob[idx].CurrentTarget = 0;
	}
#pragma endregion
	LABEL_59:

			int regen = 0;
			int upScore = 0;
			int FaceChange = 0;
			int Damage = 0;

			for (int i = 0; i < MAX_AFFECT; i++)
			{
				int Type = pMob[idx].Affect[i].Type;

				if (Type <= 0)
					continue;

				int MaxHp = pMob[idx].MOB.CurrentScore.MaxHp;
				int Hp = pMob[idx].MOB.CurrentScore.Hp;
				int AffectValue = pMob[idx].Affect[i].Value;
				int AffectLevel = pMob[idx].Affect[i].Level;
				int Level = pMob[idx].MOB.CurrentScore.Level;

				if (pMob[idx].extra.ClassMaster != MORTAL && pMob[idx].extra.ClassMaster != ARCH)
					Level += MAX_LEVEL;

#pragma region Regen de HP Aura da Vida
				if (Type == 17)
				{
					Hp += AffectLevel / 2 + AffectValue;

					if (Hp < 1)
						Hp = 1;

					if (Hp > MaxHp)
						Hp = MaxHp;

					if (pMob[idx].MOB.CurrentScore.Hp != Hp)
						upScore = 1;

					Damage = Hp - pMob[idx].MOB.CurrentScore.Hp;

					pMob[idx].MOB.CurrentScore.Hp = Hp;
					regen = 1;
					goto LessAffect;
				}
#pragma endregion
#pragma region Veneno / Sangrar - Drenagem de HP
				if (Type == 20 || Type == 47) //??? Possivelmente Veneno's
				{
					if (idx > 0 && idx < MAX_USER) {
						AffectValue = 100;

						if (idx >= MAX_USER)
							AffectValue -= pMob[idx].MOB.LearnedSkill / MAX_USER;

						AffectValue /= 10;

						int HpLose = (int)((100 - AffectValue) / 100.0);
						int Perda = 1000;

						if (idx >= MAX_USER)
							Perda = 10 * (100 - pMob[idx].MOB.LearnedSkill / MAX_USER);

						int Perdamax = Hp - Perda;

						Hp = (int)((double)Hp * HpLose);

						if (Hp < (signed int)Perdamax)
							Hp = Perdamax;

						if (Hp < 1)
							Hp = 1;

						if (Hp > MaxHp)
							Hp = MaxHp;

						if (pMob[idx].MOB.CurrentScore.Hp != Hp)
							upScore = 1;

						Damage = Hp - pMob[idx].MOB.CurrentScore.Hp;
						pMob[idx].MOB.CurrentScore.Hp = Hp;

						if (idx > 0 && idx < MAX_USER)
							pUser[idx].ReqHp += Damage;

						regen = 1;

						if (idx > MAX_USER && pMob[idx].MOB.Clan == 4)
							LinkMountHp(idx);

						goto LessAffect;
					}
				}
#pragma endregion
#pragma region RegenHP Type21
				/*		if (Type == 21)//Regen de HT
						{
							Hp += AffectValue * MaxHp / 100;

							if (Hp < 1)
								Hp = 1;

							if (Hp > MaxHp)
								Hp = MaxHp;

							if (pMob[idx].MOB.CurrentScore.Hp != Hp)
								upScore = 1;

							Damage = Hp - pMob[idx].MOB.CurrentScore.Hp;

							pMob[idx].MOB.CurrentScore.Hp = Hp;
							regen = 1;

							goto LessAffect;
						}*/
#pragma endregion
#pragma region Trovão
				if (Type == 22)
				{
					int alvo1 = 0;
					int alvo2 = 0;
					int alvo3 = 0;
					int alvo4 = 0;
					int alvo6 = 0;
					int alvo7 = 0;

					unsigned char map_att = GetAttribute(pMob[idx].TargetX, pMob[idx].TargetY);

					int Clan = pMob[idx].MOB.Clan;

					if (map_att & 1)
						goto LessAffect;

					int yv = pMob[idx].TargetY - 1;
					int xv = pMob[idx].TargetX - 1;
					int leader = pMob[idx].Leader;

					if (leader <= 0)
						leader = idx;

					for (int yy = yv; yy <= (yv + 1); yy++)
					{
						for (int xx = xv; xx <= (xv + 1); xx++)
						{
							if (xx < 0 || xx >= MAX_GRIDX || yy < 0 || yy >= MAX_GRIDY || pMobGrid[yy][xx] <= 0 || pMobGrid[yy][xx] >= MAX_MOB || !pMob[pMobGrid[yy][xx]].Mode || pMob[pMobGrid[yy][xx]].MOB.CurrentScore.Hp <= 0 || leader == pMob[pMobGrid[yy][xx]].Leader)
								continue;

							int tmob = pMobGrid[yy][xx];

							int tclan = pMob[tmob].MOB.Clan;
							int SameClan = 0;

							if (Clan == 7 && tclan == 7 || Clan == 8 && tclan == 8)
								SameClan = 1;

							if (pMob[tmob].MOB.Merchant & 1)
								continue;

							unsigned char map_attack = GetAttribute(xx, yy);

							if (map_attack & 1)
								continue;

							if (idx >= MAX_USER)
								break;

							if ((pUser[idx].PKMode || tmob >= MAX_USER && tclan != 4 && SameClan != 1) && (map_att & 0x40 || tmob >= 100 && tclan != 4 && SameClan != 1) && !(pMob[tmob].MOB.Rsv & 0x10))
							{
								if (SameClan == 1 && tmob >= MAX_USER || tclan == 6 || tmob == idx)
									continue;

								int idxleader = pMob[idx].Leader;

								if (!idxleader)
									idxleader = idx;

								int mobleader = pMob[tmob].Leader;
								if (!mobleader)
									mobleader = tmob;

								int Guild = pMob[idx].MOB.Guild;

								if (pMob[idx].GuildDisable)
									Guild = 0;

								int MobGuild = pMob[tmob].MOB.Guild;

								if (pMob[tmob].GuildDisable)
									MobGuild = 0;

								int Ally = g_pGuildAlly[Guild];

								if (!Ally)
									Ally = -2;

								if (!Guild && !MobGuild)
									Guild = -1;

								if (idxleader == mobleader || Guild == MobGuild || Ally == MobGuild)
									continue;

								if (!alvo1)
								{
									alvo1 = tmob;
									continue;
								}

								if (alvo1 == tmob)
									continue;

								if (!alvo2)
								{
									alvo2 = tmob;
									continue;
								}
								if (alvo2 == tmob)
									continue;

								if (!alvo3)
								{
									alvo3 = tmob;
									continue;
								}
								if (alvo3 == tmob)
									continue;

								if (!alvo4)
								{
									alvo4 = tmob;
									continue;
								}
								if (alvo4 == tmob)
									continue;

								if (!alvo6)
								{
									alvo6 = tmob;
									continue;
								}

								if (alvo6 == tmob || alvo7)
									continue;

								alvo7 = tmob;
							}
						}
					}

					yv = pMob[idx].TargetY - 4;
					xv = pMob[idx].TargetX - 4;


					for (int yy = yv; yy <= (yv + 4); yy++)
					{
						for (int xx = xv; xx <= (xv + 4); xx++)
						{
							if (xx < 0 || xx >= MAX_GRIDX || yy < 0 || yy >= MAX_GRIDY || pMobGrid[yy][xx] <= 0 || pMobGrid[yy][xx] >= MAX_MOB || !pMob[pMobGrid[yy][xx]].Mode || pMob[pMobGrid[yy][xx]].MOB.CurrentScore.Hp <= 0 || leader == pMob[pMobGrid[yy][xx]].Leader)
								continue;

							int tmob = pMobGrid[yy][xx];

							int tclan = pMob[tmob].MOB.Clan;
							int SameClan = 0;

							if (Clan == 7 && tclan == 7 || Clan == 8 && tclan == 8)
								SameClan = 1;

							if (pMob[tmob].MOB.Merchant & 1)
								continue;

							unsigned char map_attack = GetAttribute(xx, yy);

							if (map_attack & 1)
								continue;

							if (idx >= MAX_USER)
								break;

							if ((pUser[idx].PKMode || tmob >= MAX_USER && tclan != 4 && SameClan != 1) && (map_att & 0x40 || tmob >= MAX_USER && tclan != 4 && SameClan != 1) && !(pMob[tmob].MOB.Rsv & 0x10))
							{
								if (SameClan == 1 && tmob >= MAX_USER || tclan == 6 || tmob == idx)
									continue;

								int idxleader = pMob[idx].Leader;

								if (!idxleader)
									idxleader = idx;

								int mobleader = pMob[tmob].Leader;
								if (!mobleader)
									mobleader = tmob;

								int Guild = pMob[idx].MOB.Guild;

								if (pMob[idx].GuildDisable)
									Guild = 0;

								int MobGuild = pMob[tmob].MOB.Guild;

								if (pMob[tmob].GuildDisable)
									MobGuild = 0;

								int Ally = g_pGuildAlly[Guild];

								if (!Ally)
									Ally = -2;

								if (!Guild && !MobGuild)
									Guild = -1;

								if (idxleader == mobleader || Guild == MobGuild || Ally == MobGuild)
									continue;

								if (!alvo1)
								{
									alvo1 = tmob;
									continue;
								}

								if (alvo1 == tmob)
									continue;

								if (!alvo2)
								{
									alvo2 = tmob;
									continue;
								}
								if (alvo2 == tmob)
									continue;

								if (!alvo3)
								{
									alvo3 = tmob;
									continue;
								}
								if (alvo3 == tmob)
									continue;

								if (!alvo4)
								{
									alvo4 = tmob;
									continue;
								}
								if (alvo4 == tmob)
									continue;

								if (!alvo6)
								{
									alvo6 = tmob;
									continue;
								}

								if (alvo6 == tmob || alvo7)
									continue;

								alvo7 = tmob;
							}
						}
					}

					if (alvo1)
					{
						MSG_Attack sm;

						memset(&sm, 0, sizeof(MSG_Attack));

						sm.Type = _MSG_Attack;
						sm.ID = idx;
						sm.Size = sizeof(MSG_Attack);

						sm.ClientTick = 0xE0A1ACA;
						sm.Motion = 254;

						sm.TargetX = pMob[idx].TargetX;
						sm.TargetY = pMob[idx].TargetY;

						sm.CurrentMp = -2;

						if (pMob[idx].MOB.Equip[0].sIndex == 219)
							sm.CurrentMp = -4;

						sm.AttackerID = idx;
						sm.SkillIndex = 33;

						int calc = 500 + rand() % 100 + (pMob[idx].extra.ClassMaster == MORTAL || pMob[idx].extra.ClassMaster == MORTAL ? Level : Level + MAX_CLEVEL) + AffectLevel;

						sm.Dam[0].TargetID = alvo1;
						sm.Dam[0].Damage = -1;

						if (calc > 300)
						{
							sm.Dam[1].TargetID = alvo2;
							sm.Dam[1].Damage = -1;
						}

						if (calc > 350)
						{
							sm.Dam[2].TargetID = alvo3;
							sm.Dam[2].Damage = -1;
						}

						if (calc > 400)
						{
							sm.Dam[3].TargetID = alvo4;
							sm.Dam[3].Damage = -1;
						}

						if (calc > 450)
						{
							sm.Dam[4].TargetID = alvo6;
							sm.Dam[4].Damage = -1;
						}

						if (calc > 500)
						{
							sm.Dam[5].TargetID = alvo7;
							sm.Dam[5].Damage = -1;
						}


						if (idx < MAX_USER)
							ProcessClientMessage(idx, (char*)&sm, TRUE);
					}
				}
#pragma endregion
#pragma region Aura Bestial
				if (Type == 23)
				{
					int alvo1 = 0;
					int alvo2 = 0;
					int alvo3 = 0;
					int alvo4 = 0;
					int alvo6 = 0;
					int alvo7 = 0;

					unsigned char map_att = GetAttribute(pMob[idx].TargetX, pMob[idx].TargetY);

					int Clan = pMob[idx].MOB.Clan;

					if (map_att & 1)
						goto LessAffect;

					int yv = pMob[idx].TargetY - 1;
					int xv = pMob[idx].TargetX - 1;
					int leader = pMob[idx].Leader;

					if (leader <= 0)
						leader = idx;

					for (int yy = yv; yy <= (yv + 1); yy++)
					{
						for (int xx = xv; xx <= (xv + 1); xx++)
						{
							if (xx < 0 || xx >= MAX_GRIDX || yy < 0 || yy >= MAX_GRIDY || pMobGrid[yy][xx] <= 0 || pMobGrid[yy][xx] >= MAX_MOB || !pMob[pMobGrid[yy][xx]].Mode || pMob[pMobGrid[yy][xx]].MOB.CurrentScore.Hp <= 0 || leader == pMob[pMobGrid[yy][xx]].Leader)
								continue;

							int tmob = pMobGrid[yy][xx];

							int tclan = pMob[tmob].MOB.Clan;
							int SameClan = 0;

							if (Clan == 7 && tclan == 7 || Clan == 8 && tclan == 8)
								SameClan = 1;

							if (pMob[tmob].MOB.Merchant & 1)
								continue;

							unsigned char map_attack = GetAttribute(xx, yy);

							if (map_attack & 1)
								continue;

							if (idx >= MAX_USER)
								break;

							if ((pUser[idx].PKMode || tmob >= MAX_USER && tclan != 4 && SameClan != 1) && (map_att & 0x40 || tmob >= 100 && tclan != 4 && SameClan != 1) && !(pMob[tmob].MOB.Rsv & 0x10))
							{
								if (SameClan == 1 && tmob >= MAX_USER || tclan == 6 || tmob == idx)
									continue;

								int idxleader = pMob[idx].Leader;

								if (!idxleader)
									idxleader = idx;

								int mobleader = pMob[tmob].Leader;
								if (!mobleader)
									mobleader = tmob;

								int Guild = pMob[idx].MOB.Guild;

								if (pMob[idx].GuildDisable)
									Guild = 0;

								int MobGuild = pMob[tmob].MOB.Guild;

								if (pMob[tmob].GuildDisable)
									MobGuild = 0;

								int Ally = g_pGuildAlly[Guild];

								if (!Ally)
									Ally = -2;

								if (!Guild && !MobGuild)
									Guild = -1;

								if (idxleader == mobleader || Guild == MobGuild || Ally == MobGuild)
									continue;

								if (!alvo1)
								{
									alvo1 = tmob;
									continue;
								}

								if (alvo1 == tmob)
									continue;

								if (!alvo2)
								{
									alvo2 = tmob;
									continue;
								}
								if (alvo2 == tmob)
									continue;

								if (!alvo3)
								{
									alvo3 = tmob;
									continue;
								}
								if (alvo3 == tmob)
									continue;

								if (!alvo4)
								{
									alvo4 = tmob;
									continue;
								}
								if (alvo4 == tmob)
									continue;

								if (!alvo6)
								{
									alvo6 = tmob;
									continue;
								}

								if (alvo6 == tmob || alvo7)
									continue;

								alvo7 = tmob;
							}
						}
					}

					yv = pMob[idx].TargetY - 4;
					xv = pMob[idx].TargetX - 4;


					for (int yy = yv; yy <= (yv + 4); yy++)
					{
						for (int xx = xv; xx <= (xv + 4); xx++)
						{
							if (xx < 0 || xx >= MAX_GRIDX || yy < 0 || yy >= MAX_GRIDY || pMobGrid[yy][xx] <= 0 || pMobGrid[yy][xx] >= MAX_MOB || !pMob[pMobGrid[yy][xx]].Mode || pMob[pMobGrid[yy][xx]].MOB.CurrentScore.Hp <= 0 || leader == pMob[pMobGrid[yy][xx]].Leader)
								continue;

							int tmob = pMobGrid[yy][xx];

							int tclan = pMob[tmob].MOB.Clan;
							int SameClan = 0;

							if (Clan == 7 && tclan == 7 || Clan == 8 && tclan == 8)
								SameClan = 1;

							if (pMob[tmob].MOB.Merchant & 1)
								continue;

							unsigned char map_attack = GetAttribute(xx, yy);

							if (map_attack & 1)
								continue;

							if (idx >= MAX_USER)
								break;

							if ((pUser[idx].PKMode || tmob >= MAX_USER && tclan != 4 && SameClan != 1) && (map_att & 0x40 || tmob >= MAX_USER && tclan != 4 && SameClan != 1) && !(pMob[tmob].MOB.Rsv & 0x10))
							{
								if (SameClan == 1 && tmob >= MAX_USER || tclan == 6 || tmob == idx)
									continue;

								int idxleader = pMob[idx].Leader;

								if (!idxleader)
									idxleader = idx;

								int mobleader = pMob[tmob].Leader;
								if (!mobleader)
									mobleader = tmob;

								int Guild = pMob[idx].MOB.Guild;

								if (pMob[idx].GuildDisable)
									Guild = 0;

								int MobGuild = pMob[tmob].MOB.Guild;

								if (pMob[tmob].GuildDisable)
									MobGuild = 0;

								int Ally = g_pGuildAlly[Guild];

								if (!Ally)
									Ally = -2;

								if (!Guild && !MobGuild)
									Guild = -1;

								if (idxleader == mobleader || Guild == MobGuild || Ally == MobGuild)
									continue;

								if (!alvo1)
								{
									alvo1 = tmob;
									continue;
								}

								if (alvo1 == tmob)
									continue;

								if (!alvo2)
								{
									alvo2 = tmob;
									continue;
								}
								if (alvo2 == tmob)
									continue;

								if (!alvo3)
								{
									alvo3 = tmob;
									continue;
								}
								if (alvo3 == tmob)
									continue;

								if (!alvo4)
								{
									alvo4 = tmob;
									continue;
								}
								if (alvo4 == tmob)
									continue;

								if (!alvo6)
								{
									alvo6 = tmob;
									continue;
								}

								if (alvo6 == tmob || alvo7)
									continue;

								alvo7 = tmob;
							}
						}
					}

					if (alvo1)
					{
						MSG_Attack sm;

						memset(&sm, 0, sizeof(MSG_Attack));

						sm.Type = _MSG_Attack;
						sm.ID = idx;
						sm.Size = sizeof(MSG_Attack);

						sm.ClientTick = 0xE0A1ACA;
						sm.Motion = 254;

						sm.TargetX = pMob[idx].TargetX;
						sm.TargetY = pMob[idx].TargetY;

						sm.CurrentMp = -2;

						if (pMob[idx].MOB.Equip[0].sIndex == 219)
							sm.CurrentMp = -4;

						sm.AttackerID = idx;
						sm.SkillIndex = 52;

						int calc = 5000 + rand() % 100 + (pMob[idx].extra.ClassMaster == MORTAL || pMob[idx].extra.ClassMaster == MORTAL ? Level : Level + MAX_CLEVEL) + AffectLevel;

						sm.Dam[0].TargetID = alvo1;
						sm.Dam[0].Damage = -1;

						if (calc > 300)
						{
							sm.Dam[1].TargetID = alvo2;
							sm.Dam[1].Damage = -1;
						}

						if (calc > 350)
						{
							sm.Dam[2].TargetID = alvo3;
							sm.Dam[2].Damage = -1;
						}

						if (calc > 400)
						{
							sm.Dam[3].TargetID = alvo4;
							sm.Dam[3].Damage = -1;
						}

						if (calc > 450)
						{
							sm.Dam[4].TargetID = alvo6;
							sm.Dam[4].Damage = -1;
						}

						if (calc > 500)
						{
							sm.Dam[5].TargetID = alvo7;
							sm.Dam[5].Damage = -1;
						}


						if (idx < MAX_USER)
							ProcessClientMessage(idx, (char*)&sm, TRUE);
					}
				}
#pragma endregion
#pragma region Aura Bestial
				if (Type == 23)
				{
					int alvo1 = 0;
					int alvo2 = 0;
					int alvo3 = 0;
					int alvo4 = 0;
					int alvo6 = 0;
					int alvo7 = 0;

					unsigned char map_att = GetAttribute(pMob[idx].TargetX, pMob[idx].TargetY);

					int Clan = pMob[idx].MOB.Clan;

					if (map_att & 1)
						goto LessAffect;

					int yv = pMob[idx].TargetY - 1;
					int xv = pMob[idx].TargetX - 1;
					int leader = pMob[idx].Leader;

					if (leader <= 0)
						leader = idx;

					for (int yy = yv; yy <= (yv + 1); yy++)
					{
						for (int xx = xv; xx <= (xv + 1); xx++)
						{
							if (xx < 0 || xx >= MAX_GRIDX || yy < 0 || yy >= MAX_GRIDY || pMobGrid[yy][xx] <= 0 || pMobGrid[yy][xx] >= MAX_MOB || !pMob[pMobGrid[yy][xx]].Mode || pMob[pMobGrid[yy][xx]].MOB.CurrentScore.Hp <= 0 || leader == pMob[pMobGrid[yy][xx]].Leader)
								continue;

							int tmob = pMobGrid[yy][xx];

							int tclan = pMob[tmob].MOB.Clan;
							int SameClan = 0;

							if (Clan == 7 && tclan == 7 || Clan == 8 && tclan == 8)
								SameClan = 1;

							if (pMob[tmob].MOB.Merchant & 1)
								continue;

							unsigned char map_attack = GetAttribute(xx, yy);

							if (map_attack & 1)
								continue;

							if (idx >= MAX_USER)
								break;

							if ((pUser[idx].PKMode || tmob >= MAX_USER && tclan != 4 && SameClan != 1) && (map_att & 0x40 || tmob >= 100 && tclan != 4 && SameClan != 1) && !(pMob[tmob].MOB.Rsv & 0x10))
							{
								if (SameClan == 1 && tmob >= MAX_USER || tclan == 6 || tmob == idx)
									continue;

								int idxleader = pMob[idx].Leader;

								if (!idxleader)
									idxleader = idx;

								int mobleader = pMob[tmob].Leader;
								if (!mobleader)
									mobleader = tmob;

								int Guild = pMob[idx].MOB.Guild;

								if (pMob[idx].GuildDisable)
									Guild = 0;

								int MobGuild = pMob[tmob].MOB.Guild;

								if (pMob[tmob].GuildDisable)
									MobGuild = 0;

								int Ally = g_pGuildAlly[Guild];

								if (!Ally)
									Ally = -2;

								if (!Guild && !MobGuild)
									Guild = -1;

								if (idxleader == mobleader || Guild == MobGuild || Ally == MobGuild)
									continue;

								if (!alvo1)
								{
									alvo1 = tmob;
									continue;
								}

								if (alvo1 == tmob)
									continue;

								if (!alvo2)
								{
									alvo2 = tmob;
									continue;
								}
								if (alvo2 == tmob)
									continue;

								if (!alvo3)
								{
									alvo3 = tmob;
									continue;
								}
								if (alvo3 == tmob)
									continue;

								if (!alvo4)
								{
									alvo4 = tmob;
									continue;
								}
								if (alvo4 == tmob)
									continue;

								if (!alvo6)
								{
									alvo6 = tmob;
									continue;
								}

								if (alvo6 == tmob || alvo7)
									continue;

								alvo7 = tmob;
							}
						}
					}

					yv = pMob[idx].TargetY - 4;
					xv = pMob[idx].TargetX - 4;


					for (int yy = yv; yy <= (yv + 4); yy++)
					{
						for (int xx = xv; xx <= (xv + 4); xx++)
						{
							if (xx < 0 || xx >= MAX_GRIDX || yy < 0 || yy >= MAX_GRIDY || pMobGrid[yy][xx] <= 0 || pMobGrid[yy][xx] >= MAX_MOB || !pMob[pMobGrid[yy][xx]].Mode || pMob[pMobGrid[yy][xx]].MOB.CurrentScore.Hp <= 0 || leader == pMob[pMobGrid[yy][xx]].Leader)
								continue;

							int tmob = pMobGrid[yy][xx];

							int tclan = pMob[tmob].MOB.Clan;
							int SameClan = 0;

							if (Clan == 7 && tclan == 7 || Clan == 8 && tclan == 8)
								SameClan = 1;

							if (pMob[tmob].MOB.Merchant & 1)
								continue;

							unsigned char map_attack = GetAttribute(xx, yy);

							if (map_attack & 1)
								continue;

							if (idx >= MAX_USER)
								break;

							if ((pUser[idx].PKMode || tmob >= MAX_USER && tclan != 4 && SameClan != 1) && (map_att & 0x40 || tmob >= MAX_USER && tclan != 4 && SameClan != 1) && !(pMob[tmob].MOB.Rsv & 0x10))
							{
								if (SameClan == 1 && tmob >= MAX_USER || tclan == 6 || tmob == idx)
									continue;

								int idxleader = pMob[idx].Leader;

								if (!idxleader)
									idxleader = idx;

								int mobleader = pMob[tmob].Leader;
								if (!mobleader)
									mobleader = tmob;

								int Guild = pMob[idx].MOB.Guild;

								if (pMob[idx].GuildDisable)
									Guild = 0;

								int MobGuild = pMob[tmob].MOB.Guild;

								if (pMob[tmob].GuildDisable)
									MobGuild = 0;

								int Ally = g_pGuildAlly[Guild];

								if (!Ally)
									Ally = -2;

								if (!Guild && !MobGuild)
									Guild = -1;

								if (idxleader == mobleader || Guild == MobGuild || Ally == MobGuild)
									continue;

								if (!alvo1)
								{
									alvo1 = tmob;
									continue;
								}

								if (alvo1 == tmob)
									continue;

								if (!alvo2)
								{
									alvo2 = tmob;
									continue;
								}
								if (alvo2 == tmob)
									continue;

								if (!alvo3)
								{
									alvo3 = tmob;
									continue;
								}
								if (alvo3 == tmob)
									continue;

								if (!alvo4)
								{
									alvo4 = tmob;
									continue;
								}
								if (alvo4 == tmob)
									continue;

								if (!alvo6)
								{
									alvo6 = tmob;
									continue;
								}

								if (alvo6 == tmob || alvo7)
									continue;

								alvo7 = tmob;
							}
						}
					}

					if (alvo1)
					{
						MSG_Attack sm;

						memset(&sm, 0, sizeof(MSG_Attack));

						sm.Type = _MSG_Attack;
						sm.ID = idx;
						sm.Size = sizeof(MSG_Attack);

						sm.ClientTick = 0xE0A1ACA;
						sm.Motion = 254;

						sm.TargetX = pMob[idx].TargetX;
						sm.TargetY = pMob[idx].TargetY;

						sm.CurrentMp = -2;

						if (pMob[idx].MOB.Equip[0].sIndex == 219)
							sm.CurrentMp = -4;

						sm.AttackerID = idx;
						sm.SkillIndex = 52;

						int calc = 5000 + rand() % 100 + (pMob[idx].extra.ClassMaster == MORTAL || pMob[idx].extra.ClassMaster == MORTAL ? Level : Level + MAX_CLEVEL) + AffectLevel;

						sm.Dam[0].TargetID = alvo1;
						sm.Dam[0].Damage = -1;

						if (calc > 300)
						{
							sm.Dam[1].TargetID = alvo2;
							sm.Dam[1].Damage = -1;
						}

						if (calc > 350)
						{
							sm.Dam[2].TargetID = alvo3;
							sm.Dam[2].Damage = -1;
						}

						if (calc > 400)
						{
							sm.Dam[3].TargetID = alvo4;
							sm.Dam[3].Damage = -1;
						}

						if (calc > 450)
						{
							sm.Dam[4].TargetID = alvo6;
							sm.Dam[4].Damage = -1;
						}

						if (calc > 500)
						{
							sm.Dam[5].TargetID = alvo7;
							sm.Dam[5].Damage = -1;
						}


						if (idx < MAX_USER)
							ProcessClientMessage(idx, (char*)&sm, TRUE);
					}
				}
#pragma endregion
#pragma region Chama Resistente
				if (Type == 46)
				{
					int alvo1 = 0;

					unsigned char map_att = GetAttribute(pMob[idx].TargetX, pMob[idx].TargetY);

					int Clan = pMob[idx].MOB.Clan;

					if (map_att & 1)
						goto LessAffect;

					int yv = pMob[idx].TargetY - 1;
					int xv = pMob[idx].TargetX - 1;
					int leader = pMob[idx].Leader;

					if (leader <= 0)
						leader = idx;

					for (int yy = yv; yy <= (yv + 1); yy++)
					{
						for (int xx = xv; xx <= (xv + 1); xx++)
						{
							if (xx < 0 || xx >= MAX_GRIDX || yy < 0 || yy >= MAX_GRIDY || pMobGrid[yy][xx] <= 0 || pMobGrid[yy][xx] >= MAX_MOB || !pMob[pMobGrid[yy][xx]].Mode || pMob[pMobGrid[yy][xx]].MOB.CurrentScore.Hp <= 0 || leader == pMob[pMobGrid[yy][xx]].Leader)
								continue;

							int tmob = pMobGrid[yy][xx];

							int tclan = pMob[tmob].MOB.Clan;
							int SameClan = 0;

							if (Clan == 7 && tclan == 7 || Clan == 8 && tclan == 8)
								SameClan = 1;

							if (pMob[tmob].MOB.Merchant & 1)
								continue;

							unsigned char map_attack = GetAttribute(xx, yy);

							if (map_attack & 1)
								continue;

							if (idx >= MAX_USER)
								break;

							if ((pUser[idx].PKMode || tmob >= MAX_USER && tclan != 4 && SameClan != 1) && (map_att & 0x40 || tmob >= 100 && tclan != 4 && SameClan != 1) && !(pMob[tmob].MOB.Rsv & 0x10))
							{
								if (SameClan == 1 && tmob >= MAX_USER || tclan == 6 || tmob == idx)
									continue;

								int idxleader = pMob[idx].Leader;

								if (!idxleader)
									idxleader = idx;

								int mobleader = pMob[tmob].Leader;
								if (!mobleader)
									mobleader = tmob;

								int Guild = pMob[idx].MOB.Guild;

								if (pMob[idx].GuildDisable)
									Guild = 0;

								int MobGuild = pMob[tmob].MOB.Guild;

								if (pMob[tmob].GuildDisable)
									MobGuild = 0;

								int Ally = g_pGuildAlly[Guild];

								if (!Ally)
									Ally = -2;

								if (!Guild && !MobGuild)
									Guild = -1;

								if (idxleader == mobleader || Guild == MobGuild || Ally == MobGuild)
									continue;

								if (!alvo1)
								{
									alvo1 = tmob;
									continue;
								}

								if (alvo1 == tmob)
									continue;
							}
						}
					}

					yv = pMob[idx].TargetY - 4;
					xv = pMob[idx].TargetX - 4;


					for (int yy = yv; yy <= (yv + 4); yy++)
					{
						for (int xx = xv; xx <= (xv + 4); xx++)
						{
							if (xx < 0 || xx >= MAX_GRIDX || yy < 0 || yy >= MAX_GRIDY || pMobGrid[yy][xx] <= 0 || pMobGrid[yy][xx] >= MAX_MOB || !pMob[pMobGrid[yy][xx]].Mode || pMob[pMobGrid[yy][xx]].MOB.CurrentScore.Hp <= 0 || leader == pMob[pMobGrid[yy][xx]].Leader)
								continue;

							int tmob = pMobGrid[yy][xx];

							int tclan = pMob[tmob].MOB.Clan;
							int SameClan = 0;

							if (Clan == 7 && tclan == 7 || Clan == 8 && tclan == 8)
								SameClan = 1;

							if (pMob[tmob].MOB.Merchant & 1)
								continue;

							unsigned char map_attack = GetAttribute(xx, yy);

							if (map_attack & 1)
								continue;

							if (idx >= MAX_USER)
								break;

							if ((pUser[idx].PKMode || tmob >= MAX_USER && tclan != 4 && SameClan != 1) && (map_att & 0x40 || tmob >= MAX_USER && tclan != 4 && SameClan != 1) && !(pMob[tmob].MOB.Rsv & 0x10))
							{
								if (SameClan == 1 && tmob >= MAX_USER || tclan == 6 || tmob == idx)
									continue;

								int idxleader = pMob[idx].Leader;

								if (!idxleader)
									idxleader = idx;

								int mobleader = pMob[tmob].Leader;
								if (!mobleader)
									mobleader = tmob;

								int Guild = pMob[idx].MOB.Guild;

								if (pMob[idx].GuildDisable)
									Guild = 0;

								int MobGuild = pMob[tmob].MOB.Guild;

								if (pMob[tmob].GuildDisable)
									MobGuild = 0;

								int Ally = g_pGuildAlly[Guild];

								if (!Ally)
									Ally = -2;

								if (!Guild && !MobGuild)
									Guild = -1;

								if (idxleader == mobleader || Guild == MobGuild || Ally == MobGuild)
									continue;

								if (!alvo1)
								{
									alvo1 = tmob;
									continue;
								}

								if (alvo1 == tmob)
									continue;
							}
						}
					}

					if (alvo1)
					{
						MSG_Attack sm;

						memset(&sm, 0, sizeof(MSG_AttackOne));

						sm.Type = _MSG_AttackOne;
						sm.ID = idx;
						sm.Size = sizeof(MSG_AttackOne);

						sm.ClientTick = 0xE0A1ACA;
						sm.Motion = 254;

						sm.TargetX = pMob[idx].TargetX;
						sm.TargetY = pMob[idx].TargetY;

						sm.CurrentMp = -2;

						sm.AttackerID = idx;
						sm.SkillIndex = 48;

						//int calc = 500 + rand() % 100 + (pMob[idx].extra.ClassMaster == MORTAL || pMob[idx].extra.ClassMaster == MORTAL ? Level : Level + MAX_CLEVEL) + AffectLevel;

						sm.Dam[0].TargetID = alvo1;
						sm.Dam[0].Damage = -1;

						if (idx < MAX_USER)
							ProcessClientMessage(idx, (char*)&sm, TRUE);
					}
				}
#pragma endregion
#pragma region Affects less time
				LessAffect :
						   if (pMob[idx].Affect[i].Time < 32400000)
							   pMob[idx].Affect[i].Time--;


						   if (pMob[idx].Affect[i].Time <= 0)
						   {
							   if (pMob[idx].Affect[i].Type == 16 || pMob[idx].Affect[i].Type == 33)
								   FaceChange = 1;

							   pMob[idx].Affect[i].Type = 0;
							   pMob[idx].Affect[i].Time = 0;
							   pMob[idx].Affect[i].Value = 0;
							   pMob[idx].Affect[i].Level = 0;
							   upScore = 1;
						   }
#pragma endregion
			}

			if (regen)
			{
				if (idx > 0 && idx < MAX_USER)
				{
					SetReqHp(idx);
					SetReqMp(idx);
				}
				MSG_SetHpDam dam;

				dam.Type = _MSG_SetHpDam;
				dam.Size = sizeof(MSG_SetHpDam);
				dam.ID = idx;

				dam.Hp = pMob[idx].MOB.CurrentScore.Hp;
				dam.Dam = Damage;

				GridMulticast(pMob[idx].TargetX, pMob[idx].TargetY, (MSG_STANDARD*)&dam, 0);
			}
			if (upScore)
			{
				pMob[idx].GetCurrentScore(idx);
				SendScore(idx);

				if (FaceChange)
					SendEquip(idx, 0);

				return TRUE;
			}
			else
				return 0;

			return 0;
}

void SendDamage(int x1, int y1, int x2, int y2)
{
	for (int i = 0; i < MAX_USER; i++)
	{
		if (pUser[i].Mode != USER_PLAY)
			continue;

		if (pMob[i].MOB.CurrentScore.Hp <= 0)
			continue;

		if (pMob[i].TargetX < x1 || pMob[i].TargetX > x2 || pMob[i].TargetY < y1 || pMob[i].TargetY > y2)
			continue;

		int UNK = 1048576000;

		int dam_base = 2000;

		int hp = pMob[i].MOB.CurrentScore.Hp;

		if (hp < dam_base)
			dam_base = hp - 1;

		int dam = hp - dam_base;


		if (hp < dam_base)
			dam = hp;

		if (hp < 1)
			dam = 1;

		int req_hp = dam - pMob[i].MOB.CurrentScore.Hp;

		pMob[i].MOB.CurrentScore.Hp = dam;

		pUser[i].ReqHp = dam;

		SetReqHp(i);
		SetReqMp(i);

		MSG_SetHpDam sm;
		memset(&sm, 0, sizeof(MSG_SetHpDam));

		sm.Type = _MSG_SetHpDam;
		sm.Size = sizeof(MSG_SetHpDam);
		sm.ID = i;

		sm.Hp = dam;
		sm.Dam = req_hp;

		GridMulticast(pMob[i].TargetX, pMob[i].TargetY, (MSG_STANDARD*)&sm, 0);
	}
}

void SendDamageKingdom(int x1, int y1, int x2, int y2, int Clan)
{
	for (int i = 0; i < MAX_USER; i++)
	{
		if (pUser[i].Mode != USER_PLAY)
			continue;

		if (pMob[i].MOB.CurrentScore.Hp <= 0)
			continue;

		if (pMob[i].TargetX < x1 || pMob[i].TargetX > x2 || pMob[i].TargetY < y1 || pMob[i].TargetY > y2)
			continue;

		if (pMob[i].MOB.Clan == Clan)
			continue;

		int UNK = 1048576000;

		int dam_base = pMob[i].MOB.CurrentScore.MaxHp / 10;

		int hp = pMob[i].MOB.CurrentScore.Hp;

		if (hp < dam_base)
			dam_base = hp - 1;

		int dam = hp - dam_base;


		if (hp < dam_base)
			dam = hp;

		if (hp < 1)
			dam = 1;

		int req_hp = dam - pMob[i].MOB.CurrentScore.Hp;

		pMob[i].MOB.CurrentScore.Hp = dam;

		pUser[i].ReqHp = dam;

		SetReqHp(i);
		SetReqMp(i);

		MSG_SetHpDam sm;
		memset(&sm, 0, sizeof(MSG_SetHpDam));

		sm.Type = _MSG_SetHpDam;
		sm.Size = sizeof(MSG_SetHpDam);
		sm.ID = i;

		sm.Hp = dam;
		sm.Dam = req_hp;

		GridMulticast(pMob[i].TargetX, pMob[i].TargetY, (MSG_STANDARD*)&sm, 0);
	}
}

void SendDamageLeader(int x1, int y1, int x2, int y2)
{
	int HaveUser = 0;

	for (int x = x1; x < x2; x++)
	{
		for (int y = y1; y < y2; y++)
		{
			if (x < 0 || x >= MAX_GRIDX || y < 0 || y >= MAX_GRIDY)
				continue;

			if (pMobGrid[y][x] == 0)
				continue;

			if (pMobGrid[y][x] >= MAX_USER)
				continue;

			int tmob = pMobGrid[y][x];

			if (tmob == Pista[4].Party[0].LeaderID)
			{
				HaveUser++;
				continue;
			}

			if (tmob == Pista[4].Party[1].LeaderID)
			{
				HaveUser++;
				continue;
			}
			if (tmob == Pista[4].Party[1].LeaderID)
			{
				HaveUser++;
				continue;
			}
		}
	}

	if (HaveUser)
		return;

	for (int i = 0; i < MAX_USER; i++)
	{
		if (pUser[i].Mode != USER_PLAY)
			continue;

		if (pMob[i].MOB.CurrentScore.Hp <= 0)
			continue;

		if (pMob[i].TargetX < x1 || pMob[i].TargetX > x2 || pMob[i].TargetY < y1 || pMob[i].TargetY > y2)
			continue;

		int UNK = 1048576000;

		int dam_base = 2000;

		int hp = pMob[i].MOB.CurrentScore.Hp;

		if (hp < dam_base)
			dam_base = hp - 1;

		int dam = hp - dam_base;


		if (hp < dam_base)
			dam = hp;

		if (hp < 1)
			dam = 1;

		int req_hp = dam - pMob[i].MOB.CurrentScore.Hp;

		pMob[i].MOB.CurrentScore.Hp = dam;

		pUser[i].ReqHp = dam;

		SetReqHp(i);
		SetReqMp(i);

		MSG_SetHpDam sm;
		memset(&sm, 0, sizeof(MSG_SetHpDam));

		sm.Type = _MSG_SetHpDam;
		sm.Size = sizeof(MSG_SetHpDam);
		sm.ID = i;

		sm.Hp = dam;
		sm.Dam = req_hp;

		GridMulticast(pMob[i].TargetX, pMob[i].TargetY, (MSG_STANDARD*)&sm, 0);
	}
}

void SummonGuild2(int Guild, int tx, int ty, int maxsummon, int village)
{
	if (Guild <= 0)
		return;

	int summons = 0;

	for (int i = 0; i < MAX_USER; i++)
	{
		if (pUser[i].Mode != USER_PLAY || pMob[i].Mode == USER_EMPTY)
			continue;

		if (pMob[i].MOB.Guild != Guild)
			continue;

		if (pUser[i].OnlyTrade)
			continue;

		if (village < 1 || village > 3 || BASE_GetVillage(pMob[i].TargetX, pMob[i].TargetY) == village)
		{
			DoTeleport(i, tx, ty);

			summons++;

			if (summons == 30)
			{
				tx++;
				ty++;
			}

			if (summons == 45)
			{
				tx = tx - 2;
				ty = ty - 2;
			}

			if (summons >= maxsummon)
				break;
		}
	}
}

void SendItemagrupar(const int client, int itemID)
{

	int x = 0;
	int invfree = 0;
	int i = 0;
	int j = 0;

	//Verificar espaço no inventário
	for (x = 0; x < pMob[client].MaxCarry; x++)
	{
		if (pMob[client].MOB.Carry[x].sIndex == 0)
			invfree++;
	}

	if (invfree < 1)
	{
		for (j = 0; j < pMob[client].MaxCarry; j++)
		{
			if (pMob[client].MOB.Carry[j].sIndex != itemID)
				continue;

			break;
		}

		if (j != pMob[client].MaxCarry)
		{

			for (i = 0; i < pMob[client].MaxCarry; i++)
			{
				if (pMob[client].MOB.Carry[i].sIndex == itemID && pMob[client].MOB.Carry[i].stEffect[0].cValue < 120)
				{
					int amount = BASE_GetItemAmount(&pMob[client].MOB.Carry[i]);

					if (amount < 120)
						BASE_SetItemAmount(&pMob[client].MOB.Carry[i], amount + 1);

					SendItem(client, ITEM_PLACE_CARRY, i, &pMob[client].MOB.Carry[i]);

					return;
				}



			}

		}
		SendClientMessage(client, "Seu inventário está cheio");

		return;
	}

	for (j = 0; j < pMob[client].MaxCarry; j++)
	{
		if (pMob[client].MOB.Carry[j].sIndex != itemID)
			continue;

		break;
	}


	if (j != pMob[client].MaxCarry)
	{

		for (i = 0; i < pMob[client].MaxCarry; i++)
		{
			if (pMob[client].MOB.Carry[i].sIndex == itemID && pMob[client].MOB.Carry[i].stEffect[0].cValue < 120)
			{
				int amount = BASE_GetItemAmount(&pMob[client].MOB.Carry[i]);

				if (amount < 120)
					BASE_SetItemAmount(&pMob[client].MOB.Carry[i], amount + 1);

				SendItem(client, ITEM_PLACE_CARRY, i, &pMob[client].MOB.Carry[i]);

				return;
			}



		}

	}
	sendeitempremio(client, itemID, 1);
	return;
}

void sendeitempremio(const int client, int itemID, int valor)
{

	STRUCT_ITEM Item;
	memset(&Item, 0, sizeof(STRUCT_ITEM));

	int x = 0;
	int invfree = 0;

	//Verificar espaço no inventário
	for (x = 0; x < pMob[client].MaxCarry; x++)
	{
		if (pMob[client].MOB.Carry[x].sIndex == 0)
			invfree++;
	}

	if (invfree < 1)
	{
		SendClientMessage(client, "Seu inventário está cheio");
		pUser[client].TimeLojinha = 0;
		return;
	}


	Item.sIndex = itemID;
	Item.stEffect[0].cEffect = 61;
	Item.stEffect[0].cValue = valor;

	//entegrar item
	PutItem(client, &Item);
	//sprintf(temp, "!Chegou um item [%s]", g_pItemList[Item.sIndex].Name);
	//SendClientMessage(client, temp);
	SendScore(client);
	//SaveUser(conn, 0);
	//pUser[client].TimeLoja = 0;

	return;
}


void SummonGuild(int Guild, int tx, int ty, int maxsummon, int village)
{
	if (Guild <= 0)
		return;

	int summons = 0;

	for (int i = 0; i < MAX_USER; i++)
	{
		if (pUser[i].Mode != USER_PLAY || pMob[i].Mode == USER_EMPTY)
			continue;

		if (pMob[i].MOB.Guild != Guild)
			continue;

		if (pUser[i].OnlyTrade)
			continue;

		if (village && village != 1 && village != 3 || BASE_GetVillage(pMob[i].TargetX, pMob[i].TargetY) == village)
		{
			if (village != 2 || pMob[i].extra.ClassMaster == MORTAL)
			{
				DoTeleport(i, tx, ty);

				summons++;

				if (summons == 30)
				{
					tx++;
					ty++;
				}

				if (summons == 45)
				{
					tx = tx - 2;
					ty = ty - 2;
				}

				if (summons >= maxsummon)
					break;
			}
			else
		 
			SendMsgExp(i, g_pMessageStringTable[_NN_3rd_village_limit], TNColor::Default, false);
		}
	}
}

void ClearAreaQuest(int conn, int x1, int y1, int x2, int y2)
{
	for (int i = 0; i < MAX_USER; i++)
	{

		if (pUser[conn].Mode != USER_PLAY)
			continue;

		if (pMob[conn].Mode == USER_EMPTY)
			continue;

		if (pMob[conn].TargetX < x1 || pMob[conn].TargetX > x2 || pMob[conn].TargetY < y1 || pMob[conn].TargetY > y2)
			continue;

		if (pMob[conn].MOB.CurrentScore.Hp <= 0)
		{
			pMob[conn].MOB.CurrentScore.Hp = 2;
			SendScore(conn);
		}

		pMob[conn].QuestFlag = 0;
		pMob[conn].extra.CheckTimeKersef = 0;
		pMob[conn].CheckQuest = 0;
		//pMob[conn].MOB.CheckQuestisDead = FALSE;
		DoRecall(conn);
	}
}
void ClearAreaQuestold(int x1, int y1, int x2, int y2)
{
	for (int i = 0; i < MAX_USER; i++)
	{
		if (pUser[i].Mode != USER_PLAY)
			continue;

		if (pMob[i].Mode == USER_EMPTY)
			continue;

		if (pMob[i].TargetX < x1 || pMob[i].TargetX > x2 || pMob[i].TargetY < y1 || pMob[i].TargetY > y2)
			continue;

		if (pMob[i].MOB.CurrentScore.Hp <= 0)
		{
			pMob[i].MOB.CurrentScore.Hp = 2;
			SendScore(i);
		}

		pMob[i].QuestFlag = 0;
		DoRecall(i);
	}
}

void ClearMobArea(int x1, int y1, int x2, int y2)
{
	for (int i = MAX_USER; i < MAX_MOB; i++)
	{
		if (pMob[i].Mode == USER_EMPTY)
			continue;

		if (pMob[i].TargetX < x1 || pMob[i].TargetX > x2 || pMob[i].TargetY < y1 || pMob[i].TargetY > y2)
			continue;

		DeleteMob(i, 1);
	}
}

void ClearArea(int x1, int y1, int x2, int y2)
{
	for (int i = 0; i < MAX_USER; i++)
	{
		if (pUser[i].Mode != USER_PLAY)
			continue;

		if (pMob[i].Mode == USER_EMPTY)
			continue;

		if (pMob[i].TargetX < x1 || pMob[i].TargetX > x2 || pMob[i].TargetY < y1 || pMob[i].TargetY > y2)
			continue;

		if (pMob[i].MOB.CurrentScore.Hp <= 0)
		{
			pMob[i].MOB.CurrentScore.Hp = 2;
			SendScore(i);
		}
		pUser[i].CaptchaDelay = GetTickCount64();

		pMob[i].QuestFlag = 0;
		pMob[i].LanNFlag = 0;
		pMob[i].LanMFlag = 0;
		pMob[i].LanAFlag = 0;
		DoRecall(i);
	}
}

void ClearAreaNoVip(int x1, int y1, int x2, int y2)
{
	for (int i = 0; i < MAX_USER; i++)
	{
		if (pUser[i].Mode != USER_PLAY)
			continue;

		if (pMob[i].Mode == USER_EMPTY)
			continue;

		if (pMob[i].TargetX < x1 || pMob[i].TargetX > x2 || pMob[i].TargetY < y1 || pMob[i].TargetY > y2)
			continue;

		if (pMob[i].MOB.CurrentScore.Hp <= 0)
		{
			pMob[i].MOB.CurrentScore.Hp = 2;
			SendScore(i);
		}

		if (pUser[i].Keys[1] == 1)
			continue;

		DoRecall(i);
	}
}

void ClearAreaVip(int x1, int y1, int x2, int y2)
{
	for (int i = 0; i < MAX_USER; i++)
	{
		if (pUser[i].Keys[1] == 0)
			continue;

		if (pUser[i].Mode != USER_PLAY)
			continue;

		if (pMob[i].Mode == USER_EMPTY)
			continue;

		if (pMob[i].TargetX < x1 || pMob[i].TargetX > x2 || pMob[i].TargetY < y1 || pMob[i].TargetY > y2)
			continue;

		if (pMob[i].MOB.CurrentScore.Hp <= 0)
		{
			pMob[i].MOB.CurrentScore.Hp = 2;
			SendScore(i);
		}
		DoRecall(i);
	}
}

void ClearAreaLevel(int x1, int y1, int x2, int y2, int minLv, int maxLv)
{
	for (int i = 0; i < MAX_USER; i++)
	{
		if (pUser[i].Mode != USER_PLAY)
			continue;

		if (pMob[i].Mode == USER_EMPTY)
			continue;

		if (pMob[i].TargetX < x1 || pMob[i].TargetX > x2 || pMob[i].TargetY < y1 || pMob[i].TargetY > y2)
			continue;

		if (pMob[i].MOB.CurrentScore.Level < minLv)
			continue;

		if (pMob[i].MOB.CurrentScore.Level > maxLv)
			continue;

		if (pMob[i].MOB.CurrentScore.Hp <= 0)
		{
			pMob[i].MOB.CurrentScore.Hp = 2;
			SendScore(i);
		}

		DoRecall(i);
	}
}

void ClearAreaGuild(int x1, int y1, int x2, int y2, int Guild)
{
	for (int i = 0; i < MAX_USER; i++)
	{
		if (pUser[i].Mode != USER_PLAY)
			continue;

		if (pMob[i].Mode == USER_EMPTY)
			continue;

		if (pMob[i].TargetX < x1 || pMob[i].TargetX > x2 || pMob[i].TargetY < y1 || pMob[i].TargetY > y2)
			continue;

		if (pMob[i].MOB.Guild == Guild)
			continue;

		if (pMob[i].MOB.CurrentScore.Hp <= 0)
		{
			pMob[i].MOB.CurrentScore.Hp = 2;
			SendScore(i);
		}

		DoRecall(i);
	}
}

void ClearAreaTeleport(int x1, int y1, int x2, int y2, int tx, int ty)
{
	for (int i = 0; i < MAX_USER; i++)
	{
		if (pUser[i].Mode != USER_PLAY)
			continue;

		if (pMob[i].Mode == USER_EMPTY)
			continue;

		if (pMob[i].TargetX < x1 || pMob[i].TargetX > x2 || pMob[i].TargetY < y1 || pMob[i].TargetY > y2)
			continue;

		if (pMob[i].MOB.CurrentScore.Hp <= 0)
		{
			pMob[i].MOB.CurrentScore.Hp = 1;

			SendScore(i);
		}
		/*
		if(rand()%1 == 0)
			tx -= rand()%3;
		else
			tx += rand()%3;

		if(rand()%1 == 0)
			ty -= rand()%3;
		else
			ty += rand()%3;
*/
		DoTeleport(i, tx, ty);
	}
}

void ClearGuildPKZone()
{
	int x1 = 128;
	int y1 = 128;

	int x2 = 256;
	int y2 = 256;

	for (int i = 0; i < MAX_USER; i++)
	{
		if (pUser[i].Mode != USER_PLAY)
			continue;

		if (pMob[i].Mode == 0)
			continue;

		if (pMob[i].TargetX >= x1 && pMob[i].TargetX <= x2 && pMob[i].TargetY >= y1 && pMob[i].TargetY <= y2)
			DoRecall(i);
	}
}

void SetBigCuboDoor(int state)
{
	int gate = 0;

	int height = 0;

	for (int i = 0; i < 10; i++)
	{
		gate = i + 49;

		if (pItem[i + 49].ITEM.sIndex <= 0 || pItem[gate].ITEM.sIndex >= MAX_ITEMLIST)
			continue;

		if (pItem[gate].State == state)
			continue;

		UpdateItem(gate, state, &height);

		if (state == 1)
		{
			MSG_UpdateItem sm;
			memset(&sm, 0, sizeof(MSG_UpdateItem));

			sm.ID = ESCENE_FIELD;
			sm.Type = _MSG_UpdateItem;

			sm.ItemID = gate + 10000;

			sm.Size = sizeof(MSG_UpdateItem);

			//		sm.Height = height;
			sm.State = pItem[gate].State;

			GridMulticast(pItem[gate].PosX, pItem[gate].PosY, (MSG_STANDARD*)&sm, 0);
		}
		else
		{
			MSG_CreateItem sm;
			memset(&sm, 0, sizeof(MSG_CreateItem));

			GetCreateItem(gate, &sm);

			GridMulticast(pItem[gate].PosX, pItem[gate].PosY, (MSG_STANDARD*)&sm, 0);
		}

		pItem[gate].Delay = 0;
	}
}

void SetColoseumDoor(int state)
{
	int gate = 0;

	int height = 0;

	for (int i = 0; i < 2; i++)
	{
		gate = i + 13;

		if (pItem[i + 13].ITEM.sIndex <= 0 || pItem[gate].ITEM.sIndex >= MAX_ITEMLIST)
			continue;

		if (pItem[gate].State == state)
			continue;

		UpdateItem(gate, state, &height);

		if (state == STATE_OPEN)
		{
			MSG_UpdateItem sm;
			memset(&sm, 0, sizeof(MSG_UpdateItem));

			sm.ID = ESCENE_FIELD;
			sm.Type = _MSG_UpdateItem;

			sm.ItemID = gate + 10000;

			sm.Size = sizeof(MSG_UpdateItem);

			//		sm.Height = height;
			sm.State = pItem[gate].State;

			GridMulticast(pItem[gate].PosX, pItem[gate].PosY, (MSG_STANDARD*)&sm, 0);
		}
		else
		{
			MSG_CreateItem sm;
			memset(&sm, 0, sizeof(MSG_CreateItem));

			GetCreateItem(gate, &sm);

			GridMulticast(pItem[gate].PosX, pItem[gate].PosY, (MSG_STANDARD*)&sm, 0);
		}
		pItem[gate].Delay = 0;
	}
}

void SetColoseumDoor2(int state)
{
	int gate = 0;

	int height = 0;

	for (int i = 0; i < 5; i++)
	{
		gate = i + 15;

		if (pItem[i + 15].ITEM.sIndex <= 0 || pItem[gate].ITEM.sIndex >= MAX_ITEMLIST)
			continue;

		if (pItem[gate].State == state)
			continue;

		UpdateItem(gate, state, &height);

		if (state == STATE_OPEN)
		{
			MSG_UpdateItem sm;
			memset(&sm, 0, sizeof(MSG_UpdateItem));

			sm.ID = ESCENE_FIELD;
			sm.Type = _MSG_UpdateItem;

			sm.ItemID = gate + 10000;

			sm.Size = sizeof(MSG_UpdateItem);

			//		sm.Height = height;
			sm.State = pItem[gate].State;

			GridMulticast(pItem[gate].PosX, pItem[gate].PosY, (MSG_STANDARD*)&sm, 0);
		}
		else
		{
			MSG_CreateItem sm;
			memset(&sm, 0, sizeof(MSG_CreateItem));

			GetCreateItem(gate, &sm);

			GridMulticast(pItem[gate].PosX, pItem[gate].PosY, (MSG_STANDARD*)&sm, 0);
		}
		pItem[gate].Delay = 0;
	}
}

void GenerateColoseum(int InitID)
{
	int MaxSpawn = 4 + rand() % 4;

	for (int i = 0; i < MaxSpawn; i++)
		GenerateMob(InitID, 0, 0);
}

void DeleteColoseum()
{
	for (int i = MAX_USER; i < MAX_MOB; i++)
	{
		if (!pMob[i].Mode)
			continue;

		if (pMob[i].MOB.CurrentScore.Hp <= 0)
			continue;

		if (!pMob[i].GenerateIndex || pMob[i].GenerateIndex == 1 || pMob[i].GenerateIndex == 2)
			DeleteMob(i, 2);

		if (pMob[i].GenerateIndex == 5 || pMob[i].GenerateIndex == 6 || pMob[i].GenerateIndex == 7)
			DeleteMob(i, 2);
	}
}

void SetArenaDoor(int state)
{
	for (int i = 0; i < ValidGuild; i++)
	{
		if (i == 4)
			continue;

		for (int j = 0; j < 3; j++)
		{
			int gate = 3 * i + j + 1;
			int height = 0;

			if (pItem[gate].ITEM.sIndex <= 0 || pItem[gate].ITEM.sIndex >= MAX_ITEMLIST)
				continue;

			if (pItem[gate].State == state)
				continue;

			UpdateItem(gate, state, &height);

			if (state == STATE_OPEN)
			{
				MSG_UpdateItem sm;
				memset(&sm, 0, sizeof(MSG_UpdateItem));

				sm.ID = ESCENE_FIELD;
				sm.Type = _MSG_UpdateItem;

				sm.ItemID = gate + 10000;

				sm.Size = sizeof(MSG_UpdateItem);

				//sm.Height = height;
				sm.State = pItem[gate].State;

				GridMulticast(pItem[gate].PosX, pItem[gate].PosY, (MSG_STANDARD*)&sm, 0);
			}
			else
			{
				MSG_CreateItem sm;
				memset(&sm, 0, sizeof(MSG_CreateItem));

				GetCreateItem(gate, &sm);

				GridMulticast(pItem[gate].PosX, pItem[gate].PosY, (MSG_STANDARD*)&sm, 0);
			}
			pItem[gate].Delay = 0;
		}
	}
}

void SetCastleDoor(int state)
{
	for (int i = 0; i < 4; i++)
	{
		int DoorId = i + 36;

		if (pItem[DoorId].ITEM.sIndex <= 0 || pItem[DoorId].ITEM.sIndex >= MAX_ITEMLIST)
			continue;

		if (pItem[DoorId].State == state)
			continue;

		int height = 0;

		UpdateItem(DoorId, state, &height);

		if (state == STATE_OPEN)
		{
			MSG_UpdateItem sm;
			memset(&sm, 0, sizeof(MSG_UpdateItem));

			sm.ID = ESCENE_FIELD;
			sm.Type = _MSG_UpdateItem;
			sm.ItemID = DoorId + 10000;
			sm.Size = sizeof(MSG_UpdateItem);
			//		sm.Height = height;
			sm.State = pItem[DoorId].State;

			GridMulticast(pItem[DoorId].PosX, pItem[DoorId].PosY, (MSG_STANDARD*)&sm, 0);
		}
		else
		{
			int keyid = BASE_GetItemAbility(&pItem[DoorId].ITEM, EF_KEYID);

			if (keyid == 15)
				CreateMob("GATE", pItem[DoorId].PosX, pItem[DoorId].PosY, "npc", 0);

			MSG_CreateItem sm;
			memset(&sm, 0, sizeof(MSG_CreateItem));

			GetCreateItem(DoorId, &sm);

			GridMulticast(pItem[DoorId].PosX, pItem[DoorId].PosY, (MSG_STANDARD*)&sm, 0);
		}
		pItem[DoorId].Delay = 0;
	}
}


//Decidir Armia
void DecideWinner0()
{
	int i = 0;

	int ChargeSurvivor = 0;
	int ChallangeSurvivor = 0;

	int ChargeGuild = g_pGuildZone[i].ChargeGuild;
	int ChallangeGuild = g_pGuildZone[i].ChallangeGuild;

	if (ChallangeGuild == 0)
		return;

	char GuildChargeName[256];
	char GuildChallangeName[256];

	BASE_GetGuildName(ServerGroup, g_pGuildZone[i].ChargeGuild, GuildChargeName);
	BASE_GetGuildName(ServerGroup, ChallangeGuild, GuildChallangeName);

	for (int j = g_pGuildZone[i].WarAreaY1; j <= g_pGuildZone[i].WarAreaY2; j++)
	{
		for (int k = g_pGuildZone[i].WarAreaX1; k <= g_pGuildZone[i].WarAreaX2; k++)
		{
			if (j < 0 || j >= MAX_GRIDY || k < 0 || k >= MAX_GRIDX)
				continue;

			int tmob = pMobGrid[j][k];

			if (tmob <= 0 || tmob >= MAX_USER)
				continue;

			if (pUser[tmob].Mode != USER_PLAY)
				continue;

			if (pMob[tmob].Mode == MOB_EMPTY)
				continue;

			if (pMob[tmob].MOB.CurrentScore.Hp <= 0)
				continue;

			int Guild = pMob[tmob].MOB.Guild;
			int Level = pMob[tmob].extra.ClassMaster != MORTAL && pMob[tmob].extra.ClassMaster != MORTAL ? pMob[tmob].MOB.CurrentScore.Level + MAX_LEVEL : pMob[tmob].MOB.CurrentScore.Level;

			if (Guild == 0)
				continue;

			if (Guild == ChargeGuild || Guild == ChallangeGuild)
			{
				sprintf_s(temp, "sys,guild war survive %s(%d-%d)", pMob[tmob].MOB.MobName, Guild, Level);
				SystemLog("-system", "-", 0, temp);

				if (Guild == ChargeGuild)
					ChargeSurvivor += Level;

				else if (Guild == ChallangeGuild)
					ChallangeSurvivor += Level;

				else;
				//Log("err, more than 3 guild, at same guild zone", "-system", 0);
			}
		}
	}

	sprintf_s(temp, "sys,guild war %d result %d(%d) %d(%d)", i, ChargeGuild, ChargeSurvivor, ChallangeGuild, ChallangeSurvivor);
	SystemLog("-system", "-", 0, temp);

	if (ChargeSurvivor < ChallangeSurvivor)
	{
		SendGuildNotice(ChargeGuild, strFmt(g_pMessageStringTable[_SSNN_GuildWarResult], GuildChallangeName, GuildChargeName, ChallangeSurvivor, ChargeSurvivor));
		SendGuildNotice(ChallangeGuild, strFmt(g_pMessageStringTable[_SSNN_GuildWarResult], GuildChallangeName, GuildChargeName, ChallangeSurvivor, ChargeSurvivor));

		g_pGuildZone[i].ChargeGuild = ChallangeGuild;
		g_pGuildZone[i].Victory = 0;
	}
	else
	{
		SendGuildNotice(ChargeGuild, strFmt(g_pMessageStringTable[_SSNN_GuildWarResult], GuildChargeName, GuildChallangeName, ChargeSurvivor, ChallangeSurvivor));
		SendGuildNotice(ChallangeGuild, strFmt(g_pMessageStringTable[_SSNN_GuildWarResult], GuildChargeName, GuildChallangeName, ChargeSurvivor, ChallangeSurvivor));

		if (g_pGuildZone[i].Victory < 4)
			g_pGuildZone[i].Victory++;
	}

	g_pGuildZone[i].ChallangeGuild = 0;

	// Verificação para setar Noatum
	if (g_pGuildZone[1].ChargeGuild == g_pGuildZone[0].ChargeGuild && g_pGuildZone[2].ChargeGuild == g_pGuildZone[0].ChargeGuild && g_pGuildZone[3].ChargeGuild == g_pGuildZone[0].ChargeGuild)
		g_pGuildZone[4].ChargeGuild = g_pGuildZone[0].ChargeGuild;
}

//Decidir Azran
void DecideWinner1()
{
	int i = 1;

	int ChargeSurvivor = 0;
	int ChallangeSurvivor = 0;

	int ChargeGuild = g_pGuildZone[i].ChargeGuild;
	int ChallangeGuild = g_pGuildZone[i].ChallangeGuild;

	if (ChallangeGuild == 0)
		return;

	char GuildChargeName[256];
	char GuildChallangeName[256];

	BASE_GetGuildName(ServerGroup, g_pGuildZone[i].ChargeGuild, GuildChargeName);
	BASE_GetGuildName(ServerGroup, ChallangeGuild, GuildChallangeName);

	for (int j = g_pGuildZone[i].WarAreaY1; j <= g_pGuildZone[i].WarAreaY2; j++)
	{
		for (int k = g_pGuildZone[i].WarAreaX1; k <= g_pGuildZone[i].WarAreaX2; k++)
		{
			if (j < 0 || j >= MAX_GRIDY || k < 0 || k >= MAX_GRIDX)
				continue;

			int tmob = pMobGrid[j][k];

			if (tmob <= 0 || tmob >= MAX_USER)
				continue;

			if (pUser[tmob].Mode != USER_PLAY)
				continue;

			if (pMob[tmob].Mode == MOB_EMPTY)
				continue;

			if (pMob[tmob].MOB.CurrentScore.Hp <= 0)
				continue;

			int Guild = pMob[tmob].MOB.Guild;
			int Level = pMob[tmob].extra.ClassMaster != MORTAL && pMob[tmob].extra.ClassMaster != MORTAL ? pMob[tmob].MOB.CurrentScore.Level + MAX_LEVEL : pMob[tmob].MOB.CurrentScore.Level;

			if (Guild == 0)
				continue;

			if (Guild == ChargeGuild || Guild == ChallangeGuild)
			{
				sprintf_s(temp, "sys,guild war survive %s(%d-%d)", pMob[tmob].MOB.MobName, Guild, Level);
				SystemLog("-system", "-", 0, temp);

				if (Guild == ChargeGuild)
					ChargeSurvivor += Level;

				else if (Guild == ChallangeGuild)
					ChallangeSurvivor += Level;

				else;
				//Log("err, more than 3 guild, at same guild zone", "-system", 0);
			}
		}
	}

	sprintf_s(temp, "sys,guild war %d result %d(%d) %d(%d)", i, ChargeGuild, ChargeSurvivor, ChallangeGuild, ChallangeSurvivor);
	SystemLog("-system", "-", 0, temp);

	if (ChargeSurvivor < ChallangeSurvivor)
	{
		SendGuildNotice(ChargeGuild, strFmt(g_pMessageStringTable[_SSNN_GuildWarResult], GuildChallangeName, GuildChargeName, ChallangeSurvivor, ChargeSurvivor));
		SendGuildNotice(ChallangeGuild, strFmt(g_pMessageStringTable[_SSNN_GuildWarResult], GuildChallangeName, GuildChargeName, ChallangeSurvivor, ChargeSurvivor));

		g_pGuildZone[i].ChargeGuild = ChallangeGuild;
		g_pGuildZone[i].Victory = 0;
	}
	else
	{
		SendGuildNotice(ChargeGuild, strFmt(g_pMessageStringTable[_SSNN_GuildWarResult], GuildChargeName, GuildChallangeName, ChargeSurvivor, ChallangeSurvivor));
		SendGuildNotice(ChallangeGuild, strFmt(g_pMessageStringTable[_SSNN_GuildWarResult], GuildChargeName, GuildChallangeName, ChargeSurvivor, ChallangeSurvivor));

		if (g_pGuildZone[i].Victory < 4)
			g_pGuildZone[i].Victory++;
	}

	g_pGuildZone[i].ChallangeGuild = 0;

}

//Decidir Erion
void DecideWinner2()
{
	int i = 2;

	int ChargeSurvivor = 0;
	int ChallangeSurvivor = 0;

	int ChargeGuild = g_pGuildZone[i].ChargeGuild;
	int ChallangeGuild = g_pGuildZone[i].ChallangeGuild;

	if (ChallangeGuild == 0)
		return;

	char GuildChargeName[256];
	char GuildChallangeName[256];

	BASE_GetGuildName(ServerGroup, g_pGuildZone[i].ChargeGuild, GuildChargeName);
	BASE_GetGuildName(ServerGroup, ChallangeGuild, GuildChallangeName);

	for (int j = g_pGuildZone[i].WarAreaY1; j <= g_pGuildZone[i].WarAreaY2; j++)
	{
		for (int k = g_pGuildZone[i].WarAreaX1; k <= g_pGuildZone[i].WarAreaX2; k++)
		{
			if (j < 0 || j >= MAX_GRIDY || k < 0 || k >= MAX_GRIDX)
				continue;

			int tmob = pMobGrid[j][k];

			if (tmob <= 0 || tmob >= MAX_USER)
				continue;

			if (pUser[tmob].Mode != USER_PLAY)
				continue;

			if (pMob[tmob].Mode == MOB_EMPTY)
				continue;

			if (pMob[tmob].MOB.CurrentScore.Hp <= 0)
				continue;

			int Guild = pMob[tmob].MOB.Guild;
			int Level = pMob[tmob].extra.ClassMaster != MORTAL && pMob[tmob].extra.ClassMaster != MORTAL ? pMob[tmob].MOB.CurrentScore.Level + MAX_LEVEL : pMob[tmob].MOB.CurrentScore.Level;

			if (Guild == 0)
				continue;

			if (Guild == ChargeGuild || Guild == ChallangeGuild)
			{
				sprintf_s(temp, "sys,guild war survive %s(%d-%d)", pMob[tmob].MOB.MobName, Guild, Level);
				SystemLog("-system", "-", 0, temp);

				if (Guild == ChargeGuild)
					ChargeSurvivor += Level;

				else if (Guild == ChallangeGuild)
					ChallangeSurvivor += Level;

				else;
				//Log("err, more than 3 guild, at same guild zone", "-system", 0);
			}
		}
	}

	sprintf_s(temp, "sys,guild war %d result %d(%d) %d(%d)", i, ChargeGuild, ChargeSurvivor, ChallangeGuild, ChallangeSurvivor);
	SystemLog("-system", "-", 0, temp);

	if (ChargeSurvivor < ChallangeSurvivor)
	{
		SendGuildNotice(ChargeGuild, strFmt(g_pMessageStringTable[_SSNN_GuildWarResult], GuildChallangeName, GuildChargeName, ChallangeSurvivor, ChargeSurvivor));
		SendGuildNotice(ChallangeGuild, strFmt(g_pMessageStringTable[_SSNN_GuildWarResult], GuildChallangeName, GuildChargeName, ChallangeSurvivor, ChargeSurvivor));

		g_pGuildZone[i].ChargeGuild = ChallangeGuild;
		g_pGuildZone[i].Victory = 0;
	}
	else
	{
		SendGuildNotice(ChargeGuild, strFmt(g_pMessageStringTable[_SSNN_GuildWarResult], GuildChargeName, GuildChallangeName, ChargeSurvivor, ChallangeSurvivor));
		SendGuildNotice(ChallangeGuild, strFmt(g_pMessageStringTable[_SSNN_GuildWarResult], GuildChargeName, GuildChallangeName, ChargeSurvivor, ChallangeSurvivor));

		if (g_pGuildZone[i].Victory < 4)
			g_pGuildZone[i].Victory++;
	}

	g_pGuildZone[i].ChallangeGuild = 0;
}

//Decidir Nippleheim
void DecideWinner3()
{
	int i = 3;

	int ChargeSurvivor = 0;
	int ChallangeSurvivor = 0;

	int ChargeGuild = g_pGuildZone[i].ChargeGuild;
	int ChallangeGuild = g_pGuildZone[i].ChallangeGuild;

	if (ChallangeGuild == 0)
		return;

	char GuildChargeName[256];
	char GuildChallangeName[256];

	BASE_GetGuildName(ServerGroup, g_pGuildZone[i].ChargeGuild, GuildChargeName);
	BASE_GetGuildName(ServerGroup, ChallangeGuild, GuildChallangeName);

	for (int j = g_pGuildZone[i].WarAreaY1; j <= g_pGuildZone[i].WarAreaY2; j++)
	{
		for (int k = g_pGuildZone[i].WarAreaX1; k <= g_pGuildZone[i].WarAreaX2; k++)
		{
			if (j < 0 || j >= MAX_GRIDY || k < 0 || k >= MAX_GRIDX)
				continue;

			int tmob = pMobGrid[j][k];

			if (tmob <= 0 || tmob >= MAX_USER)
				continue;

			if (pUser[tmob].Mode != USER_PLAY)
				continue;

			if (pMob[tmob].Mode == MOB_EMPTY)
				continue;

			if (pMob[tmob].MOB.CurrentScore.Hp <= 0)
				continue;

			int Guild = pMob[tmob].MOB.Guild;
			int Level = pMob[tmob].extra.ClassMaster != MORTAL && pMob[tmob].extra.ClassMaster != MORTAL ? pMob[tmob].MOB.CurrentScore.Level + MAX_LEVEL : pMob[tmob].MOB.CurrentScore.Level;

			if (Guild == 0)
				continue;

			if (Guild == ChargeGuild || Guild == ChallangeGuild)
			{
				sprintf_s(temp, "sys,guild war survive %s(%d-%d)", pMob[tmob].MOB.MobName, Guild, Level);
				SystemLog("-system", "-", 0, temp);

				if (Guild == ChargeGuild)
					ChargeSurvivor += Level;

				else if (Guild == ChallangeGuild)
					ChallangeSurvivor += Level;

				else;
				//Log("err, more than 3 guild, at same guild zone", "-system", 0);
			}
		}
	}

	sprintf_s(temp, "sys,guild war %d result %d(%d) %d(%d)", i, ChargeGuild, ChargeSurvivor, ChallangeGuild, ChallangeSurvivor);
	SystemLog("-system", "-", 0, temp);

	if (ChargeSurvivor < ChallangeSurvivor)
	{
		SendGuildNotice(ChargeGuild, strFmt(g_pMessageStringTable[_SSNN_GuildWarResult], GuildChallangeName, GuildChargeName, ChallangeSurvivor, ChargeSurvivor));
		SendGuildNotice(ChallangeGuild, strFmt(g_pMessageStringTable[_SSNN_GuildWarResult], GuildChallangeName, GuildChargeName, ChallangeSurvivor, ChargeSurvivor));

		g_pGuildZone[i].ChargeGuild = ChallangeGuild;
		g_pGuildZone[i].Victory = 0;
	}
	else
	{
		SendGuildNotice(ChargeGuild, strFmt(g_pMessageStringTable[_SSNN_GuildWarResult], GuildChargeName, GuildChallangeName, ChargeSurvivor, ChallangeSurvivor));
		SendGuildNotice(ChallangeGuild, strFmt(g_pMessageStringTable[_SSNN_GuildWarResult], GuildChargeName, GuildChallangeName, ChargeSurvivor, ChallangeSurvivor));

		if (g_pGuildZone[i].Victory < 4)
			g_pGuildZone[i].Victory++;
	}

	g_pGuildZone[i].ChallangeGuild = 0;
}

void GuildProcess()
{
	time_t rawtime;
	tm *timeinfo;

	time(&rawtime);
	timeinfo = localtime(&rawtime);

	if (timeinfo->tm_hour == 3 && GuildNameInitialized == 0)
	{
		BASE_InitializeGuildName();

		//Log("sys,GuildName initialized", "-system", 0);

		GuildNameInitialized = 1;
	}

	if (timeinfo->tm_hour > 3 && GuildNameInitialized == 1)
		GuildNameInitialized = 0;

#pragma region Guerra de Noatum
	if (CastleServer == 1 && (timeinfo->tm_hour == 14))
	{
		if (CastleState || timeinfo->tm_min >= 5)
		{
			if (CastleState != 1 || timeinfo->tm_min <= 5 || timeinfo->tm_min >= 10)
			{
				if (CastleState != 2 || timeinfo->tm_min <= 50)
				{
					if (CastleState == 3 && timeinfo->tm_min > 55)
					{
						SendNotice(strFmt(g_pMessageStringTable[_DN_Castle_closed], timeinfo->tm_hour - 17));
						FinishCastleWar();
					}
				}
				else
				{
					SendNotice(strFmt(g_pMessageStringTable[_DN_Castle_will_be_closed], timeinfo->tm_hour - 17));
					CastleState = 3;
				}
			}
			else
			{
				ClearAreaGuild(1036, 1672, 1144, 1764, g_pGuildZone[4].ChargeGuild);

				ClearAreaTeleport(1129, 1705, 1129, 1709, 1057, 1742);
				ClearAreaTeleport(1116, 1705, 1116, 1709, 1057, 1742);
				ClearAreaTeleport(1094, 1688, 1094, 1692, 1057, 1742);
				ClearAreaTeleport(1087, 1609, 1087, 1713, 1057, 1742);
				ClearAreaTeleport(1050, 1690, 1050, 1690, 1057, 1742);
				ClearAreaTeleport(1046, 1690, 1047, 1691, 1057, 1742);
				ClearAreaTeleport(1124, 1708, 1124, 1708, 1057, 1742);

				SetCastleDoor(3);

				for (int i = 0; i < 3; ++i)
				{
					GenerateMob(i + TORRE_NOATUM1, 0, 0);
					LiveTower[i] = 1;
				}

				SendNotice(strFmt(g_pMessageStringTable[_DN_Castle_opened], timeinfo->tm_hour - 17));
				CastleState = 2;
			}
		}
		else
		{
			SendNotice(strFmt(g_pMessageStringTable[_DN_Castle_will_be_open], timeinfo->tm_hour - 17));
			CastleState = 1;

			for (int j = 0; j < MAX_USER; j++)
			{
				if (pUser[j].Mode == USER_PLAY)
					SendClientSignalParm(j, ESCENE_FIELD, 940, CastleState);
			}
		}
	}

//#pragma region Guerra de Cidades
//	int day = GuildDay - 1;
//
//	if (day < 0)
//		day += 7;
//
//	int fweek = timeinfo->tm_wday;
//
//	if (ForceWeekMode != -1)
//		fweek = -1;
//
//	//Libera as Apostas
//	if (WeekMode == 4 && timeinfo->tm_wday == 6) {
//		SendNotice(g_pMessageStringTable[_NN_Guild_Battle_Notice5]);
//		WeekMode = 5;
//	}
//	//Define os desafiantes
//	if (WeekMode == 5 && timeinfo->tm_wday == 0)
//	{
//		SendNotice(g_pMessageStringTable[_NN_Guild_Battle_Notice6]);
//		WeekMode = 0;
//
//		for (int i = 0; i < MAX_GUILDZONE; i++)
//		{
//			if (i == 4)
//				continue;
//
//			if (g_pGuildZone[i].ChallangeGuild == 0 && g_pGuildZone[i].Victory < 4)
//				g_pGuildZone[i].Victory++;
//		}
//	}
//	//Diz para começarem a esperar nas cidades (20h)
//	if (WeekMode == 0 && timeinfo->tm_wday == 0 && timeinfo->tm_hour == GuildHour)
//	{
//		SendNotice(g_pMessageStringTable[_NN_Guild_Battle_Notice1]);
//		WeekMode = 1;
//	}
//	//A guerra de Erion irá começar em 3 minutos e Teleporta os Players (20:02)
//	if (WeekMode == 1 && timeinfo->tm_wday == 0 && timeinfo->tm_hour == GuildHour && timeinfo->tm_min == 2)
//	{
//		SendNotice("A Guerra de Erion irá começar em 3 minutos");
//		ClearGuildPKZone();
//		WeekMode = 2;
//		SetArenaDoor(STATE_LOCKED);
//
//		//0-armia,1-arzan,2-erion,3-nipplehein,4-noatum
//		int n = 2;
//
//		if (g_pGuildZone[n].ChallangeGuild)
//		{
//			if (g_pGuildZone[n].ChargeGuild)
//				SummonGuild(g_pGuildZone[n].ChargeGuild, g_pGuildZone[n].ChargeWarSpawnX, g_pGuildZone[n].ChargeWarSpawnY, NumGuildBattle, n);
//		}
//		if (g_pGuildZone[n].ChallangeGuild)
//			SummonGuild(g_pGuildZone[n].ChallangeGuild, g_pGuildZone[n].ChallangeWarSpawnX, g_pGuildZone[n].ChallangeWarSpawnY, NumGuildBattle, n);
//	}
//	//Guerra de Erion Iniciada (20:05)
//	if (WeekMode == 2 && timeinfo->tm_wday == 0 && timeinfo->tm_hour == GuildHour && timeinfo->tm_min == 5)
//	{
//		SendNotice(g_pMessageStringTable[_NN_Guild_Battle_Notice3]);
//		WeekMode = 3;
//		SetArenaDoor(STATE_OPEN);
//	}
//	//Guerra de Erion Encerrada (20:15)
//	if (WeekMode == 3 && timeinfo->tm_wday == 0 && timeinfo->tm_hour == GuildHour && timeinfo->tm_min == 15)
//	{
//		SendNotice("Guerra de Erion Finalizada!");
//		//0-armia,1-arzan,2-erion,3-nipplehein,4-noatum
//		DecideWinner2();
//		ClearChallanger2();
//		ClearGuildPKZone();
//
//		CReadFiles::WriteChallanger();
//		SetArenaDoor(STATE_LOCKED);
//		WeekMode = 1;
//
//		GuildZoneReport();
//	}
//	//A guerra de Nipplehein irá começar em 3 minutos e Teleporta os Players (20:17)
//	if (WeekMode == 1 && timeinfo->tm_wday == 0 && timeinfo->tm_hour == GuildHour && timeinfo->tm_min == 17)
//	{
//		SendNotice("A Guerra de Nipplehein irá começar em 3 minutos");
//		ClearGuildPKZone();
//		WeekMode = 2;
//		SetArenaDoor(STATE_LOCKED);
//
//		//0-armia,1-arzan,2-erion,3-nipplehein,4-noatum
//		int n = 3;
//
//		if (g_pGuildZone[n].ChallangeGuild)
//		{
//			if (g_pGuildZone[n].ChargeGuild)
//				SummonGuild(g_pGuildZone[n].ChargeGuild, g_pGuildZone[n].ChargeWarSpawnX, g_pGuildZone[n].ChargeWarSpawnY, NumGuildBattle, n);
//		}
//		if (g_pGuildZone[n].ChallangeGuild)
//			SummonGuild(g_pGuildZone[n].ChallangeGuild, g_pGuildZone[n].ChallangeWarSpawnX, g_pGuildZone[n].ChallangeWarSpawnY, NumGuildBattle, n);
//	}
//	//Guerra de Nipplehein Iniciada (20:20)
//	if (WeekMode == 2 && timeinfo->tm_wday == 0 && timeinfo->tm_hour == GuildHour && timeinfo->tm_min == 20)
//	{
//		SendNotice(g_pMessageStringTable[_NN_Guild_Battle_Notice3]);
//		WeekMode = 3;
//		SetArenaDoor(STATE_OPEN);
//	}
//	//Guerra de Nipplehein Encerrada (20:30)
//	if (WeekMode == 3 && timeinfo->tm_wday == 0 && timeinfo->tm_hour == GuildHour && timeinfo->tm_min == 30)
//	{
//		SendNotice("Guerra de Nipplehein Finalizada!");
//		//0-armia,1-arzan,2-erion,3-nipplehein,4-noatum
//		DecideWinner3();
//		ClearChallanger3();
//		ClearGuildPKZone();
//
//		CReadFiles::WriteChallanger();
//		SetArenaDoor(STATE_LOCKED);
//		WeekMode = 1;
//
//		GuildZoneReport();
//	}
//	//A guerra de Azran irá começar em 3 minutos e Teleporta os Players (20:32)
//	if (WeekMode == 1 && timeinfo->tm_wday == 0 && timeinfo->tm_hour == GuildHour && timeinfo->tm_min == 32)
//	{
//		SendNotice("A Guerra de Azran irá começar em 3 minutos");
//		ClearGuildPKZone();
//		WeekMode = 2;
//		SetArenaDoor(STATE_LOCKED);
//
//		//0-armia,1-arzan,2-erion,3-nipplehein,4-noatum
//		int n = 1;
//
//		if (g_pGuildZone[n].ChallangeGuild)
//		{
//			if (g_pGuildZone[n].ChargeGuild)
//				SummonGuild(g_pGuildZone[n].ChargeGuild, g_pGuildZone[n].ChargeWarSpawnX, g_pGuildZone[n].ChargeWarSpawnY, NumGuildBattle, n);
//		}
//		if (g_pGuildZone[n].ChallangeGuild)
//			SummonGuild(g_pGuildZone[n].ChallangeGuild, g_pGuildZone[n].ChallangeWarSpawnX, g_pGuildZone[n].ChallangeWarSpawnY, NumGuildBattle, n);
//	}
//	//Guerra de Azran Iniciada (20:35)
//	if (WeekMode == 2 && timeinfo->tm_wday == 0 && timeinfo->tm_hour == GuildHour && timeinfo->tm_min == 35)
//	{
//		SendNotice(g_pMessageStringTable[_NN_Guild_Battle_Notice3]);
//		WeekMode = 3;
//		SetArenaDoor(STATE_OPEN);
//	}
//	//Guerra de Azran Encerrada (20:45)
//	if (WeekMode == 3 && timeinfo->tm_wday == 0 && timeinfo->tm_hour == GuildHour && timeinfo->tm_min == 45)
//	{
//		SendNotice("Guerra de Azran Finalizada!");
//		//0-armia,1-arzan,2-erion,3-nipplehein,4-noatum
//		DecideWinner1();
//		ClearChallanger1();
//		ClearGuildPKZone();
//
//		CReadFiles::WriteChallanger();
//		SetArenaDoor(STATE_LOCKED);
//		WeekMode = 1;
//
//		GuildZoneReport();
//	}
//	//A guerra de Armia irá começar em 3 minutos e Teleporta os Players (20:47)
//	if (WeekMode == 1 && timeinfo->tm_wday == 0 && timeinfo->tm_hour == GuildHour && timeinfo->tm_min == 47)
//	{
//		SendNotice("A Guerra de Armia irá começar em 3 minutos");
//		ClearGuildPKZone();
//		WeekMode = 2;
//		SetArenaDoor(STATE_LOCKED);
//
//		//0-armia,1-arzan,2-erion,3-nipplehein,4-noatum
//		int n = 0;
//
//		if (g_pGuildZone[n].ChallangeGuild)
//		{
//			if (g_pGuildZone[n].ChargeGuild)
//				SummonGuild(g_pGuildZone[n].ChargeGuild, g_pGuildZone[n].ChargeWarSpawnX, g_pGuildZone[n].ChargeWarSpawnY, NumGuildBattle, n);
//		}
//		if (g_pGuildZone[n].ChallangeGuild)
//			SummonGuild(g_pGuildZone[n].ChallangeGuild, g_pGuildZone[n].ChallangeWarSpawnX, g_pGuildZone[n].ChallangeWarSpawnY, NumGuildBattle, n);
//	}
//	//Guerra de Armia Iniciada (20:50)
//	if (WeekMode == 2 && timeinfo->tm_wday == 0 && timeinfo->tm_hour == GuildHour && timeinfo->tm_min == 50)
//	{
//		SendNotice(g_pMessageStringTable[_NN_Guild_Battle_Notice3]);
//		WeekMode = 3;
//		SetArenaDoor(STATE_OPEN);
//	}
//	//Guerra de Armia Encerrada (20:59)
//	if (WeekMode == 3 && timeinfo->tm_wday == 0 && timeinfo->tm_hour == GuildHour && timeinfo->tm_min == 59)
//	{
//		SendNotice("Guerra de Armia Finalizada!");
//		//0-armia,1-arzan,2-erion,3-nipplehein,4-noatum
//		DecideWinner0();
//		ClearChallanger0();
//		ClearGuildPKZone();
//
//		CReadFiles::WriteChallanger();
//		SetArenaDoor(STATE_LOCKED);
//		WeekMode = 4;
//
//		GuildZoneReport();
//	}
//
//#pragma endregion
#pragma region Guerra de Cidades
	int day = GuildDay - 1;

	if (day < 0)
		day += 7;

	int fweek = timeinfo->tm_wday;

	if (ForceWeekMode != -1)
		fweek = -1;

	if (WeekMode || ((fweek != GuildDay) || timeinfo->tm_hour < GuildHour) && ForceWeekMode != 1)
	{
		if (WeekMode != 1 || (fweek != GuildDay || (timeinfo->tm_hour < GuildHour) || timeinfo->tm_min <= 2) && ForceWeekMode != 2)
		{
			if (WeekMode != 2 || ((fweek != GuildDay) || timeinfo->tm_hour < GuildHour || timeinfo->tm_min <= 5) && ForceWeekMode != 3)
			{
				if (WeekMode != 3
					|| (fweek != GuildDay || (timeinfo->tm_hour < GuildHour) || timeinfo->tm_min <= 20) && ForceWeekMode != 4)
				{
					if (WeekMode != 4 || fweek != day && ForceWeekMode != 5)
					{
						if (WeekMode == 5 && (fweek == GuildDay || !ForceWeekMode))
						{
							SendNotice(g_pMessageStringTable[_NN_Guild_Battle_Notice6]);
							WeekMode = 0;

							for (int i = 0; i < MAX_GUILDZONE; i++)
							{
								if (i == 4)
									continue;

								if (g_pGuildZone[i].ChallangeGuild == 0 && g_pGuildZone[i].Victory < 4)
									g_pGuildZone[i].Victory++;
							}

						}
					}
					else
					{
						SendNotice(g_pMessageStringTable[_NN_Guild_Battle_Notice5]);
						WeekMode = 5;
					}
				}
				else
				{
					SendNotice(g_pMessageStringTable[_NN_Guild_Battle_Notice4]);
					DecideWinner1();
					DecideWinner2();
					DecideWinner3();
					DecideWinner0();
					ClearGuildPKZone();
					ClearChallanger0();
					ClearChallanger1();
					ClearChallanger2();
					ClearChallanger3();
					ClearGuildPKZone();
					CReadFiles::WriteChallanger();
					SetArenaDoor(STATE_LOCKED);
					WeekMode = 4;

					GuildZoneReport();
				}
			}
			else
			{
				SendNotice(g_pMessageStringTable[_NN_Guild_Battle_Notice3]);
				WeekMode = 3;
				SetArenaDoor(STATE_OPEN);
			}
		}
		else
		{
			SendNotice(g_pMessageStringTable[_NN_Guild_Battle_Notice2]);
			ClearGuildPKZone();
			WeekMode = 2;
			SetArenaDoor(STATE_LOCKED);

			for (int n = 0; n < ValidGuild; n++)
			{
				if (n != 4)
				{
					if (g_pGuildZone[n].ChallangeGuild)
					{
						if (g_pGuildZone[n].ChargeGuild)
							SummonGuild(g_pGuildZone[n].ChargeGuild, g_pGuildZone[n].ChargeWarSpawnX, g_pGuildZone[n].ChargeWarSpawnY, NumGuildBattle, n);
					}
				}
			}

			for (int n = 0; n < ValidGuild; n++)
			{
				if (n != 4)
				{
					if (g_pGuildZone[n].ChallangeGuild)
						SummonGuild(g_pGuildZone[n].ChallangeGuild, g_pGuildZone[n].ChallangeWarSpawnX, g_pGuildZone[n].ChallangeWarSpawnY, NumGuildBattle, n);
				}
			}
		}
	}
	else
	{
		SendNotice(g_pMessageStringTable[_NN_Guild_Battle_Notice1]);
		WeekMode = 1;
	}
#pragma endregion
#pragma region Guerra de Reino RVR_ON
	//if (NewbieEventServer == 1 && timeinfo->tm_wday != 0 && timeinfo->tm_wday != 6 && timeinfo->tm_hour == RvRHour)
	if (timeinfo->tm_wday != 0 && timeinfo->tm_wday != 6 && timeinfo->tm_hour == RvRHour)
	{
		if (RvRState == 0 && timeinfo->tm_min < 5)
		{
			SendNotice(strFmt(g_pMessageStringTable[_DD_KINGDOMWAR_BEGIN], 5, ServerIndex + 1));
			RvRState = 1;
		}
		if (RvRState == 1 && timeinfo->tm_min >= 5)
		{
			GenerateMob(RVRTORRE_1, 0, 0);
			GenerateMob(RVRTORRE_2, 0, 0);

			SendNotice(g_pMessageStringTable[_DD_KINGDOMWAR_START]);
			RvRState = 2;
			RvRRedPoint = 0;
			RvRBluePoint = 0;
		}

		if (RvRState == 2 && timeinfo->tm_min >= 29)
			RvRState = 3;

		if (RvRState == 3 && timeinfo->tm_min == 34)
		{
			for (int conn = 1; conn < MAX_USER; conn++)
			{
				if (pMob[conn].MOB.Clan)
				{
					if (RvRRedPoint > RvRBluePoint)
					{
						SendNotice(strFmt(g_pMessageStringTable[_SN_KINGDOMWAR_DROP_], g_pMessageStringTable[_NN_KINGDOM_RED]));
						RvRBonus = 8;
					}
					else if (RvRBluePoint > RvRRedPoint)
					{
						SendNotice(strFmt(g_pMessageStringTable[_SN_KINGDOMWAR_DROP_], g_pMessageStringTable[_NN_KINGDOM_BLUE]));
						RvRBonus = 7;
					}
					else if (RvRBluePoint == RvRRedPoint)
					{
						SendNotice("Guerra de Reinos terminou em empate [Sem Bônus RVR]. ");
						RvRBonus = 0;
					}
				}
			}
			for (int i = MAX_USER; i < MAX_MOB; i++)
			{
				if (pMob[i].GenerateIndex == RVRTORRE_1 || pMob[i].GenerateIndex == RVRTORRE_2)
					DeleteMob(i, 1);
			}

			ClearArea(1020, 1916, 1286, 2178);
			RvRState = 0;
			RvRRedPoint = 0;
			RvRBluePoint = 0;
		}
	}
#pragma endregion
	/*CCOLISEU::ColoProcessN(timeinfo);
	CCOLISEU::ColoProcessM(timeinfo);
	CCOLISEU::ColoProcessA(timeinfo);*/
	CWarTower::GuildProcess(timeinfo); 
}
 
int GetUserInAreaMac(int notUsage, int x1, int y1, int x2, int y2)
{
	int userCount = 0;

	for (int conn = 1; conn < MAX_USER; conn++)
	{
		if (pUser[conn].Mode != USER_PLAY)
			continue;

		if (pMob[conn].Mode == 0)
			continue;

		for (int i = 1; i < MAX_USER; i++)
		{
			if (pUser[i].Mode != USER_PLAY)
				continue;

			if (i == conn) continue;

			if (pMob[i].Mode == 0)
				continue;

			if (pMob[conn].TargetX >= x1 && pMob[conn].TargetX <= x2 && pMob[conn].TargetY >= y1 && pMob[conn].TargetY <= y2)
			{
				if (pMob[i].TargetX >= x1 && pMob[i].TargetX <= x2 && pMob[i].TargetY >= y1 && pMob[i].TargetY <= y2)
				{
					if (!strcmp(pUser[conn].MacAddress, pUser[i].MacAddress))
					{
						DoRecall(i);

						SendClientMessage(i, "Somente 1 conta por computador.");
						userCount++;
						continue;
					}
				}
			}
		}
	}
	return userCount;
}

void StartLog()
{
	if (fLogFile1 != NULL)
		fclose(fLogFile1);

	struct tm when;
	time_t now;
	time(&now);
	when = *localtime(&now);

	sprintf_s(temp, ".\\Logs\\server_log\\TM_%02d_%02d_%04d_%02d_%02d_%02d.txt", when.tm_mday, when.tm_mon + 1, when.tm_year + 1900, when.tm_hour, when.tm_min, when.tm_sec);

	fLogFile1 = fopen(temp, "wt");

	LastLogDay = when.tm_mday;
}

void CrackLog(int conn, char *str)
{
	char AccountName[16];

	if (conn <= 0 || conn >= MAX_USER)
	{
		if (conn < 0 || conn >= MAX_MOB)
			sprintf_s(temp, "index:%d", conn);

		else
			sprintf_s(temp, "mob:%d name:%s", conn, pMob[conn].MOB.MobName);
	}

	else
	{
		memcpy(AccountName, pUser[conn].AccountName, sizeof(pUser[conn].AccountName));

		pUser[conn].AccountName[15] = 0;
		pUser[conn].AccountName[14] = 0;

		sprintf_s(temp, "conn:%d mode:%d name:%s", conn, pUser[conn].Mode, AccountName);
	}

	strcat(temp, str);

	//Log(temp, "-system", 0);

	SetWindowTextA(hWndMain, temp);
}

void StartSystemLog()
{
	if (g_pSystemLog && g_pSystemLog.get()->m_pStream.get()->is_open()) {
		g_pSystemLog.get()->m_pStream.get()->close();
		g_pSystemLog.get()->m_pStream.get()->clear();
		g_pSystemLog.get()->m_pStream.release();
	}

	if (g_pSystemLog)
		g_pSystemLog.release();

	g_pSystemLog = std::make_unique<LogControl>();

	struct tm when;
	time_t now;
	time(&now);
	when = *localtime(&now);
	char temp[1024];
	snprintf(temp, sizeof(temp), ".\\Logs\\server_log\\TM_%02d_%02d_%04d_%02d_%02d_%02d.txt", when.tm_mday, when.tm_mon + 1, when.tm_year + 1900, when.tm_hour, when.tm_min, when.tm_sec);

	char tmg[256];
	snprintf(tmg, sizeof(tmg), "chat logs started successfully");
	SystemLog("-system", "-", 0, tmg);

	g_pSystemLog.get()->Initialize(std::string(temp));

	LastSystemLogDay = when.tm_mday;
}

void SystemLog(char* AccountName, char* MacAddress, unsigned int IPAddress, char* Message)
{
	char temp_str[64] = { 0, };

	if (IPAddress != 0) //for some reason the ip address isn't working properly...
	{
		//Vamo do jeito hard
		sprintf_s(temp_str, "%d.%d.%d.%d",
			IPAddress & 0xFF,
			(IPAddress >> 8) & 0xFF,
			(IPAddress >> 16) & 0xFF,
			(IPAddress >> 24) & 0xFF);
	}
	else
		snprintf(temp_str, sizeof(temp_str), "NO_VALID_IP");

	if (g_pSystemLog)
		g_pSystemLog.get()->WriteLog(std::string(Message), std::string(MacAddress), std::string(temp_str), std::string(AccountName));
}

void Log(char* str1, char* str2, unsigned int ip)
{
	struct tm when;
	time_t now;
	time(&now);
	when = *localtime(&now);

	char LogTemp[1024];

	unsigned char* cIP = (unsigned char*)&ip;

	sprintf_s(LogTemp, "%2.2d%2.2d%2.2d,%2.2d%2.2d%2.2d,%8.8x", when.tm_year - 100, when.tm_mon + 1, when.tm_mday, when.tm_hour, when.tm_min, when.tm_sec, ip);
	sprintf_s(LogTemp, "%s,%s,%s \n", LogTemp, str2, str1);

	if (ip != 0)
		sprintf_s(LogTemp, "[%02d/%02d/%04d][%02d:%02d:%02d] IP: %d.%d.%d.%d.%d", when.tm_mday, when.tm_mon + 1, when.tm_year + 1900, when.tm_hour, when.tm_min, when.tm_sec, cIP[0], cIP[1], cIP[2], cIP[3], cIP[4]);
	else
		sprintf_s(LogTemp, "[%02d/%02d/%04d][%02d:%02d:%02d] ", when.tm_mday, when.tm_mon + 1, when.tm_year + 1900, when.tm_hour, when.tm_min, when.tm_sec);

	sprintf_s(LogTemp, "\n%s %s %s\n", LogTemp, str2, str1);
	printf("%s", LogTemp);  //monitor console

	if (fLogFile1)
		fprintf(fLogFile1, LogTemp);

	SetWindowText(hWndMain, LogTemp);
}

int  GetUserFromSocket(int Sock)
{
	if (Sock == 0)
		return 0;

	for (int i = 1; i < MAX_USER; i++)
	{
		if (pUser[i].cSock.Sock == (unsigned)Sock)
			return i;
	}

	return 0;
}

int  GetEmptyUser(void)
{
	for (int i = 1; i < MAX_USER; i++)
	{
		if (pUser[i].Mode == USER_EMPTY)
			return i;
	}

	return 0;
}

int  GetEmptyItem()
{
	for (int i = 1; i < MAX_ITEM; i++)
	{
		if (pItem[i].Mode == 0)
			return i;
	}

	return 0;
}

int  GetEmptyNPCMob()
{
	static int CurrentNumMob = MAX_USER;
	if (CurrentNumMob >= MAX_MOB)
		CurrentNumMob = MAX_USER;
	int tmpNumMob = CurrentNumMob;
	for (int i = 0; i < MAX_MOB - MAX_USER; ++i)
	{
		if (tmpNumMob < MAX_MOB)
		{
			if (!pMob[tmpNumMob].Mode)
			{
				CurrentNumMob = tmpNumMob;
				CurrentNumMob++;
				return tmpNumMob;
			}
		}
		else
		{
			tmpNumMob = MAX_USER;
		}
		++tmpNumMob;
	}
	return 0;

	//if (g_EmptyMob >= MAX_MOB)
	//	g_EmptyMob = MAX_USER;

	//int MaxCount = MAX_MOB - MAX_USER;
	//int EmptyMob = g_EmptyMob;

	//for (int i = 0; i < MaxCount; i++, EmptyMob++)
	//{
	//	if (EmptyMob >= MAX_MOB)
	//	{
	//		EmptyMob = MAX_USER;

	//		continue;
	//	}

	//	if (pMob[EmptyMob].Mode == MOB_EMPTY)
	//	{
	//		g_EmptyMob = EmptyMob;

	//		return EmptyMob;
	//	}
	//}

	//return 0;
}

int  GetUserByName(char *name)
{
	if (name[0] == '+')
	{
		char *tname = name + 1;

		_strupr(tname);

		for (int i = 1; i < MAX_USER; i++)
		{
			if (pMob[i].Mode == MOB_EMPTY)
				continue;

			if (pUser[i].Mode != USER_PLAY)
				continue;

			if (!strcmp(tname, pUser[i].AccountName))
				return i;
		}
		return 0;
	}

	for (int i = 1; i < MAX_USER; i++)
	{
		if (pMob[i].Mode == MOB_EMPTY)
			continue;

		if (pUser[i].Mode != USER_PLAY)
			continue;

		if (!strcmp(name, pMob[i].MOB.MobName))
			return i;
	}
	return 0;
}

int  IsImple(int user)
{
	return 0;
}

void CloseUser(int conn)
{
	int unk = 0;
	int unk2 = 0;

	if (conn < 0 || conn >= MAX_USER)
		return;

	/*
#pragma region Cubo N
	if (((pMob[conn].TargetX / 128) == 13 && (pMob[conn].TargetY / 128) == 31) && CuboN.pRoom > 0) // Cubo N
		CuboN.pRoom--;

	if (CuboN.pRoom < 0)
		CuboN.pRoom = 0;
#pragma endregion*/

	if (pUser[conn].Mode == USER_PLAY && pMob[conn].TargetX >= 0 && pMob[conn].TargetX < 4096
		&& pMob[conn].TargetY >= 0 && pMob[conn].TargetY < 4096)
	{
		goResetLeilao(conn);

		pMobGrid[pMob[conn].TargetY][pMob[conn].TargetX] = 0;
	}

	if (pUser[conn].IsBillConnect)
		SendBilling(conn, pUser[conn].AccountName, 2, 0);

	pUser[conn].cSock.CloseSocket();

	auto& pc = cSQL::instance();
	sprintf(xQuery, "UPDATE accounts SET online = '%d' WHERE username = '%s' ", 0, pUser[conn].AccountName);
	pc.wQuery(xQuery);

	int Mode = pUser[conn].Mode;

	if (Mode && Mode != USER_ACCEPT)
	{
		if (Mode != USER_PLAY && Mode != USER_SAVING4QUIT)
		{
			MSG_STANDARD sm;
			memset(&sm, 0, sizeof(MSG_STANDARD));

			sm.Type = _MSG_DBNoNeedSave;
			sm.ID = conn;

			DBServerSocket.SendOneMessage((char*)&sm, sizeof(MSG_STANDARD));

			pMob[conn].Mode = USER_EMPTY;

			pUser[conn].CloseUser();
		}

		else
		{
			RemoveParty(conn);

			int tradeOpponentID = pUser[conn].Trade.OpponentID;

			if (tradeOpponentID > 0 && tradeOpponentID < MAX_USER && pUser[tradeOpponentID].Mode == USER_PLAY && pUser[tradeOpponentID].Trade.OpponentID == conn)
				RemoveTrade(tradeOpponentID);

			pUser[conn].Trade.OpponentID = 0;

			MSG_SavingQuit sm; 
			memset(&sm, 0, sizeof(MSG_SavingQuit));

			sm.Type = _MSG_SavingQuit;

			if (conn < 0 || conn > MAX_MOB)
			{
				CrackLog(conn, " SaveAndQuitMobidx");
				return;
			}

			int Slot = pUser[conn].Slot;

			if (Slot < 0 || Slot >= MAX_CLASS)
			{
				CrackLog(conn, " SaveAndQuitWrongSlot");
				return;
			}

			memcpy(&sm.MOB, &pMob[conn], sizeof(STRUCT_MOB));
			memcpy(sm.Cargo, &pUser[conn].Cargo, sizeof(pUser[conn].Cargo));

			sm.chave1 = pUser[conn].chave1;
			sm.chave2 = pUser[conn].chave2;
			sm.chave3 = pUser[conn].chave3;

			sm.Timer.RwdTime = pUser[conn].Timer.RwdTime;
			sm.Timer.VipTime = pUser[conn].Timer.VipTime;
			sm.Timer.Time1 = pUser[conn].Timer.Time1;
			sm.Timer.Time2 = pUser[conn].Timer.Time2;
			sm.Timer.Time3 = pUser[conn].Timer.Time3;
			sm.Timer.Time4 = pUser[conn].Timer.Time4;
			sm.Timer.Time5 = pUser[conn].Timer.Time5;
			sm.Timer.Time6 = pUser[conn].Timer.Time6;

			for (int i = 0; i < 50; i++) {
				sm.Keys[i] = pUser[conn].Keys[i];
			}

			for (int c = 0; c < MAX_AFFECT; c++)
			{
				if (pMob[conn].Affect[c].Type != 33)
				{
					if ((pMob[conn].MOB.Equip[0].sIndex == 316 || pMob[conn].MOB.Equip[0].sIndex == 317 || pMob[conn].MOB.Equip[0].sIndex == 297 ||
						pMob[conn].MOB.Equip[0].sIndex == 202 || pMob[conn].MOB.Equip[0].sIndex == 297 || pMob[conn].MOB.Equip[0].sIndex == 209 ||
						pMob[conn].MOB.Equip[0].sIndex == 212 || pMob[conn].MOB.Equip[0].sIndex == 230 || pMob[conn].MOB.Equip[0].sIndex == 228))
						pMob[conn].MOB.Equip[0].sIndex = pMob[conn].extra.ClassMaster == MORTAL ? pMob[conn].extra.MortalFace : pMob[conn].extra.MortalFace + 5 + pMob[conn].MOB.Class;
				}
			}

			if (pMob[conn].MOB.Class == 1)
			{
				for (int o = 0; o < 4; o++)
				{
					if (pMob[conn].MOB.SkillBar[o] == 106 || pMob[conn].MOB.SkillBar[o] == 109 || pMob[conn].MOB.SkillBar[o] == 114)
					{
						if (pMob[conn].MOB.SkillBar[o] == 106) {
							sm.MOB.SkillBar[o] = 118;
						}

						if (pMob[conn].MOB.SkillBar[o] == 109) {
							sm.MOB.SkillBar[o] = 121;
						}

						if (pMob[conn].MOB.SkillBar[o] == 114) {
							sm.MOB.SkillBar[o] = 126;
						}
					}
					else
						sm.MOB.SkillBar[o] = pMob[conn].MOB.SkillBar[o];
				}
			}

			if (pMob[conn].MOB.Class == 1)
			{
				for (int i = 0; i < 16; i++)
				{
					if (pUser[conn].CharShortSkill[i] >= 0 || pUser[conn].CharShortSkill[i] <= 152)
					{
						// Proteção Absoluta
						if (pUser[conn].CharShortSkill[i] == 106) {
							sm.ShortSkill[i] = 118;
						}

						// Magia Misteriosa
						if (pUser[conn].CharShortSkill[i] == 109) {
							sm.ShortSkill[i] = 121;
						}

						// Incapacitador
						if (pUser[conn].CharShortSkill[i] == 114) {
							sm.ShortSkill[i] = 126;
						}

						sm.ShortSkill[i] = pUser[conn].CharShortSkill[i];
					}
				}
			}
			else
				memcpy(sm.ShortSkill, pUser[conn].CharShortSkill, 16);

			memcpy(sm.affect, pMob[conn].Affect, sizeof(sm.affect));
			sm.extra = pMob[conn].extra;

			strncpy((char*)&sm.AccountName, pUser[conn].AccountName, ACCOUNTNAME_LENGTH);

			sm.Coin = pUser[conn].Coin;
			sm.Donate = pUser[conn].Donate;
			sm.Honra = pUser[conn].Honra;

			for (int i = 0; i < 4; i++) {
				for (int y = 0; y < 2; y++) {
					memcpy(&sm.Joias[i][y], &pUser[conn].Joias[i][y], sizeof(STRUCT_ITEM));
				}
			}

			sm.DonateBuyItem = pUser[conn].Ingame.DonateBuyItem;
			sm.MobDonateStore = pUser[conn].Ingame.MobDonateStore;

			sm.GemaX = pUser[conn].GemaX;
			sm.GemaY = pUser[conn].GemaY;

			pMob[conn].MOB.SPX = pMob[conn].TargetX;
			pMob[conn].MOB.SPY = pMob[conn].TargetY;

			sm.MOB.SPX = pMob[conn].MOB.SPX;
			sm.MOB.SPY = pMob[conn].MOB.SPY;

			pUser[conn].File.Char[pUser[conn].Slot].SPX = sm.MOB.SPX;
			pUser[conn].File.Char[pUser[conn].Slot].SPY = sm.MOB.SPY;

			pUser[conn].SelChar.SPX[pUser[conn].Slot] = pUser[conn].File.Char[pUser[conn].Slot].SPX;
			pUser[conn].SelChar.SPY[pUser[conn].Slot] = pUser[conn].File.Char[pUser[conn].Slot].SPY;

			sm.Slot = pUser[conn].Slot;

			sm.ID = conn;

			DBServerSocket.SendOneMessage((char*)&sm, sizeof(MSG_SavingQuit));

			pUser[conn].Mode = USER_SAVING4QUIT;
			pMob[conn].CheckLojinha = 0;
			strncpy(pMob[conn].Tab, "", 26);
			DeleteMob(conn, 2);
		}

	}

	else
		pUser[conn].CloseUser();
}

CMob *GetMobFromIndex(unsigned int index)
{
	if (index < 0 || index >= MAX_MOB)
		return NULL;

	return &pMob[index];
}

int  GetAngle(int x, int y)
{
	if (x == 0 || y == 0)
		return 0;

	double tangle = atan2((FLOAT)y, (FLOAT)x);

	int angle = (int)((tangle * 3600) / 6.283184);

	if (angle < 0)
		angle += 3600;

	if (angle > 3600)
		angle -= 3600;

	return angle;
}

int  GetLength(int x, int y)
{
	FLOAT valx = (FLOAT)(x * x);
	FLOAT valy = (FLOAT)(y * y);

	FLOAT valxy = valx + valy;

	if (valxy > 100)
		return 100;

	if (valxy <= 0)
		return 0;

	double fout = sqrt(valxy);

	int out = (int)fout;

	return out;
}

int  ReadMob(STRUCT_MOB *mob, char *dir)
{
	sprintf_s(temp, "./%s/%s", dir, mob->MobName);

	int Handle = _open(temp, O_RDONLY | O_BINARY);

	if (Handle == -1)
	{
		if (errno == EINVAL)
			sprintf_s(temp, "err,ReadMob EEXIST %s", mob->MobName);

		else if (errno == EMFILE)
			sprintf_s(temp, "err,ReadMob EMFILE %s", mob->MobName);

		else if (errno == ENOENT)
			sprintf_s(temp, "err,ReadMob ENOENTN %s", mob->MobName);

		else
			sprintf_s(temp, "err,ReadMob UNKNOW %s", mob->MobName);

		//Log(temp, "-system", 0);
		return FALSE;
	}

	strncpy(temp, mob->MobName, NAME_LENGTH);

	int ret = _read(Handle, mob, sizeof(STRUCT_MOB));

	if (ret == -1)
	{
		_close(Handle);

		return FALSE;
	}

	_close(Handle);

	strncpy(mob->MobName, temp, NAME_LENGTH);

	BASE_GetEnglish(mob->MobName);

	mob->BaseScore = mob->CurrentScore;

	return TRUE;
} 

void DeleteMob(int conn, int Type)
{
	MSG_RemoveMob sm;
	memset(&sm, 0, sizeof(MSG_RemoveMob));

	sm.Type = _MSG_RemoveMob;
	sm.Size = sizeof(MSG_RemoveMob);
	sm.ID = conn;
	sm.RemoveType = Type;

	GridMulticast(pMob[conn].TargetX, pMob[conn].TargetY, (MSG_STANDARD*)&sm, conn);

	if (Type != 0)
	{
		if (conn >= MAX_USER)
		{
			int geneidx = pMob[conn].GenerateIndex;

			if (geneidx >= 0 && geneidx < MAX_NPCGENERATOR)
			{
				mNPCGen.pList[geneidx].CurrentNumMob--;

				if (mNPCGen.pList[geneidx].CurrentNumMob < 0)
					mNPCGen.pList[geneidx].CurrentNumMob = 0;
			}
		}

		pMob[conn].MOB.CurrentScore.Hp = 0;
		pMob[conn].Mode = 0;
		pMobGrid[pMob[conn].TargetY][pMob[conn].TargetX] = 0;

		RemoveParty(conn);
	}

}

void SaveUser(int conn, int Export)
{
	MSG_DBSaveMob sm;
	memset(&sm, 0, sizeof(MSG_DBSaveMob));

	sm.Type = _MSG_DBSaveMob;

	memcpy(&sm.MOB, &pMob[conn].MOB, sizeof(STRUCT_MOB));

	memcpy(&sm.Cargo, pUser[conn].Cargo, sizeof(STRUCT_ITEM)* MAX_CARGO);

	sm.Coin = pUser[conn].Coin;

	sm.ID = conn;
	sm.Export = Export;

	sm.Slot = pUser[conn].Slot;
	sm.Donate = pUser[conn].Donate;
	sm.Honra = pUser[conn].Honra;

	sm.DonateBuyItem = pUser[conn].Ingame.DonateBuyItem;
	sm.MobDonateStore = pUser[conn].Ingame.MobDonateStore;

	sm.chave1 = pUser[conn].chave1;
	sm.chave2 = pUser[conn].chave2;
	sm.chave3 = pUser[conn].chave3; 
	sm.chave4 = pUser[conn].chave4;

	sm.Timer.RwdTime = pUser[conn].Timer.RwdTime;
	sm.Timer.VipTime = pUser[conn].Timer.VipTime;
	sm.Timer.Time1 = pUser[conn].Timer.Time1;
	sm.Timer.Time2 = pUser[conn].Timer.Time2;
	sm.Timer.Time3 = pUser[conn].Timer.Time3;
	sm.Timer.Time4 = pUser[conn].Timer.Time4;
	sm.Timer.Time5 = pUser[conn].Timer.Time5;
	sm.Timer.Time6 = pUser[conn].Timer.Time6;

	/*sm.QuestDiaria.Count1 = pUser[conn].CountMob1;
	sm.QuestDiaria.Count2 = pUser[conn].CountMob2;
	sm.QuestDiaria.Count3 = pUser[conn].CountMob3;

	sm.QuestDiaria.CountMax1 = QuestDiaria[pUser[conn].QuestAtiva].QtdMob1;
	sm.QuestDiaria.CountMax2 = QuestDiaria[pUser[conn].QuestAtiva].QtdMob2;
	sm.QuestDiaria.CountMax3 = QuestDiaria[pUser[conn].QuestAtiva].QtdMob3;

	sm.QuestDiaria.QtdItem = QuestDiaria[pUser[conn].QuestAtiva].Item->stEffect[0].cValue;
	sm.QuestDiaria.ExpReward = QuestDiaria[pUser[conn].QuestAtiva].ExpReward;
	sm.QuestDiaria.GoldReward = QuestDiaria[pUser[conn].QuestAtiva].GoldReward;

	sm.QuestDiaria.IndexQuest = pUser[conn].QuestAtiva;
	sm.QuestDiaria.LastTimeQuest = pUser[conn].LastQuestDay;

	strcpy(sm.QuestDiaria.QuestMobName[0], g_pItemList[QuestDiaria[pUser[conn].QuestAtiva].IdMob1].Name);
	strcpy(sm.QuestDiaria.QuestMobName[1], g_pItemList[QuestDiaria[pUser[conn].QuestAtiva].IdMob2].Name);
	strcpy(sm.QuestDiaria.QuestMobName[2], g_pItemList[QuestDiaria[pUser[conn].QuestAtiva].IdMob3].Name);
	strcpy(sm.QuestDiaria.ItemName, g_pItemList[QuestDiaria[pUser[conn].QuestAtiva].Item->sIndex].Name);*/

	for (int i = 0; i < 50; i++) {
		sm.Keys[i] = pUser[conn].Keys[i];
	}

	for (int i = 0; i < 4; i++) {
		for (int y = 0; y < 2; y++) {
			memcpy(&sm.Joias[i][y], &pUser[conn].Joias[i][y], sizeof(STRUCT_ITEM));
		}
	}

	sm.GemaX = pUser[conn].GemaX;
	sm.GemaY = pUser[conn].GemaY;
	strncpy(sm.AccountName, pUser[conn].AccountName, ACCOUNTNAME_LENGTH);

	if (pMob[conn].MOB.Class == 1)
	{
		for (int o = 0; o < 4; o++)
		{
			if (pMob[conn].MOB.SkillBar[o] == 106 || pMob[conn].MOB.SkillBar[o] == 109 || pMob[conn].MOB.SkillBar[o] == 114)
			{
				if (pMob[conn].MOB.SkillBar[o] == 106) {
					sm.MOB.SkillBar[o] = 118;
				}

				if (pMob[conn].MOB.SkillBar[o] == 109) {
					sm.MOB.SkillBar[o] = 121;
				}

				if (pMob[conn].MOB.SkillBar[o] == 114) {
					sm.MOB.SkillBar[o] = 126;
				}
			}
			else
				sm.MOB.SkillBar[o] = pMob[conn].MOB.SkillBar[o];
		}
	}

	if (pMob[conn].MOB.Class == 1)
	{
		for (int i = 0; i < 16; i++)
		{
			if (pUser[conn].CharShortSkill[i] == 106 || pUser[conn].CharShortSkill[i] == 109 || pUser[conn].CharShortSkill[i] == 114)
			{
				// Proteção Absoluta
				if (pUser[conn].CharShortSkill[i] == 106) {
					sm.ShortSkill[i] = 118;
				}

				// Magia Misteriosa
				if (pUser[conn].CharShortSkill[i] == 109) {
					sm.ShortSkill[i] = 121;
				}

				// Incapacitador
				if (pUser[conn].CharShortSkill[i] == 114) {
					sm.ShortSkill[i] = 126;
				}
			}
			else
				sm.ShortSkill[i] = pUser[conn].CharShortSkill[i];
		}
	}
	else
		memcpy(sm.ShortSkill, pUser[conn].CharShortSkill, 16);


	memcpy(sm.affect, pMob[conn].Affect, sizeof(sm.affect));
	sm.extra = pMob[conn].extra;

	sm.MOB.SPX = pMob[conn].MOB.SPX;
	sm.MOB.SPY = pMob[conn].MOB.SPY;

	pUser[conn].File.Char[pUser[conn].Slot].SPX = sm.MOB.SPX;
	pUser[conn].File.Char[pUser[conn].Slot].SPY = sm.MOB.SPY;

	pUser[conn].SelChar.SPX[pUser[conn].Slot] = pUser[conn].File.Char[pUser[conn].Slot].SPX;
	pUser[conn].SelChar.SPY[pUser[conn].Slot] = pUser[conn].File.Char[pUser[conn].Slot].SPY;

	pMob[conn].MissPlayer = FALSE;

	DBServerSocket.SendOneMessage((char*)&sm, sizeof(MSG_DBSaveMob));
}

void CharLogOut(int conn)
{
	if (conn < 0 || conn >= MAX_USER)
	{
		//Log("err,char logout - not conn valid", "-system", 0);
		return;
	}
	if (pUser[conn].Mode != USER_PLAY)
	{
		//Log("err,char logout - not user_play", pUser[conn].AccountName, pUser[conn].IP);

		SendClientSignal(conn, conn, _MSG_CNFCharacterLogout);

		return;
	}
	goResetLeilao(conn); 

	pUser[conn].Ingame.MobDonateStore = FALSE;
	pUser[conn].Mode = USER_CHARWAIT;

	if (pUser[conn].IsBillConnect && CHARSELBILL == 0)
		SendBilling(conn, pUser[conn].AccountName, 2, 0);

	int trade = pUser[conn].Trade.OpponentID;

	if (trade > 0 && trade < MAX_USER)
	{
		if (pUser[trade].Mode == USER_PLAY && pUser[trade].Trade.OpponentID == conn)
			RemoveTrade(trade);
	}


	//pUser[conn].Mode = USER_SELCHAR;

	pUser[conn].SelChar.Score[pUser[conn].Slot].Level = pMob[conn].MOB.BaseScore.Level;

	pMob[conn].MOB.SPX = pMob[conn].TargetX;
	pMob[conn].MOB.SPY = pMob[conn].TargetY;

	pUser[conn].File.Char[pUser[conn].Slot].SPX = pMob[conn].MOB.SPX;
	pUser[conn].File.Char[pUser[conn].Slot].SPY = pMob[conn].MOB.SPY;

	pUser[conn].SelChar.SPX[pUser[conn].Slot] = pUser[conn].File.Char[pUser[conn].Slot].SPX;
	pUser[conn].SelChar.SPY[pUser[conn].Slot] = pUser[conn].File.Char[pUser[conn].Slot].SPY;

	for (int c = 0; c < MAX_AFFECT; c++)
	{
		if (pMob[conn].Affect[c].Type != 33)
		{
			if ((pMob[conn].MOB.Equip[0].sIndex == 316 || pMob[conn].MOB.Equip[0].sIndex == 317 || pMob[conn].MOB.Equip[0].sIndex == 297 ||
				pMob[conn].MOB.Equip[0].sIndex == 202 || pMob[conn].MOB.Equip[0].sIndex == 297 || pMob[conn].MOB.Equip[0].sIndex == 209 ||
				pMob[conn].MOB.Equip[0].sIndex == 212 || pMob[conn].MOB.Equip[0].sIndex == 230 || pMob[conn].MOB.Equip[0].sIndex == 228))
				pMob[conn].MOB.Equip[0].sIndex = pMob[conn].extra.ClassMaster == MORTAL ? pMob[conn].extra.MortalFace : pMob[conn].extra.MortalFace + 5 + pMob[conn].MOB.Class;
		}
	}

	SaveUser(conn, 1);
	DeleteMob(conn, 2);

	pUser[conn].chave4 = 0;
	pMob[conn].Mode = 0;

	SendClientSignal(conn, conn, _MSG_CNFCharacterLogout);
}

void Reboot()
{
	for (int y = 0; y < MAX_GRIDY; y++)
	{
		for (int x = 0; x < MAX_GRIDX; x++)
		{
			pMobGrid[y][x] = 0;
			pItemGrid[y][x] = 0;
			pHeightGrid[y][x] = 0;
		}
	}

	for (int i = 0; i < 3; i++)
		LiveTower[i] = 0;

	BASE_InitializeMobname("MobName.txt", 0);

	mNPCGen.ReadNPCGenerator();
	// mNPCGen.DropList();

	int Handle = _open("./heightmap.dat", _O_RDONLY | _O_BINARY, NULL);

	if (Handle == -1)
	{
		Log("err Load height grid fail", "-system", 0);

		return;
	}

	_read(Handle, (void*)pHeightGrid, sizeof(pHeightGrid));
	_close(Handle);

	BASE_InitializeBaseDef();
	BASE_ApplyAttribute((char*)pHeightGrid, MAX_GRIDX);
	BASE_InitializeMessage("Language.txt");

	mSummon.Initialize();

	Log("sys,start server", "-system", 0);

	for (int i = 0; i < g_dwInitItem; i++)
	{
		STRUCT_ITEM Item;
		memset(&Item, 0, sizeof(STRUCT_ITEM));

		Item.sIndex = g_pInitItem[i].ItemIndex;

		int ID = CreateItem(g_pInitItem[i].PosX, g_pInitItem[i].PosY, &Item, g_pInitItem[i].Rotate, 1);

		if (ID >= MAX_ITEM || ID <= 0)
			continue;

		int ret = BASE_GetItemAbility(&Item, EF_KEYID);

		if (ret != 0 && ret < 15)
		{
			int Height;

			UpdateItem(ID, STATE_LOCKED, &Height);
		}
	}

	WeekMode = 4;

	struct tm when;
	time_t now;
	time(&now);
	when = *localtime(&now);

	int GDay = GuildDay - 1;

	if (GDay < 0)
		GDay += 7;

	if (when.tm_wday == GDay)
		WeekMode = 5;

	if (when.tm_wday == GuildDay && when.tm_hour < GuildHour)
		WeekMode = 0;

	SetColoseumDoor(1);
}

void ClearChallanger0()
{
	for (int i = 0; i < ValidGuild; i++)
	{
		if (i == 1 || i == 2 || i == 3 || i == 4)
			continue;

		g_pGuildZone[i].ChallangeGuild = 0;
		pChallangerMoney[i] = 0;
	}
}

void ClearChallanger1()
{
	for (int i = 0; i < ValidGuild; i++)
	{
		if (i == 0 || i == 2 || i == 3 || i == 4)
			continue;

		g_pGuildZone[i].ChallangeGuild = 0;
		pChallangerMoney[i] = 0;
	}
}

void ClearChallanger2()
{
	for (int i = 0; i < ValidGuild; i++)
	{
		if (i == 0 || i == 1 || i == 3 || i == 4)
			continue;

		g_pGuildZone[i].ChallangeGuild = 0;
		pChallangerMoney[i] = 0;
	}
}

void ClearChallanger3()
{
	for (int i = 0; i < ValidGuild; i++)
	{
		if (i == 0 || i == 1 || i == 2 || i == 4)
			continue;

		g_pGuildZone[i].ChallangeGuild = 0;
		pChallangerMoney[i] = 0;
	}
}

void SetBattle(int mob, int target)
{
	if (mob <= 0 || target <= 0 || mob >= MAX_MOB || target >= MAX_MOB)
		return;

	if (pMob[mob].Mode == MOB_EMPTY)
		return;

	if (pMob[target].Mode == MOB_EMPTY)
		return;

	if (mob == target)
		return;

	if (mob >= MAX_USER && (target >= MAX_USER || pUser[target].Mode == USER_PLAY))
	{
		if (pMob[mob].TargetX >= pMob[target].TargetX - 23 && pMob[mob].TargetX <= pMob[target].TargetX + 23 && pMob[mob].TargetY >= pMob[target].TargetY - 23 && pMob[mob].TargetY <= pMob[target].TargetY + 23)
		{
			pMob[mob].Mode = MOB_COMBAT;

			pMob[mob].AddEnemyList(target);

			int generateindex = pMob[mob].GenerateIndex;
			int say = rand() % 4;

			if (generateindex < 0 || generateindex >= MAX_NPCGENERATOR)
				return;

			if (mNPCGen.pList[generateindex].FightAction[say][0] && !pMob[mob].Leader)
				SendChat(mob, mNPCGen.pList[generateindex].FightAction[say]);
		}
	}
}

int  CreateItem(int x, int y, STRUCT_ITEM *item, int rotate, int Create)
{
	if (item->sIndex <= 0 || item->sIndex >= MAX_ITEMLIST)
		return FALSE;

	GetEmptyItemGrid(&x, &y);

	//	if (pHeightGrid[y][x] >= -15 || pHeightGrid[y][x] >= 90)
	//		return FALSE;

	if (pItemGrid[y][x])
		return FALSE;

	int empty = GetEmptyItem();

	if (empty == 0)
		return FALSE;

	pItem[empty].Mode = 1;

	pItem[empty].PosX = x;
	pItem[empty].PosY = y;

	memcpy(&pItem[empty].ITEM, item, sizeof(STRUCT_ITEM));

	pItem[empty].Rotate = rotate;
	pItem[empty].State = STATE_OPEN;

	pItem[empty].Delay = 90;
	pItem[empty].Decay = 0;

	pItem[empty].GridCharge = BASE_GetItemAbility(item, EF_GROUND);

	pItemGrid[y][x] = empty;

	pItem[empty].Height = pHeightGrid[y][x];

	MSG_CreateItem sm;
	memset(&sm, 0, sizeof(MSG_CreateItem));

	sm.Type = _MSG_CreateItem;
	sm.Size = sizeof(MSG_CreateItem);
	sm.ID = ESCENE_FIELD;

	sm.ItemID = empty + 10000;

	memcpy(&sm.Item, &pItem[empty].ITEM, sizeof(STRUCT_ITEM));

	sm.GridX = x;
	sm.GridY = y;

	sm.Rotate = rotate;
	sm.State = pItem[empty].State;
	//	sm.Create = Create;

	//	sm.Height = pItem[empty].Height;

	if (Create == 2)//Bau
		sm.Height = -204;

	GridMulticast(x, y, (MSG_STANDARD*)&sm, 0);

	return TRUE;
}

void RemoveTrade(int conn)
{
	if (conn <= 0 || conn >= MAX_USER)
		return;

	memset(&pUser[conn].Trade, 0, sizeof(MSG_Trade));

	for (int i = 0; i < MAX_TRADE; i++)
		pUser[conn].Trade.InvenPos[i] = -1;

	memset(&pMob[conn].AutoTrade, 0, sizeof(pMob[conn].AutoTrade));

	for (int k = 0; k < MAX_SLOT_LEILAO_AUTOTRADE; k++)
		pMob[conn].AutoTrade.List[k].SlotBank = -1;

	if (pUser[conn].Mode != USER_PLAY)
		return;

	SendClientSignal(conn, conn, 900);

	if (pUser[conn].TradeMode)
	{
		int posX = pMob[conn].TargetX;
		int posY = pMob[conn].TargetY;

		MSG_CreateMob sm;
		memset(&sm, 0, sizeof(MSG_CreateMob));

		GetCreateMob(conn, &sm);
		GridMulticast(posX, posY, (MSG_STANDARD*)&sm, 0);

		pUser[conn].TradeMode = 0;
	}
}

void RemoveParty(int conn)
{
	int leader = pMob[conn].Leader;

	if (leader < 0 || leader >= MAX_MOB)
	{
		//Log("err,RemoveParty but worng leader", pUser[conn].AccountName, pUser[conn].IP);
		return;
	}

	if (leader && leader < MAX_USER && pUser[leader].Mode != USER_PLAY)
	{
		//Log("err,removeparty - conn mode", pUser[conn].AccountName, pUser[conn].IP);
		//Log("err,removeparty - leader mode", pUser[conn].AccountName, pUser[conn].IP);

		pMob[conn].Leader = 0;
	}
	else
	{
		if (conn > 0 && conn < MAX_USER)
			SendRemoveParty(conn, 0);

		if (leader)
		{
			SendRemoveParty(leader, conn);
			pMob[conn].Leader = 0;

			for (int i = 0; i < MAX_PARTY; i++)
			{
				int partyconn = pMob[leader].PartyList[i];

				if (partyconn)
				{
					if (partyconn == conn)
						pMob[leader].PartyList[i] = 0;

					if (pMob[partyconn].Summoner && pMob[partyconn].Summoner == conn)
						DeleteMob(partyconn, 3);

					if (!pMob[partyconn].Summoner && partyconn >= MAX_USER && leader < MAX_USER)
						DeleteMob(partyconn, 3);

					if (partyconn > 0 && partyconn <= MAX_USER && pUser[partyconn].Mode == USER_PLAY)
						SendRemoveParty(partyconn, conn);
				}
			}
		}

		else
		{
			int novolider = 0;

			for (int i = 0; i < MAX_PARTY; i++)
			{
				int partyconn = pMob[conn].PartyList[i];

				if (partyconn != 0 && partyconn < MAX_USER)
				{
					novolider = partyconn;

					for (int s = 0; s < 7; s++)
					{
						for (int t = 0; t < 3; t++)
						{
							if (Pista[s].Party[t].LeaderID == conn && strcmp(Pista[s].Party[t].LeaderName, pMob[conn].MOB.MobName) == 0)
							{
								strncpy(Pista[s].Party[t].LeaderName, pMob[novolider].MOB.MobName, NAME_LENGTH);
								Pista[s].Party[t].LeaderID = novolider;
							}
						}
					}

					break;
				}
			}

			for (int i = 0; i < MAX_PARTY; i++)
			{
				int partyconn = pMob[conn].PartyList[i];

				if (partyconn > 0 && partyconn <= MAX_MOB)
				{
					pMob[conn].PartyList[i] = 0;
					pMob[partyconn].Leader = 0;

					if (partyconn > 0 && partyconn < MAX_USER && pUser[partyconn].Mode == USER_PLAY)
						SendRemoveParty(partyconn, 0);

					if (partyconn > MAX_USER)
					{
						if (conn < MAX_USER && pMob[partyconn].Summoner && pMob[partyconn].Summoner == conn)
							DeleteMob(partyconn, 3);

						pMob[partyconn].Summoner = 0;
					}
					if (novolider != 0 && novolider != partyconn && partyconn < MAX_USER && novolider < MAX_USER)
					{
						MSG_AcceptParty sm;
						memset(&sm, 0, sizeof(MSG_AcceptParty));

						sm.Size = sizeof(MSG_AcceptParty);
						sm.Type = _MSG_AcceptParty;
						sm.ID = 0;

						sm.LeaderID = novolider;

						strncpy(sm.MobName, pMob[novolider].MOB.MobName, NAME_LENGTH);

						pMob[partyconn].LastReqParty = novolider;

						ProcessClientMessage(partyconn, (char*)&sm, TRUE);
					}
				}
			}
		}
	}
}

void RemoveEvocation(int conn)
{
	int leader = pMob[conn].Leader;

	if (leader < 0 || leader >= MAX_MOB)
	{
		//Log("err,RemoveParty but worng leader", pUser[conn].AccountName, pUser[conn].IP);
		return;
	}

	if (leader && leader < MAX_USER && pUser[leader].Mode != USER_PLAY)
	{
		//Log("err,removeparty - conn mode", pUser[conn].AccountName, pUser[conn].IP);
		//Log("err,removeparty - leader mode", pUser[conn].AccountName, pUser[conn].IP);

		pMob[conn].Leader = 0;
		pMob[conn].Evocation = 0;
	}
	else
	{
		if (conn > 0 && conn < MAX_USER)
			memset(&pMob[conn].Evocations, 0, sizeof(pMob[conn].Evocations));

		if (leader)
		{
			SendRemoveParty(leader, conn);
			pMob[conn].Leader = 0;
			pMob[conn].Evocation = 0;

			for (int i = 0; i < MAX_PARTY; i++)
			{
				int partyconn = pMob[leader].Evocations[i];

				if (partyconn)
				{
					if (partyconn == conn)
						pMob[leader].Evocations[i] = 0;

					if (pMob[partyconn].Summoner && pMob[partyconn].Summoner == conn)
						DeleteMob(partyconn, 3);

					if (!pMob[partyconn].Summoner && partyconn >= MAX_USER && leader < MAX_USER)
						DeleteMob(partyconn, 3);
				}
			}
		}
	}
}

int UpdateItem(int Gate, int state, int *height)
{
	int rotate = pItem[Gate].Rotate;

	int update = BASE_UpdateItem(pItem[Gate].GridCharge, pItem[Gate].State, state, pItem[Gate].PosX, pItem[Gate].PosY, (char*)&pHeightGrid, rotate, height);

	if (update == 0)
		return FALSE;

	pItem[Gate].State = state;
	pItem[Gate].Height = *height;

	int GridCharge = pItem[Gate].GridCharge;
	int itemstate = pItem[Gate].State;

	pItem[Gate].Delay = 0;

	if (GridCharge >= 6 || GridCharge < 0)
	{
		//Log("err,updateItem maskidx illegal", "-system", 0);
		return TRUE;
	}

	if (itemstate == state)
	{
		int keyid = BASE_GetItemAbility(&pItem[Gate].ITEM, EF_KEYID);

		if (keyid == 15 && itemstate == 1 && state == 3)
			CreateMob("GATE", pItem[Gate].PosX, pItem[Gate].PosY, "npc", 0);

		pItem[Gate].State = state;

		return TRUE;
	}

	int posX = pItem[Gate].PosX;
	int posY = pItem[Gate].PosY;

	for (int i = 0; i <= MAX_GROUNDMASK - 2; i++)
	{
		for (int j = 0; j <= MAX_GROUNDMASK - 2; j++)
		{
			int val = g_pGroundMask[GridCharge][rotate][i][j];

			int iX = posX + j - 2;
			int jY = posY + i - 2;

			if (iX >= 1 && jY >= 1 && iX <= 4094 && jY <= 4094 && val)
			{
				int tmob = pMobGrid[jY][iX];

				if (tmob != 0)
				{
					if (pMob[tmob].MOB.Equip[0].sIndex == 220)
						DeleteMob(tmob, 3);

					else
					{
						int mobgrid = GetEmptyMobGrid(tmob, &iX, &jY);

						if (mobgrid != 0)
						{
							pMob[tmob].Route[0] = 0;

							MSG_Action sm;
							memset(&sm, 0, sizeof(MSG_Action));

							GetAction(tmob, iX, jY, &sm);

							int unk = 20;
							int unk2 = 0;

							GridMulticast(iX, jY, (MSG_STANDARD*)&sm, 0);

							if (tmob < MAX_USER)
								pUser[tmob].cSock.SendOneMessage((char*)&sm, sizeof(sm));
						}
					}
				}
			}
		}
	}

	return TRUE;
}

void DoRecall(int conn)
{

	int x = pMob[conn].MOB.SPX;
	int y = pMob[conn].MOB.SPY;
	int CityID = (pMob[conn].MOB.Merchant & 0xC0) >> 6;

	x = rand() % 15 + g_pGuildZone[CityID].CitySpawnX;
	y = rand() % 15 + g_pGuildZone[CityID].CitySpawnY;

	int Guild = pMob[conn].MOB.Guild;

	pMob[conn].LanNFlag = 0;
	pMob[conn].LanMFlag = 0;
	pMob[conn].LanAFlag = 0;
	pUser[conn].DiariaState = 0;

	if (Guild > 0)
	{
		for (int i = 0; i < MAX_GUILDZONE; i++)
		{
			if (Guild == g_pGuildZone[i].ChargeGuild)
			{
				x = g_pGuildZone[i].GuildSpawnX;
				y = g_pGuildZone[i].GuildSpawnY;

				break;
			}
		}
	}	

	int j = 0;
	for (j = 0; j < pMob[conn].MaxCarry; j++)
	{
		if (pMob[conn].MOB.Carry[j].sIndex != 5675)
			continue;

		if (pMob[conn].MOB.Carry[j].sIndex == 5675) {
			BASE_ClearItem(&pMob[conn].MOB.Carry[j]);
			SendItem(conn, ITEM_PLACE_CARRY, j, &pMob[conn].MOB.Carry[j]);
			SendCarry(conn);
		}

	}

	if (pMob[conn].extra.ClassMaster == MORTAL && pMob[conn].MOB.CurrentScore.Level < FREEEXP)
	{
		x = 2112 + rand() % 5 - 3;
		y = 2042 + rand() % 5 - 3;
	}

	int tret = GetEmptyMobGrid(conn, &x, &y);

	MSG_Action sm;
	memset(&sm, 0, sizeof(MSG_Action));

	GetAction(conn, x, y, &sm);

	sm.Effect = 1;

	if (conn < MAX_USER)
		pUser[conn].cSock.SendOneMessage((char*)&sm, sizeof(sm));

	GridMulticast(conn, x, y, (MSG_STANDARD*)&sm);
}

void DoWar(int myguild, int target)
{
	int max_guild = 65536;

	if (myguild <= 0 || target < 0 || myguild >= max_guild || target >= max_guild)
	{
		//sprintf(temp, "err,dowar my: %d ta:%d", myguild, target);
		//Log(temp, "-system", 0);
		return;
	}

	char myGuildName[16];
	char targetGuildName[16];

	BASE_GetGuildName(ServerGroup, myguild, myGuildName);
	BASE_GetGuildName(ServerGroup, target, targetGuildName);

	int myGuildWar = g_pGuildWar[myguild];

	if (myGuildWar < 0 || myGuildWar >= max_guild)
		myGuildWar = 0;

	int targetGuildWar = g_pGuildWar[target];

	if (target)
	{
		if (myGuildWar || !target || targetGuildWar == myguild)
		{
			if (myGuildWar || !target || targetGuildWar != myguild)
			{
				//sprintf(temp, "err,dowar my:%d ta:%d ct:%d et:%d", myguild, target, myGuildWar, targetGuildWar);
				//Log(temp, "-system", 0);
			}
			else
			{
				SendNotice(strFmt(g_pMessageStringTable[_SS_War_Started], myGuildName, targetGuildName));

				g_pGuildWar[myguild] = target;

				for (int i = 0; i < MAX_USER; i++)
				{
					if (pUser[i].Mode == USER_PLAY && (pMob[i].MOB.Guild == myguild || pMob[i].MOB.Guild == target))
						SendWarInfo(i, g_pGuildZone[4].Clan);

				}
			}
		}

		else
		{
			SendGuildNotice(myguild, strFmt(g_pMessageStringTable[_SS_War_Declared], myGuildName, targetGuildName));
			SendGuildNotice(target, strFmt(g_pMessageStringTable[_SS_War_Declared], myGuildName, targetGuildName));

			g_pGuildWar[myguild] = target;
		}
	}
	else
	{
		if (myGuildWar <= 0 || myGuildWar >= max_guild)
			return;

		targetGuildWar = g_pGuildWar[myGuildWar];

		BASE_GetGuildName(ServerGroup, myGuildWar, targetGuildName);

		if (targetGuildWar == myguild)
		{
			sprintf_s(temp, g_pMessageStringTable[_SS_War_Canceled], myGuildName, targetGuildName);

			g_pGuildWar[myGuildWar] = 0;
			g_pGuildWar[myguild] = 0;

			for (int j = 0; j < MAX_USER; j++)
			{
				if (pUser[j].Mode == USER_PLAY && (pMob[j].MOB.Guild == myguild || pMob[j].MOB.Guild == myGuildWar))
					SendWarInfo(j, g_pGuildZone[4].Clan);
			}
		}

		else
		{
			sprintf_s(temp, g_pMessageStringTable[_SS_War_declare_canceled], myGuildName, targetGuildName);
			g_pGuildWar[myguild] = 0;
		}

		SendGuildNotice(myguild, temp);
		SendGuildNotice(myGuildWar, temp);
	}
}

void DoAlly(int myguild, int target)
{
	int max_guild = 65536;

	if (myguild <= 0 || target < 0 || myguild >= max_guild || target >= max_guild)
	{
		//sprintf(temp, "err,doally my: %d ta:%d", myguild, target);
		//Log(temp, "-system", 0);
		return;
	}

	char myGuildName[16];
	char targetGuildName[16];

	BASE_GetGuildName(ServerGroup, myguild, myGuildName);
	BASE_GetGuildName(ServerGroup, target, targetGuildName);

	int myGuildAlly = g_pGuildAlly[myguild];

	if (myGuildAlly < 0 || myGuildAlly >= max_guild)
		myGuildAlly = 0;

	int targetGuildAlly = g_pGuildAlly[target];

	if (!myGuildAlly)
	{
		if (!myGuildAlly && target)
		{
			SendNotice(strFmt(g_pMessageStringTable[_SS_Ally_Declared], myGuildName, targetGuildName));

			g_pGuildAlly[myguild] = target;
		}
	}
	else
	{
		myGuildAlly = g_pGuildAlly[myguild];

		if (myGuildAlly > 0 && myGuildAlly < max_guild)
		{
			BASE_GetGuildName(ServerGroup, myGuildAlly, targetGuildName);

			SendNotice(strFmt(g_pMessageStringTable[_SS_Ally_Canceled], myGuildName, targetGuildName));

			g_pGuildAlly[myguild] = 0;
		}
	}

	for (int i = 0; i < MAX_USER; i++)
	{
		if (pUser[i].Mode == USER_PLAY && pMob[i].MOB.Guild == myguild)
			SendWarInfo(i, g_pGuildZone[4].Clan);
	}
}

void DoDeprivate(int conn, int target)
{
	if (conn <= 0 || conn > MAX_USER)
	{
		//Log("err,dodeprivate - conn", "-system", 0);

		return;
	}

	int Guild = pMob[conn].MOB.Guild;
	int GuildLevel = pMob[conn].MOB.GuildLevel;


	if (target <= 0 || target > MAX_USER || pUser[target].Mode != USER_PLAY)
	{
		SendClientMessage(conn, g_pMessageStringTable[_NN_Not_Connected]);

		return;
	}

	if (GuildLevel <= pMob[target].MOB.GuildLevel)
	{
		 SendMsgExp(conn, g_pMessageStringTable[_NN_Only_Guild_Master_Can], TNColor::Default, false);
		return;
	}

	int sub = pMob[conn].MOB.GuildLevel;
	int Disqualified = FALSE;


	int gGuild = pMob[target].MOB.Guild;

	if (Guild != gGuild)
		return;

	if (sub >= 6 && sub <= 8 && pMob[target].MOB.GuildLevel < 6 || sub == 9)
	{
		Disqualified = TRUE;

		if (pMob[target].MOB.GuildLevel >= 6 && pMob[target].MOB.GuildLevel <= 8)
		{
			if (GuildInfo[gGuild].Sub1 != 0)
				GuildInfo[gGuild].Sub1 = 0;
			else if (GuildInfo[gGuild].Sub2 != 0)
				GuildInfo[gGuild].Sub2 = 0;

			else if (GuildInfo[gGuild].Sub3 != 0)
				GuildInfo[gGuild].Sub3 = 0;


			//sprintf(temp, "etc,subdelete subname:%s guild:%d ", pMob[target].MOB.MobName, Guild);
			//Log(temp, pUser[conn].AccountName, pUser[conn].IP);

			MSG_GuildInfo sm_gi;
			memset(&sm_gi, 0, sizeof(MSG_GuildInfo));

			sm_gi.Type = _MSG_GuildInfo;
			sm_gi.Size = sizeof(MSG_GuildInfo);
			sm_gi.ID = conn;

			sm_gi.Guild = Guild;
			sm_gi.GuildInfo = GuildInfo[Guild];

			DBServerSocket.SendOneMessage((char*)&sm_gi, sizeof(MSG_GuildInfo));
		}

		pMob[target].MOB.Guild = 0;
		pMob[target].MOB.GuildLevel = 0;

		doRanking(target);
		
		MSG_CreateMob sm;
		memset(&sm, 0, sizeof(MSG_CreateMob));

		GetCreateMob(target, &sm);

		GridMulticast(pMob[target].TargetX, pMob[target].TargetY, (MSG_STANDARD*)&sm, 0);
	}


	if (Disqualified == FALSE)
	{
		 
		SendMsgExp(conn, g_pMessageStringTable[_NN_Deprivate], TNColor::Default, false);
		return;
	}

	SendScore(target);

	SendClientMessage(target, g_pMessageStringTable[_NN_Disqualified_By_Guild_Master]);
	SendClientMessage(conn, g_pMessageStringTable[_NN_Disqualify]);
}

void ProcessRanking()
{
	if (RankingTime <= 0)
		return;

	RankingTime--;

	if (RankingTime % 5 == 0)
	{
		int Rank1 = 0;
		int Rank2 = 0;

		for (int i = 1; i < MAX_USER; i++)
		{
			if (pUser[i].Mode != USER_PLAY)
				continue;

			if (pMob[i].MOB.CurrentScore.Hp <= 0)
				continue;

			int posX = pMob[i].TargetX;
			int posY = pMob[i].TargetY;

			if (posX >= kRanking1X && posX <= kRanking2X && posY >= kRanking1Y && posY <= kRanking2Y)
			{
				if (RankingProgress == 1)
				{
					if (i == Ranking1)
						Rank1++;

					if (i == Ranking2)
						Rank2++;
				}

				else
				{
					if (pMob[i].MOB.Guild == Ranking1)
						Rank1++;

					if (pMob[i].MOB.Guild == Ranking2)
						Rank2++;
				}
			}
		}

		if (Rank1 == 0 || Rank2 == 0)
			RankingTime = 0;
	}

	if (RankingTime >= 60)
	{
		if (RankingTime >= 120)
		{
			if (RankingTime < 180)
			{
				SendDamage(142, 4007, 195, 4019);
				SendDamage(142, 4070, 195, 4082);

				SendEnvEffect(142, 4007, 168, 4018, 32, 0);
				SendEnvEffect(142, 4071, 168, 4082, 32, 0);
				SendEnvEffect(169, 4007, 195, 4018, 32, 0);
				SendEnvEffect(169, 4071, 195, 4082, 32, 0);
			}
		}
		else
		{
			SendDamage(142, 4007, 195, 4034);
			SendDamage(142, 4055, 195, 4082);

			SendEnvEffect(142, 4007, 168, 4018, 32, 0);
			SendEnvEffect(142, 4071, 168, 4082, 32, 0);
			SendEnvEffect(142, 4019, 168, 4030, 32, 0);
			SendEnvEffect(142, 4059, 168, 4070, 32, 0);
			SendEnvEffect(168, 4007, 195, 4018, 32, 0);
			SendEnvEffect(168, 4071, 195, 4082, 32, 0);
			SendEnvEffect(168, 4019, 195, 4030, 32, 0);
			SendEnvEffect(168, 4059, 195, 4070, 32, 0);
		}
	}
	else
	{
		SendDamage(142, 4007, 195, 4042);
		SendDamage(142, 4046, 195, 4082);
		SendEnvEffect(142, 4007, 168, 4018, 32, 0);
		SendEnvEffect(142, 4071, 168, 4082, 32, 0);
		SendEnvEffect(142, 4019, 168, 4030, 32, 0);
		SendEnvEffect(142, 4059, 168, 4070, 32, 0);
		SendEnvEffect(142, 4031, 168, 4042, 32, 0);
		SendEnvEffect(142, 4047, 168, 4058, 32, 0);
		SendEnvEffect(168, 4007, 195, 4018, 32, 0);
		SendEnvEffect(168, 4071, 195, 4082, 32, 0);
		SendEnvEffect(168, 4019, 195, 4030, 32, 0);
		SendEnvEffect(168, 4059, 195, 4070, 32, 0);
		SendEnvEffect(168, 4031, 195, 4042, 32, 0);
		SendEnvEffect(168, 4047, 195, 4058, 32, 0);
	}

	if (RankingTime <= 0)
	{
		int Rank1 = 0;
		int Rank2 = 0;

		for (int i = 1; i < MAX_USER; i++)
		{
			if (pUser[i].Mode != USER_PLAY)
				continue;

			if (pMob[i].MOB.CurrentScore.Hp <= 0)
				continue;

			int posX = pMob[i].TargetX;
			int posY = pMob[i].TargetY;

			if (posX >= kRanking1X && posX <= kRanking2X && posY >= kRanking1Y && posY <= kRanking2Y)
			{
				if (RankingProgress == 1)
				{
					if (i == Ranking1)
						Rank1++;

					if (i == Ranking2)
						Rank2++;
				}

				else
				{
					if (pMob[i].MOB.Guild == Ranking1)
						Rank1++;

					if (pMob[i].MOB.Guild == Ranking2)
						Rank2++;
				}
			}
		}

		nRanking1[15] = 0;
		nRanking1[16] = 0;
		nRanking2[15] = 0;
		nRanking2[16] = 0;

		nTitle1[15] = 0;
		nTitle1[16] = 0;
		nTitle2[15] = 0;
		nTitle2[16] = 0;


		if (Rank1 == Rank2)
		{
			SendNoticeArea(strFmt(g_pMessageStringTable[_SS_S_S_Draw], nRanking1, nRanking2), cRanking1X, cRanking1Y, cRanking2X, cRanking2Y);
			SendNoticeArea(strFmt(g_pMessageStringTable[_SS_S_S_Draw], nRanking1, nRanking2), kRanking1X, kRanking1Y, kRanking2X, kRanking2Y);
		}

		else
		{
			if (Rank1 <= Rank2)
				sprintf_s(temp, g_pMessageStringTable[_SS_S_WinBy_S], nRanking2, nRanking1);
			else
				sprintf_s(temp, g_pMessageStringTable[_SS_S_WinBy_S], nRanking1, nRanking2);

			SendNoticeArea(temp, cRanking1X, cRanking1Y, cRanking2X, cRanking2Y);
			SendNoticeArea(temp, kRanking1X, kRanking1Y, kRanking2X, kRanking2Y);

			MSG_MessageDBRecord sm;
			memset(&sm, 0, sizeof(MSG_MessageDBRecord));

			sm.Type = _MSG_MessageDBRecord;
			sm.ID = 0;
			sm.Size = sizeof(MSG_MessageDBRecord);

			if (RankingProgress != 1 || Ranking1 <= 0 || Ranking1 >= MAX_USER || Ranking2 <= 0 || Ranking2 >= MAX_USER)
			{
				if (Rank1 <= Rank2)
					sprintf_s(temp, "RNK %d %d %s %d %d %s %d %d", ServerIndex, RankingProgress, nRanking2, lTitle2, Ranking2, nRanking1, lTitle1, Ranking1);
				else
					sprintf_s(temp, "RNK %d %d %s %d %d %s %d %d", ServerIndex, RankingProgress, nRanking1, lTitle1, Ranking1, nRanking2, lTitle2, Ranking2);
			}

			else
			{
				int GuildR1 = pMob[Ranking1].MOB.Guild;
				int GuildR2 = pMob[Ranking2].MOB.Guild;

				if (Rank1 <= Rank2)
					sprintf_s(temp, "RNK %d %d %s %d %d %s %d %d", ServerIndex, RankingProgress, nRanking2, lTitle2, GuildR2, nRanking1, lTitle1, GuildR1);
				else
					sprintf_s(temp, "RNK %d %d %s %d %d %s %d %d", ServerIndex, RankingProgress, nRanking1, lTitle1, GuildR1, nRanking2, lTitle2, GuildR2);
			}

			DBServerSocket.SendOneMessage((char*)&sm, sm.Size);
		}

		RankingProgress = 0;
		RankingTime = 0;
		Ranking1 = 0;
		Ranking2 = 0;

		nRanking1[0] = 0;
		nRanking2[0] = 0;

		ClearAreaTeleport(kRanking1X, kRanking1Y, kRanking2X, kRanking2Y, 2572, 1752);
	}
}

void DoRanking(int tDuel, int conn, int enemy)
{
	if (tDuel == 0)
	{
		int duelTime = 121;

		if (conn < 0 || conn >= MAX_USER || enemy < 0 || enemy >= MAX_USER)
			return;

		strncpy(nRanking1, pMob[conn].MOB.MobName, NAME_LENGTH);
		strncpy(nRanking2, pMob[enemy].MOB.MobName, NAME_LENGTH);

		lTitle1 = pMob[conn].MOB.CurrentScore.Level;
		lTitle2 = pMob[enemy].MOB.CurrentScore.Level;

		DoTeleport(conn, Ranking2X, Ranking2Y);
		DoTeleport(enemy, Ranking1X, Ranking1Y);

		sprintf_s(temp, g_pMessageStringTable[_NN_Battle_Started], pMob[conn].MOB.MobName, pMob[enemy].MOB.MobName);

		SendClientMessage(conn, temp);
		SendClientMessage(enemy, temp);

		SendClientSignalParm(conn, ESCENE_FIELD, _MSG_StartTime, 2 * duelTime - 2);
		SendClientSignalParm(enemy, ESCENE_FIELD, _MSG_StartTime, 2 * duelTime - 2);

		RankingProgress = 1;
		Ranking1 = conn;
		Ranking2 = enemy;
		RankingTime = duelTime;

		return;
	}

	int duelTime = 301;

	int GuildR1 = pMob[conn].MOB.Guild;
	int GuildR2 = pMob[enemy].MOB.Guild;

	if (GuildR1 <= 0 || GuildR2 <= 0)
		return;

	if (GuildR1 == GuildR2)
		return;

	RankingProgress = tDuel + 1;
	Ranking1 = GuildR1;
	Ranking2 = GuildR2;
	RankingTime = duelTime;

	BASE_GetGuildName(ServerGroup, Ranking1, nRanking1);
	BASE_GetGuildName(ServerGroup, Ranking2, nRanking2);

	strncpy(nTitle1, pMob[conn].MOB.MobName, NAME_LENGTH);

	lTitle1 = pMob[conn].MOB.CurrentScore.Level;

	strncpy(nTitle2, pMob[enemy].MOB.MobName, NAME_LENGTH);

	lTitle2 = pMob[enemy].MOB.CurrentScore.Level;

	int jRank1 = 5;
	int jRank2 = 5;

	if (tDuel == 2)
	{
		jRank1 = 10;
		jRank2 = 10;
	}

	else if (tDuel == 3)
	{
		jRank1 = 100;
		jRank2 = 100;

		SummonGuild(Ranking1, Ranking1X, Ranking1Y, 100, 3);
		SummonGuild(Ranking2, Ranking1X, Ranking1Y, 100, 3);
	}

	else
	{
		for (int i = cRanking1Y; i <= cRanking2Y; i++)
		{
			for (int j = cRanking1X; j <= cRanking2X; j++)
			{
				int tmob = pMobGrid[i][j];

				if (tmob <= 0 || tmob >= MAX_USER)
					continue;

				if (jRank1 > 0 && pMob[tmob].MOB.Guild == Ranking1)
				{
					jRank1--;

					DoTeleport(tmob, Ranking1X, Ranking1Y);

					SendClientMessage(tmob, g_pMessageStringTable[194]);
					SendClientSignalParm(tmob, ESCENE_FIELD, _MSG_StartTime, 2 * duelTime - 2);
				}

				if (jRank2 > 0 && pMob[tmob].MOB.Guild == Ranking2)
				{
					jRank2--;

					DoTeleport(tmob, Ranking2X, Ranking2Y);

					SendClientMessage(tmob, g_pMessageStringTable[194]);
					SendClientSignalParm(tmob, ESCENE_FIELD, _MSG_StartTime, 2 * duelTime - 2);
				}
				if (jRank1 <= 0 || jRank2 <= 0)
					break;
			}
		}
	}
}

void DoRemoveHide(int conn)
{
	if (conn <= 0 || conn >= MAX_USER)
		return;

	for (int i = 0; i < MAX_AFFECT; i++)
	{
		if (pMob[conn].Affect[i].Type != 28)
			continue;

		pMob[conn].Affect[i].Type = 0;
		pMob[conn].Affect[i].Value = 0;
		pMob[conn].Affect[i].Level = 0;
		pMob[conn].Affect[i].Time = 0;

		pMob[conn].GetCurrentScore(conn);
		SendScore(conn);

		break;
	}
}


void DoRemoveMutation(int conn)
{
	if (conn <= 0 || conn >= MAX_USER)
		return;

	for (int i = 0; i < MAX_AFFECT; i++)
	{
		if (pMob[conn].Affect[i].Type != 33)
			continue;

		pMob[conn].Affect[i].Type = 0;
		pMob[conn].Affect[i].Value = 0;
		pMob[conn].Affect[i].Level = 0;
		pMob[conn].Affect[i].Time = 0;

		if ((pMob[conn].MOB.Equip[0].sIndex == 316 || pMob[conn].MOB.Equip[0].sIndex == 317 || pMob[conn].MOB.Equip[0].sIndex == 297 ||
			pMob[conn].MOB.Equip[0].sIndex == 202 || pMob[conn].MOB.Equip[0].sIndex == 297 || pMob[conn].MOB.Equip[0].sIndex == 209 ||
			pMob[conn].MOB.Equip[0].sIndex == 212 || pMob[conn].MOB.Equip[0].sIndex == 230 || pMob[conn].MOB.Equip[0].sIndex == 228))
			pMob[conn].MOB.Equip[0].sIndex = pMob[conn].extra.ClassMaster == MORTAL ? pMob[conn].extra.MortalFace : pMob[conn].extra.MortalFace + 5 + pMob[conn].MOB.Class;

		pMob[conn].GetCurrentScore(conn);
		SendScore(conn);
		SendEquip(conn, 0);

		break;
	}
}


void DoRemoveAbsoluteProtection(int conn)
{
	if (conn <= 0 || conn >= MAX_USER)
		return;

	for (int i = 0; i < MAX_AFFECT; i++)
	{
		if (pMob[conn].Affect[i].Type != 6)
			continue;

		pMob[conn].Affect[i].Type = 0;
		pMob[conn].Affect[i].Value = 0;
		pMob[conn].Affect[i].Level = 0;
		pMob[conn].Affect[i].Time = 0;

		pMob[conn].GetCurrentScore(conn);
		SendScore(conn);

		break;
	}
}

void DoRemoveAllBuffs(int conn)
{
	if (conn <= 0 || conn >= MAX_USER)
		return;

	for (int i = 0; i < MAX_AFFECT; i++)
	{
		if  (pMob[conn].Affect[i].Type != 2 || pMob[conn].Affect[i].Type !=  6 || pMob[conn].Affect[i].Type != 9 ||
			pMob[conn].Affect[i].Type != 11 || pMob[conn].Affect[i].Type != 13 || pMob[conn].Affect[i].Type != 14 ||
			pMob[conn].Affect[i].Type != 15 || pMob[conn].Affect[i].Type != 16 || pMob[conn].Affect[i].Type != 17 ||
			pMob[conn].Affect[i].Type != 18 || pMob[conn].Affect[i].Type != 19 || pMob[conn].Affect[i].Type != 21 ||
			pMob[conn].Affect[i].Type != 22 || pMob[conn].Affect[i].Type != 23 || pMob[conn].Affect[i].Type != 24 ||
			pMob[conn].Affect[i].Type != 25 || pMob[conn].Affect[i].Type != 26 || pMob[conn].Affect[i].Type != 27 ||
			pMob[conn].Affect[i].Type != 31 || pMob[conn].Affect[i].Type != 36 || pMob[conn].Affect[i].Type != 37 ||
			pMob[conn].Affect[i].Type != 38 || pMob[conn].Affect[i].Type != 42 || pMob[conn].Affect[i].Type != 43)
			continue;

		pMob[conn].Affect[i].Type = 0;
		pMob[conn].Affect[i].Value = 0;
		pMob[conn].Affect[i].Level = 0;
		pMob[conn].Affect[i].Time = 0;

		pMob[conn].GetCurrentScore(conn);
		SendScore(conn);

		break;
	}
}

void DoRemoveSamaritano(int conn)
{
	if (conn <= 0 || conn >= MAX_USER)
		return;

	for (int i = 0; i < MAX_AFFECT; i++)
	{
		if (pMob[conn].Affect[i].Type != 24)
			continue;

		pMob[conn].Affect[i].Type = 0;
		pMob[conn].Affect[i].Value = 0;
		pMob[conn].Affect[i].Level = 0;
		pMob[conn].Affect[i].Time = 0;

		pMob[conn].GetCurrentScore(conn);
		SendScore(conn);

		break;
	}
}

void DoTeleport(int mob, int x, int y)
{
	MSG_Action sm;
	memset(&sm, 0, sizeof(MSG_Action));

	int ret = GetEmptyMobGrid(mob, &x, &y);

	pMob[mob].LanNFlag = 0;
	pMob[mob].LanMFlag = 0;
	pMob[mob].LanAFlag = 0;

	if (mob < MAX_USER && mob > 0)
		pUser[mob].DiariaState = 0;

	if (ret)
	{
		GetAction(mob, x, y, &sm);

		sm.Effect = 1; // teleport effect

		if (mob < MAX_USER && mob > 0)
			if (!pUser[mob].cSock.AddMessage((char*)&sm, sizeof(MSG_Action)))
				CloseUser(mob);

		GridMulticast(mob, x, y, (MSG_STANDARD*)&sm);
	}
}

void DoSummon(int target, int x, int y)
{
	MSG_Action sm;

	memset(&sm, 0, sizeof(MSG_Action));

	int tret = GetEmptyMobGrid(target, &x, &y);

	GetAction(target, x, y, &sm);

	sm.Effect = 1; // teleport effect

	if (target < MAX_USER)
		pUser[target].cSock.SendOneMessage((char*)&sm, sizeof(sm));

	GridMulticast(target, x, y, (MSG_STANDARD*)&sm);
}

void DoGreatTeleport(int mob, int x, int y)
{
	MSG_Action sm;
	memset(&sm, 0, sizeof(MSG_Action));

	int ret = GetEmptyMobGridGreat(mob, &x, &y);

	if (ret)
	{
		GetAction(mob, x, y, &sm);

		sm.Effect = 1; // teleport effect

		if (mob < MAX_USER)
			pUser[mob].cSock.SendOneMessage((char*)&sm, sizeof(sm));

		GridMulticast(mob, x, y, (MSG_STANDARD*)&sm);
	}
}

BOOL SetAffect1(int conn, int skillnum, int time, int Level)
{
	if (skillnum < 104)
	{
		if (pMob[conn].MOB.Merchant != 1 || conn <= MAX_USER)
		{
			int sAffectType = g_pSpell[skillnum].AffectType;
			int sAggressive = g_pSpell[skillnum].Aggressive;
			int sAffectTime = g_pSpell[skillnum].AffectTime;
			int unk = skillnum / 24 % 4;
			int unk2 = skillnum % 24 / 8;
			int sTickType = g_pSpell[skillnum].TickType;
			int unk3 = 0;

			if (skillnum != 47 && pMob[conn].MOB.Rsv & 0x200 && sAggressive)
				return FALSE;
			else
			{
				if (skillnum == 47 && pMob[conn].MOB.Rsv & 0x200)
				{
					for (int i = 1; i < MAX_AFFECT; i++)
					{
						if (pMob[conn].Affect[i].Type == 19)
						{
							pMob[conn].Affect[i].Type = 0;
							pMob[conn].Affect[i].Time = 0;
							pMob[conn].GetCurrentScore(conn);
							SendScore(conn);
							//Level = 0;
							//return Level;

							return FALSE;
						}
					}
				}

				if (skillnum == 102)
					unk3 = 15;
				else
				{
					unk3 = GetEmptyAffect(conn, sAffectType);

					if (sAffectType > 0)
						unk3 = GetEmptyAffect(conn, sAffectType);

					if (sTickType > 0)
						unk3 = GetEmptyAffect(conn, sTickType);
				}

				if (unk3 < 0 || unk3 >= 16)
					return FALSE;
				else
				{
					if (sTickType)
					{

					}
					else
					{

					}
				}
			}
		}
	}
}
BOOL SetAffect(int conn, int skillnum, int time, int Level)
{
	if (pMob[conn].MOB.Merchant == 1 || conn > MAX_USER)
		return FALSE;

	int sAffectType = g_pSpell[skillnum].AffectType;
	int sAggressive = g_pSpell[skillnum].Aggressive;

	if (pMob[conn].MOB.Rsv & RSV_BLOCK && sAggressive)
		return FALSE;

	int EmptyAffect = 0;

	if (skillnum == 102)
		EmptyAffect = 15;
	else
		EmptyAffect = GetEmptyAffect(conn, sAffectType);

	if (sAffectType <= 0 || EmptyAffect < 0 || EmptyAffect >= MAX_AFFECT)
		return FALSE;

	int sType = pMob[conn].Affect[EmptyAffect].Type;

	pMob[conn].Affect[EmptyAffect].Type = sAffectType;
	pMob[conn].Affect[EmptyAffect].Value = g_pSpell[skillnum].AffectValue;

	int sTime = (g_pSpell[skillnum].AffectTime + 1) * time / 100;

	if (sType == 1 || sType == 3 || sType == 10)
		sTime = 4;

	if (sType == sAffectType && (unsigned int)sTime > pMob[conn].Affect[EmptyAffect].Time)
		pMob[conn].Affect[EmptyAffect].Time = sTime;
	else
		pMob[conn].Affect[EmptyAffect].Time = sTime;

	if (sType == sAffectType && Level > pMob[conn].Affect[EmptyAffect].Level)
		pMob[conn].Affect[EmptyAffect].Level = Level;
	else
		pMob[conn].Affect[EmptyAffect].Level = Level;

	if (time >= 2139062143)
		pMob[conn].Affect[EmptyAffect].Time = 2139062143;

	pMob[conn].GetCurrentScore(conn);

	return TRUE;
}

BOOL SetTick(int mob, int skillnum, int Delay, int Level)
{
	if (pMob[mob].MOB.Merchant == 1 && mob > MAX_USER)
		return FALSE;

	int sTickType = g_pSpell[skillnum].TickType;
	int sAggressive = g_pSpell[skillnum].Aggressive;

	if ((pMob[mob].MOB.Rsv & RSV_BLOCK) && (sAggressive != 0))
		return 0;

	int EmptyAffect = 0;

	if (skillnum == 102)
		EmptyAffect = 15;
	else
		EmptyAffect = GetEmptyAffect(mob, sTickType);

	if (sTickType > 0 && EmptyAffect >= 0 && EmptyAffect < MAX_AFFECT) //EmptyAffect >= 0
	{
		pMob[mob].Affect[EmptyAffect].Type = sTickType;
		pMob[mob].Affect[EmptyAffect].Value = g_pSpell[skillnum].TickValue;
		pMob[mob].Affect[EmptyAffect].Time = (Delay * (g_pSpell[skillnum].AffectTime + 1)) / 100;

		if (Delay >= 500000000)
			pMob[mob].Affect[EmptyAffect].Time = 500000000;

		if (pMob[mob].Affect[EmptyAffect].Time >= 3 && (sTickType == 1 || sTickType == 3 || sTickType == 10))
			pMob[mob].Affect[EmptyAffect].Time = 2;

		pMob[mob].Affect[EmptyAffect].Level = Level;

		pMob[mob].GetCurrentScore(mob);

		return TRUE;
	}

	return FALSE;
}

void ProcessDecayItem()
{
	for (int i = 0; i < ItemCount; i++)
	{
		ItemCount++;

		if (ItemCount >= 5000)
			ItemCount = g_dwInitItem + 1;

		if (pItem[ItemCount].ITEM.sIndex == 1727)
			continue;

		if (pItem[ItemCount].Mode == 0 || pItem[ItemCount].Mode == 2)
			continue;

		if (pItem[ItemCount].Delay >= 1)
		{
			pItem[ItemCount].Delay--;
			continue;
		}

		if (pItem[ItemCount].Decay != -1)
		{
			int itemPosX = pItem[ItemCount].PosX;
			int itemPosY = pItem[ItemCount].PosY;

			BASE_ClearItem(&pItem[ItemCount].ITEM);

			pItemGrid[itemPosX][itemPosY] = 0;
			pItem[ItemCount].Mode = 0;

			MSG_DecayItem sm;
			memset(&sm, 0, sizeof(MSG_DecayItem));

			sm.Type = _MSG_DecayItem;
			sm.Size = sizeof(MSG_DecayItem);
			sm.ID = ESCENE_FIELD;

			sm.ItemID = ItemCount + 10000;

			GridMulticast(itemPosX, itemPosY, (MSG_STANDARD*)&sm, 0);
		}
	}
}

int  CombineTreasureMap(int conn)
{
	for (int i = 0; i < MAX_CARRY; i++)
	{
		if (pMob[conn].MOB.Carry[i].sIndex != 788)
			continue;

		if (i + 1 >= MAX_CARRY)
			continue;

		if (pMob[conn].MOB.Carry[i + 1].sIndex != 789)
			continue;

		if (i + 9 >= MAX_CARRY)
			continue;

		if (pMob[conn].MOB.Carry[i + 9].sIndex != 790)
			continue;

		if (i + 10 >= MAX_CARRY)
			continue;

		if (pMob[conn].MOB.Carry[i + 10].sIndex != 791)
			continue;

		if (i + 18 >= MAX_CARRY)
			continue;

		if (pMob[conn].MOB.Carry[i + 18].sIndex != 792)
			continue;

		if (i + 19 >= MAX_CARRY)
			continue;

		if (pMob[conn].MOB.Carry[i + 19].sIndex != 793)
			continue;

		MSG_MessageDBRecord sm;
		memset(&sm, 0, sizeof(MSG_MessageDBRecord));

		sm.Type = _MSG_MessageDBRecord;
		sm.ID = 0;

		sm.Size = sizeof(MSG_MessageDBRecord);

		sprintf_s(sm.Record, "ETC treasure_map %d %s %s", ServerIndex, pUser[conn].AccountName, pMob[conn].MOB.MobName);

		DBServerSocket.SendOneMessage((char*)&sm, sizeof(MSG_MessageDBRecord));

		if (i >= MAX_CARRY)
			continue;

		pMob[conn].MOB.Carry[i].sIndex = 0;
		SendItem(conn, ITEM_PLACE_CARRY, i, &pMob[conn].MOB.Carry[i]);

		if (i + 1 >= MAX_CARRY)
			continue;

		pMob[conn].MOB.Carry[i + 1].sIndex = 0;
		SendItem(conn, ITEM_PLACE_CARRY, i + 1, &pMob[conn].MOB.Carry[i + 1]);

		if (i + 9 >= MAX_CARRY)
			continue;

		pMob[conn].MOB.Carry[i + 9].sIndex = 0;
		SendItem(conn, ITEM_PLACE_CARRY, i + 9, &pMob[conn].MOB.Carry[i + 9]);

		if (i + 10 >= MAX_CARRY)
			continue;

		pMob[conn].MOB.Carry[i + 10].sIndex = 0;
		SendItem(conn, ITEM_PLACE_CARRY, i + 10, &pMob[conn].MOB.Carry[i + 10]);

		if (i + 18 >= MAX_CARRY)
			continue;

		pMob[conn].MOB.Carry[i + 18].sIndex = 0;
		SendItem(conn, ITEM_PLACE_CARRY, i + 18, &pMob[conn].MOB.Carry[i + 18]);

		if (i + 19 >= MAX_CARRY)
			continue;

		pMob[conn].MOB.Carry[i + 19].sIndex = 0;
		SendItem(conn, ITEM_PLACE_CARRY, i + 19, &pMob[conn].MOB.Carry[i + 19]);

		SendClientMessage(conn, g_pMessageStringTable[_NN_Treasure_Map]);

		return TRUE;
	}

	int itemCount = 0;

	for (int i = 0; i < MAX_CARRY; i++)
	{
		if (pMob[conn].MOB.Carry[i].sIndex >= 788 && pMob[conn].MOB.Carry[i].sIndex <= 793)
		{
			pMob[conn].MOB.Carry[i].sIndex = 485;

			SendItem(conn, ITEM_PLACE_CARRY, i, &pMob[conn].MOB.Carry[i]);

			itemCount++;
		}
	}

	if (itemCount <= 0)
		return 0;

	SendClientMessage(conn, g_pMessageStringTable[_NN_Congratulations]);
	return TRUE;
}

void Combine(int conn, int item, int PrizeItem)
{
	int founditem = 0;

	if (conn < 0 || conn >= MAX_USER)
		return;

	for (int i = 0; i < MAX_CARRY; i++)
	{
		int index = pMob[conn].MOB.Carry[i].sIndex;

		if (index == item)
			founditem += pMob[conn].MOB.Carry[i].stEffect[0].cEffect == 61 ? pMob[conn].MOB.Carry[i].stEffect[0].cValue : 1;

		if (founditem >= 10)
			break;
	}

	if (founditem < 10)
		return;

	int clearitem = 0;

	for (int i = 0; i < MAX_CARRY; i++)
	{
		int index = pMob[conn].MOB.Carry[i].sIndex;

		if (index != item)
			continue;

		if (clearitem >= founditem)
			break;

		clearitem += pMob[conn].MOB.Carry[i].stEffect[0].cEffect == 61 ? pMob[conn].MOB.Carry[i].stEffect[0].cValue : 1;

		if (pMob[conn].MOB.Carry[i].stEffect[0].cEffect == 61 && pMob[conn].MOB.Carry[i].stEffect[0].cValue > 10)
			pMob[conn].MOB.Carry[i].stEffect[0].cValue -= 10;

		else
			BASE_ClearItem(&pMob[conn].MOB.Carry[i]);


		if (clearitem < 10)
			continue;
	}

	STRUCT_ITEM Prize;

	Prize.sIndex = PrizeItem;

	Prize.stEffect[0].cEffect = 59;
	Prize.stEffect[0].cValue = rand() % 100;

	Prize.stEffect[1].cEffect = 59;
	Prize.stEffect[1].cValue = rand() % 100;

	Prize.stEffect[2].cEffect = 59;
	Prize.stEffect[2].cValue = rand() % 50 + 50;

	int i = 0;

	for (i = 0; i < MAX_CARRY; i++)
	{
		int error = -1;

		//if (BASE_CanCarry(&Prize, pMob[conn].MOB.Carry, i % 9, i / 9, &error) == 1)
		//	break;

		if (pMob[conn].MOB.Carry[i].sIndex == 0)
			break;
	}

	if (i >= 0 && i < MAX_CARRY)
	{
		*(int*)&pMob[conn].MOB.Carry[i] = *(int*)&Prize;
		*(int*)((int)&pMob[conn].MOB.Carry[i] + 4) = *(int*)((int)&Prize + 4);
	}

	else
		CreateItem(pMob[conn].TargetX, pMob[conn].TargetY, &Prize, rand() % 4, 1);
}

int RemoveItem(int a_iMob, int a_iObject, int a_iCount)
{
	if (a_iCount < TRUE) a_iCount = TRUE;

	int FindCount = 0;

	int ProcSlot = -1;

	for (int i = 0; i < pMob[a_iMob].MaxCarry; i++)
	{
		if (pMob[a_iMob].MOB.Carry[i].sIndex == 0)
		{
			ProcSlot = i;

			break;
		}
	}

	if (ProcSlot == -1)
	{
		SendClientMessage(a_iMob, g_pMessageStringTable[_NN_You_Have_No_Space_To_Trade]);

		return FALSE;
	}

	for (int i = 0; i < pMob[a_iMob].MaxCarry; i++)
	{
		if (pMob[a_iMob].MOB.Carry[i].sIndex != a_iObject) continue;

		int byCount = BASE_GetItemAmount(&pMob[a_iMob].MOB.Carry[i]);

		if (byCount == FALSE) byCount = TRUE;

		FindCount += byCount;
	}

	if (FindCount < a_iCount) return FALSE; int RemoveCount = a_iCount;

	for (int i = 0; i < pMob[a_iMob].MaxCarry && RemoveCount > FALSE; i++)
	{
		if (pMob[a_iMob].MOB.Carry[i].sIndex != a_iObject) continue;

		int byCount = BASE_GetItemAmount(&pMob[a_iMob].MOB.Carry[i]);

		if (byCount == FALSE) byCount = TRUE;

		if (byCount > RemoveCount)
		{
			byCount -= RemoveCount;

			BASE_SetItemAmount(&pMob[a_iMob].MOB.Carry[i], byCount); SendItem(a_iMob, ITEM_PLACE_CARRY, i, &pMob[a_iMob].MOB.Carry[i]);

			return TRUE;
		}

		RemoveCount -= byCount;

		memset(&pMob[a_iMob].MOB.Carry[i], 0, sizeof(STRUCT_ITEM)); SendItem(a_iMob, ITEM_PLACE_CARRY, i, &pMob[a_iMob].MOB.Carry[i]);
	}

	return TRUE;
}

int ApplyHp(int conn)
{
	int retnValue = FALSE;

	if (pUser[conn].ReqHp > pMob[conn].MOB.CurrentScore.MaxHp)
		pUser[conn].ReqHp = pMob[conn].MOB.CurrentScore.MaxHp;

	int hp = pMob[conn].MOB.CurrentScore.Hp;
	int reqhp = pUser[conn].ReqHp;

	if (reqhp > hp)
	{
		int hpdif = reqhp - hp;
		if (reqhp - hp > 2000)
			hpdif = 2000;

		hp += hpdif;

		if (hp > 2000000000)
			hp = 2000000000;

		pMob[conn].MOB.CurrentScore.Hp = hp;

		if (pMob[conn].MOB.CurrentScore.Hp > reqhp)
			pMob[conn].MOB.CurrentScore.Hp = reqhp;

		retnValue = TRUE;
	}
	else
		retnValue = FALSE;

	return retnValue;
}

int ApplyMp(int conn)
{
	int retnValue = FALSE;

	if (pUser[conn].ReqMp > pMob[conn].MOB.CurrentScore.MaxMp)
		pUser[conn].ReqMp = pMob[conn].MOB.CurrentScore.MaxMp;

	int mp = pMob[conn].MOB.CurrentScore.Mp;
	int reqmp = pUser[conn].ReqMp;

	if (reqmp > mp)
	{
		int mpdif = reqmp - mp;
		if (reqmp - mp > 2000)
			mpdif = 2000;

		mp += mpdif;

		if (mp > 2000000000)
			mp = 2000000000;

		pMob[conn].MOB.CurrentScore.Mp = mp;

		if (pMob[conn].MOB.CurrentScore.Mp > reqmp)
			pMob[conn].MOB.CurrentScore.Mp = reqmp;

		retnValue = TRUE;
	}
	else
		retnValue = FALSE;

	return retnValue;
}

void SetReqHp(int conn)
{
	if (conn <= 0 || conn >= MAX_USER)
		return;

	if (pUser[conn].ReqHp < 0)
		pUser[conn].ReqHp = 0;

	if (pMob[conn].MOB.CurrentScore.Hp > pMob[conn].MOB.CurrentScore.MaxHp)
		pMob[conn].MOB.CurrentScore.Hp = pMob[conn].MOB.CurrentScore.MaxHp;

	if (pUser[conn].ReqHp < pMob[conn].MOB.CurrentScore.Hp)
		pUser[conn].ReqHp = pMob[conn].MOB.CurrentScore.Hp;
}

void SetReqMp(int conn)
{
	if (conn <= 0 || conn >= MAX_USER)
		return;

	if (pUser[conn].ReqMp < 0)
		pUser[conn].ReqMp = 0;

	if (pMob[conn].MOB.CurrentScore.Mp > pMob[conn].MOB.CurrentScore.MaxMp)
		pMob[conn].MOB.CurrentScore.Mp = pMob[conn].MOB.CurrentScore.MaxMp;

	if (pUser[conn].ReqMp < pMob[conn].MOB.CurrentScore.Mp)
		pUser[conn].ReqMp = pMob[conn].MOB.CurrentScore.Mp;
}

void ClearMapa(int x, int y)
{
	for (int i = 0; i < MAX_USER; i++)
	{
		if (pUser[i].Mode != USER_PLAY)
			continue;

		if (pMob[i].Mode == MOB_EMPTY)
			continue;

		if ((pMob[i].TargetX / 128) != x || (pMob[i].TargetY / 128) != y)
			continue;

		if (pMob[i].MOB.CurrentScore.Hp == 0)
		{
			pMob[i].MOB.CurrentScore.Hp = 2;

			pUser[i].NumError = 0;

			SendScore(i);
			SendSetHpMp(i);
		}

		DoRecall(i);
	}
}

void DeleteMobMapa(int x, int y)
{
	for (int i = MAX_USER; i < MAX_MOB; i++)
	{
		if (pMob[i].Mode == USER_EMPTY)
			continue;

		if ((pMob[i].TargetX / 128) != x || (pMob[i].TargetY / 128) != y)
			continue;

		DeleteMob(i, 1);
	}
}

// evento txt por txt PINHEIRO
void ReadEvent(void) {
	FILE* fp = NULL;

	fp = fopen("Event.txt", "rt");

	if (fp == NULL)
	{
		MessageBox(hWndMain, "no Event.txt", "Error", MB_OK | MB_SYSTEMMODAL);

		return;
	}

	int Linha = 1;
	int Item = 1;

	while (1)
	{
		char tmp[256];
		char* ret = fgets(tmp, 256, fp);

		if (ret == NULL)
			break;

		int ItemID = 0;
		int ItemQt = 0;


		sscanf(tmp, "%d %d", &ItemID, &ItemQt);

		if (Linha >= 2 && Linha <= 5) {
			EvItemId[1][Item] = ItemID;
			EvItemQt[1][Item] = ItemQt;
		}
		if (Linha >= 7 && Linha <= 10) {
			EvItemId[2][Item] = ItemID;
			EvItemQt[2][Item] = ItemQt;
		}
		if (Linha >= 12 && Linha <= 15) {
			EvItemId[3][Item] = ItemID;
			EvItemQt[3][Item] = ItemQt;
		}
		if (Linha >= 17 && Linha <= 20) {
			EvItemId[4][Item] = ItemID;
			EvItemQt[4][Item] = ItemQt;
		}

		Item++;
		Linha++;
		if (Item == 5)
			Item = 1;
	}
	fclose(fp);
}

void ReadEvent2(void) {
	FILE* fp = NULL;

	fp = fopen("Event2.txt", "rt");

	if (fp == NULL)
	{
		MessageBox(hWndMain, "no Event2.txt", "Error", MB_OK | MB_SYSTEMMODAL);

		return;
	}

	int Linha = 1;
	int Item = 1;

	while (1)
	{
		char tmp[256];
		char* ret = fgets(tmp, 256, fp);

		if (ret == NULL)
			break;

		int ItemID = 0;
		int ItemQt = 0;


		sscanf(tmp, "%d %d", &ItemID, &ItemQt);

		if (Linha >= 2 && Linha <= 5) {
			EvItemId2[1][Item] = ItemID;
			EvItemQt2[1][Item] = ItemQt;
		}
		if (Linha >= 7 && Linha <= 10) {
			EvItemId2[2][Item] = ItemID;
			EvItemQt2[2][Item] = ItemQt;
		}
		if (Linha >= 12 && Linha <= 15) {
			EvItemId2[3][Item] = ItemID;
			EvItemQt2[3][Item] = ItemQt;
		}
		if (Linha >= 17 && Linha <= 20) {
			EvItemId2[4][Item] = ItemID;
			EvItemQt2[4][Item] = ItemQt;
		}

		Item++;
		Linha++;
		if (Item == 5)
			Item = 1;
	}
	fclose(fp);
}
void ReadGuildPoints(void) {
	FILE* fp = NULL;

	fp = fopen("GuildPoints.txt", "rt");

	if (fp == NULL)
	{
		MessageBox(hWndMain, "no GuildPoints.txt", "Error", MB_OK | MB_SYSTEMMODAL);

		return;
	}

	while (1)
	{
		char tmp[256];
		char* ret = fgets(tmp, 256, fp);

		if (ret == NULL)
			break;

		int points = 0;
		int Id = 0;

		sscanf(tmp, "%d %d", &Id, &points);

		GuildPoints[Id][1] = points;
	}
	fclose(fp);
}

void ReadLevelItemConfig(void)
{
	FILE* fp = NULL;

	fp = fopen("LevelItem.txt", "rt");

	if (fp == NULL)
	{
		MessageBox(hWndMain, "no LevelItem.txt", "Error", MB_OK | MB_SYSTEMMODAL);

		return;
	}

	memset(&LevelItem, 0, sizeof(LevelItem));

	while (1)
	{
		char tmp[256];
		char* ret = fgets(tmp, 256, fp);

		if (ret == NULL)
			break;

		int cls = 0;
		int type = 0;
		int level = 0;
		STRUCT_ITEM Item;
		memset(&Item, 0, sizeof(STRUCT_ITEM));

		int ival1 = 0, ival2 = 0, ival3 = 0;
		int ival4 = 0, ival5 = 0, ival6 = 0, ival7 = 0, id = 0;

		//sscanf(tmp, "%d %d %d %d %d %d %d %d %d %d", &cls, &type, &level, &ival1, &ival2, &ival3, &ival4, &ival5, &ival6, &ival7);
		sscanf(tmp, "%d %d %d %d %d %d %d %d %d %d", &id, &level, &cls, &type, &ival1, &ival2, &ival3, &ival4, &ival5, &ival6, &ival7);

		Item.sIndex = ival1;
		Item.stEffect[0].cEffect = ival2;
		Item.stEffect[0].cValue = ival3;
		Item.stEffect[1].cEffect = ival4;
		Item.stEffect[1].cValue = ival5;
		Item.stEffect[2].cEffect = ival6;
		Item.stEffect[2].cValue = ival7;

		if (cls == 4 && type != 4)//Item para todas as classes mais não para todas build
		{
			LevelItem[0][type][level] = Item;
			LevelItem[1][type][level] = Item;
			LevelItem[2][type][level] = Item;
			LevelItem[3][type][level] = Item;
		}

		else if (cls == 4 && type == 4)//Item para todas as classes e todas as build
		{
			for (int j = 0; j < 4; j++)
			{
				for (int k = 0; k < 4; k++)
					LevelItem[j][k][level] = Item;
			}

		}

		else if (type == 4)//Item para todas as build
		{
			LevelItem[cls][0][level] = Item;
			LevelItem[cls][1][level] = Item;
			LevelItem[cls][2][level] = Item;
			LevelItem[cls][3][level] = Item;
		}

		else
			LevelItem[cls][type][level] = Item;
	}

	fclose(fp);
}

void DoItemLevel(int conn)
{
	int type = 0;

	if (pMob[conn].MOB.BaseScore.Str > pMob[conn].MOB.BaseScore.Int && pMob[conn].MOB.BaseScore.Str > pMob[conn].MOB.BaseScore.Dex && pMob[conn].MOB.BaseScore.Str > pMob[conn].MOB.BaseScore.Con)
		type = 0;

	else if (pMob[conn].MOB.BaseScore.Int > pMob[conn].MOB.BaseScore.Str && pMob[conn].MOB.BaseScore.Int > pMob[conn].MOB.BaseScore.Dex && pMob[conn].MOB.BaseScore.Int > pMob[conn].MOB.BaseScore.Con)
		type = 1;

	else if (pMob[conn].MOB.BaseScore.Dex > pMob[conn].MOB.BaseScore.Str && pMob[conn].MOB.BaseScore.Dex > pMob[conn].MOB.BaseScore.Int && pMob[conn].MOB.BaseScore.Dex > pMob[conn].MOB.BaseScore.Con)
		type = 2;

	else
		type = 3;

	if (pMob[conn].MOB.BaseScore.Str > pMob[conn].MOB.BaseScore.Int && pMob[conn].MOB.BaseScore.Str > pMob[conn].MOB.BaseScore.Dex && pMob[conn].MOB.BaseScore.Str > pMob[conn].MOB.BaseScore.Con)
		type = 0;

	else if (pMob[conn].MOB.BaseScore.Int > pMob[conn].MOB.BaseScore.Str && pMob[conn].MOB.BaseScore.Int > pMob[conn].MOB.BaseScore.Dex && pMob[conn].MOB.BaseScore.Int > pMob[conn].MOB.BaseScore.Con)
		type = 1;

	else if (pMob[conn].MOB.BaseScore.Dex > pMob[conn].MOB.BaseScore.Str && pMob[conn].MOB.BaseScore.Dex > pMob[conn].MOB.BaseScore.Int && pMob[conn].MOB.BaseScore.Dex > pMob[conn].MOB.BaseScore.Con)
		type = 2;

	else
		type = 3;

	if (LevelItem[pMob[conn].MOB.Class][type][pMob[conn].MOB.BaseScore.Level].sIndex != 0)
	{
		for (int i = 0; i < MAX_CARGO - 2; i++)
		{
			int retsour = pUser[conn].Cargo[i].sIndex;

			if (retsour != 0)
				continue;

			pUser[conn].Cargo[i] = LevelItem[pMob[conn].MOB.Class][type][pMob[conn].MOB.BaseScore.Level];

			SendItem(conn, ITEM_PLACE_CARGO, i, &LevelItem[pMob[conn].MOB.Class][type][pMob[conn].MOB.BaseScore.Level]);

			char cMsg[128];

			sprintf_s(cMsg, "%s [%s]", g_pMessageStringTable[_NN_Item_Arrived], g_pItemList[LevelItem[pMob[conn].MOB.Class][type][pMob[conn].MOB.BaseScore.Level].sIndex].Name);

			SendClientMessage(conn, cMsg);

			char ItemCode[256];

			//sprintf(temp, "tra,%s %d", pUser[conn].AccountName, i);
			BASE_GetItemCode(&LevelItem[pMob[conn].MOB.Class][type][pMob[conn].MOB.BaseScore.Level], ItemCode);
			strcat(temp, ItemCode);
			//Log(temp, "_lvlreward_", pUser[conn].IP);

			if (pUser[conn].Mode == USER_SELCHAR)
				SaveUser(conn, 0);

			return;
		}
	}
}

/*void SetCircletSubGod(int conn)
{
	int type1 = pMob[conn].MOB.Equip[1].stEffect[0].cEffect = EF_SANC;
	int typefv1 = pMob[conn].MOB.Equip[1].stEffect[0].cValue;
	int type2 = pMob[conn].MOB.Equip[1].stEffect[1].cEffect = EF_SANC;
	int typefv2 = pMob[conn].MOB.Equip[1].stEffect[1].cValue;
	int type3 = pMob[conn].MOB.Equip[1].stEffect[2].cEffect = EF_SANC;
	int typefv3 = pMob[conn].MOB.Equip[1].stEffect[2].cValue;

	if (pMob[conn].extra.ClassMaster == SCELESTIAL && pMob[conn].MOB.Equip[1].sIndex >= 3500 && pMob[conn].MOB.Equip[1].sIndex <= 3507)
	{
		if (pMob[conn].MOB.BaseScore.Level == 119 && pMob[conn].extra.QuestInfo.Celestial.Add120 == 0) // Nível 120
		{
			if (type1)
			{
				pMob[conn].MOB.Equip[1].stEffect[0].cValue = typefv1;
				pMob[conn].MOB.Equip[1].stEffect[1].cEffect = EF_AC;
				pMob[conn].MOB.Equip[1].stEffect[1].cValue = 30;
				pMob[conn].MOB.Equip[1].stEffect[2].cEffect = EF_HP;
				pMob[conn].MOB.Equip[1].stEffect[2].cValue = 40;

				pMob[conn].extra.QuestInfo.Celestial.Add120 = TRUE;

				SendItem(conn, ITEM_PLACE_EQUIP, 1, &pMob[conn].MOB.Equip[1]);
			}
			else if (type2)
			{
				pMob[conn].MOB.Equip[1].stEffect[0].cEffect = EF_AC;
				pMob[conn].MOB.Equip[1].stEffect[0].cValue = 30;
				pMob[conn].MOB.Equip[1].stEffect[1].cValue = typefv2;
				pMob[conn].MOB.Equip[1].stEffect[2].cEffect = EF_HP;
				pMob[conn].MOB.Equip[1].stEffect[2].cValue = 40;

				pMob[conn].extra.QuestInfo.Celestial.Add120 = TRUE;

				SendItem(conn, ITEM_PLACE_EQUIP, 1, &pMob[conn].MOB.Equip[1]);
			}
			else if (type3)
			{
				pMob[conn].MOB.Equip[1].stEffect[0].cEffect = EF_AC;
				pMob[conn].MOB.Equip[1].stEffect[0].cValue = 30;
				pMob[conn].MOB.Equip[1].stEffect[1].cEffect = EF_HP;
				pMob[conn].MOB.Equip[1].stEffect[1].cValue = 40;
				pMob[conn].MOB.Equip[1].stEffect[2].cValue = typefv3;

				pMob[conn].extra.QuestInfo.Celestial.Add120 = TRUE;

				SendItem(conn, ITEM_PLACE_EQUIP, 1, &pMob[conn].MOB.Equip[1]);
			}
		}
		if (pMob[conn].MOB.BaseScore.Level == 149 && pMob[conn].extra.QuestInfo.Celestial.Add150 == 0) // Nível 150
		{
			if (type1)
			{
				pMob[conn].MOB.Equip[1].stEffect[0].cValue = typefv1;
				pMob[conn].MOB.Equip[1].stEffect[1].cEffect = EF_AC;
				pMob[conn].MOB.Equip[1].stEffect[1].cValue = 35;
				pMob[conn].MOB.Equip[1].stEffect[2].cEffect = EF_HP;
				pMob[conn].MOB.Equip[1].stEffect[2].cValue = 50;

				pMob[conn].extra.QuestInfo.Celestial.Add150 = TRUE;

				SendItem(conn, ITEM_PLACE_EQUIP, 1, &pMob[conn].MOB.Equip[1]);
			}
			else if (type2)
			{
				pMob[conn].MOB.Equip[1].stEffect[0].cEffect = EF_AC;
				pMob[conn].MOB.Equip[1].stEffect[0].cValue = 35;
				pMob[conn].MOB.Equip[1].stEffect[1].cValue = typefv2;
				pMob[conn].MOB.Equip[1].stEffect[2].cEffect = EF_HP;
				pMob[conn].MOB.Equip[1].stEffect[2].cValue = 50;

				pMob[conn].extra.QuestInfo.Celestial.Add150 = TRUE;

				SendItem(conn, ITEM_PLACE_EQUIP, 1, &pMob[conn].MOB.Equip[1]);
			}
			else if (type3)
			{
				pMob[conn].MOB.Equip[1].stEffect[0].cEffect = EF_AC;
				pMob[conn].MOB.Equip[1].stEffect[0].cValue = 35;
				pMob[conn].MOB.Equip[1].stEffect[1].cEffect = EF_HP;
				pMob[conn].MOB.Equip[1].stEffect[1].cValue = 50;
				pMob[conn].MOB.Equip[1].stEffect[2].cValue = typefv3;

				pMob[conn].extra.QuestInfo.Celestial.Add150 = TRUE;

				SendItem(conn, ITEM_PLACE_EQUIP, 1, &pMob[conn].MOB.Equip[1]);
			}
		}
		if (pMob[conn].MOB.BaseScore.Level == 179 && pMob[conn].extra.QuestInfo.Celestial.Add180 == 0) // Nível 180
		{
			if (type1)
			{
				pMob[conn].MOB.Equip[1].stEffect[0].cValue = typefv1;
				pMob[conn].MOB.Equip[1].stEffect[1].cEffect = EF_AC;
				pMob[conn].MOB.Equip[1].stEffect[1].cValue = 45;
				pMob[conn].MOB.Equip[1].stEffect[2].cEffect = EF_HP;
				pMob[conn].MOB.Equip[1].stEffect[2].cValue = 60;

				pMob[conn].extra.QuestInfo.Celestial.Add180 = TRUE;

				SendItem(conn, ITEM_PLACE_EQUIP, 1, &pMob[conn].MOB.Equip[1]);
			}
			else if (type2)
			{
				pMob[conn].MOB.Equip[1].stEffect[0].cEffect = EF_AC;
				pMob[conn].MOB.Equip[1].stEffect[0].cValue = 45;
				pMob[conn].MOB.Equip[1].stEffect[1].cValue = typefv2;
				pMob[conn].MOB.Equip[1].stEffect[2].cEffect = EF_HP;
				pMob[conn].MOB.Equip[1].stEffect[2].cValue = 60;

				pMob[conn].extra.QuestInfo.Celestial.Add180 = TRUE;

				SendItem(conn, ITEM_PLACE_EQUIP, 1, &pMob[conn].MOB.Equip[1]);
			}
			else if (type3)
			{
				pMob[conn].MOB.Equip[1].stEffect[0].cEffect = EF_AC;
				pMob[conn].MOB.Equip[1].stEffect[0].cValue = 45;
				pMob[conn].MOB.Equip[1].stEffect[1].cEffect = EF_HP;
				pMob[conn].MOB.Equip[1].stEffect[1].cValue = 60;
				pMob[conn].MOB.Equip[1].stEffect[2].cValue = typefv3;

				pMob[conn].extra.QuestInfo.Celestial.Add180 = TRUE;

				SendItem(conn, ITEM_PLACE_EQUIP, 1, &pMob[conn].MOB.Equip[1]);
			}
		}
		if (pMob[conn].MOB.BaseScore.Level == 199 && pMob[conn].extra.QuestInfo.Celestial.Add200 == 0) // Nível 200
		{
			if (type1)
			{
				pMob[conn].MOB.Equip[1].stEffect[0].cValue = typefv1;
				pMob[conn].MOB.Equip[1].stEffect[1].cEffect = EF_AC;
				pMob[conn].MOB.Equip[1].stEffect[1].cValue = 50;
				pMob[conn].MOB.Equip[1].stEffect[2].cEffect = EF_HP;
				pMob[conn].MOB.Equip[1].stEffect[2].cValue = 70;

				pMob[conn].extra.QuestInfo.Celestial.Add200 = TRUE;

				SendItem(conn, ITEM_PLACE_EQUIP, 1, &pMob[conn].MOB.Equip[1]);
			}
			else if (type2)
			{
				pMob[conn].MOB.Equip[1].stEffect[0].cEffect = EF_AC;
				pMob[conn].MOB.Equip[1].stEffect[0].cValue = 50;
				pMob[conn].MOB.Equip[1].stEffect[1].cValue = typefv2;
				pMob[conn].MOB.Equip[1].stEffect[2].cEffect = EF_HP;
				pMob[conn].MOB.Equip[1].stEffect[2].cValue = 70;

				pMob[conn].extra.QuestInfo.Celestial.Add200 = TRUE;

				SendItem(conn, ITEM_PLACE_EQUIP, 1, &pMob[conn].MOB.Equip[1]);
			}
			else if (type3)
			{
				pMob[conn].MOB.Equip[1].stEffect[0].cEffect = EF_AC;
				pMob[conn].MOB.Equip[1].stEffect[0].cValue = 50;
				pMob[conn].MOB.Equip[1].stEffect[1].cEffect = EF_HP;
				pMob[conn].MOB.Equip[1].stEffect[1].cValue = 70;
				pMob[conn].MOB.Equip[1].stEffect[2].cValue = typefv3;

				pMob[conn].extra.QuestInfo.Celestial.Add200 = TRUE;

				SendItem(conn, ITEM_PLACE_EQUIP, 1, &pMob[conn].MOB.Equip[1]);
			}
		}
	}
}*/

void SetCircletSubGod(int conn)
{
	if (pMob[conn].extra.ClassMaster == SCELESTIAL && pMob[conn].MOB.BaseScore.Level == 120 && pMob[conn].extra.QuestInfo.Celestial.Add120 == 0)
	{
		if (PutAddOnItem(&pMob[conn].MOB.Equip[1], EF_AC, EF_HP, 30, 40))
		{
			pMob[conn].extra.QuestInfo.Celestial.Add120 = 1;
			SendItem(conn, ITEM_PLACE_EQUIP, 1, &pMob[conn].MOB.Equip[1]);
		}
	}

	if (pMob[conn].extra.ClassMaster == SCELESTIAL && pMob[conn].MOB.BaseScore.Level == 150 && pMob[conn].extra.QuestInfo.Celestial.Add150 == 0)
	{
		if (PutAddOnItem(&pMob[conn].MOB.Equip[1], EF_AC, EF_HP, 35, 50))
		{
			pMob[conn].extra.QuestInfo.Celestial.Add150 = 1;
			SendItem(conn, ITEM_PLACE_EQUIP, 1, &pMob[conn].MOB.Equip[1]);
		}
	}

	if (pMob[conn].extra.ClassMaster == SCELESTIAL && pMob[conn].MOB.BaseScore.Level == 180 && pMob[conn].extra.QuestInfo.Celestial.Add180 == 0)
	{
		if (PutAddOnItem(&pMob[conn].MOB.Equip[1], EF_AC, EF_HP, 45, 60))
		{
			pMob[conn].extra.QuestInfo.Celestial.Add180 = 1;
			SendItem(conn, ITEM_PLACE_EQUIP, 1, &pMob[conn].MOB.Equip[1]);
		}
	}

	if (pMob[conn].extra.ClassMaster == SCELESTIAL && pMob[conn].MOB.BaseScore.Level == 199 && pMob[conn].extra.QuestInfo.Celestial.Add200 == 0)
	{
		if (PutAddOnItem(&pMob[conn].MOB.Equip[1], EF_AC, EF_HP, 50, 70))
		{
			pMob[conn].extra.QuestInfo.Celestial.Add200 = 1;
			SendItem(conn, ITEM_PLACE_EQUIP, 1, &pMob[conn].MOB.Equip[1]);
		}
	}

}

bool PutAddOnItem(STRUCT_ITEM *Item, UINT8 ef1, UINT8 ef2, UINT8 efv1, UINT8 efv2)
{
	if (Item->sIndex < 0 || Item->sIndex > 6500) // Id inválido
		return false;
	else if (ef1 && !efv1) // Diz que vai por add mas não tem o valor
		return false;
	else if (ef2 && !efv2) // '''''''''''''''''''''''''''''''''''''''
		return false;
	else if (!ef1 && efv1) // '''''''''''''''''''''''''''''''''''''''
		return false;
	else if (!ef2 && efv2) // '''''''''''''''''''''''''''''''''''''''
		return false;

	// Salva a sanc do item
	UINT8 Sanc = 0;

	Sanc = GetItemSanc(Item);

	// Zera os adds prévios do item
	memset(Item->stEffect, 0x0, 6);

	INT8 value = 0;

	if (Sanc)
	{
		value++;

		// Põe a sanc anterior do item nele novamente
		SetItemSanc(Item, Sanc);
	}
	// Seta os novos adicionais
	Item->stEffect[value].cEffect = ef1;
	Item->stEffect[value].cValue = efv1;

	Item->stEffect[value + 1].cEffect = ef2;
	Item->stEffect[value + 1].cValue = efv2;

	return true;
}

void SummonServer(int tx, int ty)
{
	int summons = 0;

	for (int i = 0; i < MAX_USER; i++)
	{
		if (pUser[i].Mode != USER_PLAY || pMob[i].Mode == USER_EMPTY)
			continue;

		DoGreatTeleport(i, tx, ty);
	}
}

void MobAttack(int attacker, MSG_Attack sm)
{
	int _rd = rand() % 100;

	if (sm.SkillIndex == 109)
	{
		if (_rd < 40)
			sm.SkillIndex = 110;

		else if (_rd < 80)
			sm.SkillIndex = 111;
	}

	for (int i = 0; i < MAX_TARGET; i++)
	{
		int skillbase = sm.SkillIndex;
		int Target = sm.Dam[i].TargetID;

		if (Target <= 0 || Target >= MAX_MOB)
			continue;

		if (pMob[Target].MOB.CurrentScore.Hp <= 0)
			continue;

		sm.FlagLocal = 0;

		Target = sm.Dam[i].TargetID;

		if (skillbase != 109)
			sm.Dam[i].Damage = 500 + rand() % 200;

		sm.SkillIndex = skillbase;

		int skill = sm.SkillIndex;

		if (skill >= 0 && skill < MAX_SKILLINDEX && sm.SkillParm == 0)
		{
			if (skill == 33)
				sm.Motion = 253;

			int kind = ((skill % MAX_SKILL / 8) + 1);

			if (kind >= 1 && kind <= 3)
			{
				int special = pMob[attacker].MOB.CurrentScore.Special[kind];

				int NeedUpdate = 0;

				if (SetAffect(Target, skill, 100, special) != FALSE)
					NeedUpdate = 1;

				if (SetTick(Target, skill, 100, special) != FALSE)
					NeedUpdate = 1;

				if (NeedUpdate)
					SendScore(Target);
			}
		}
		if (Target < MAX_USER && sm.Dam[i].Damage > 0)
		{
			int attackdex = pMob[attacker].MOB.CurrentScore.Dex / 5;

			if (pMob[attacker].MOB.LearnedSkill & 0x1000000)
				attackdex += 100;

			if (pMob[attacker].MOB.Rsv & 0x40)
				attackdex += 500;

			int parryretn = WGetParryRate(&pMob[Target].MOB, pMob[Target].Parry, attackdex, pMob[attacker].MOB.Rsv);

			if (sm.SkillIndex == 79 || sm.SkillIndex == 22)
				parryretn = 30 * parryretn / 100;

			int rd = rand() % 1000 + 1;

			if (rd < parryretn)
			{
				sm.Dam[i].Damage = -3;

				if ((pMob[Target].MOB.Rsv & 0x200) != 0 && rd < 100)
					sm.Dam[i].Damage = -4;
			}

			else if (pMob[attacker].MOB.Clan == 4)
				sm.Dam[i].Damage = (2 * sm.Dam[i].Damage) / 5;
		}

		int TargetLeader = pMob[Target].CurrentTarget;

		if (sm.Dam[i].Damage > 0)
		{
			if (TargetLeader <= MOB_EMPTY)
				TargetLeader = Target;

			SetBattle(TargetLeader, attacker);

			if (pMob[attacker].MOB.Clan != 4)
				SetBattle(attacker, TargetLeader);

			for (int z = 0; z < MAX_PARTY; z++)
			{
				int partyconn = pMob[TargetLeader].PartyList[z];
				if (partyconn <= MAX_USER)
					continue;

				if (pMob[partyconn].Mode == MOB_EMPTY || pMob[partyconn].MOB.CurrentScore.Hp <= 0)
				{
					if (pMob[partyconn].Mode != MOB_EMPTY)
					{
						pMob[partyconn].MOB.CurrentScore.Hp = 0;
						DeleteMob(partyconn, 1);
					}

					pMob[TargetLeader].PartyList[attacker] = MOB_EMPTY;
					continue;
				}

				SetBattle(partyconn, attacker);
				SetBattle(attacker, partyconn);
			}

			for (int z = 0; z < MAX_PARTY; z++)
			{
				int partyconn = pMob[TargetLeader].Evocations[z];
				if (partyconn <= MAX_USER)
					continue;

				if (pMob[partyconn].Mode == MOB_EMPTY || pMob[partyconn].MOB.CurrentScore.Hp <= 0)
				{
					if (pMob[partyconn].Mode != MOB_EMPTY)
					{
						pMob[partyconn].MOB.CurrentScore.Hp = 0;
						DeleteMob(partyconn, 1);
					}

					pMob[TargetLeader].Evocations[attacker] = MOB_EMPTY;
					continue;
				}

				SetBattle(partyconn, attacker);
				SetBattle(attacker, partyconn);
			}

			int Summoner = pMob[attacker].Summoner;

			if (pMob[attacker].MOB.Clan == 4 && Target >= MAX_USER && Summoner > 0 && Summoner < MAX_USER && pUser[Summoner].Mode == USER_PLAY)
			{
				int posX = pMob[Summoner].TargetX;
				int posY = pMob[Summoner].TargetY;
				int num = 46;
				int dam = 0;
				int exp = 0;
				int setDam = 0;

				if (pMob[attacker].TargetX > posX - num && pMob[attacker].TargetX < posX + num && pMob[attacker].TargetY > posY - num && pMob[attacker].TargetY < posY + num)
				{
					if (pMob[Target].MOB.CurrentScore.Hp < sm.Dam[i].Damage)
						setDam = pMob[Target].MOB.CurrentScore.Hp;
					else
						setDam = sm.Dam[i].Damage;

					dam = setDam;
					exp = (int)(pMob[Target].MOB.Exp * dam / pMob[Target].MOB.CurrentScore.MaxHp);

					if (pMob[Summoner].MOB.CurrentScore.Level == pMob[attacker].MOB.CurrentScore.Level)
					{
						exp = GetExpApply(pMob[attacker].extra, exp, pMob[attacker].MOB.CurrentScore.Level, pMob[Target].MOB.CurrentScore.Level);

						if (exp > 12000)
							exp = 12000;

						if (pMob[Target].MOB.Clan == 4)
							exp = 0;

						pMob[Summoner].MOB.Exp = pMob[Summoner].MOB.Exp + exp;
					}
				}
			}
		}

		if (sm.Dam[i].Damage > 0 || sm.Dam[i].Damage <= -5)
		{
			int DamageNow = sm.Dam[i].Damage;
			int damage = 0;
			int mountindex = pMob[Target].MOB.Equip[14].sIndex;

			if (Target < MAX_USER && mountindex >= 2360 && mountindex < 2390 && pMob[Target].MOB.Equip[14].stEffect[0].sValue > 0)
			{
				DamageNow = (3 * sm.Dam[i].Damage) / 4;
				damage = sm.Dam[i].Damage - DamageNow;

				if (DamageNow <= 0)
					DamageNow = 1;

				sm.Dam[i].Damage = DamageNow;
			}

			for (int c = 0; c < MAX_AFFECT; c++)
			{
				if (pMob[Target].Affect[c].Type == 18)
				{
					if (pMob[Target].MOB.CurrentScore.Mp > ((pMob[Target].MOB.CurrentScore.MaxMp / 100) * 10))
					{
						int mana = pMob[Target].MOB.CurrentScore.Mp - (DamageNow >> 1);

						if (mana < 0)
						{
							DamageNow -= mana;
							mana = 0;
						}

						pMob[Target].MOB.CurrentScore.Mp = mana;

						pUser[Target].ReqMp = pUser[Target].ReqMp - (DamageNow >> 1);
						SetReqMp(Target);

						DamageNow = ((DamageNow >> 1) + (DamageNow << 4)) / 80;
						sm.Dam[i].Damage = DamageNow;
					}
				}
			}

			if (pMob[Target].MOB.Equip[13].sIndex == 786)
			{
				int sanc = pMob[Target].MOB.Equip[13].stEffect[0].cValue;

				if (sanc < 2)
					sanc = 2;

				pMob[Target].MOB.CurrentScore.Hp = pMob[Target].MOB.CurrentScore.Hp - ((sm.Dam[i].Damage) / sanc);
			}
			else if (pMob[Target].MOB.Equip[13].sIndex == 1936)
			{
				int sanc = pMob[Target].MOB.Equip[13].stEffect[0].cValue;

				if (sanc < 2)
					sanc = 2;

				sanc *= 10;

				pMob[Target].MOB.CurrentScore.Hp = pMob[Target].MOB.CurrentScore.Hp - ((sm.Dam[i].Damage) / sanc);
			}
			else if (pMob[Target].MOB.Equip[13].sIndex == 1937)
			{
				int sanc = pMob[Target].MOB.Equip[13].stEffect[0].cValue;

				if (sanc < 2)
					sanc = 2;

				sanc *= 1000;

				pMob[Target].MOB.CurrentScore.Hp = pMob[Target].MOB.CurrentScore.Hp - ((sm.Dam[i].Damage) / sanc);
			}
			else
			{

				if (pMob[Target].MOB.CurrentScore.Hp < sm.Dam[i].Damage)
					pMob[Target].MOB.CurrentScore.Hp = 0;

				else
					pMob[Target].MOB.CurrentScore.Hp = pMob[Target].MOB.CurrentScore.Hp - sm.Dam[i].Damage;

			}

			if (Target > MAX_USER)
				SendScore(Target);

			if (Target > MAX_USER && pMob[Target].MOB.Clan == 4)
				LinkMountHp(Target);

			if (damage > 0)
				ProcessAdultMount(Target, damage);
		}

		GridMulticast(pMob[Target].TargetX, pMob[Target].TargetY, (MSG_STANDARD*)&sm, 0);

		if (Target > 0 && Target < MAX_USER)
		{
			if (pUser[Target].ReqHp < sm.Dam[i].Damage)
				pUser[Target].ReqHp = 0;

			else
				pUser[Target].ReqHp = pUser[Target].ReqHp - sm.Dam[i].Damage;

			if (sm.SkillIndex == 109)
			{
				pMob[Target].MOB.CurrentScore.Hp = 0;
				pUser[Target].ReqHp = 0;
			}

			SetReqHp(Target);
			SendSetHpMp(Target);
		}

		if (pMob[Target].MOB.CurrentScore.Hp <= 0)
		{
			pMob[Target].MOB.CurrentScore.Hp = 0;

			MobKilled(Target, attacker, 0, 0);
		}
	}
}

void StartChatLog()
{
	if (g_pChatLog && g_pChatLog.get()->m_pStream.get()->is_open()) {
		g_pChatLog.get()->m_pStream.get()->close();
		g_pChatLog.get()->m_pStream.get()->clear();
		g_pChatLog.get()->m_pStream.release();
	}

	if (g_pChatLog)
		g_pChatLog.release();

	g_pChatLog = std::make_unique<LogControl>();

	struct tm when;
	time_t now;
	time(&now);
	when = *localtime(&now);

	sprintf_s(temp, ".\\Logs\\chat_log\\TM_%02d_%02d_%04d_%02d_%02d_%02d.txt", when.tm_mday, when.tm_mon + 1, when.tm_year + 1900, when.tm_hour, when.tm_min, when.tm_sec);

	char tmg[256];
	sprintf_s(tmg, "chat logs started successfully");
	Log(tmg, "-system", 0);

	g_pChatLog.get()->Initialize(std::string(temp));

	LastChatLogDay = when.tm_mday;
}

void ChatLog(char* AccountName, char* MacAddress, unsigned int IPAddress, char* Message)
{
	char temp_str[64] = { 0, };

	if (IPAddress != 0) //for some reason the ip address isn't working properly...
	{
		sprintf_s(temp_str, "%d.%d.%d.%d",
			IPAddress & 0xFF,
			(IPAddress >> 8) & 0xFF,
			(IPAddress >> 16) & 0xFF,
			(IPAddress >> 24) & 0xFF);
	}
	else
		sprintf_s(temp_str, "NO_VALID_IP");

	if (g_pChatLog)
		g_pChatLog.get()->WriteLog(std::string(Message), std::string(MacAddress), std::string(temp_str), std::string(AccountName));
}

void Starthacklog()
{
	if (g_phackLog && g_phackLog.get()->m_pStream.get()->is_open()) {
		g_phackLog.get()->m_pStream.get()->close();
		g_phackLog.get()->m_pStream.get()->clear();
		g_phackLog.get()->m_pStream.release();
	}


	if (g_phackLog)
		g_phackLog.release();

	g_phackLog = std::make_unique<LogControl>();

	struct tm when;
	time_t now;
	time(&now);
	when = *localtime(&now);

	sprintf_s(temp, ".\\Logs\\hack_log\\TM_%02d_%02d_%04d_%02d_%02d_%02d.txt", when.tm_mday, when.tm_mon + 1, when.tm_year + 1900, when.tm_hour, when.tm_min, when.tm_sec);

	char tmg[256];
	sprintf_s(tmg, "chat logs started successfully");
	Log(tmg, "-system", 0);

	g_phackLog.get()->Initialize(std::string(temp));

	LasthackLogDay = when.tm_mday;
}

void HackLog(char* AccountName, char* MacAddress, unsigned int IPAddress, char* Message)
{
	char temp_str[64] = { 0, };

	if (IPAddress != 0) //for some reason the ip address isn't working properly...
	{
		//Vamo do jeito hard
		sprintf_s(temp_str, "%d.%d.%d.%d",
			IPAddress & 0xFF,
			(IPAddress >> 8) & 0xFF,
			(IPAddress >> 16) & 0xFF,
			(IPAddress >> 24) & 0xFF);
	}
	else
		sprintf_s(temp_str, "NO_VALID_IP");

	if (g_phackLog)
		g_phackLog.get()->WriteLog(std::string(Message), std::string(MacAddress), std::string(temp_str), std::string(AccountName));
}

void MobDropLogs()
{
	if (g_pMobdropLog && g_pMobdropLog.get()->m_pStream.get()->is_open()) {
		g_pMobdropLog.get()->m_pStream.get()->close();
		g_pMobdropLog.get()->m_pStream.get()->clear();
		g_pMobdropLog.get()->m_pStream.release();
	}

	if (g_pMobdropLog)
		g_pMobdropLog.release();

	g_pMobdropLog = std::make_unique<LogControl>();

	struct tm when;
	time_t now;
	time(&now);
	when = *localtime(&now);

	sprintf_s(temp, ".\\Logs\\Mobdrop\\TM_%02d_%02d_%04d_%02d_%02d_%02d.txt", when.tm_mday, when.tm_mon + 1, when.tm_year + 1900, when.tm_hour, when.tm_min, when.tm_sec);

	char tmg[256];
	sprintf_s(tmg, "chat logs started successfully");
	Log(tmg, "-system", 0);

	g_pMobdropLog.get()->Initialize(std::string(temp));

	fIMobDropLogFileDay = when.tm_mday;
}

void MobDropLog(char* AccountName, char* MacAddress, unsigned int IPAddress, char* Message)
{
	char temp_str[64] = { 0, };

	if (IPAddress != 0) //for some reason the ip address isn't working properly...
	{
		//Vamo do jeito hard
		sprintf_s(temp_str, "%d.%d.%d.%d",
			IPAddress & 0xFF,
			(IPAddress >> 8) & 0xFF,
			(IPAddress >> 16) & 0xFF,
			(IPAddress >> 24) & 0xFF);
	}
	else
		sprintf_s(temp_str, "NO_VALID_IP");

	if (g_pMobdropLog)
		g_pMobdropLog.get()->WriteLog(std::string(Message), std::string(MacAddress), std::string(temp_str), std::string(AccountName));
}

void CompositorLog()
{
	if (g_pCompositorLog && g_pCompositorLog.get()->m_pStream.get()->is_open()) {
		g_pCompositorLog.get()->m_pStream.get()->close();
		g_pCompositorLog.get()->m_pStream.get()->clear();
		g_pCompositorLog.get()->m_pStream.release();
	}

	if (g_pCompositorLog)
		g_pCompositorLog.release();

	g_pCompositorLog = std::make_unique<LogControl>();

	struct tm when;
	time_t now;
	time(&now);
	when = *localtime(&now);

	sprintf_s(temp, ".\\Logs\\Compositor_Logs\\TM_%02d_%02d_%04d_%02d_%02d_%02d.txt", when.tm_mday, when.tm_mon + 1, when.tm_year + 1900, when.tm_hour, when.tm_min, when.tm_sec);

	char tmg[256];
	sprintf_s(tmg, "chat logs started successfully");
	Log(tmg, "-system", 0);

	g_pCompositorLog.get()->Initialize(std::string(temp));

	LastCompositorLogsDay = when.tm_mday;
}

void Combinelogsitem(char* AccountName, char* MacAddress, unsigned int IPAddress, char* Message)
{
	char temp_str[64] = { 0, };

	if (IPAddress != 0) //for some reason the ip address isn't working properly...
	{
		//Vamo do jeito hard
		sprintf_s(temp_str, "%d.%d.%d.%d",
			IPAddress & 0xFF,
			(IPAddress >> 8) & 0xFF,
			(IPAddress >> 16) & 0xFF,
			(IPAddress >> 24) & 0xFF);
	}
	else
		sprintf_s(temp_str, "NO_VALID_IP");

	if (g_pCompositorLog)
		g_pCompositorLog.get()->WriteLog(std::string(Message), std::string(MacAddress), std::string(temp_str), std::string(AccountName));
}

void trade_item()
{
	if (g_pItradeLog && g_pItradeLog.get()->m_pStream.get()->is_open()) {
		g_pItradeLog.get()->m_pStream.get()->close();
		g_pItradeLog.get()->m_pStream.get()->clear();
		g_pItradeLog.get()->m_pStream.release();
	}

	if (g_pItradeLog)
		g_pItradeLog.release();

	g_pItradeLog = std::make_unique<LogControl>();

	struct tm when;
	time_t now;
	time(&now);
	when = *localtime(&now);

	sprintf_s(temp, ".\\Logs\\trade_item\\TM_%02d_%02d_%04d_%02d_%02d_%02d.txt", when.tm_mday, when.tm_mon + 1, when.tm_year + 1900, when.tm_hour, when.tm_min, when.tm_sec);

	char tmg[256];
	sprintf_s(tmg, "chat logs started successfully");
	Log(tmg, "-system", 0);

	g_pItradeLog.get()->Initialize(std::string(temp));

	trade_itemLogsFileDay = when.tm_mday;
}

void Tradelogs(char* AccountName, char* MacAddress, unsigned int IPAddress, char* Message)
{
	char temp_str[64] = { 0, };

	if (IPAddress != 0) //for some reason the ip address isn't working properly...
	{
		//Vamo do jeito hard
		sprintf_s(temp_str, "%d.%d.%d.%d",
			IPAddress & 0xFF,
			(IPAddress >> 8) & 0xFF,
			(IPAddress >> 16) & 0xFF,
			(IPAddress >> 24) & 0xFF);
	}
	else
		sprintf_s(temp_str, "NO_VALID_IP");

	if (g_pItradeLog)
		g_pItradeLog.get()->WriteLog(std::string(Message), std::string(MacAddress), std::string(temp_str), std::string(AccountName));
}

void StartItemLog()
{
	if (g_pItemLog && g_pItemLog.get()->m_pStream.get()->is_open()) {
		g_pItemLog.get()->m_pStream.get()->close();
		g_pItemLog.get()->m_pStream.get()->clear();
		g_pItemLog.get()->m_pStream.release();
	}

	if (g_pItemLog)
		g_pItemLog.release();

	g_pItemLog = std::make_unique<LogControl>();

	struct tm when;
	time_t now;
	time(&now);
	when = *localtime(&now);

	sprintf_s(temp, ".\\Logs\\item_log\\TM_%02d_%02d_%04d_%02d_%02d_%02d.txt", when.tm_mday, when.tm_mon + 1, when.tm_year + 1900, when.tm_hour, when.tm_min, when.tm_sec);

	char tmg[256];
	sprintf_s(tmg, "chat logs started successfully");
	Log(tmg, "-system", 0);

	g_pItemLog.get()->Initialize(std::string(temp));

	LastItemLogDay = when.tm_mday;
}

void ItemLog(char* AccountName, char* MacAddress, unsigned int IPAddress, char* Message)
{
	char temp_str[64] = { 0, };

	if (IPAddress != 0) //for some reason the ip address isn't working properly...
	{
		//Vamo do jeito hard
		sprintf_s(temp_str, "%d.%d.%d.%d",
			IPAddress & 0xFF,
			(IPAddress >> 8) & 0xFF,
			(IPAddress >> 16) & 0xFF,
			(IPAddress >> 24) & 0xFF);
	}
	else
		sprintf_s(temp_str, "NO_VALID_IP");

	if (g_pItemLog)
		g_pItemLog.get()->WriteLog(std::string(Message), std::string(MacAddress), std::string(temp_str), std::string(AccountName));
}

//void ChatLog(char* str1, char* str2, char* str3)
//{
//	struct tm when;
//	time_t now;
//	time(&now);
//	when = *localtime(&now);
//
//	char LogTemp[1024];
//
//	sprintf(LogTemp, "%02d.%02d.%04d.%02d.%02d.%02d IP-MAC: %s", when.tm_mday, when.tm_mon + 1, when.tm_year + 1900, when.tm_hour, when.tm_min, when.tm_sec, str3);
//
//	sprintf(LogTemp, "%s %s %s \n", LogTemp, str2, str1);
//
//	if (fChatLogFile)
//		fprintf(fChatLogFile, LogTemp);
//}
//
//void StartItemLog()
//{
//	if (fItemLogFile != NULL)
//		fclose(fItemLogFile);
//
//	struct tm when;
//	time_t now;
//	time(&now);
//	when = *localtime(&now);
//
//	sprintf(temp, ".\\Logs\\item_log\\TM_%02d_%02d_%04d_%02d_%02d_%02d.txt", when.tm_mday, when.tm_mon + 1, when.tm_year + 1900, when.tm_hour, when.tm_min, when.tm_sec);
//
//	char tmg[256];
//	sprintf(tmg, "item logs started successfully");
//	Log(tmg, "-system", 0);
//
//	fItemLogFile = fopen(temp, "wt");
//
//	LastItemLogDay = when.tm_mday;
//}
//
//void trade_item() // 23/02
//{
//	if (trade_itemLogsFile != NULL)
//		fclose(trade_itemLogsFile);
//
//	struct tm when;
//	time_t now;
//	time(&now);
//	when = *localtime(&now);
//
//	sprintf(temp, ".\\Logs\\trade_item\\TM_%02d_%02d_%04d_%02d_%02d_%02d.txt", when.tm_mday, when.tm_mon + 1, when.tm_year + 1900, when.tm_hour, when.tm_min, when.tm_sec);
//
//	char tmg[256];
//	sprintf(tmg, "Trades logs started successfully");
//	Log(tmg, "-system", 0);
//
//	trade_itemLogsFile = fopen(temp, "wt");
//
//	trade_itemLogsFileDay = when.tm_mday;
//}
//
//void MobDropLogs() // 23/02
//{
//	if (fIMobDropLogLogsFile != NULL)
//		fclose(fIMobDropLogLogsFile);
//
//	struct tm when;
//	time_t now;
//	time(&now);
//	when = *localtime(&now);
//
//	sprintf(temp, ".\\Logs\\Mobdrop\\TM_%02d_%02d_%04d_%02d_%02d_%02d.txt", when.tm_mday, when.tm_mon + 1, when.tm_year + 1900, when.tm_hour, when.tm_min, when.tm_sec);
//
//	char tmg[256];
//	sprintf(tmg, "MobDrops logs started successfully");
//	Log(tmg, "-system", 0);
//
//	fIMobDropLogLogsFile = fopen(temp, "wt");
//
//	fIMobDropLogFileDay = when.tm_mday;
//}
//
//void MobDropLog(char* str1, char* str2, char* str3) //23/02
//{
//	struct tm when;
//	time_t now;
//	time(&now);
//	when = *localtime(&now);
//
//	char LogTemp[1024];
//
//	sprintf(LogTemp, "%02d.%02d.%04d.%02d.%02d.%02d IP-MAC : %s", when.tm_mday, when.tm_mon + 1, when.tm_year + 1900, when.tm_hour, when.tm_min, when.tm_sec, str3);
//
//	sprintf(LogTemp, "%s %s %s \n", LogTemp, str2, str1);
//
//	if (fIMobDropLogLogsFile)
//		fprintf(fIMobDropLogLogsFile, LogTemp);
//}
//
//void CompositorLog() // 23/02
//{
//	if (fICompositorLogsFile != NULL)
//		fclose(fICompositorLogsFile);
//
//	struct tm when;
//	time_t now;
//	time(&now);
//	when = *localtime(&now);
//
//	sprintf(temp, ".\\Logs\\Compositor_Logs\\TM_%02d_%02d_%04d_%02d_%02d_%02d.txt", when.tm_mday, when.tm_mon + 1, when.tm_year + 1900, when.tm_hour, when.tm_min, when.tm_sec);
//
//	char tmg[256];
//	sprintf(tmg, "Compositor logs started successfully");
//	Log(tmg, "-system", 0);
//
//	fICompositorLogsFile = fopen(temp, "wt");
//
//	LastCompositorLogsDay = when.tm_mday;
//}
//
//void Combinelogsitem(char* str1, char* str2, char* str3) //23/02
//{
//	struct tm when;
//	time_t now;
//	time(&now);
//	when = *localtime(&now);
//
//	char LogTemp[1024];
//
//	sprintf(LogTemp, "%02d.%02d.%04d.%02d.%02d.%02d IP-MAC : %s", when.tm_mday, when.tm_mon + 1, when.tm_year + 1900, when.tm_hour, when.tm_min, when.tm_sec, str3);
//
//	sprintf(LogTemp, "%s %s %s \n", LogTemp, str2, str1);
//
//	if (fICompositorLogsFile)
//		fprintf(fICompositorLogsFile, LogTemp);
//}
//
//void Tradelogs(char* str1, char* str2, char* str3)
//{
//	struct tm when;
//	time_t now;
//	time(&now);
//	when = *localtime(&now);
//
//	char LogTemp[1024];
//
//	sprintf(LogTemp, "%02d.%02d.%04d.%02d.%02d.%02d IP-MAC : %s", when.tm_mday, when.tm_mon + 1, when.tm_year + 1900, when.tm_hour, when.tm_min, when.tm_sec, str3);
//
//	sprintf(LogTemp, "%s %s %s \n", LogTemp, str2, str1);
//
//	if (trade_itemLogsFile)
//		fprintf(trade_itemLogsFile, LogTemp);
//}
//
//void ItemLog(char* str1, char* str2, char* str3)
//{
//	struct tm when;
//	time_t now;
//	time(&now);
//	when = *localtime(&now);
//
//	char LogTemp[1024];
//
//	sprintf(LogTemp, "%02d.%02d.%04d.%02d.%02d.%02d IP-MAC : %s", when.tm_mday, when.tm_mon + 1, when.tm_year + 1900, when.tm_hour, when.tm_min, when.tm_sec, str3);
//
//	sprintf(LogTemp, "%s %s %s \n", LogTemp, str2, str1);
//
//	if (fItemLogFile)
//		fprintf(fItemLogFile, LogTemp);
//}

int  ParseMobMercString(int Num, char *str)
{
	char str1[128];
	str1[0] = 0;

	char str2[128];
	str2[0] = 0;

	char str3[128];
	str3[0] = 0;

	int  value = 0;
	int secondvalue = 0;

	sscanf(str, "%s %s %s", str1, str2, str3);

	if (str[0] == 47)
		return FALSE;

	if (str[0] == 0)
		return FALSE;

	STRUCT_ITEM Item;
	memset(&Item, 0, sizeof(STRUCT_ITEM));

	char item_str1[256];
	char item_str2[256];
	char item_str3[256];
	char item_str4[256];
	char item_str5[256];
	char item_str6[256];
	char item_str7[256];
	char item_str8[256];

	int item_value[8] = { 0, 0, 0, 0, 0, 0, 0 , 0 };

	sscanf(str2, "%s %s %s %s %s %s %s - %s", item_str1, item_str2, item_str3, item_str4, item_str5, item_str6, item_str7, item_str8);
	item_value[0] = atoi(item_str1);
	item_value[1] = atoi(item_str2);
	item_value[2] = atoi(item_str3);
	item_value[3] = atoi(item_str4);
	item_value[4] = atoi(item_str5);
	item_value[5] = atoi(item_str6);
	item_value[6] = atoi(item_str7);
	item_value[7] = atoi(item_str8);

	value = atoi(str2);
	secondvalue = atoi(str3);

	if (strlen(str2) > 80)
		return FALSE;

	_strupr(str1);

	if (!strcmp(str1, "MOBNAME:"))
		strncpy(pMobMerc[Num].MobName, str2, NAME_LENGTH);

	else if (!strcmp(str1, "GENERATEINDEX:"))
		pMobMerc[Num].GenerateIndex = value;

	else if (!strcmp(str1, "RENEWTIME:"))
		pMobMerc[Num].RenewTime = value * 2;

	else if (!strcmp(str1, "REBORNTIME:"))
		pMobMerc[Num].RebornTime = value * 2;

	else
	{
		for (int i = 0; i < MAX_CARRY; i++)
		{
			sprintf_s(temp, "ITEM_%d:", i);

			if (!strcmp(str1, temp))
			{
				pMobMerc[Num].Carry[i].sIndex = item_value[0];
				pMobMerc[Num].Carry[i].stEffect[0].cEffect = item_value[1];
				pMobMerc[Num].Carry[i].stEffect[0].cValue = item_value[2];
				pMobMerc[Num].Carry[i].stEffect[1].cEffect = item_value[3];
				pMobMerc[Num].Carry[i].stEffect[1].cValue = item_value[4];
				pMobMerc[Num].Carry[i].stEffect[2].cEffect = item_value[5];
				pMobMerc[Num].Carry[i].stEffect[2].cValue = item_value[6];

				pMobMerc[Num].MaxStock[i] = item_value[7];
				pMobMerc[Num].Stock[i] = item_value[7];

				return TRUE;
			}
		}
	}
	return TRUE;
}

void DeleteGenerateMob(int generate)
{
	for (int i = MAX_USER; i < MAX_MOB; i++)
	{
		if (pMob[i].Mode == MOB_EMPTY)
			continue;

		if (pMob[i].GenerateIndex != generate)
			continue;

		DeleteMob(i, 3);
	}
}

int  CreateTreasureBox(int x, int y, STRUCT_ITEM *item, int rotate, int State)
{
	if (item->sIndex <= 0 || item->sIndex >= MAX_ITEMLIST)
		return FALSE;

	GetEmptyItemGrid(&x, &y);


	if (pItemGrid[y][x])
		return FALSE;

	int empty = GetEmptyItem();

	if (empty == 0)
		return FALSE;

	pItem[empty].Mode = 2;

	pItem[empty].PosX = x;
	pItem[empty].PosY = y;

	memcpy(&pItem[empty].ITEM, item, sizeof(STRUCT_ITEM));

	pItem[empty].Rotate = rotate;
	pItem[empty].State = State;

	pItem[empty].Delay = 0;
	pItem[empty].Decay = 0;

	pItem[empty].GridCharge = BASE_GetItemAbility(item, EF_GROUND);

	pItemGrid[y][x] = empty;

	pItem[empty].Height = pHeightGrid[y][x];

	MSG_CreateItem sm;
	memset(&sm, 0, sizeof(MSG_CreateItem));

	sm.Type = _MSG_CreateItem;
	sm.Size = sizeof(MSG_CreateItem);
	sm.ID = ESCENE_FIELD;

	sm.ItemID = empty + 10000;

	memcpy(&sm.Item, &pItem[empty].ITEM, sizeof(STRUCT_ITEM));

	sm.GridX = x;
	sm.GridY = y;

	sm.Rotate = rotate;
	sm.State = pItem[empty].State;

	sm.Height = -204;

	GridMulticast(x, y, (MSG_STANDARD*)&sm, 0);

	return TRUE;
}

void RefinarItemMais(STRUCT_ITEM *item, int value)
{
	if (item->stEffect[1].cEffect == EF_SANC || (item->stEffect[1].cEffect >= 116 && item->stEffect[1].cEffect <= 125))
		item->stEffect[1].cValue += value;
	else if (item->stEffect[2].cEffect == EF_SANC || (item->stEffect[2].cEffect >= 116 && item->stEffect[2].cEffect <= 125))
		item->stEffect[2].cValue += value;
	else if (item->stEffect[3].cEffect == EF_SANC || (item->stEffect[3].cEffect >= 116 && item->stEffect[3].cEffect <= 125))
		item->stEffect[1].cValue += value;
	else
	{
		if (!item->stEffect[1].cEffect)
		{
			item->stEffect[1].cEffect = EF_SANC;
			item->stEffect[1].cValue = value;
		}
		else if (!item->stEffect[2].cEffect)
		{
			item->stEffect[2].cEffect = EF_SANC;
			item->stEffect[2].cValue = value;
		}
		else if (!item->stEffect[3].cEffect)
		{
			item->stEffect[3].cEffect = EF_SANC;
			item->stEffect[3].cValue = value;
		}
	}

	return;
}

int GetItemSanc(STRUCT_ITEM *item)
{
	for (int i = 0; i < 3; i++)
		if (item->stEffect[i].cEffect == EF_SANC || (item->stEffect[i].cEffect >= 116 && item->stEffect[i].cEffect <= 125))
			return item->stEffect[i].cValue;

	return 0;
}

bool CheckArchItem(int id)
{
	int retorno = false;
	///SET'S
	if (id >= 1221 && id <= 1224) retorno = true;
	else if (id >= 1356 && id <= 1359) retorno = true;
	else if (id >= 1506 && id <= 1509) retorno = true;
	else if (id >= 1656 && id <= 1659) retorno = true;
	///ARMAS ARCH
	else if (id == 811 || id == 826 || id == 841) retorno = true;
	else if (id == 856 || id == 871 || id == 886) retorno = true;
	else if (id == 871 || id == 886 || id == 903 || id == 904) retorno = true;
	else if (id == 912 || id == 937 || id == 2379 || id == 2380) retorno = true;
	///ARMAS ARCH ANCT
	else if ((id >= 2491 && id <= 2494) || (id >= 2551 && id <= 2554)) retorno = true;
	else if ((id >= 2611 && id <= 2614) || (id >= 2671 && id <= 2674)) retorno = true;
	else if ((id >= 2791 && id <= 2794) || (id >= 2859 && id <= 2866)) retorno = true;
	else if ((id >= 2895 && id <= 2898) || (id >= 2935 && id <= 2938)) retorno = true;
	else if ((id >= 2731 && id <= 2734)) retorno = true;
	return retorno;
}

bool CheckHardItem(int id)
{
	int retorno = false;
	///SET'S
	if (id >= 1901 && id <= 1910) {
		retorno = true;
	}

	///ARMAS ARCH
	else if (id == 1230 || id == 1231 || id == 1232 || id == 1667)
		retorno = true;
	else if (id == 1233 || id == 1365 || id == 1366 || id == 1668)
		retorno = true;
	else if (id == 1367 || id == 1368 || id == 1515 || id == 1516)
		retorno = true;
	else if (id == 1517 || id == 1518 || id == 1665 || id == 1666)
		retorno = true;

	return retorno;
}

void AmountMinus(STRUCT_ITEM *item)
{
	int index = 0;
	int amount = 0;
	for (int i = 0; i < 3; i++)
	{
		if (item->stEffect[i].cEffect == 61)
		{
			index = i;
			amount = item->stEffect[i].cValue;
			break;
		}
	}

	if (amount <= 1)
		memset(item, 0, sizeof STRUCT_ITEM);
	else
		item->stEffect[index].cValue--;
}

bool CheckMount(STRUCT_ITEM *Item, INT16 Mount)
{
	int number = Item->sIndex - 3351;

	for (INT8 e = 0; e < 4; e++)
		if (MountCheck[number][e] && MountCheck[number][e] == Mount)
			return true;

	return false;
}

bool CheckMount2(STRUCT_ITEM *Item, INT16 Mount)
{
	int number = Item->sIndex - 3344;

	for (INT8 e = 0; e < 4; e++)
		if (MountCheck2[number][e] && MountCheck2[number][e] == Mount)
			return true;

	return false;
}

void SetItemSanc(STRUCT_ITEM *item, int value)
{
	if (item->stEffect[0].cEffect == EF_SANC || (item->stEffect[0].cEffect >= 116 && item->stEffect[0].cEffect <= 125))
		item->stEffect[0].cValue = value;
	else if (item->stEffect[1].cEffect == EF_SANC || (item->stEffect[1].cEffect >= 116 && item->stEffect[1].cEffect <= 125))
		item->stEffect[1].cValue = value;
	else if (item->stEffect[2].cEffect == EF_SANC || (item->stEffect[2].cEffect >= 116 && item->stEffect[2].cEffect <= 125))
		item->stEffect[2].cValue = value;
	else
	{
		for (int i = 0; i < 3; i++)
		{
			if (!item->stEffect[i].cEffect)
			{
				item->stEffect[i].cEffect = EF_SANC;
				item->stEffect[i].cValue = value;
				return;
			}
		}
	}
}

 

bool ReadQuiz()
{
	FILE *fp;

	fopen_s(&fp, "RandomQuiz.txt", "rt");

	if (fp == NULL)
	{
		MessageBoxA(0, "Missing RandomQuiz.txt file", "Error", MB_ICONERROR | MB_OK);
		fclose(fp);
		return false;
	}

	QuizLineCounter = -1;

	char line[256];
	while (fgets(line, sizeof(line), fp))
	{
		MSG_Quiz UsedQuiz;
		memset(&UsedQuiz, 0, sizeof(MSG_Quiz));

		char *p = line;

		for (int o = 0; o < 1024; o++)
		{
			if (line[o] == ',') { line[o] = ' '; }
			if (line[o] == '[') { break; }
		}

		if (line[0] == '#')
			continue;

		char title[128], str0[32], str1[32], str2[32], str3[32];
		int test = -1;

		if (sscanf(line, "%s %s %s %s %s %d", title, str0, str1, str2, str3, &test))
		{
			strncpy(UsedQuiz.Title, title, 128);
			strncpy(UsedQuiz.Answer[0], str0, 32);
			strncpy(UsedQuiz.Answer[1], str1, 32);
			strncpy(UsedQuiz.Answer[2], str2, 32);
			strncpy(UsedQuiz.Answer[3], str3, 32);
			UsedQuiz.CorrectAlternative = test;
			memcpy(&QuizList[QuizLineCounter], &UsedQuiz, sizeof UsedQuiz);
			QuizLineCounter++;
		}
		else
		{
			MessageBoxA(0, "Missing data in quiz", "Error", MB_ICONERROR | MB_OK);
			fclose(fp);
			return false;
		}
	}

	fclose(fp);
	return true;
}

bool ReadCuboQuiz()
{
	FILE *fp;

	fopen_s(&fp, "CuboQuiz.txt", "rt");

	if (fp == NULL)
	{
		MessageBoxA(0, "Missing CuboQuiz.txt file", "Error", MB_ICONERROR | MB_OK);
		fclose(fp);
		return false;
	}

	CuboQuizLine = -1;

	char line[256];
	while (fgets(line, sizeof(line), fp))
	{
		MSG_BigQuiz qq;
		memset(&qq, 0, sizeof(MSG_BigQuiz));

		char *p = line;

		for (int o = 0; o < 1024; o++)
		{
			if (line[o] == ',') { line[o] = ' '; }
			if (line[o] == '[') { break; }
		}

		if (line[0] == '#')
			continue;

		int num, k;
		char title[128], string[128];

		int test = -1;

		if (sscanf(line, "%d %d %s", &num, &k, string))
		{
			qq.Unknow = num;
			sprintf_s(title, "<<_No._%d_>>", num);
			strncpy(qq.Title, title, 128);
			strncpy(qq.Line[0], string, 128);
			memcpy(&CuboList[CuboQuizLine], &qq, sizeof qq);
			CuboQuizLine++;
		}
		else
		{
			MessageBoxA(0, "Missing data in quiz", "Error", MB_ICONERROR | MB_OK);
			fclose(fp);
			return false;
		}
	}

	fclose(fp);
	return true;
}

/*
bool LoadCuboCoord()
{
	FILE *fp = fopen("CuboCord.txt", "r+");

	if (fp == NULL)
		return FALSE;

	char line[1024];
	int Xr = 0;
	int Or = 0;

	while (fgets(line, sizeof(line), fp))
	{
		if (*line == '\n' || *line == '#')
			continue;

		char *p = line;

		while (*p != '\0')
		{
			if (*p == ',')
				*p = ' ';
			else if (*p == '[')
				*p = ' ';
			else if (*p == ']')
				*p = ' ';

			p++;
		}

		char VF;
		int indessx;

		sPoint Cord;
		memset(&Cord, 0, sizeof(sPoint));
		sscanf(line, "%c %d %4d %4d", &VF, &indessx, &Cord.PosX, &Cord.PosY);

		if (VF == 'O')
		{
			Cubo.O[Or].PosX = Cord.PosX;
			Cubo.O[Or].PosY = Cord.PosY;
			Or++;
		}
		else if (VF == 'X')
		{
			Cubo.X[Xr].PosX = Cord.PosX;
			Cubo.X[Xr].PosY = Cord.PosY;
			Xr++;
		}
	}

	fclose(fp);
	return TRUE;
}

bool LoadCubo()
{
	FILE *fp = fopen("Cubo.txt", "r+");

	if (fp == NULL)
		return false;

	char line[1024];

	for (int x = 0; x < 25; x++)
	{
		int index = 0, num = 0;

		fgets(line, sizeof(line), fp);

		sscanf(line, "%d %d %100[^=]", &num, &index, Cubo.Question[x]);

		Cubo.CurrentQuestion[x] = num;
		Cubo.Question[x][strlen(Cubo.Question[x]) - 1] = '\0';

		if (index == 0)
			Cubo.Answer[x] = FALSE;
		else if (index == 1)
			Cubo.Answer[x] = TRUE;
		else
			return FALSE;
	}

	fclose(fp);
	return TRUE;
}*/

void ReadDirectory()
{
	if ((fReadDir = fopen("Account_Directory.txt", "r")) == NULL)
	{
		MessageBox(hWndMain, "Não foi possivel abrir Account_Directory.txt!", "Erro ao iniciar", NULL);
		return;
	}
	else
	{
		fscanf(fReadDir, "%s", ACCOUNT_DIRECTORY);
		fclose(fReadDir);
	}
}

void SendSpkMsg(int conn, char* Msg, TNColor Color32, bool ToAll = false)
{
	if (conn <= 0 || conn >= MAX_USER) return;

	MSG_ChatColor sm_mt;
	memset(&sm_mt, 0, sizeof(MSG_STANDARDPARM));

	sm_mt.Size = sizeof(MSG_ChatColor);
	sm_mt.ID = 0;
	sm_mt.Type = _MSG_MagicTrumpet;
	strncpy(sm_mt.Message, Msg, sizeof(sm_mt.Message));
	sm_mt.Color = Color32;

	if (ToAll)
	{
		for (int i = 1; i < MAX_USER; i++)
		{
			if (pUser[i].Mode != USER_PLAY) continue;

			pUser[i].cSock.SendOneMessage((char*)&sm_mt, sizeof(sm_mt));
		}
	}
	else
	{
		pUser[conn].cSock.SendOneMessage((char*)&sm_mt, sizeof(sm_mt));
	}


}

void SendMsgExp(int conn, char* Msg, TNColor Color32, bool ToAll = false)
{
	if (conn <= 0 || conn >= MAX_USER) return;

	MSG_Exp_Msg_Panel_ sm;
	memset(&sm, 0, sizeof(MSG_Exp_Msg_Panel_));

	sm.Type = _MSG_Exp_Msg_Panel_;
	sm.Size = sizeof(MSG_Exp_Msg_Panel_);
	sm.ID = conn;

	strncpy(sm.Msg, Msg, sizeof(sm.Msg));

	sm.Color32 = Color32;

	if (ToAll)
	{
		for (int i = 0; i < MAX_USER; i++)
		{
			if (pUser[i].Mode != USER_PLAY) continue;

			pUser[i].cSock.SendOneMessage((char*)&sm, sizeof(sm));
		}
	}
	else
	{
		pUser[conn].cSock.SendOneMessage((char*)&sm, sizeof(sm));
	}
}

# -------------------- Server.h --------------------

/*
*   Copyright (C) {2015}  {Victor Klafke, Charles TheHouse}
*
*   This program is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program.  If not, see [http://www.gnu.org/licenses/].
*
*   Contact at: victor.klafke@ecomp.ufsm.br
*/
#ifndef __SERVER_H__
#define	__SERVER_H__

#include <windows.h>
#include <windowsx.h>
#include <stdlib.h>
#include <stdio.h> 
#include <fcntl.h>
#include <io.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/timeb.h>
#include <string.h>        
#include <time.h>
#include <memory>
#include <fstream>
#include <vector>

#include "..\Basedef.h"
#include "..\CPSock.h"


#include "CItem.h"
#include "CMob.h"
#include "CUser.h"
#include "CNPCGene.h"
#include "LogControl.h"

#include <locale.h>

// Externs
extern HWND hWndMain;
extern bool g_BSombraNegra;
extern bool g_BVerid;
extern bool g_SombraP;
extern int g_LanNBossCount;
extern bool g_LanNBoss;
extern bool g_RainhaG;

extern bool PistaPlaying;
extern bool g_BFDarkShadow;
extern int ServerGroup;

extern unsigned int CurrentTime;
extern int BrState;
extern int BrTime;
extern unsigned short g_pGuildWar[65536];
extern unsigned short g_pGuildAlly[65536];

extern unsigned short pMobGrid  [MAX_GRIDY][MAX_GRIDX];
extern unsigned short pItemGrid [MAX_GRIDY][MAX_GRIDX];
extern char pHeightGrid [MAX_GRIDY][MAX_GRIDX];

extern int CurrentWeather;

extern int GuildImpostoID[MAX_GUILDZONE];

extern CNPCGenerator mNPCGen;

extern CUser pUser[MAX_USER];
extern STRUCT_BLOCKMAC pMac[MAX_MAC];
extern int BigCubo;

//Recaptcha
extern int random_words;

extern char Keywords[30][7];

extern char Keywords1[30][7];

extern char Keywords2[30][7];

// Donate Store

extern int cStoreItens[3][5][15][3];

// Funcs


void  SendItemagrupar(const int client, int itemID);
void  SendItemagrupar2(const int client, int itemID, int valor);
void  sendeitempremio(const int client, int itemID, int valor);

void  SendMsgExp(int conn, char* msg, TNColor Color, bool flag);
void  SendSpkMsg(int conn, char* msg, TNColor Color, bool Flag);
void  ClearCrown(int conn);
void  LimiteBsWepom(int conn);
BOOL  AddCrackError(int conn, int val, int Type);
BOOL  PutItem(int conn, STRUCT_ITEM *item);
void  GuildZoneReport();
HFONT__ *  GetAFont();
void  ReadConfig();
void  DrawConfig(int wb);
void BASE_ReadQuestDiaria();
void  AddFailAccount(char *Account);
int   CheckFailAccount(char *Account);
int   IsFree(STRUCT_SELCHAR *sel);
int   SendBilling(int a1, char *a2, int a3, int a4);
int   SendBilling2(_AUTH_GAME *m, int hostlong);
void  SetItemBonus(STRUCT_ITEM *Dest, int Level, int a3, int DropBonus);
int   Challange(int conn, int mob, int coin);
int   GenerateSummon(int conn, int SummonID, STRUCT_ITEM *sItem, int Num);
int   GenerateEvocation(int conn, int SummonID, STRUCT_ITEM *sItem, int Num);
int   CreateMob(char *MobName, int PosX, int PosY, char *folder, int Type); 
void  GenerateMob(int index, int PosX, int PosY);
void  RebuildGenerator();
BOOL  InitApplication(HANDLE hInstance);
bool FileExist(const char* Name);
BOOL  InitInstance(HANDLE hInstance, int nCmdShow);
FILE* WriteHeader(char *fileName);
void  WriteArmor(FILE *fp);
void  WriteWeapon(FILE *fp);
void  BuildList();
LONG  APIENTRY MainWndProc(HWND hWnd, UINT message, UINT wParam, LONG lParam);
int   GetUserInArea(int x1, int y1, int x2, int y2, char *MobName);
void  MountProcess(int conn, STRUCT_ITEM *Mount);
void  LinkMountHp(int mobConn);
int GetItemSancNew(STRUCT_ITEM* item);
void  ProcessAdultMount(int conn, int HpLost);
void  ProcessBILLMessage(char *pMsg);
void  ProcessDBMessage(char *Msg);
void  CheckIdle(int conn); 
void  FinishCastleWar();
void  RegenMob(int conn);
int   ProcessAffect(int conn);
void  SendDamage(int x1, int y1, int x2, int y2);
void  ProcessSecTimer();
void  ProcessMinTimer();
void  SummonGuild2(int Guild, int tx, int ty, int maxsummon, int village);
void  SummonGuild(int Guild, int tx, int ty, int maxsummon, int village);
void  ClearArea(int x1, int y1, int x2, int y2);
void  ClearAreaNoVip(int x1, int y1, int x2, int y2);
void  ClearAreaVip(int x1, int y1, int x2, int y2);
void  ClearAreaLevel(int x1, int y1, int x2, int y2, int minLv, int maxLv);
void  ClearAreaGuild(int x1, int y1, int x2, int y2, int Guild);
void  ClearAreaTeleport(int x1, int y1, int x2, int y2, int tx, int ty);
void  ClearGuildPKZone();
void  SetBigCuboDoor(int state);
void  SetColoseumDoor(int state); 
void  SetColoseumDoor2(int state);
void  GenerateColoseum(int InitID);
void  DeleteColoseum();
void  SetArenaDoor(int state);
void  SetCastleDoor(int state);
void  DecideWinner0();
void  DecideWinner1();
void  DecideWinner2();
void  DecideWinner3();
void  GuildProcess(); 
void  StartLog();
 
int   GetUserInAreaMac(int notUsage, int x1, int y1, int x2, int y2);
void  CrackLog(int conn, char *str);
void  Log(char *str1, char *str2, unsigned int ip);
int   GetUserFromSocket(int Sock);
int   GetEmptyUser();
int   GetEmptyItem();
int   GetEmptyNPCMob();
int   GetUserByName(char *name);
int   IsImple(int user);
void  CloseUser(int conn);
CMob *GetMobFromIndex(unsigned int index);
int   GetAngle(int x, int y);
int   GetLength(int x, int y);
int   ReadMob(STRUCT_MOB *mob, char *dir);
void  DeleteMob(int conn, int Type);
void  SaveUser(int conn,int Export);
void  CharLogOut(int conn);
void  Reboot();  
void  ClearChallanger0();
void  ClearChallanger1();
void  ClearChallanger2();
void  ClearChallanger3();
void  SetBattle(int mob, int target);      
void  MobKilled(int conn, int target, int PosX, int PosY); 
int   CreateItem(int x, int y, STRUCT_ITEM *item, int rotate, int Create);
void  RemoveTrade(int conn);
void  RemoveParty(int conn);
void  RemoveEvocation(int conn);
int   UpdateItem(int Gate, int state, int *height);
void  DoRecall(int conn);  
void  DoWar(int myguild, int target);     
void  DoAlly(int myguild, int target);       
void  DoDeprivate(int conn, int target);     
void  ProcessRanking();    
void  DoRanking(int tDuel, int conn, int enemy);   
void  DoRemoveHide(int conn);  
void  DoRemoveAbsoluteProtection(int conn);
void  DoRemoveAllBuffs(int conn);
void  DoRemoveMutation(int conn);
void  DoTeleport(int mob, int x, int y);     
void  DoSummon(int target, int x, int y);       
int   SetAffect(int conn, int skillnum, int time, int Level);
int   SetTick(int mob, int skillnum, int Delay, int Level); 
void  ProcessDecayItem();
int   CombineTreasureMap(int conn);
void  Combine(int conn, int item, int PrizeItem);
int RemoveItem(int a_iMob, int a_iObject, int a_iCount);
int   ApplyHp(int conn); 
int   ApplyMp(int conn); 
void  SetReqHp(int conn); 
void  SetReqMp(int conn); 
void  ClearMapa(int x, int y);
void  DeleteMobMapa(int x, int y);
void  SetItemBonus2(STRUCT_ITEM *Dest);
void  DoRemoveSamaritano(int conn);
void  SaveAll();
void  ReadLevelItemConfig(void);
void  ReadEvent(void);
void  ReadEvent2(void);
void  ReadGuildPoints(void);
void  DoItemLevel(int conn);
void  SetCircletSubGod(int conn);
void  SummonServer(int tx, int ty);
void  DoGreatTeleport(int mob, int x, int y);
void  SendDamageKingdom(int x1, int y1, int x2, int y2, int Clan);
void  SendDamageLeader(int x1, int y1, int x2, int y2);
void  MobAttack(int attacker, MSG_Attack sm);
void  ItemLog(char* AccountName, char* MacAddress, unsigned int IPAddress, char* Message);
void  Tradelogs(char* AccountName, char* MacAddress, unsigned int IPAddress, char* Message);
void  Combinelogsitem(char* AccountName, char* MacAddress, unsigned int IPAddress, char* Message);
void ChatLog(char* AccountName, char* MacAddress, unsigned int IPAddress, char* Message);
void  HackLog(char* AccountName, char* MacAddress, unsigned int IPAddress, char* Message);
void  MobDropLog(char* AccountName, char* MacAddress, unsigned int IPAddress, char* Message);
void SystemLog(char* AccountName, char* MacAddress, unsigned int IPAddress, char* Message);
void StartSystemLog();
void  StartChatLog();
void  StartItemLog();
void  Starthacklog();
void  CompositorLog();  //23/02 
void  trade_item();  //23/02 
void  MobDropLogs();  //23/02 
//int   ParseCastleString(int Num, char *str);
int   ParseMobMercString(int Num, char *str);
//int   ParseCampString(int Num, char *str);
void  DeleteGenerateMob(int generate);
int   CreateTreasureBox(int x, int y, STRUCT_ITEM *item, int rotate, int State);
void  ClearAreaQuestold(int x1, int y1, int x2, int y2);
void  ClearAreaQuest(int conn, int x1, int y1, int x2, int y2);
void  ClearMobArea(int x1, int y1, int x2, int y2);
void  RefinarItemMais(STRUCT_ITEM *item, int value);
//void  ItemRefinar(STRUCT_ITEM *item, int value);
int   GetItemSanc(STRUCT_ITEM *item);
bool  CheckArchItem(int id);
bool  CheckHardItem(int id);
void  AmountMinus(STRUCT_ITEM *item);
bool  CheckMount(STRUCT_ITEM *Item, INT16 Mount);
bool  CheckMount2(STRUCT_ITEM *Item, INT16 Mount);
void  SetItemSanc(STRUCT_ITEM *item, int value);
bool  PutAddOnItem(STRUCT_ITEM *Item, UINT8 ef1, UINT8 ef2, UINT8 efv1, UINT8 efv2);
/*INT64 SystemTimeDifference(const SYSTEMTIME time1, const SYSTEMTIME time2);
bool  FileExist(const char* Name );
bool  CheckBan(const char *login);
void  SendBan(const char *login);
void  SendBan3Hours(unsigned int ip);
bool  CheckBan3Hours(unsigned int ip);
bool  Check3HoursAccBan(const char *login);
void  Send3HoursAccBan(const char *login);
bool  CheckMacBan(const int *mac0, const int *mac1, const int *mac2, const int *mac3);
void  SendMacBan(const int *mac0, const int *mac1, const int *mac2, const int *mac3);
void  SendIpBan(unsigned int ip);
bool  CheckIpBan(unsigned int ip);
void  ReadArquivo(void);
void  DoItemArquivo(int conn);*/
bool ReadQuiz();
bool ReadCuboQuiz();
BOOL PutItemArea(STRUCT_ITEM *item, int x1, int y1, int x2, int y2);
void ReadDirectory();
//bool LoadCuboCoord();
//bool LoadCubo();
// External func

void ProcessImple(int conn, int level, char * str);
void ProcessImple2(int conn, int level, char* str);

//Externs

extern  int FREEEXP; 

extern int ServerDown;

extern int g_EmptyMob;

extern int ServerIndex;
extern int Sapphire;
extern int ServerGroup;
extern int GuildCounter;
extern bool TarantulaKilled;
extern bool MsgArea;
extern bool MsgArea2;
extern int ApostaPista;

extern AccountBanned BannedUser[MAX_USER];
extern STRUCT_USER  wUser[MAX_USER];
extern int ValidGuild ;
extern int WaterScrollPosition[3][10][2]; 

extern short weapon[32][9];

extern CPSock BillServerSocket;
extern char   BillServerAddress[32];
extern int	   BillServerPort;

extern HWND  hWndMain;
extern HMENU hMainMenu;
extern HFONT hFont;

extern FILE *fLogFile1;
//extern FILE *fChatLogFile;
//extern FILE *fItemLogFile;
//extern FILE *fReadDir;

extern std::unique_ptr<std::ofstream> fLogFile;
extern std::string fLogFile_Dir;

//extern std::unique_ptr<LogControl> g_pLogFileLog;

extern std::unique_ptr<LogControl> g_pChatLog;

extern std::unique_ptr<LogControl> g_phackLog;

extern std::unique_ptr<LogControl> g_pMobdropLog;

extern std::unique_ptr<LogControl> g_pCompositorLog;

extern std::unique_ptr<LogControl> g_pItemLog;

extern std::unique_ptr<LogControl> g_pItradeLog;

extern CPSock DBServerSocket;

extern CNPCGenerator mNPCGen;
extern CNPCSummon mSummon;

extern CUser pUser[MAX_USER];
extern CMob pMob[MAX_MOB];

extern STRUCT_TREASURE g_pTreasure[8];
extern STRUCT_ITEM LevelItem[4][4][400];

extern CItem pItem[MAX_ITEM];

extern unsigned int CurrentTime;
extern unsigned int LastSendTime;

extern int ItemDropControl[MAX_ITEMLIST];

extern int BillCounter;

extern int	g_Week;
extern int	g_Hour;

extern int LastLogDay;
extern int LastChatLogDay;
extern int LastItemLogDay;
extern int LastSystemLogDay;
extern int LastCompositorLogsDay;
extern int trade_itemLogsFileDay;
extern int fIMobDropLogFileDay;
extern int LasthackLogDay;
extern int maxNightmare;
extern int maxPortaoInfernal;

extern int ConfigReady;

///////////////////////////////////////
//Config for Event
//////////////////////////////////////
extern int evNotice;
extern int evStartIndex;
extern int evEndIndex;
extern int evCurrentIndex;
extern int evRate;
extern int evItem;
extern int evIndex;
extern int evOn;
extern int evDelete;
////////////////////////////////////

////////////////////////////////////
// New Server Stats
////////////////////////////////////

extern int EventStatus;
extern int DOUBLEMODE;
extern int AUTODOUBLE;
extern int GlobalExp;
extern int GTorreHour;
extern int GTorreStatus;
extern int RvRHour;
extern int RvRStatus;
extern int RvRBonus;
extern int BatalhaRealStatus;
extern int BatalhaRealHour;
extern int PistaStatus;
extern int EvolutionStatus;
extern int PesaStatus;
extern int PergaStatus;
extern int ExpBaseN[12];
extern int ExpBaseM[12];
extern int ExpCele[24];
extern int ArchDiv;
extern int CeleDiv;

////////////////////////////////////


extern int GTorreState;
extern int RvRState;
extern MSG_BattleReal p_BatalhaReal;

extern int CastleServer;

extern int NewbieEventServer;
extern int DUNGEONEVENT;
extern int DEADPOINT;
extern int StatSapphire;
extern int BRItem;

extern int BRHour;

extern int BILLING;
extern int CHARSELBILL;
extern int POTIONCOUNT;
extern int PARTYBONUS;
extern int GUILDBOARD;

extern int UserCount;
extern int SaveCount;
extern int ItemCount;

extern int ForceWeather;

extern int WeekMode;
extern int ForceWeekMode;
extern int GuildDay;
extern int GuildHour;

extern int NumGuildBattle;
extern int PotionReady;
extern int PotionDelay;
extern int NewbieHour;

extern int AltarSta;
extern int RvRBluePoint;
extern int RvRRedPoint;

extern int NumServerInGroup;

extern int LiveTower[3];

extern int pChallangerMoney[6];

extern unsigned short g_pGuildWar[65536];
extern unsigned short g_pGuildAlly[65536];

extern unsigned short pMobGrid[MAX_GRIDY][MAX_GRIDX];
extern unsigned short pItemGrid[MAX_GRIDY][MAX_GRIDX];
extern char pHeightGrid[MAX_GRIDY][MAX_GRIDX];

extern unsigned char LocalIP[4];

extern char FailAccount[16][16];

extern CPSock ListenSocket;
extern unsigned int pAdminIP[MAX_ADMIN];

extern char DBServerAddress[32];
extern int DBServerPort;
extern QuizInfo SendQuiz[1000];
extern char QuizLineCounter;
extern MSG_Quiz QuizList[50];

extern MSG_BigQuiz CuboList[50];
extern char CuboQuizLine;

extern int CurrentWeather;
extern int TESTSERVER;
extern int LOCALSERVER;

extern int TransperCharacter;

extern int WTowerState;
extern unsigned int SecCounter;
extern unsigned int MinCounter;

extern int GuildImpostoID[MAX_GUILDZONE];

extern int BrState;
extern int BrMod;
extern int BrGrid;

extern int CastleState;

extern int ColoLevelN;
extern int ColoLevelM;
extern int ColoLevelA;
extern int ColoStateN;
extern int ColoStateM;
extern int ColoStateA;
extern int ColoHourN;
extern int ColoHourM; //coliseu
extern int ColoHourA; //coliseu
extern int KefraLive;
extern int EspelhoLive;
extern int RandBoss;
extern int Lich_1;
extern int Lich_2;
extern int Lich_3;
extern int Lich_4;
extern char KefraKiller[32];

extern int g_dLevel;
extern int g_dLevel1;
extern int g_dLevel2;

extern int Kingdom1Clear;
extern int Kingdom2Clear;
extern int PARTY_DIF;
extern int FreyjaGoldAposta;
extern int isDropItem;
extern int isHardCore; 

///////////////////////////////////////
//Config for Duel: 1:1 5:5 10:10 All:All
//////////////////////////////////////
extern char nRanking1[32];
extern char nRanking2[32];
extern char nTitle1[32];
extern char nTitle2[32];

extern int RankingProgress;
extern int Ranking1;
extern int Ranking2;
extern int lTitle1;
extern int lTitle2;
extern int RankingTime;

extern int Ranking1X;
extern int Ranking1Y;
extern int Ranking2X;
extern int Ranking2Y;

extern int cRanking1X;
extern int cRanking1Y;
extern int cRanking2X;
extern int cRanking2Y;

extern int kRanking1X;
extern int kRanking1Y;
extern int kRanking2X;
extern int kRanking2Y;

extern char temp[4096];
extern char logQuery[256];

extern int TaxChanged[MAX_GUILDZONE];


//////////////////////////////////////

extern int WaterClear1[3][10];
extern int PartyPesa[3];
extern int PartyPortao[3];
extern int PesaNPosStandard[13][2];
extern int PesaMPosStandard[13][2];
extern int PesaAPosStandard[13][2];
extern int CartaPos[4][2];
extern int PistaPos[7][3][2];
extern int TarantulaPos[2][2][2];
extern int CTarantulaPos[4][2];
extern int CartaTime;
extern int CartaSala;

extern STRUCT_PISTA Pista[7];
extern STRUCT_PVP Desafio[1];
extern STRUCT_QUESTS g_quests;
extern STRUCT_MERC pMobMerc[MAX_MOB_MERC];

extern int PistaRune[7][10];
extern int PistaBalrogPos[5][2];
extern int PistaBalrogPortalPos[5][5][2]; 


extern int GTorreGuild;

extern int GTorrePoints[10];
extern int GTorreGuildID[10];

extern std::vector<TMP_BLOCKIP> g_pBlockIP;

extern int GShopItens[30][2];
extern int GuildPoints[100][2];

extern int EvItemId[5][4];
extern int EvItemQt[5][4];

extern int EvItemId2[5][4];
extern int EvItemQt2[5][4];

extern char ACCOUNT_DIRECTORY[MESSAGECHAT_LENGTH];


/// MERCADO

extern int pOriRest;
extern int pLacRest;
extern int pOriPounder;
extern int pLacPounder;
extern int pSabio;
extern int pDiamante;
extern int pEsmeralda;
extern int pCoral;
extern int pGarnet;
extern int pBarraDn;
extern int pBarraMg;
extern int pBarraAc;
extern int pBarraCr;
extern int pClasseD;
extern int pClasseE;
extern int pLuz;
extern int pUnk;
extern int pUnk2;
extern int pUnk3;
extern int pUnk4;

// Ranking In Game
extern char RankName[50][16];
extern int RankLevel[50];
extern char RankClasse[50][4];
extern char RankClass[50][4];

//DROPLIST

extern int dListItem[170][64];
extern char dListMobName[170][16];

/////////////////////////////////////
//Externs

static const INT16 MountCheck[7][4] =
{
	{
		2363, 2364, 2365, 0
	},
	{
		2367, 2368, 2372, 2373
	},
	{
		2369, 2370, 2374, 2375
	},
	{
		2376, 2377, 2378, 0
	},
	{
		2381, 2382, 2383, 0
	},
	{
		2384, 2385, 2386, 0
	},
	{
		2379, 2380, 2387, 2388
	}
};

static const INT16 MountCheck2[7][4] =
{
	{
		2333, 2334, 2335, 0
	},
	{
		2337, 2338, 2342, 2343
	},
	{
		2339, 2340, 2344, 2345
	},
	{
		2346, 2347, 2348, 0
	},
	{
		2351, 2352, 2353, 0
	},
	{
		2354, 2355, 2356, 0
	},
	{
		2349, 2350, 2357, 2358
	}
};

inline void CreateConsole(char* Titulo)
{
	//Fixed bug printf vs 15 - 17
	//By seitbnao
	char Temp[256];
	AllocConsole();
	sprintf_s(Temp, "%s", Titulo);
#ifdef _DEBUG
	sprintf_s(Temp, "[DEBUG] - %s", Titulo);
#endif // _DEBUG

#ifdef __RELEASE
	sprintf_s(Temp, "[RELEASE] - %s", Titulo);
#endif // __RELEASE

	SetConsoleTitleA(Temp);
	typedef struct
	{
		char* _ptr;
		int _cnt;
		char* _base;
		int _flag;
		int _file;
		int _charbuf;
		int _bufsiz;
		char* _tmpfname;
	} FILE_COMPLETE;
	*(FILE_COMPLETE*)stdout = *(FILE_COMPLETE*)_fdopen(_open_osfhandle((long)GetStdHandle(STD_OUTPUT_HANDLE), _O_TEXT), "w");
	*(FILE_COMPLETE*)stderr = *(FILE_COMPLETE*)_fdopen(_open_osfhandle((long)GetStdHandle(STD_ERROR_HANDLE), _O_TEXT), "w");
	*(FILE_COMPLETE*)stdin = *(FILE_COMPLETE*)_fdopen(_open_osfhandle((long)GetStdHandle(STD_INPUT_HANDLE), _O_TEXT), "r");
	setvbuf(stdout, NULL, _IONBF, 0);
	setvbuf(stderr, NULL, _IONBF, 0);
	setvbuf(stdin, NULL, _IONBF, 0);
	setlocale(LC_ALL, "Portuguese");
}
static unsigned char ref[11] = { 43, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125 };

extern STRUCT_GUILDZONE g_pGuildZone[MAX_GUILDZONE];
#endif

# -------------------- ServerConfig.cpp --------------------

#pragma once

#include "ProcessClientMessage.h"
#include <iostream>
#include <cstdlib>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <random>
#include <ctime>
#include "SendFunc.h"
#include "Functions.h"
#include "wMySQL.h"

void ReadServerConfigs()
{
	auto& pc = cSQL::instance();

	sprintf(hQuery, "SELECT * FROM `serverconfig` WHERE `id` = '%d'", 1);
	MYSQL_ROW row;
	MYSQL* wSQL = pc.wStart();
	MYSQL_RES* result = pc.wRes(wSQL, hQuery);

	if (result == NULL)
		return;

	while ((row = mysql_fetch_row(result)) != NULL)
	{
		EventStatus = atoi(row[1]);
		DOUBLEMODE = atoi(row[2]);
		AUTODOUBLE = atoi(row[3]);
		GlobalExp = atoi(row[4]);
		GTorreHour = atoi(row[5]);
		GTorreStatus = atoi(row[6]);
		RvRHour = atoi(row[7]);
		RvRStatus = atoi(row[8]);
		RvRBonus = atoi(row[9]);
		BatalhaRealStatus = atoi(row[10]);
		BatalhaRealHour = atoi(row[11]);
		PistaStatus = atoi(row[12]);
		EvolutionStatus = atoi(row[13]);
		PesaStatus = atoi(row[14]);
		PergaStatus = atoi(row[15]);
	}
}

void ReadExpTableN() {
	auto& pc = cSQL::instance();

	sprintf(hQuery, "SELECT * FROM `expbase` WHERE `id` = '%d'", 1);
	MYSQL_ROW row;
	MYSQL* wSQL = pc.wStart();
	MYSQL_RES* result = pc.wRes(wSQL, hQuery);

	if (result == NULL)
		return;
		
	while ((row = mysql_fetch_row(result)) != NULL)
	{
		ExpBaseN[0] = atoi(row[1]);
		ExpBaseN[1] = atoi(row[2]);
		ExpBaseN[2] = atoi(row[3]);
		ExpBaseN[3] = atoi(row[4]);
		ExpBaseN[4] = atoi(row[5]);
		ExpBaseN[5] = atoi(row[6]);
		ExpBaseN[6] = atoi(row[7]);
		ExpBaseN[7] = atoi(row[8]);
		ExpBaseN[8] = atoi(row[9]);
		ExpBaseN[9] = atoi(row[10]);
		ExpBaseN[10] = atoi(row[11]);
		ExpBaseN[11] = atoi(row[12]);
	}
}
void ReadExpTableM() {
	auto& pc = cSQL::instance();

	sprintf(hQuery, "SELECT * FROM `expbase` WHERE `id` = '%d'", 2);
	MYSQL_ROW row;
	MYSQL* wSQL = pc.wStart();
	MYSQL_RES* result = pc.wRes(wSQL, hQuery);

	if (result == NULL)
		return;

	while ((row = mysql_fetch_row(result)) != NULL)
	{
		ExpBaseM[0] = atoi(row[1]);
		ExpBaseM[1] = atoi(row[2]);
		ExpBaseM[2] = atoi(row[3]);
		ExpBaseM[3] = atoi(row[4]);
		ExpBaseM[4] = atoi(row[5]);
		ExpBaseM[5] = atoi(row[6]);
		ExpBaseM[6] = atoi(row[7]);
		ExpBaseM[7] = atoi(row[8]);
		ExpBaseM[8] = atoi(row[9]);
		ExpBaseM[9] = atoi(row[10]);
		ExpBaseM[10] = atoi(row[11]);
		ExpBaseM[11] = atoi(row[12]);
	}
}

# -------------------- tMontarias.cpp --------------------

#pragma once

#include "ProcessClientMessage.h"
#include <iostream>
#include <cstdlib>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <random>
#include <ctime>
#include "SendFunc.h"
#include "Functions.h"
#include "wMySQL.h"

void attMountTraje(int conn, char* pMsg) {

	if (conn <= 0 || conn >= MAX_USER)
		return;

	if (pUser[conn].Mode != USER_PLAY)
		return;

	if (pUser[conn].cSock.Sock == 0)
		return;

	MSG_SendTraje* m = (MSG_SendTraje*)pMsg;

	int Size = m->Size;

	if (Size > sizeof(MSG_SendTraje)) //CONTROLE DE SIZE
	{
		SendClientMessage(conn, "Impossível executar ação, tente mais tarde.");
		return;
	}

	if (m->Tipo < 0 || m->Tipo > 255)
		return;

	int Type = m->Tipo;
	

	STRUCT_ITEM* dest = &pMob[conn].MOB.Equip[14];

	dest->sIndex = pMob[conn].MOB.Equip[14].sIndex;
	dest->stEffect[0].cEffect = pMob[conn].MOB.Equip[14].stEffect[0].cEffect;
	dest->stEffect[0].cValue = pMob[conn].MOB.Equip[14].stEffect[0].cValue;
	dest->stEffect[1].cEffect = pMob[conn].MOB.Equip[14].stEffect[1].cEffect;
	dest->stEffect[1].cValue = pMob[conn].MOB.Equip[14].stEffect[1].cValue;
	dest->stEffect[2].cEffect = pMob[conn].MOB.Equip[14].stEffect[2].cEffect;
	dest->stEffect[2].cValue = pMob[conn].MOB.Equip[14].stEffect[2].cValue;

	for (int i = 1; i < 16; i++) {
		if (pUser[conn].Keys[i] == Type) {
			dest->stEffect[2].cValue = Type;
			SendItem(conn, ITEM_PLACE_EQUIP, 14, dest);
			SendEquip(conn, conn);
		}
	}
	return;
}

void RemoveMountTraje(int conn) {
	pUser[conn].Keys[16] = 0;
	return;
}

void RequestTraje(int conn) {
	if (conn <= 0 || conn >= MAX_USER)
		return;

	if (pUser[conn].Mode != USER_PLAY)
		return;

	if (pUser[conn].cSock.Sock == 0)
		return;

	MSG_SendTraje sm;
	memset(&sm, 0, sizeof(MSG_SendTraje));

	sm.Type = _MSG_SendTraje;
	sm.Size = sizeof(MSG_SendTraje);
	sm.ID = conn;
	sm.Tipo = 1;

	int Size = sm.Size;

	if (Size > sizeof(MSG_SendTraje))
	{
		sm.Size = 0;
		return;
	}

	if (!pUser[conn].cSock.AddMessage((char*)&sm, sizeof(MSG_SendTraje)))
		CloseUser(conn);
}

bool MountTrajeBuy(int conn, int Index) {
	int Traje = 4000 - Index;
	
	for (int i = 1; i < 16; i++) {
		if (pUser[conn].Keys[i] == 0) {
			pUser[conn].Keys[i] = Traje;
			return true;
		}
		if (i == 15 && pUser[conn].Keys[i] != 0) {
			SendClientMessage(conn, "Não há slots de trajes disponíveis");
			return false;
		}
	}
}

# -------------------- wMySQL.cpp --------------------

#include "ProcessClientMessage.h"
#include "wMySQL.h"

HANDLE hThread;
HANDLE ThreadLog;

unsigned long iID;
int contador = 0;

char xQuery[1000];
char mQuery[1000];
char hQuery[1000];
char xMsg[1000];
char xRow[400];
char xMAC[400];
char xIP[400];
char* xPass;

unsigned long lID;

MYSQL* cSQL::wStart()
{
	MYSQL* wSQL = mysql_init(NULL);

	try
	{
		my_bool reconnect = 1;
		mysql_options(wSQL, MYSQL_OPT_RECONNECT, &reconnect);
		mysql_options(wSQL, MYSQL_OPT_COMPRESS, 0);
		mysql_options(wSQL, MYSQL_OPT_CONNECT_TIMEOUT, "300");

		if (!mysql_real_connect(wSQL, HOST, USER, PASS, DB, PORT, NULL, 0))
		{
			printf("[wMySQL][TMSVR] Ocorreu um erro na conexão.\n\t\tErro: %s\n", mysql_error(wSQL));
			return wSQL;
		}

		return wSQL;
	}
	catch (...)
	{
		return wSQL;
	}
}

MYSQL_RES *cSQL::wRes(MYSQL *sql, char* query)
{
	try {
		if (mysql_query(sql, query))
		{
			printf("[wMySQL][wRes] Erro na execução da wRes.\nQuery: %s\n\t\tErro: %s\n", query, mysql_error(sql));
			mysql_close(sql);
			return NULL;
		}

		MYSQL_RES* result = mysql_store_result(sql);

		mysql_close(sql);

		if (result)
			return result;

		return NULL;
	}
	catch (...)
	{
		return NULL;
	}
}

void cSQL::wLog(char* acc, char* pers, char* mensagem, char* type)
{

	time_t rawtime;
	struct tm * timeinfo;

	time(&rawtime);
	timeinfo = localtime(&rawtime);

	sprintf(logQuery, "INSERT INTO `log` (`ID`, `Conta`, `Char`, `Mensagem`, `Data`, `Tipo`) VALUES(NULL, '%s', '%s', '%s', '%d/%d/%d %d:%d:%d', '%s')", acc, pers, mensagem, timeinfo->tm_mday, (timeinfo->tm_mon + 1), (timeinfo->tm_year + 1900), timeinfo->tm_hour, timeinfo->tm_min, timeinfo->tm_sec, type);
	////ThreadLog = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)wQuery, (void*)logQuery, 0, &lID);
	//cSQL::wQuery(xQuery);

	auto& pc = cSQL::instance();

	MYSQL* wSQL = pc.wStart();

	if (mysql_query(wSQL, logQuery))
	{
		printf("[wMySQL][Log] Erro na execução da wQuery.\n\t\tErro: %s\n", mysql_error(wSQL));
		mysql_close(wSQL);
		//ExitThread(0);
		return;
	}

	mysql_close(wSQL);

	printf("[%02d/%02d/%d][%02d:%02d:%02d][%s - %s] %s\n", timeinfo->tm_mday, (timeinfo->tm_mon + 1), (timeinfo->tm_year + 1900), timeinfo->tm_hour, timeinfo->tm_min, timeinfo->tm_sec, acc, pers, mensagem);
	return;
}

/// Executes a query.
bool cSQL::wQuery(char* query)
{
	try
	{
		auto& pc = cSQL::instance();

		MYSQL* wSQL = pc.wStart();

		if (mysql_query(wSQL, query))
		{
			printf("[wMySQL][wQuery] Erro na execução da wQuery.\n\t\tErro: %s\n", mysql_error(wSQL));
			mysql_close(wSQL);
			//ExitThread(0);
			return FALSE;
		}

		mysql_close(wSQL);
		//ExitThread(0);
		return TRUE;
	}
	catch (...)
	{
		return FALSE;
	}
}



int cSQL::Cont(char* query)
{
	int res = 0;
	auto& cnt = cSQL::instance();

	MYSQL* wSQL = cnt.wStart();
	MYSQL_RES* result = cnt.wRes(wSQL, query);

	if (result == NULL)
	{
		printf("[wMySQL][wInfo]: Ocorreu um erro ao retornar Dados.\n");
		//mysql_free_result(sq.result);
		//mysql_close(sq.wSQL);
		return res;
	}


	res= (int)mysql_num_rows(result);

	mysql_free_result(result);
	mysql_close(wSQL);
	return res;
}

int cSQL::iInfo(char* query)
{
	int res = 0;
	MYSQL_ROW row;

	auto& cnt = cSQL::instance();

	MYSQL* wSQL = cnt.wStart();
	MYSQL_RES* result = cnt.wRes(wSQL, query);

	if (result == NULL)
	{
		printf("[wMySQL][wInfo]: Ocorreu um erro ao retornar Dados.\n");
		//mysql_free_result(sq.result);
		//mysql_close(sq.wSQL);
		return res;
	}

	while ((row = mysql_fetch_row(result)) != NULL)
		res = atoi(row[0]);

	mysql_free_result(result);
	mysql_close(wSQL);
	return res;
}


long long cSQL::lInfo(char* query)
{
	long long res = 0;
	MYSQL_ROW row;

	auto& cnt = cSQL::instance();

	MYSQL* wSQL = cnt.wStart();
	MYSQL_RES* result = cnt.wRes(wSQL, query);

	if (result == NULL)
	{
		printf("[wMySQL][wInfo]: Ocorreu um erro ao retornar Dados.\n");
		//mysql_free_result(sq.result);
		//mysql_close(sq.wSQL);
		return res;
	}


	while ((row = mysql_fetch_row(result)) != NULL)
		res = atoll(row[0]);

	mysql_free_result(result);
	mysql_close(wSQL);
	return res;
}

char *cSQL::wInfo(char* query)
{

	MYSQL_ROW row;

	auto& cnt = cSQL::instance();

	MYSQL* wSQL = cnt.wStart();
	MYSQL_RES* result = cnt.wRes(wSQL, query);

	if (result == NULL)
	{
		printf("[wMySQL][wInfo]: Ocorreu um erro ao retornar Dados.\n");
		//mysql_free_result(sq.result);
		//mysql_close(sq.wSQL);
		return "0";
	}

	char res[1000];
	memset(res, 0, sizeof(char));

	while ((row = mysql_fetch_row(result)) != NULL)
		strcpy(res, row[0]);

	mysql_free_result(result);
	mysql_close(wSQL);
	return res;

}


uint32_t convert(const char* name)
{
	uint32_t val = uint32_t(name[3])
		+ (uint32_t(name[2]) << 8)
		+ (uint32_t(name[1]) << 16)
		+ (uint32_t(name[0]) << 24);
	return val;
}

# -------------------- wMySQL.h --------------------

﻿#include <mysql.h>
#include <stdint.h>
#pragma comment(lib, "libmysql.lib")
#include "../../Code/DBSRV/singleton.h"

#define HOST "127.0.0.1"
#define USER "root"
#define PASS "123456"
#define PORT 3306
#define DB "wydsite"

extern int contador;

extern char xQuery[1000];
extern char mQuery[1000];
extern char hQuery[1000];
extern char xMsg[1000];
extern char xRow[400];
extern char xMAC[400];
extern char xIP[400];
extern char* xPass;

class cSQL : public Singleton<cSQL>
{
protected:
	friend class Singleton<cSQL>;
	cSQL() {}
	virtual ~cSQL() {}
	cSQL(const cSQL&) = delete;
	cSQL& operator=(const cSQL&) = delete;
public:

	static MYSQL *wStart();
	static MYSQL_RES *wRes(MYSQL*sql, char* query);

	static bool wQuery(char* query);
	static char *wInfo(char* query);
	static int iInfo(char* query);
	static int Cont(char* query);
	static void wLog(char* acc, char* pers, char* mensagem, char* type);

	static long long lInfo(char* query);


};




uint32_t convert(const char* name);

# -------------------- _MSG_AcceptParty.cpp --------------------

/*
*   Copyright (C) {2015}  {Victor Klafke, Charles TheHouse}
*
*   This program is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program.  If not, see [http://www.gnu.org/licenses/].
*
*   Contact at: victor.klafke@ecomp.ufsm.br
*/
#include "ProcessClientMessage.h"

void Exec_MSG_AcceptParty(int conn, char *pMsg)
{
	MSG_AcceptParty *m = (MSG_AcceptParty*)pMsg;

	int Size = m->Size;

	if (Size > sizeof(MSG_AcceptParty)) //CONTROLE DE SIZE
	{
		SendClientMessage(conn, "Impossível executar ação2, tente mais tarde.");
		return;
	}

	int myindex = conn;
	int leaderID = m->LeaderID;

	m->MobName[NAME_LENGTH - 1] = 0;

	if (leaderID <= 0 || leaderID >= MAX_USER)
	{
		//Log("err,CNFParty leader out of range", pUser[conn].AccountName, pUser[conn].IP);
		return;
	}

	if (m->Type == _MSG_AcceptParty && strcmp(pMob[leaderID].MOB.MobName, m->MobName))
	{
		SendClientMessage(conn, g_pMessageStringTable[_NN_Not_Connected]);
		return;
	}

	if (pUser[conn].Ingame.PartyPassword <= 0 || pUser[leaderID].Ingame.PartyPassword <= 0 && leaderID != pMob[myindex].LastReqParty)
	{
		//Log("err,CNFParty leader no send reqparty", pUser[conn].AccountName, pUser[conn].IP);
		CrackLog(conn, "PARTYHACK");
		return;
	}

	if (myindex <= 0 || myindex >= MAX_USER || myindex != conn)
	{
		//Log("err,CNFParty fol out of range", pUser[conn].AccountName, pUser[conn].IP);
		return;
	}
	if (pMob[leaderID].Leader)
	{
		SendClientMessage(conn, g_pMessageStringTable[_NN_Other_Partys_Member]);
		return;
	}

	if (pUser[leaderID].Mode != USER_PLAY)
	{
		SendClientMessage(conn, g_pMessageStringTable[_NN_Not_Connected]);
		return;
	}
	if (pMob[myindex].Leader)
	{
		SendClientMessage(conn, g_pMessageStringTable[_NN_Dropped_Current_Party_First]);
		return;
	}

	/*if (pUser[myindex].OnlyTrade)
	{
		SendClientMessage(myindex, g_pMessageStringTable[_NN_ONLYTRADE]);
		return;
	}

	if (pUser[leaderID].OnlyTrade)
	{
		SendClientMessage(leaderID, g_pMessageStringTable[_NN_ONLYTRADE]);
		return;
	}*/

	int i = 0;
	for (i = 0; i < MAX_PARTY; i++)
	{
		if (pMob[myindex].PartyList[i] == 0)
			continue;

		SendClientMessage(conn, g_pMessageStringTable[_NN_Dropped_Current_Party_First]);
		return;
	}

	int leaderLV =  pMob[leaderID].extra.ClassMaster == MORTAL || pMob[leaderID].extra.ClassMaster == ARCH ? pMob[leaderID].MOB.BaseScore.Level : pMob[leaderID].MOB.BaseScore.Level+MAX_CLEVEL+1;
	int myLV = pMob[conn].extra.ClassMaster == MORTAL || pMob[conn].extra.ClassMaster == ARCH ? pMob[conn].MOB.BaseScore.Level : pMob[conn].MOB.BaseScore.Level+MAX_CLEVEL;

	
	//if (myLV >= leaderLV - PARTY_DIF && myLV < leaderLV + PARTY_DIF || leaderLV >= 1000 || myLV >= 1000) //|| pMob[conn].extra.ClassMaster == pMob[leaderID].extra.ClassMaster)
	//{
	if (!BrState || conn >= MAX_USER || BRItem <= 0 || pMob[conn].TargetX < 2604
		|| pMob[conn].TargetY < 1708 || pMob[conn].TargetX > 2648 || pMob[conn].TargetY > 1744)
	{
		int slot = 0;
		for (i = 0; i < MAX_PARTY; i++)
		{
			if (pMob[leaderID].PartyList[i])
				slot++;
		}

		for (i = 0; i < MAX_PARTY && pMob[leaderID].PartyList[i]; i++);

		if (i == MAX_PARTY)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Partys_Full]);
			return;
		}

		pMob[leaderID].PartyList[i] = myindex;
		pMob[myindex].Leader = leaderID;
				
		i++;

		if (!slot)
			SendAddParty(leaderID, leaderID, 0);
				
		if (!slot)
			SendAddParty(myindex, myindex, i);
				
		SendAddParty(myindex, leaderID, 0);
		SendAddParty(leaderID, myindex, i);
				
		for (int j = 0; j < MAX_PARTY; j++)
		{
			int pt = pMob[leaderID].PartyList[j];

			if (pt)
			{
				if (pt != myindex)
					SendAddParty(myindex, pt, i);

				SendAddParty(pt, myindex, j + 1);
			}
		}

		//sprintf(temp, "accept_party,%s aceitou party de %s.", pMob[myindex].MOB.MobName, pMob[leaderID].MOB.MobName);
		//Log(temp, pUser[myindex].AccountName, pUser[myindex].IP);
	}
	//}
	//else
		//SendClientMessage(conn, g_pMessageStringTable[_NN_Party_Level_Limit]);
}

# -------------------- _MSG_AccountLogin.cpp --------------------


#include "ProcessClientMessage.h"
#include <regex>

void Exec_MSG_AccountLogin(int conn, char *pMsg)
{

	MSG_AccountLogin* m = (MSG_AccountLogin*)pMsg;

	if (m->Size > sizeof(MSG_AccountLogin))
	{
		CloseUser(conn);
		return;
	}

	m->Decode();

	m->AccountLogin[NAME_LENGTH - 1] = 0;
	m->AccountPassword[ACCOUNTPASS_LENGTH - 1] = 0;


	pUser[conn].AccountName[NAME_LENGTH - 1] = 0;


	if (conn <= 0 || (conn >= (MAX_USER - ADMIN_RESERV)))
	{
		SendClientMessage(conn, strFmt(g_pMessageStringTable[_NN_Reconnect]));

		pUser[conn].cSock.SendMessageA();

		CloseUser(conn);
		return;
	}

	std::string login = { m->AccountLogin };
	std::regex int_regex("^[A-Za-z0-9]{4,16}$");

	if (!std::regex_match(login, int_regex))
	{
		pUser[conn].cSock.SendMessageA();
		CloseUser(conn);
		return;
	}

	std::string password = { m->AccountPassword };
	std::regex int_regex2("^[A-Za-z0-9]{4,16}$");

	if (!std::regex_match(password, int_regex2))
	{
		pUser[conn].cSock.SendMessageA();
		CloseUser(conn);
		return;
	}

	std::string macaddress{ m->MacAddres };
	std::regex int_regex3("^[A-ZA-Z0-9:]{17,18}$");

	if (!std::regex_match(macaddress, int_regex3)) {
		pUser[conn].cSock.SendMessageA();
		CloseUser(conn);		
		return;
	}

	if (pUser[conn].Mode != USER_ACCEPT)
	{
		SendClientMessage(conn, "Login now, wait a moment.");
		CloseUser(conn);
		//CrackLog(conn, " accountlogin");
		//pUser[conn].cSock.SendMessageA();
		return;
	}

	if (Limitadordeconexoes(m->MacAddres) >= 5)
	{
		SendClientMessage(conn, "Limite de [5] conexões por máquina.");
		return;
	}

	/*     Copia o Mac      */
	memcpy(pUser[conn].MacAddress, m->MacAddres, sizeof(pUser[conn].MacAddress));

	/* até o presente momento estamos fazendo cliver manualmente atraves da define APP_VERSION , futuramente será sql. */
	if (m->Version > 6518 && m->Version != APP_VERSION) // ATT CLIENTE
	{
		SendClientMessage(conn, "Atualização disponível no Launcher! Atualize seu jogo para logar!");
		return;
	}

	/* Faz a leitura no txt se o mac estiver lá vai bloquear o acesso */
	/*int macBan = ReadMacList(pUser[conn].MacAddress);

	if (macBan == TRUE)
	{
		SendClientMessage(conn, "Você foi impedido de acessar esse servidor.");
		return;
	}*/

	time_t rawnow = time(NULL);
	struct tm* now = localtime(&rawnow);

	auto min = now->tm_min;
	auto sec = now->tm_sec;
	auto hour = now->tm_hour;

	FILE* fs = nullptr;
	fs = fopen(strFmt("Ban/%s.bin", m->AccountLogin), "rb");

	if (fs)
	{
		fread(&BannedUser[conn], 1, sizeof(AccountBanned), fs);
		fclose(fs);
		memcpy(&BannedUser[conn], &BannedUser[conn], sizeof(AccountBanned));
		auto account = &BannedUser[conn];
		auto mac = &BannedUser[conn];

		if (account->Permanente == TRUE)
		{
			SendClientMessage(conn, "Conta permanentemente. Entre em contato com o suporte para mais informações.");
			pUser[conn].cSock.SendMessageA();
			return;
		}


		if (account->Analyze == TRUE)
		{
			SendClientMessage(conn, "Estamos analizando a sua conta. Entre em contato com o suporte.");
			pUser[conn].cSock.SendMessageA();
			return;
		}

		if (now->tm_mon < account->mes || now->tm_mon == account->mes &&
			now->tm_mday < account->dia || now->tm_mon == account->mes &&
			now->tm_mday == account->dia && now->tm_hour < account->hora ||
			now->tm_mon == account->mes && now->tm_mday == account->dia &&
			now->tm_hour == account->hora && now->tm_min < account->min)
		{
			SendClientMessage(conn, strFmt("Conta bloqueada até as: [%02d:%02d] de [%02d/%02d/%04d] ", account->hora, account->min, account->dia, account->mes + 1, account->ano + 1900));
			pUser[conn].cSock.SendMessageA();
			return;
		}
		remove(strFmt("Ban/%s.bin", m->AccountLogin));
	}

	m->Type = _MSG_DBAccountLogin;
	m->ID = conn;

	sscanf(m->AccountLogin, "%s", pUser[conn].AccountName);

	_strupr(pUser[conn].AccountName);

	strncpy(m->AccountLogin, pUser[conn].AccountName, NAME_LENGTH);

	int check = CheckFailAccount(m->AccountLogin);

	if (check >= 3)
	{
		SendClientMessage(conn, g_pMessageStringTable[_NN_3_Tims_Wrong_Pass]);

		pUser[conn].cSock.SendMessageA();
		return;
	}

	DBServerSocket.SendOneMessage((char*)m, sizeof(MSG_AccountLogin));

	pUser[conn].Mode = USER_LOGIN;
	pMob[conn].Mode = MOB_EMPTY;
}

# -------------------- _MSG_AccountSecure.cpp --------------------

/*
*   Copyright (C) {2015}  {Victor Klafke, Charles TheHouse}
*
*   This program is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program.  If not, see [http://www.gnu.org/licenses/].
*
*   Contact at: victor.klafke@ecomp.ufsm.br
*/
#include "ProcessClientMessage.h"

void Exec_MSG_AccountSecure(int conn, char *pMsg)
{
	MSG_AccountSecure* m = (MSG_AccountSecure*)pMsg;

	if (m->Size > sizeof(MSG_AccountSecure))
		return;

	if (pUser[conn].Mode != USER_SELCHAR && pUser[conn].Mode != USER_CHARWAIT || pUser[conn].Mode == USER_WAITDB)
		return;

	if (conn <= 0 || conn >= MAX_USER)
		return;

	m->ID = conn;

	pUser[conn].Mode = USER_WAITDB;

	DBServerSocket.SendOneMessage((char*)m, sizeof(MSG_AccountSecure));
}

# -------------------- _MSG_Action.cpp --------------------

/*
*   Copyright (C) {2015}  {Victor Klafke, Charles TheHouse}
*
*   This program is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program.  If not, see [http://www.gnu.org/licenses/].
*
*   Contact at: victor.klafke@ecomp.ufsm.br
*/
#include "ProcessClientMessage.h"

void Exec_MSG_Action(int conn, char *pMsg)
{
	MSG_Action* m = (MSG_Action*)pMsg;

	if (m->PosX <= 0 || m->PosX >= MAX_GRIDX)
		return;

	if (m->PosY <= 0 || m->PosY >= MAX_GRIDY)
		return;

	if (m->TargetX <= 0 || m->TargetX >= MAX_GRIDX)
		return;

	if (m->TargetY <= 0 || m->TargetY >= MAX_GRIDY)
		return;

	if (m->Effect < 0)
		return;

	if (m->Speed < 0)
		return;

	if (pUser[conn].Mode != USER_PLAY)
	{
		SendHpMode(conn);

		return;
	}

	if (pMob[conn].MOB.CurrentScore.Hp == 0)
	{
		SendHpMode(conn);

		AddCrackError(conn, 5, 3);
		return;	
	}

	if (pUser[conn].Trade.OpponentID)
	{
		RemoveTrade(pUser[conn].Trade.OpponentID);
		RemoveTrade(conn);
		return;
	}
	if (pUser[conn].TradeMode)
	{
		RemoveTrade(conn);
		return;
	}

	if((pMob[conn].TargetX/128) == 9 && (pMob[conn].TargetY/128) == 1 || (pMob[conn].TargetX/128) == 8 && (pMob[conn].TargetY/128) == 2 || (pMob[conn].TargetX/128) == 10 && (pMob[conn].TargetY/128) == 2)
	{
		if((pMob[conn].extra.ClassMaster == CELESTIAL || pMob[conn].extra.ClassMaster == CELESTIALCS || pMob[conn].extra.ClassMaster == SCELESTIAL) && pMob[conn].MOB.CurrentScore.Level >= 180)
		{
			DoRecall(conn);

			return;
		}
	} 
	if ((ColoStateN) >= 1 && (pMob[conn].TargetX) >= 2604 && (pMob[conn].TargetY) >= 1708 && (pMob[conn].TargetX) <= 2648 && (pMob[conn].TargetY) <= 1744)
	{
		if (pMob[conn].extra.ClassMaster == ARCH || pMob[conn].extra.ClassMaster == CELESTIAL || pMob[conn].extra.ClassMaster == CELESTIALCS || pMob[conn].extra.ClassMaster == SCELESTIAL)
		{
			DoRecall(conn);
			return;
		}
	}
	/*if ((ColoStateM) >= 1  && (pMob[conn].TargetX) >= 2604 && (pMob[conn].TargetY) >= 1708 && (pMob[conn].TargetX) <= 2648 && (pMob[conn].TargetY) <= 1744)
	{
		if (pMob[conn].extra.ClassMaster == MORTAL || pMob[conn].extra.ClassMaster == CELESTIAL || pMob[conn].extra.ClassMaster == CELESTIALCS || pMob[conn].extra.ClassMaster == SCELESTIAL)
		{
			DoRecall(conn);
			return;
		}
	} */
	/*if ((ColoStateA) >= 1 && (pMob[conn].TargetX) >= 2604 && (pMob[conn].TargetY) >= 1708 && (pMob[conn].TargetX) <= 2648 && (pMob[conn].TargetY) <= 1744)

	{
		if (pMob[conn].extra.ClassMaster == MORTAL || pMob[conn].extra.ClassMaster == ARCH)
		{
			DoRecall(conn);
			return;
		}
	}*/
	if (pMob[conn].MOB.Equip[0].sIndex == 358)
		return;

	int movetime = m->ClientTick;
	int checktime = 0;

	if (CurrentTime <= 0x1D4C0)
		checktime = 0;
	else
		checktime = CurrentTime - 120000;

	//Skill Ilusão
	if (m->Type == _MSG_Action3)
	{
		if (pMob[conn].MOB.Class != 3 || (pMob[conn].MOB.LearnedSkill & 2) == 0)
		{
			if (pMob[conn].MOB.CurrentScore.Level < MAX_LEVEL)
				if (AddCrackError(conn, 10, 28) == TRUE)
					return;
		}

		int mana = g_pSpell[73].ManaSpent;

		if (pMob[conn].MOB.CurrentScore.Mp < mana)
		{
			SendSetHpMp(conn);
			return;
		}

		pMob[conn].MOB.CurrentScore.Mp -= mana;
		pUser[conn].ReqMp -= mana;

		if (pUser[conn].LastActionTick != 235543242 && movetime < pUser[conn].LastIllusionTick + 900)
		{
			sprintf_s(temp, "err,illusion %d %d 900ms limit", movetime, pUser[conn].LastIllusionTick);

			//Log(temp, pUser[conn].AccountName, pUser[conn].IP);
			AddCrackError(conn, 1, 105);
			return;
		}
		if ((unsigned int)movetime > CurrentTime + 15000 || movetime < checktime)
		{
			sprintf_s(temp, "err,illusion %d %d 15000ms limit", movetime, CurrentTime);

			//Log(temp, pUser[conn].AccountName, pUser[conn].IP);
			//Log("err,illution faster than 15 sec - MSG_ACTION", pUser[conn].AccountName, pUser[conn].IP);

			AddCrackError(conn, 1, 104);
			return;
		}
		pUser[conn].LastIllusionTick = movetime;
	}

	else if (m->Type == _MSG_Action)
	{
		if (pUser[conn].LastActionTick != 235543242 && movetime < pUser[conn].LastIllusionTick + 900)
		{
			sprintf_s(temp, "err,illusion %d %d 900ms limit", movetime, pUser[conn].LastIllusionTick);

			//Log(temp, pUser[conn].AccountName, pUser[conn].IP);
			AddCrackError(conn, 1, 103);
			return;
		}
		if ((unsigned int)movetime > CurrentTime + 15000 || movetime < checktime)
		{
			sprintf_s(temp, "err,illusion %d %d 15000ms limit", movetime, CurrentTime);

			//Log(temp, pUser[conn].AccountName, pUser[conn].IP);
			//Log("err,illution faster than 15 sec - MSG_ACTION", pUser[conn].AccountName, pUser[conn].IP);

			AddCrackError(conn, 1, 102);
			return;
		}
		pUser[conn].LastIllusionTick = movetime;
	}

	else if (m->Type == _MSG_Action2)
	{
		if (pUser[conn].LastMove == _MSG_Action2)
		{
			//Log("err,can't send MSG_Stop continuously", pUser[conn].AccountName, pUser[conn].IP);
			AddCrackError(conn, 1, 101);

			return;
		}
	}

	if (m->Speed > (pMob[conn].MOB.CurrentScore.AttackRun & 0xF))
	{
		AddCrackError(conn, 5, 4);

		//sprintf(temp, "etc,diffrent movement. %d-%d", m->Speed, pMob[conn].MOB.CurrentScore.AttackRun);
		//Log(temp, pUser[conn].AccountName, pUser[conn].IP);

		m->Speed = pMob[conn].MOB.CurrentScore.AttackRun & 0xF;
	}

	int posx = pMob[conn].TargetX;
	int posy = pMob[conn].TargetY;
		
	if (/*m->Effect != 1 && m->Effect != 2 && */(m->TargetX < posx - VIEWGRIDX || m->TargetX  > posx + VIEWGRIDX || m->TargetY < posy - VIEWGRIDY || m->TargetY > posy + VIEWGRIDY))
	{
		if (m->TargetX < posx - VIEWGRIDX * 2 || m->TargetX > posx + VIEWGRIDX * 2 || m->TargetY < posy - VIEWGRIDY * 2 || m->TargetY > posy + VIEWGRIDY * 2)
		{
			MSG_Action sm_action;
			memset(&sm_action, 0, sizeof(MSG_Action));

			GetAction(conn, posx, posy, (MSG_Action*)&sm_action);
			sm_action.Type = _MSG_Action3;
			sm_action.Speed = 6;

			pUser[conn].cSock.SendOneMessage((char*)&sm_action, sizeof(MSG_Action));
		}
		AddCrackError(conn, 1, 5);
		return;
	}

	// pista +2 retirar player do centro do boss
	/*if (m->TargetX >= 3378 && m->TargetX <= 3398 && m->TargetY >= 1427 && m->TargetY <= 1448)
	{
		int partyleader = pMob[conn].Leader;

		if (partyleader <= 0)
			partyleader = conn;

		if(partyleader != conn || conn != Pista[2].Party[0].LeaderID && conn != Pista[2].Party[1].LeaderID && conn != Pista[2].Party[2].LeaderID)
		{
			int rd = rand()%3;
			DoTeleport(conn, PistaPos[2][rd][0], PistaPos[2][rd][1]);
			return;
		}
	}*/
		
	if (m->TargetX <= 0 || m->TargetX >= 4096 || m->TargetY <= 0 || m->TargetY >= 4096)
	{
		//Log("err,action - viewgrid", pMob[conn].MOB.MobName, pUser[conn].IP);
		return;
	}

	/*if(pUser[conn].OnlyTrade)
	{
		int Village = BASE_GetVillage(m->TargetX, m->TargetY);
		unsigned char mapAttribute = GetAttribute(m->TargetX, m->TargetY) & 0x80;

		if ((Village < 0 || Village >= 5) && mapAttribute == 0)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_OnlyVillage]);
			DoRecall(conn);
			return;
		}
	}*/

	if (m->TargetX != pMob[conn].TargetX || m->TargetY != pMob[conn].TargetY)
	{
		unsigned char mapAttribute = GetAttribute(m->TargetX, m->TargetY);

		if (mapAttribute & 0x80 && (pMob[conn].MOB.CurrentScore.Level >= FREEEXP && pMob[conn].MOB.CurrentScore.Level <= 999 || pMob[conn].extra.ClassMaster != MORTAL))
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Newbie_zone]);

			DoRecall(conn);
			return;
		}

		if (mapAttribute & 0x20)
		{
			if (pMob[conn].MOB.CurrentScore.Level <= MAX_LEVEL)
			{
				int Zone = BASE_GetGuild(m->TargetX, m->TargetY);

				if (Zone >= 0 && Zone < MAX_GUILDZONE && pMob[conn].MOB.Guild != g_pGuildZone[Zone].ChargeGuild)
				{
					SendClientMessage(conn, g_pMessageStringTable[_NN_Only_Guild_Members]);
					DoRecall(conn);
					return;
				}
			}
		}
		
		CCastleZakum::CheckMove(conn, m->TargetX, m->TargetY);

		pUser[conn].LastMove = m->Type;

		pMob[conn].LastSpeed = 0;

		strncpy(pMob[conn].Route, m->Route, MAX_ROUTE);

		if (pMobGrid[m->TargetY][m->TargetX] && pMobGrid[m->TargetY][m->TargetX] != conn)
		{
			int destx = m->TargetX;
			int desty = m->TargetY;

			int len = strlen(m->Route);

			int i = 0;

			GetEmptyMobGrid(conn, &destx, &desty);

			for (i = len; i >= 0; i--)
			{
				if (pMobGrid[desty][destx] && pMobGrid[desty][destx] != conn)
					continue;

				BASE_GetRoute(m->PosX, m->PosY, &destx, &desty, m->Route, i, (char*)pHeightGrid);
			}

			if (i == -1)
			{
				m->TargetX = destx;
				m->TargetY = desty;

				m->Effect = 0;

				pUser[conn].cSock.SendOneMessage((char*)m, sizeof(m));
				return;
			}
			m->TargetX = destx;
			m->TargetY = desty;

			int Size = m->Size;

			if (Size > sizeof(MSG_Action))
			{
				m->Size = 0;
				return;
			}

			if (!pUser[conn].cSock.AddMessage((char*)m, sizeof(m)))
				CloseUser(conn);
		}

		memcpy(pMob[conn].Route, m->Route, MAX_ROUTE);

		GridMulticast(conn, m->TargetX, m->TargetY, (MSG_STANDARD*)pMsg);
			
		if (m->Type == _MSG_Action3)
		{
			pUser[conn].cSock.SendOneMessage((char*)m, sizeof(MSG_Action));
			SendSetHpMp(conn);
		}


		int len = strlen(pMob[conn].Route);
		unsigned char Unk = 0;

		if (len > 0 && len < MAX_ROUTE-3)
		{
			Unk = pMob[conn].Route[len] + 3;
			Unk = Unk - 48;

			if (Unk < 1 || Unk > 9)
				Unk = 0;
			else
				Unk = 16 * Unk;
		}

		pMob[conn].MOB.CurrentScore.Merchant = pMob[conn].MOB.CurrentScore.Merchant | Unk & 0xF0;
		pMob[conn].MOB.BaseScore.Merchant = pMob[conn].MOB.CurrentScore.Merchant;

		//if (BrState && BRItem > 0)
		//{
		//	int tx = pMob[conn].TargetX;
		//	int ty = pMob[conn].TargetY;

		//	int lvl = pMob[conn].MOB.CurrentScore.Level;

		//	if (tx >= 2604 && ty >= 1708 && tx <= 2648 && ty <= 1744)
		//	{
		//		if (!BrGrid && lvl >= 100 && lvl < 1000)
		//			DoRecall(conn);

		//		if (BrGrid == 1 && lvl >= 200 && lvl < 1000)
		//			DoRecall(conn);
		//	}
		//}


 	}

}

# -------------------- _MSG_ApostaFreyja.cpp --------------------

#include "ProcessClientMessage.h" 


void Exec_MSG_onPaymentGold(int conn, char* pMsg)
{
	MSG_FreyjaAposta* p = (MSG_FreyjaAposta*)pMsg;

	auto mob = GetMobFromIndex(conn);
	int level = -1; 

	if (mob->TargetX >= 3332 && mob->TargetY >= 1471 && mob->TargetX <= 3449 && mob->TargetY <= 1529)
	{ 
		SendClientMessage(conn, "Essa função esta em manutenção.");
		return;
	}
}

# -------------------- _MSG_ApplyBonus.cpp --------------------

/*
*   Copyright (C) {2015}  {Victor Klafke, Charles TheHouse}
*
*   This program is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program.  If not, see [http://www.gnu.org/licenses/].
*
*   Contact at: victor.klafke@ecomp.ufsm.br
*/
#include "ProcessClientMessage.h"

void Exec_MSG_ApplyBonus(int conn, char *pMsg)
{
	MSG_ApplyBonus* m = (MSG_ApplyBonus*)pMsg;

	if (m->BonusType < 0 || m->BonusType > 2)
		return;

	if (m->Detail < 0)
		return;

	if (pUser[conn].Mode != USER_PLAY)
		return;

	int Size = m->Size;

	if (Size > sizeof(MSG_ApplyBonus)) //CONTROLE DE SIZE
	{
		SendClientMessage(conn, "Impossível executar ação5, tente mais tarde. ");
		return;
	}

	if (pMob[conn].MOB.CurrentScore.Hp <= 0 || pUser[conn].Mode != USER_PLAY)
	{
		SendHpMode(conn);
		AddCrackError(conn, 10, 20);
		return;
	}

	if (m->BonusType == 0)
	{
		if (pMob[conn].MOB.ScoreBonus > 0)
		{
			if (m->Detail >= 0 && m->Detail <= 3)
			{
				int pontos = 1;

				if (pMob[conn].MOB.ScoreBonus >= 300)
					pontos = 100;

				pMob[conn].MOB.ScoreBonus -= pontos;

				if (m->Detail == 0)
					pMob[conn].MOB.BaseScore.Str += pontos;

				if (m->Detail == 1)
				{
					pMob[conn].MOB.BaseScore.Int += pontos;
					pMob[conn].MOB.BaseScore.MaxMp += (2*pontos);
					pMob[conn].MOB.CurrentScore.MaxMp += (2*pontos);
				}

				if (m->Detail == 2)
					pMob[conn].MOB.BaseScore.Dex += pontos;

				if (m->Detail == 3)
				{
					pMob[conn].MOB.BaseScore.Con += pontos;
					pMob[conn].MOB.BaseScore.MaxHp += (2*pontos);
					pMob[conn].MOB.CurrentScore.MaxHp += (2*pontos);
				}

				pMob[conn].GetCurrentScore(conn);
				SendEtc(conn);
				SendScore(conn);

				//sprintf(temp, "etc,applybonus name:%s bonustype:%d detail:%d pontos:%d", pMob[conn].MOB.MobName, m->BonusType, m->Detail, pontos);
				//Log(temp, pUser[conn].AccountName, 0);
				return;
			}
			else
			{
				//Log("err,applybonus skill out of bound", pUser[conn].AccountName, pUser[conn].IP);
				return;
			}
		}
		else
		{
			SendScore(conn);
			return;
		}
	}
	else if (m->BonusType == 1)
	{
		if (pMob[conn].MOB.SpecialBonus > 0)
		{
			if (m->Detail >= 0 && m->Detail <= 3)
			{
				int max_special_level = 3 * (pMob[conn].MOB.BaseScore.Level + 1);

				int max_special = 200;

				if((1 << 7) & pMob[conn].MOB.LearnedSkill && m->Detail == 1 || (1 << 15) & pMob[conn].MOB.LearnedSkill && m->Detail == 2 || (1 << 23) & pMob[conn].MOB.LearnedSkill && m->Detail == 3)
					max_special = 255;

				if((1 << 0) & pMob[conn].extra.SecLearnedSkill || (1 << 4) & pMob[conn].extra.SecLearnedSkill || (1 << 8) & pMob[conn].extra.SecLearnedSkill)
					max_special = 320;

				if (pMob[conn].extra.ClassMaster == CELESTIAL || pMob[conn].extra.ClassMaster == CELESTIALCS || pMob[conn].extra.ClassMaster == SCELESTIAL || pMob[conn].extra.ClassMaster == HARDCORE)
					max_special_level += 3 * 400;

				if (pMob[conn].MOB.BaseScore.Special[m->Detail] < (max_special_level >> 1))
				{
					if (pMob[conn].MOB.BaseScore.Special[m->Detail] < max_special)
					{
						pMob[conn].MOB.SpecialBonus--;
						pMob[conn].MOB.BaseScore.Special[m->Detail]++;
						pMob[conn].GetCurrentScore(conn);

						SendScore(conn);
						SendEtc(conn);

						//sprintf(temp, "etc,applybonus name:%s bonustype:%d special%d", pMob[conn].MOB.MobName, m->BonusType, m->Detail);
						//Log(temp, pUser[conn].AccountName, 0);
					}
					else
						SendClientMessage(conn, g_pMessageStringTable[_NN_Maximum_Point_200_Now]);
				}
				else
					SendClientMessage(conn, g_pMessageStringTable[_NN_Maximum_Point_Now]);
										
			}
			else
				Log("err,applybonus Special, out of boundary", pUser[conn].AccountName, pUser[conn].IP);
		}
		else
			SendEtc(conn);
	}

	else if (m->BonusType == 2)
	{
		int MobClass = pMob[conn].MOB.Class;
		int skillclass = (m->Detail - 5000) / 24;
		int skillpos = (m->Detail - 5000) % 24;
		int MobTarget = m->TargetID;

		if (m->Detail >= 5000 && m->Detail <= 5095)
		{
			if (pUser[conn].Ingame.MobDonateStore == TRUE || MobTarget >= MAX_USER && MobTarget < MAX_MOB)
			{
				if (MobClass == skillclass)
				{
					int Skillbonus = g_pSpell[skillpos + 24 * skillclass].SkillPoint;

					int myskillbonus = pMob[conn].MOB.SkillBonus;

					if (pMob[conn].extra.ClassMaster == CELESTIAL || pMob[conn].extra.ClassMaster == CELESTIALCS || pMob[conn].extra.ClassMaster == SCELESTIAL)
						myskillbonus = 1500;

					if (Skillbonus <= myskillbonus)
					{
						int learn = 1 << skillpos;

						if(skillpos == 7 || skillpos == 15 || skillpos == 23)
						{
							if ((1 << 7) & pMob[conn].MOB.LearnedSkill || (1 << 15) & pMob[conn].MOB.LearnedSkill || (1 << 23) & pMob[conn].MOB.LearnedSkill)
							{
								SendClientMessage(conn, g_pMessageStringTable[_NN_Only_OneSkillLearn]);
								return;
							}

							int skillin = 0;
													
							for(int i = 0; i < 8; i++)
							{
								if ((1 << (skillpos - i)) & pMob[conn].MOB.LearnedSkill)
									skillin++;
							}

							if(skillin != 7)
							{
								SendClientMessage(conn, g_pMessageStringTable[_NN_Befor_LearnSkill]);
								return;
							}
							//Custo skill 8th
							int coin = pMob[conn].extra.ClassMaster != MORTAL && pMob[conn].extra.ClassMaster != ARCH ? 2000000 : 2000000;

							if(skillin == 7 && pMob[conn].MOB.Coin < coin)
							{
								SendClientMessage(conn, strFmt(g_pMessageStringTable[_DN_D_Cost], coin));
								return;
							}
						}

						if ((1 << skillpos) & pMob[conn].MOB.LearnedSkill)
						{
							SendClientMessage(conn, g_pMessageStringTable[_NN_Already_Learned_It]);
							return;
						}
						else
						{
							int reqlv = pMob[conn].extra.ClassMaster == MORTAL || pMob[conn].extra.ClassMaster == ARCH ? g_pItemList[m->Detail].ReqLvl : 0;
							if (pMob[conn].MOB.CurrentScore.Level >= reqlv)
							{
								if (pMob[conn].MOB.CurrentScore.Special[1] >= g_pItemList[m->Detail].ReqInt
									&& pMob[conn].MOB.CurrentScore.Special[2] >= g_pItemList[m->Detail].ReqDex
									&& pMob[conn].MOB.CurrentScore.Special[3] >= g_pItemList[m->Detail].ReqCon)
								{
									int coin = pMob[conn].extra.ClassMaster != MORTAL && pMob[conn].extra.ClassMaster != ARCH ? 2000000 : 2000000;

									if(skillpos == 7 || skillpos == 15 || skillpos == 23)
										pMob[conn].MOB.Coin -= coin;

									pMob[conn].MOB.LearnedSkill |= learn;
									pMob[conn].MOB.SkillBonus -= Skillbonus;
									pMob[conn].GetCurrentScore(conn);
									SendScore(conn);
									SendEtc(conn);

									//sprintf(temp, "etc,applybonus name:%s bonustype:%d skillpos:%d", pMob[conn].MOB.MobName, m->BonusType, skillpos);
									//Log(temp, pUser[conn].AccountName, 0);
								}
								else
								{
									SendClientMessage(conn, g_pMessageStringTable[_NN_Need_More_Mastery_To_Learn]);
									return;
								}
							}
							else
							{
								SendClientMessage(conn, g_pMessageStringTable[_NN_Need_More_Level_To_Learn]);
								return;
							}
						}
					}
					else
					{
						SendClientMessage(conn, g_pMessageStringTable[_NN_Not_Enough_Skill_Point]);
						return;
					}
				}
				else
				{
					SendClientMessage(conn, g_pMessageStringTable[_NN_Cant_Learn_Other_Class_Skill]);
					return;
				}
			}
			else
			{
				//Log("err,MSG_ApplyBonus, request target id is  out of bound", pUser[conn].AccountName, pUser[conn].IP);
				return;
			}
		}
		else
		{
			//Log("err,MSG_ApplyBonus, request skill out of bound", pUser[conn].AccountName, pUser[conn].IP);
			return;
		}
	}
}

# -------------------- _MSG_Attack.cpp --------------------

/*
*   Copyright (C) {2015}  {Victor Klafke, Charles TheHouse}
*
*   This program is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program.  If not, see [http://www.gnu.org/licenses/].
*
*   Contact at: victor.klafke@ecomp.ufsm.br
*/
#include "ProcessClientMessage.h"
#include <windows.h>
#include <time.h>
#include <random>
#include <ctime>

void Exec_MSG_Attack(int conn, char* pMsg)
{
	MSG_Attack* m = reinterpret_cast<MSG_Attack*>(pMsg);

	int Size = m->Size;

	if (m->PosX < 0 || m->PosX >= MAX_GRIDX)
		return;

	if (m->PosY < 0 || m->PosY >= MAX_GRIDX)
		return;

	if (m->AttackerID < 0 || m->PosY >= MAX_MOB)
		return;

	if (Size > sizeof(MSG_Attack)) //CONTROLE DE SIZE
	{
		SendClientMessage(conn, "Impossível executar ação6, tente mais tarde.");
		return;
	}

	m->ID = ESCENE_FIELD;

	if (pUser[conn].TradeMode)
	{
		SendClientMessage(conn, g_pMessageStringTable[_NN_CantWhenAutoTrade]);
		return;
	}

	if (pUser[conn].Mode != USER_PLAY)
	{
		SendHpMode(conn);
		return;
	}

	if (m->SkillIndex == 110 || m->SkillIndex == 96 || m->SkillIndex == 90) //hack use skill kefra 20/10
	{
		//pMob[conn].CrackError = SystemTime + 10800;
		/*
		snprintf(temp, sizeof(temp), "Banido por usar skill de Kefra");
		SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);*/
		SendBanAccount(conn, Banned::Permanente);
		return;
	}

	if (*(short*)&pMsg[48] == 7 && *(short*)&pMsg[73] == 0xBBB)  //HACK DIA 20/10   //one hit
	{
		/*
		snprintf(temp, sizeof(temp), "Banido por usar hack one hit");
		SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);*/
		SendBanAccount(conn, Banned::Permanente);
		return;
	}


	//Personagem morto tentando usar uma skill que não é ressureição
	if (pMob[conn].MOB.CurrentScore.Hp == 0 && m->SkillIndex != 99)
	{
		SendHpMode(conn);
		//AddCrackError(conn, 1, 8);
		return;
	}

	short TargetKilled[MAX_TARGET] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };

	unsigned int ClientTick = m->ClientTick;

	unsigned int LastAttackTick = 0;

	if (ClientTick != SKIPCHECKTICK && pUser[conn].LastAttackTick != SKIPCHECKTICK && m->ClientTick < (unsigned int)pUser[conn].LastAttackTick + 600)
	{
		CloseUser(conn);
		return;
	}

	if (ClientTick != SKIPCHECKTICK && pUser[conn].LastAttackTick != SKIPCHECKTICK)
	{
		if (ClientTick < static_cast<unsigned int>(pUser[conn].LastAttackTick) - 100)
			AddCrackError(conn, 4, 7);

		LastAttackTick = pUser[conn].LastAttackTick;

		pUser[conn].LastAttackTick = ClientTick;
		pUser[conn].LastAttack = m->SkillIndex;
	}

	if (ClientTick != SKIPCHECKTICK)
	{
		int ClientTick15sec = 0;

		if (CurrentTime <= 0x1D4C0)
			ClientTick15sec = 0;
		else
			ClientTick15sec = CurrentTime - 120000;

		if (static_cast<unsigned int>(ClientTick) > CurrentTime + 15000 || static_cast<int>(ClientTick) < ClientTick15sec)
		{
			//Log("etc,clienttime faster than 15 sec - MSG_ATTACK", pUser[conn].AccountName, pUser[conn].IP);
			//AddCrackError(conn, 1, 107);

			return;
		}

		pUser[conn].LastAttackTick = ClientTick;
	}

	int skillnum = m->SkillIndex;

	int tx = m->TargetX;
	int ty = m->TargetY;

	if (ClientTick != SKIPCHECKTICK && skillnum != 42 && (tx != m->TargetX || ty != m->TargetY))
	{

		return;
	}

	if (skillnum >= 0 && skillnum < MAX_SKILLINDEX && ClientTick != SKIPCHECKTICK)
	{
		if (skillnum < -1 || skillnum > MAX_SKILLINDEX)
		{
			return;
		}

		if (g_pSpell[skillnum].Passive == 1)
			return;


		if (pMob[conn].MOB.Class == 1)
		{
			for (int i = 0; i < MAX_AFFECT; i++)
			{
				if (pMob[conn].Affect[i].Type != 6)
					continue;

				pMob[conn].Affect[i].Type = 0;
				pMob[conn].Affect[i].Value = 0;
				pMob[conn].Affect[i].Level = 0;
				pMob[conn].Affect[i].Time = 0;

				pMob[conn].GetCurrentScore(conn);
				SendScore(conn);

				break;
			}
		}


		if (LastAttackTick != -1 && ClientTick != SKIPCHECKTICK)
		{
			int isTime = ClientTick - LastAttackTick;

			int skilldelay = g_pSpell[skillnum].Delay;

			if ((pMob[conn].MOB.Rsv & RSV_CAST) != 0 && skilldelay >= 2)
				skilldelay--;

			skilldelay = skilldelay * 1000;

			if (isTime < 700)
			{

				return;
			}
		}

		pUser[conn].LastAttackTick = m->ClientTick;

		if ((skillnum / 24) != pMob[conn].MOB.Class && (skillnum / 24) <= 3)
		{
			//Log("MSG_Attack, Request other class skill", pUser[conn].AccountName, pUser[conn].IP);
			return;
		}
	}

	/*	int Level = 0;
		int Delay = 100;
		int Special = 0;

		if (skillnum < 0 || skillnum >= MAX_SKILLINDEX)
		{
		if (skillnum >= 96 && skillnum <= MAX_SKILLINDEX)
		{
		if (skillnum == 97)
		{
		if (m->PosX <= 0 || m->PosX >= 4096 || m->PosY <= 0 || m->PosY >= 4096)
		{
		Log("err,mortar invalid", pUser[conn].AccountName, pUser[conn].IP);
		return;
		}

		int itemslot = pItemGrid[m->PosY][m->PosX];

		if (itemslot <= 0 || itemslot >= MAX_ITEM || pItem[itemslot].ITEM.sIndex != 746)
		{
		Log("err,mortar invalid", pUser[conn].AccountName, pUser[conn].IP);
		return;
		}
		m->Motion = 1;
		}
		else
		{
		int skill = skillnum - 72;
		int learned = 1 << (skillnum - 72);

		if (m->ClientTick != SKIPCHECKTICK && !(learned & pMob[conn].MOB.LearnedSkill))
		{
		if (AddCrackError(conn, 208, 1))
		return;
		}
		}
		Level = pMob[conn].MOB.CurrentScore.Level;
		Delay += Level;
		Special = Level;
		}
		}

		else
		{
		int skillkind = skillnum % MAX_SKILL / 8 + 1;

		if (ClientTick != SKIPCHECKTICK)
		{
		int learn = skillnum % MAX_SKILL;
		int learnedSkill = 1 << learn;

		if (m->ClientTick != SKIPCHECKTICK && !(learnedSkill & pMob[conn].MOB.LearnedSkill))
		{
		if (AddCrackError(conn, 8, 10))
		return;
		}

		if (skillkind < 0 || skillkind > 3)
		{
		Log("Skill kind out of bound - MSG_ATTACK", pUser[conn].AccountName, pUser[conn].IP);
		return;
		}
		}
		Level = pMob[conn].MOB.CurrentScore.Special[skillkind];
		Delay += Level;
		Special = Level;
		}*/


	int Level = 0;
	int Delay = 100;
	int Special = 0;

	if (skillnum >= 0 && skillnum < 96)
	{
		int getSkillMaster = ((skillnum % 24) / 8) + 1;

		if (ClientTick != SKIPCHECKTICK)
		{
			int learn = skillnum % 24;
			int learnedSkill = 1 << learn;

			if (m->ClientTick != SKIPCHECKTICK && (pMob[conn].MOB.LearnedSkill & learnedSkill) == FALSE)
			{
				//AddCrackError(conn, 8, 10);
				return;
			}

			if (getSkillMaster <= 0 || getSkillMaster > 3)
			{
				//Log("Skill kind out of bound - MSG_ATTACK", pUser[conn].AccountName, pUser[conn].IP);
				return;
			}
		}

		Level = pMob[conn].MOB.CurrentScore.Special[getSkillMaster];
		Delay = Delay + Level;
		Special = Level;
	}
	else
	{
		if (skillnum >= 96 && skillnum <= 103)
		{
			if (skillnum == 97)
			{
				if (m->PosX > 0 && m->PosX < 4096 && m->PosY > 0 && m->PosY < 4096)
				{
					int itemId = pItemGrid[m->PosX][m->PosY];
					if (itemId > 0 && itemId < MAX_ITEMLIST && pItem[itemId].ITEM.sIndex == 746)
						m->Motion = 1;
					else
					{
						//Log("err, mortar invalid", pUser[conn].AccountName, pUser[conn].IP);
						return;
					}
				}
				else
				{
					//Log("err, mortar invalid", pUser[conn].AccountName, pUser[conn].IP);
					return;
				}
			}
			else
			{
				int learn = skillnum - 72;
				int learnedSkill = 1 << learn;
				if (m->ClientTick != SKIPCHECKTICK && (pMob[conn].MOB.LearnedSkill & learnedSkill) == FALSE)
				{
					//AddCrackError(conn, 208, 1);
					return;
				}
			}

			Level = pMob[conn].MOB.CurrentScore.Level;
			Delay = Delay + Level;
			Special = Level;
		}
	}

#pragma region Escudo_dourado
	if (skillnum == 85)
	{
		int coin = 10 * Level;
		if (pMob[conn].MOB.Coin < coin)
			return;

		pMob[conn].MOB.Coin -= coin;
		SendEtc(conn);
	}
#pragma endregion

	int Alvo = m->Dam[0].TargetID;

#pragma region Range Hack  
	if (conn != Alvo)
	{
		int Spectral = -1;
		int WeaponRange = -1;
		int Range = 2;
		int Distance = -1;

		if (pMob[conn].MOB.LearnedSkill & (1 << 29))
			Spectral = 1;

		if (pMob[conn].MOB.Equip[6].sIndex != 0)
		{
			for (int i = 0; i < MAX_STATICEFFECT; i++)
			{
				if (g_pItemList[pMob[conn].MOB.Equip[6].sIndex].stEffect[i].sEffect == EF_RANGE)
					WeaponRange = g_pItemList[pMob[conn].MOB.Equip[6].sIndex].stEffect[i].sValue;
			}
		}

		if (Spectral != -1)
			Range = Range + 1;

		if (Alvo > 0 && Alvo < MAX_MOB)
			Distance = BASE_GetDistance(pMob[conn].TargetX, pMob[conn].TargetY, pMob[Alvo].TargetX, pMob[Alvo].TargetY);

		if (Distance <= 0 || Distance >= 150)
			Distance = -1;

		// Astaroth transformation
		if (pMob[conn].MOB.Equip[0].sIndex == 24 && Distance > Range + 5)
		{
			/*printf("\nPlayer using Astaroth has just attacked from a distance", pUser[conn].AccountName, pUser[conn].IP);*/
			return;
		}
		// Magic range attack
		else if (m->Motion == 255)
		{
			if (Distance > Range + g_pSpell[m->SkillIndex].Range + 3)
			{
				/*printf("\nPlayer using Magic Attack has just attacked from a distance", pUser[conn].AccountName, pUser[conn].IP);*/
				return;
			}
		}
		else
		{
			// Attacked without possessing any weapon
			if (WeaponRange == -1)
			{
				if (Distance > Range + 3)
				{
					/*printf("\nPlayer without weapon has just attacked from a distance without weapon", pUser[conn].AccountName, pUser[conn].IP);*/
					return;
				}
			}
			// Attacked too far
			else
			{
				if (Distance > Range + WeaponRange + 3)
				{
					/*printf("\nPlayer with weapon has just attacked from a distance", pUser[conn].AccountName, pUser[conn].IP);*/
					return;
				}
			}
		}
	}
#pragma endregion

#pragma region Resfriamento
	// Skill Hack
	if (skillnum >= 0 && skillnum < skillnum < 103)
	{
		int CurrentTime = GetTickCount64();
		int skilldelay = g_pSpell[skillnum].Delay;
		if (pUser[conn].Ingame.Skill[skillnum].IntervalTime)
		{
			int PreviousAttackTime = CurrentTime - pUser[conn].Ingame.Skill[skillnum].IntervalTime;
			if (&pMob[conn].MOB.Equip[4] && BASE_GetItemSanc(&pMob[conn].MOB.Equip[4]) >= 9) // Verificar se tem Manopla +9 = -1 Delay Skill
				skilldelay--;
			for (int i = 0; i < MAX_AFFECT; i++) {
				int index = pMob[conn].Affect[i].Type;
				if (index == NULL)
					continue;
				int master = pMob[conn].Affect[i].Level;
				if (index == 8) { // Sagacidade
					if ((master & (1 << 0)) != 0)
						skilldelay--;

				}
			}
			if (skillnum == 102) skilldelay = 1;
			skilldelay = skilldelay * 1000;
			if (skilldelay <= 0) skilldelay = 400;
			// correção skill cura 
			if (skillnum == 29) skilldelay = 1;
			if (skillnum == 47) skilldelay = 1;
			pUser[conn].Ingame.Skill[skillnum].IntervalTime = CurrentTime;
			// Skill Delay Hack
			if (PreviousAttackTime < (skilldelay - 300)) {
				for (int i = 0; i < 13; i++) {
					short target = m->Dam[i].TargetID;
					short damage = m->Dam[i].Damage;

					if (target <= NULL || target >= 12800)
						continue;

					m->Dam[i].TargetID = 0;
					m->Dam[i].Damage = 0;
					return;
				}
				memset(pMsg, 0, m->Size);
				return;
			}
		}
		pUser[conn].Ingame.Skill[skillnum].IntervalTime = CurrentTime;
	}
#pragma endregion 

	int Mp = pMob[conn].MOB.CurrentScore.Mp;
	int ReqMp = pUser[conn].ReqMp;
#pragma region Consumo de mana
	if (skillnum >= 0 && skillnum < MAX_SKILLINDEX)
	{
		int ManaSpent = BASE_GetManaSpent(skillnum, pMob[conn].MOB.SaveMana, Special);

		if ((pMob[conn].MOB.CurrentScore.Mp - ManaSpent) < 0)
		{
			SendSetHpMp(conn);
			return;
		}

		pMob[conn].MOB.CurrentScore.Mp = pMob[conn].MOB.CurrentScore.Mp - ManaSpent;
		pUser[conn].ReqMp = pUser[conn].ReqMp - ManaSpent;
		SetReqMp(conn);

		if (pMob[conn].MOB.Class == 1)
		{
			if (pMob[conn].extra.SecLearnedSkill & 0x1) // Cenote
			{
				pMob[conn].MOB.CurrentScore.Mp = pMob[conn].MOB.CurrentScore.Mp - ManaSpent * 2;
				pUser[conn].ReqMp = pUser[conn].ReqMp - ManaSpent * 2;
				SetReqMp(conn);
			}

			for (int i = 0; i < MAX_AFFECT; i++) // Magia Misteriosa
			{
				if (pMob[conn].Affect[i].Type == 42)
				{
					pMob[conn].MOB.CurrentScore.Mp = pMob[conn].MOB.CurrentScore.Mp - ManaSpent * 2;
					pUser[conn].ReqMp = pUser[conn].ReqMp - ManaSpent * 2;
					SetReqMp(conn);
				}
			}
		}

		if (pMob[conn].MOB.Class == 0 && (pMob[conn].extra.SecLearnedSkill & 0x100)) // Espelho Mágico
		{
			pMob[conn].MOB.CurrentScore.Mp = pMob[conn].MOB.CurrentScore.Mp - ManaSpent / 2;
			pUser[conn].ReqMp = pUser[conn].ReqMp - ManaSpent / 2;
			SetReqMp(conn);
		}
	}

	m->CurrentMp = pMob[conn].MOB.CurrentScore.Mp;
	m->ReqMp = pUser[conn].ReqMp;
#pragma endregion

	int master = 0;

	if (!pMob[conn].MOB.Class && pMob[conn].MOB.LearnedSkill & 0x4000)
	{
		master = pMob[conn].MOB.CurrentScore.Special[2] / 20;

		if (master < 0)
			master = 0;

		if (master > 15)
			master = 15;
	}

	DoRemoveSamaritano(conn);

	int Exp = 0;
	int mylevel = pMob[conn].MOB.CurrentScore.Level;

	unsigned char map_att = GetAttribute(pMob[conn].TargetX, pMob[conn].TargetY) & 0x40;

	int hp = pMob[conn].MOB.CurrentScore.Hp;

	int UNK2 = 0;
	unsigned char DoubleCritical = 0;

	/*if (skillnum == 102)
	{
	MSG_STANDARDPARM pSetClan;
	pSetClan.Type = _MSG_SetClan;
	pSetClan.Size = sizeof MSG_STANDARDPARM;
	pSetClan.ID = conn;
	pSetClan.Parm = pMob[conn].MOB.Clan;

	GridMulticast(pMob[conn].TargetX, pMob[conn].TargetY, (MSG_STANDARD*)&pSetClan, 0);
	}*/

	m->CurrentHp = pMob[conn].MOB.CurrentScore.Hp;

	if (skillnum == 79)
	{
		m->ClientTick = 0xE0A1ACA;
		m->Motion = 254;

		m->TargetX = pMob[conn].TargetX;
		m->TargetY = pMob[conn].TargetY;

		m->AttackerID = conn;
		m->SkillIndex = 79;

		for (int x = 1; x < 6; x++)
		{
			m->Dam[x].Damage = m->Dam[0].Damage;
			m->Dam[x].TargetID = m->Dam[0].TargetID;
		}
	}

#pragma region Loop Target
	for (int i = 0; i < MAX_TARGET; i++)
	{
		if (i >= MAX_TARGET && m->Size <= sizeof(MSG_Attack))
			break;
		if (i >= 1 && m->Size <= sizeof(MSG_AttackOne))
			break;
		if (i >= 2 && m->Size <= sizeof(MSG_AttackTwo))
			break;

		int idx = m->Dam[i].TargetID;

		if (idx <= 0 || idx >= MAX_MOB)
			continue;

		// Tiro Direto
		if (pMob[conn].MOB.Class == 3 && (pMob[conn].extra.SecLearnedSkill & 0x100))
		{
			for (int i = 0; i < MAX_AFFECT; i++)
			{
				if (pMob[conn].Affect[i].Type == 28)
				{
					if ((rand() % 100) < 40)
					{
						if (pMob[idx].Affect[i].Type == 44)
						{
							pMob[idx].Affect[i].Type = 44;
							pMob[idx].Affect[i].Value = 1;
							pMob[idx].Affect[i].Level = 1;
							pMob[idx].Affect[i].Time = 4;

							pMob[idx].GetCurrentScore(idx);
							SendScore(idx);
							break;
						}
						else
						{
							pMob[idx].Affect[i].Type = 44;
							pMob[idx].Affect[i].Value = 1;
							pMob[idx].Affect[i].Level = 1;
							pMob[idx].Affect[i].Time = 4;

							pMob[idx].GetCurrentScore(idx);
							SendScore(idx);
							break;
						}
					}
				}
			}
		}

		if (pMob[conn].MOB.Class == 3)
			DoRemoveHide(conn);

		if (pMob[idx].MOB.Class == 3)
			DoRemoveHide(idx);

		if (pMob[idx].Mode == MOB_EMPTY) // Checa possibilidade de Freeze
		{
			SendRemoveMob(conn, idx, 1, 0);
			continue;
		}

		if (pMobGrid[pMob[conn].TargetY][pMob[conn].TargetX] == 0)
			pMobGrid[pMob[conn].TargetY][pMob[conn].TargetX] = conn;

		if (idx >= MAX_USER && (pMob[idx].MOB.Equip[0].sIndex == 219 || pMob[idx].MOB.Equip[0].sIndex == 220) && ((pMob[idx].TargetX / 128) == 26 && (pMob[idx].TargetY / 128) == 12))
		{
			m->Dam[i].TargetID = 0;
			m->Dam[i].Damage = 0;

			continue;
		}

		if (pMob[idx].MOB.CurrentScore.Hp <= 0 && skillnum != 99 && skillnum != 31)
		{
			SendSetHpMp(idx);
			m->Dam[i].Damage = 0;
			m->Dam[i].TargetID = 0;
			continue;
		}

		if (pMob[idx].MOB.CurrentScore.Hp <= 0 && m->SkillIndex != 31 && m->SkillIndex != 99)
		{
			m->Dam[i].TargetID = 0;
			m->Dam[i].Damage = 0;

			SendRemoveMob(conn, idx, 1, 0);
			continue;
		}

		if (pMob[idx].MOB.Merchant == 4 || pMob[idx].MOB.Merchant == 43 || pMob[idx].MOB.Merchant == 1 || pMob[idx].MOB.Merchant == 100)
		{
			m->Dam[i].TargetID = 0;
			m->Dam[i].Damage = 0;
			continue;
		}

		if (skillnum != 42 && (pMob[conn].TargetX < pMob[idx].TargetX - VIEWGRIDX || pMob[conn].TargetX > pMob[idx].TargetX + VIEWGRIDX || pMob[conn].TargetY < pMob[idx].TargetY - VIEWGRIDY || pMob[conn].TargetY > pMob[idx].TargetY + VIEWGRIDY))
		{
			SendRemoveMob(conn, idx, 1, 0);
			continue;
		}

		int dam = m->Dam[i].Damage;

		if (dam != -2 && dam != -1 && dam)
		{
			m->Dam[i].Damage = 0;
			//AddCrackError(conn, 10, 77);

			continue;
		}

		int leader = pMob[conn].Leader;

		if (leader == 0)
			leader = conn;

		int mobleader = pMob[idx].Leader;

		if (mobleader == 0)
			mobleader = idx;

		int Guild = pMob[conn].MOB.Guild;

		if (pMob[conn].GuildDisable)
			Guild = 0;

		int MobGuild = pMob[idx].MOB.Guild;

		if (pMob[idx].GuildDisable)
			MobGuild = 0;

		if (Guild == 0 && MobGuild == 0)
			Guild = -1;

		if (BrState && BRItem > 0 && pMob[conn].TargetX >= 2604 && pMob[conn].TargetY >= 1708 && pMob[conn].TargetX <= 2648 && pMob[conn].TargetY <= 1744)
			Guild = -1;

		int Clan = pMob[conn].MOB.Clan;
		int MobClan = pMob[idx].MOB.Clan;

		int isFrag = 0;

		if (Clan == 7 && MobClan == 7 || Clan == 8 && MobClan == 8)
			isFrag = 1;

		if (CWarTower::TowerAttack(conn, idx) == FALSE)
		{
			m->Dam[i].TargetID = 0;
			m->Dam[i].Damage = 0;
			continue;
		}
		if (conn != idx && conn > 0 && conn < MAX_USER && idx > 0 && idx < MAX_USER && RvRState == 0 && CastleState == 0 && GTorreState == 0 && NewbieEventServer == 0)
		{
			int AttackerPK = pUser[conn].PKMode;
			int TargetPK = pUser[idx].PKMode;
			int TargetGuilty = GetGuilty(idx);

			unsigned char attributemap = GetAttribute(pMob[conn].TargetX, pMob[conn].TargetY) & 64;

			if (dam == -2 && !TargetPK && !TargetGuilty && attributemap || dam == -1 && skillnum >= 0 && skillnum <= MAX_SKILLINDEX && g_pSpell[skillnum].Aggressive && attributemap && !TargetPK && !TargetGuilty)
			{
				m->Dam[i].TargetID = 0;
				m->Dam[i].Damage = 0;
				continue;
			}
		}

		//TODO: CONTADORO DE HIST EVENTO
		if (pMob[idx].GenerateIndex == 4734 || pMob[idx].GenerateIndex == 4735)
		{
			if (conn <= 0 && conn >= MAX_USER)
				continue;

			if (pUser[conn].Mode != USER_PLAY)
				continue;

			if (EventStatus == 0)
				continue;

			if (pUser[conn].DiariaState == 0) {
				CloseUser(conn);
				m->Dam[i].TargetID = 0;
				m->Dam[i].Damage = 0;
				continue;
			}
			if (GetInView(conn, idx) == FALSE) {
				CloseUser(conn);
				m->Dam[i].TargetID = 0;
				m->Dam[i].Damage = 0;
				continue;
			}
			m->Dam[i].TargetID = 0;
			m->Dam[i].Damage = 0;
			SendEventCount(conn);			
			continue;
		}

		/*if (((pMob[conn].TargetX) / 128) == 31 && ((pMob[conn].TargetY) / 128) == 31) {

			if (conn <= 0 && conn >= MAX_USER)
				continue;

			if (pUser[conn].Mode != USER_PLAY)
				continue;

			if (pUser[conn].Admin != 1)
				DoRecall(conn);
		}*/

#pragma region ANTI PULO LAN

		if (!strcmp(pMob[idx].MOB.MobName, "AranhaAmald") || !strcmp(pMob[idx].MOB.MobName, "MorlockAmald") || !strcmp(pMob[idx].MOB.MobName, "HorizonAmald") || !strcmp(pMob[idx].MOB.MobName, "GargulaAmald"))
		{
			if (conn <= 0 && conn >= MAX_USER)
				continue;

			if (pUser[conn].Mode != USER_PLAY)
				continue;

			if (pMob[conn].LanNFlag != 1)
			{
				SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, "hack, Pulo LanN");
				CloseUser(conn);
				m->Dam[i].TargetID = 0;
				m->Dam[i].Damage = 0;
				continue;
			}
		}

		if (!strcmp(pMob[idx].MOB.MobName, "KalintzAmald") || !strcmp(pMob[idx].MOB.MobName, "EntAmald") || !strcmp(pMob[idx].MOB.MobName, "LoboAmald") || !strcmp(pMob[idx].MOB.MobName, "KalintzAmald "))
		{
			if (conn <= 0 && conn >= MAX_USER)
				continue;

			if (pUser[conn].Mode != USER_PLAY)
				continue;

			if (pMob[conn].LanMFlag != 1)
			{
				SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, "hack, Pulo LanM");
				CloseUser(conn);
				m->Dam[i].TargetID = 0;
				m->Dam[i].Damage = 0;
				continue;
			}
		}


		if (!strcmp(pMob[idx].MOB.MobName, "PerBerserker ") || !strcmp(pMob[idx].MOB.MobName, "PerValkyrie ") || !strcmp(pMob[idx].MOB.MobName, "PreKalintz M") || !strcmp(pMob[idx].MOB.MobName, "PreKalintz H "))
		{
			if (conn <= 0 && conn >= MAX_USER)
				continue;

			if (pUser[conn].Mode != USER_PLAY)
				continue;

			if (pMob[conn].LanAFlag != 1)
			{
				SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, "hack, Pulo LanA");
				CloseUser(conn);
				m->Dam[i].TargetID = 0;
				m->Dam[i].Damage = 0;
				continue;
			}
		}

#pragma endregion ANTI PULO LAN

#pragma region Anti Pulo Quest
		//coveiro
		if (pMob[conn].TargetX > 2379 && pMob[conn].TargetY > 2076 &&
			pMob[conn].TargetX < 2426 && pMob[conn].TargetY < 2133) {

			if (conn <= 0 && conn >= MAX_USER)
				continue;

			if (pUser[conn].Mode != USER_PLAY)
				continue;

			if (pMob[conn].QuestFlag != 1)
			{
				SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, "hack, Pulo Coveiro");
				CloseUser(conn);
				m->Dam[i].TargetID = 0;
				m->Dam[i].Damage = 0;
				continue;
			}

		}
		//carbuncle
		if (pMob[conn].TargetX > 2228 && pMob[conn].TargetY > 1700 &&
			pMob[conn].TargetX < 2257 && pMob[conn].TargetY < 1728) {

			if (conn <= 0 && conn >= MAX_USER)
				continue;

			if (pUser[conn].Mode != USER_PLAY)
				continue;

			if (pMob[conn].QuestFlag != 2)
			{
				SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, "hack, Pulo Carbuncle");
				CloseUser(conn);
				m->Dam[i].TargetID = 0;
				m->Dam[i].Damage = 0;
				continue;
			}
		}
		//cura
		if (pMob[conn].TargetX > 459 && pMob[conn].TargetY > 3887 &&
			pMob[conn].TargetX < 497 && pMob[conn].TargetY < 3916) {

			if (conn <= 0 && conn >= MAX_USER)
				continue;

			if (pUser[conn].Mode != USER_PLAY)
				continue;

			if (pMob[conn].QuestFlag != 3)
			{
				SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, "hack, Pulo Cura");
				CloseUser(conn);
				m->Dam[i].TargetID = 0;
				m->Dam[i].Damage = 0;
				continue;
			}
		}
		//mana
		if (pMob[conn].TargetX > 658 && pMob[conn].TargetY > 3728 &&
			pMob[conn].TargetX < 703 && pMob[conn].TargetY < 3762) {

			if (conn <= 0 && conn >= MAX_USER)
				continue;

			if (pUser[conn].Mode != USER_PLAY)
				continue;

			if (pMob[conn].QuestFlag != 4)
			{
				SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, "hack, Pulo Mana");
				CloseUser(conn);
				m->Dam[i].TargetID = 0;
				m->Dam[i].Damage = 0;
				continue;
			}
		}
		//emblema
		if (pMob[conn].TargetX > 1312 && pMob[conn].TargetY > 4027 &&
			pMob[conn].TargetX < 1348 && pMob[conn].TargetY < 4055) {

			if (conn <= 0 && conn >= MAX_USER)
				continue;

			if (pUser[conn].Mode != USER_PLAY)
				continue;

			if (pMob[conn].QuestFlag != 5)
			{
				SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, "hack, Pulo Emblema");
				CloseUser(conn);
				m->Dam[i].TargetID = 0;
				m->Dam[i].Damage = 0;
				continue;
			}
		}
#pragma endregion

#pragma region Antipulo Pista
		//Pista +0
		if (pMob[conn].TargetX > 3327 && pMob[conn].TargetY > 1595 && pMob[conn].TargetX < 3455 && pMob[conn].TargetY < 1660)
		{
			if (conn <= 0 && conn >= MAX_USER)
				continue;

			if (pUser[conn].Mode != USER_PLAY)
				continue;

			int partyleader = pMob[conn].Leader;

			if (partyleader <= 0)
				partyleader = conn;

			if (Pista[0].Party[0].LeaderID != partyleader && Pista[0].Party[1].LeaderID != partyleader && Pista[0].Party[2].LeaderID != partyleader) {
				SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, "hack, Pulo Pista0");
				CloseUser(conn);
			}

		}
		//Pista +1
		if (pMob[conn].TargetX > 3340 && pMob[conn].TargetY > 1540 && pMob[conn].TargetX < 3440 && pMob[conn].TargetY < 1600)
		{
			if (conn <= 0 && conn >= MAX_USER)
				continue;

			if (pUser[conn].Mode != USER_PLAY)
				continue;

			int partyleader = pMob[conn].Leader;

			if (partyleader <= 0)
				partyleader = conn;

			if (Pista[1].Party[0].LeaderID != partyleader && Pista[1].Party[1].LeaderID != partyleader && Pista[1].Party[2].LeaderID != partyleader) {
				SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, "hack, Pulo Pista1");
				CloseUser(conn);
			}
		}
		//Pista +2
		if (pMob[conn].TargetX > 3330 && pMob[conn].TargetY > 1420 && pMob[conn].TargetX < 3455 && pMob[conn].TargetY < 1470)
		{
			if (conn <= 0 && conn >= MAX_USER)
				continue;

			if (pUser[conn].Mode != USER_PLAY)
				continue;

			int partyleader = pMob[conn].Leader;

			if (partyleader <= 0)
				partyleader = conn;

			if (Pista[2].Party[0].LeaderID != partyleader && Pista[2].Party[1].LeaderID != partyleader && Pista[2].Party[2].LeaderID != partyleader) {
				SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, "hack, Pulo Pista2");
				CloseUser(conn);
			}
		}
		//Pista +3
		if (pMob[conn].TargetX > 3327 && pMob[conn].TargetY > 1020 && pMob[conn].TargetX < 3455 && pMob[conn].TargetY < 1150)
		{
			if (conn <= 0 && conn >= MAX_USER)
				continue;

			if (pUser[conn].Mode != USER_PLAY)
				continue;

			int partyleader = pMob[conn].Leader;

			if (partyleader <= 0)
				partyleader = conn;

			if (Pista[3].Party[0].LeaderID != partyleader && Pista[3].Party[1].LeaderID != partyleader && Pista[3].Party[2].LeaderID != partyleader) {
				SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, "hack, Pulo Pista3");
				CloseUser(conn);
			}
		}
		//Pista +4
		if (pMob[conn].TargetX > 3325 && pMob[conn].TargetY > 1280 && pMob[conn].TargetX < 3460 && pMob[conn].TargetY < 1410)
		{
			if (conn <= 0 && conn >= MAX_USER)
				continue;

			if (pUser[conn].Mode != USER_PLAY)
				continue;

			int partyleader = pMob[conn].Leader;

			if (partyleader <= 0)
				partyleader = conn;

			if (Pista[4].Party[0].LeaderID != partyleader && Pista[4].Party[1].LeaderID != partyleader && Pista[4].Party[2].LeaderID != partyleader) {
				SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, "hack, Pulo Pista4");
				CloseUser(conn);
			}
		}
		//Pista +5
		if (pMob[conn].TargetX > 3325 && pMob[conn].TargetY > 1150 && pMob[conn].TargetX < 3455 && pMob[conn].TargetY < 1280)
		{
			if (conn <= 0 && conn >= MAX_USER)
				continue;

			if (pUser[conn].Mode != USER_PLAY)
				continue;

			int partyleader = pMob[conn].Leader;

			if (partyleader <= 0)
				partyleader = conn;

			if (Pista[5].Party[0].LeaderID != partyleader && Pista[5].Party[1].LeaderID != partyleader && Pista[5].Party[2].LeaderID != partyleader) {
				SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, "hack, Pulo Pista5");
				CloseUser(conn);
			}
		}
		//Pista +6
		if (pMob[conn].TargetX > 3325 && pMob[conn].TargetY > 1465 && pMob[conn].TargetX < 3455 && pMob[conn].TargetY < 1535)
		{
			if (conn <= 0 && conn >= MAX_USER)
				continue;

			if (pUser[conn].Mode != USER_PLAY)
				continue;

			int partyleader = pMob[conn].Leader;

			if (partyleader <= 0)
				partyleader = conn;

			if (Pista[6].Party[0].LeaderID != partyleader && Pista[6].Party[1].LeaderID != partyleader && Pista[6].Party[2].LeaderID != partyleader) {
				SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, "hack, Pulo Pista6");
				CloseUser(conn);
			}
		}
#pragma endregion


#pragma region Ataque físico
		if (dam == -2)
		{
			int dis = BASE_GetDistance(m->PosX, m->PosY, m->TargetX, m->TargetY);
			// anti hacker 
			if (dis <= 0)
			{
				m->Dam[i].TargetID = 0;
				m->Dam[i].Damage = 0;
				pMob[conn].CurrentTarget = 0;



				continue;
			}

			if (dis > pUser[conn].Range || dis > 23)
			{
				m->Dam[i].TargetID = 0;
				m->Dam[i].Damage = 0;

				pMob[conn].CurrentTarget = 0;


				continue;
			}
			// fim	antihack

			dam = 0;

			if (i > 0 && m->Size < sizeof(MSG_AttackTwo) && pMob[conn].MOB.Class != 3 && (pMob[conn].MOB.LearnedSkill & 0x40) == 0)
			{
				//AddCrackError(conn, 10, 24);
				continue;
			}

			int CriticalDouble = 0;

			if (i == 0)
				CriticalDouble = BASE_GetDoubleCritical(&pMob[conn].MOB, &pUser[conn].cProgress, &m->Progress, &DoubleCritical);

			dam = pMob[conn].MOB.CurrentScore.Damage;

			if ((DoubleCritical & 2) != 0)
			{
				if (idx < MAX_USER)
					dam = (((rand() % 2) + 13) * dam) / 10;
				else
					dam = (((rand() % 2) + 15) * dam) / 10;
			}

			int Ac = pMob[idx].MOB.CurrentScore.Ac;

			if (idx < MAX_USER)
				Ac *= 3;

			dam = BASE_GetDamage((int)dam, Ac, master);

			//balanceamento mysql
			if (idx > 0 && idx < MAX_USER)
				dam = DamageBalancing(conn, idx, dam);

			//pve
			if (idx >= MAX_USER && idx < MAX_MOB)
			{
				if (pMob[conn].extra.ClassMaster == MORTAL)
					dam = static_cast<int>(dam * 0.7);

				if (pMob[conn].extra.ClassMaster == ARCH)
					dam = static_cast<int>(dam * 0.8);
			}

			if (i == 0 && m->Size >= sizeof(MSG_AttackTwo) && pMob[conn].MOB.Class == 3 && (pMob[conn].MOB.LearnedSkill & 0x200000) && (rand() % 4) == 0)
			{
				int skilldam = (pMob[conn].MOB.CurrentScore.Special[3] + pMob[conn].MOB.CurrentScore.Str);

				int acc = pMob[idx].MOB.CurrentScore.Ac;

				skilldam = BASE_GetDamage(skilldam, acc, master);

				if (skilldam > 0)
					skilldam /= 2;

				if (skilldam < 60)
					skilldam = 60;

				m->Dam[1].TargetID = MOB_EMPTY;
				m->Dam[1].Damage = skilldam;

				DoubleCritical |= 4;
				dam += skilldam;
			}

			if ((DoubleCritical & 1) != FALSE)
				dam *= 2;

			m->DoubleCritical = DoubleCritical;
		}


#pragma endregion

#pragma region Skills
		else if (dam == -1 && skillnum >= 0 && skillnum <= MAX_SKILLINDEX)
		{
			dam = 0;

			int maxtarget = g_pSpell[skillnum].MaxTarget;

			if (ClientTick != SKIPCHECKTICK && i > maxtarget)
			{

				continue;
			}

			if (g_pSpell[skillnum].bParty != 0 && leader != mobleader && Guild != MobGuild)
			{

				continue;
			}

			int unk2 = 0;
			int InstanceType = g_pSpell[skillnum].InstanceType;

#pragma region Ataques com elementos
			if (InstanceType >= 1 && InstanceType <= 5)
			{
				int Weather = CurrentWeather;
				int ApplyWeather = 0;

				if ((pMob[conn].TargetX / 128) < 12 && (pMob[conn].TargetY / 128) > 25)
					ApplyWeather = 1;

				else
					ApplyWeather = 0;

				if (ApplyWeather != 0)
					Weather = 0;

#pragma region Ataque de Fada
				if (ClientTick == SKIPCHECKTICK && m->Motion == 254 && (m->SkillIndex == 32 || m->SkillIndex == 34 || m->SkillIndex == 36))
				{
					int Level = pMob[conn].MOB.CurrentScore.Level;
					int familiarsanc = BASE_GetItemSanc(&pMob[conn].MOB.Equip[13]);

					switch (m->SkillIndex)
					{
					case 32:
						dam = (familiarsanc * 200) + (Level * 8);
						break;
					case 34:
						dam = (familiarsanc * 300) + (Level * 8);
						break;
					case 36:
						dam = (familiarsanc * 350) + (Level * 8);
						break;
					}

					if (dam > 1000)
						dam = 1000;
				}
#pragma endregion

				else
					dam = BASE_GetSkillDamage(skillnum, &pMob[conn].MOB, Weather, pMob[conn].WeaponDamage);

				int def = pMob[idx].MOB.CurrentScore.Ac;

				if (idx < MAX_USER)
					def *= 2;

				if (pMob[idx].MOB.Class == 1)
					def = (def * 3) / 2;

				dam = BASE_GetSkillDamage((int)dam, def, master);

				//Balanceamento Mysql
				if (idx > 0 && idx < MAX_USER)
					dam = DamageBalancing(conn, idx, dam);


				if (idx >= MAX_USER && idx < MAX_MOB)
				{
					if (pMob[conn].extra.ClassMaster == MORTAL)
						dam = static_cast<int>(dam * 0.7);

					if (pMob[conn].extra.ClassMaster == ARCH)
						dam = static_cast<int>(dam * 0.8);
				}

				if (InstanceType == 1)
				{
					int MobResist = pMob[idx].MOB.Resist[0];

					if (idx > MAX_USER)
						MobResist = MobResist / 2;

					dam = ((150 - MobResist) * dam) / 100;
				}
				else if (InstanceType >= 2 && InstanceType <= 5)
				{
					int skind = InstanceType - 2;

					int MobResist = pMob[idx].MOB.Resist[skind];

					if (idx >= MAX_USER)
						MobResist = MobResist / 2;

					dam = ((150 - MobResist) * dam) / 100;
				}
			}

			//if ((pMob[conn].MOB.Equip[0].sIndex == 11 || pMob[conn].MOB.Equip[0].sIndex == 16 || pMob[conn].MOB.Equip[0].sIndex == 17 || pMob[conn].MOB.Equip[0].sIndex == 18 || pMob[conn].MOB.Equip[0].sIndex == 19) && pMob[conn].MOB.LearnedSkill & 15)// colocar todos os index de class FM, são 4 verificar se 15 é a oitava de fm
			//	dam -= (dam * 0) / 100;// Aqui estamos diminuindo 40% do seu dano das skills, caso queira mudar, é só mudar o valor ali de 40 pra outro valor

			//Tempestade de flechas
			if (skillnum == 79)
			{
				if (idx < MAX_USER)
					dam = GetSkillDamage_PvP(skillnum, &pMob[conn].MOB, CurrentWeather, pMob[conn].WeaponDamage);

				else
					dam = BASE_GetSkillDamage(skillnum, &pMob[conn].MOB, CurrentWeather, pMob[conn].WeaponDamage);

				int Ac = pMob[idx].MOB.CurrentScore.Ac;

				if (idx < MAX_USER)
					Ac *= 2;

				dam = BASE_GetDamage((int)dam, Ac, master);

			}
			if (skillnum == 86) //Explosão Etéria
			{
				dam += pMob[conn].MOB.CurrentScore.Str;
				dam += pMob[conn].MOB.CurrentScore.Dex;
			}
#pragma endregion
#pragma region Cura / Recuperação
			else if (InstanceType == 6)
			{
				if (pMob[idx].MOB.Clan == 4)
					continue;

				unsigned char getAttribute = GetAttribute(pMob[idx].TargetX, pMob[idx].TargetY) & 0x40;

				if (map_att == 0 && getAttribute)
				{
					m->Dam[i].TargetID = MOB_EMPTY;
					m->Dam[i].Damage = 0;

					continue;
				}


				if (skillnum == 27)
					dam = (Special * 2) + g_pSpell[skillnum].InstanceValue;
				else
					dam = ((Special * 3) / 2) + g_pSpell[skillnum].InstanceValue;

				if (pMob[conn].extra.ClassMaster == MORTAL)
					dam *= 1.4;

				if (pMob[conn].extra.ClassMaster == ARCH)
					dam *= 2.4;

				if (pMob[conn].extra.ClassMaster >= CELESTIAL)
					dam *= 3.4;

				if (pMob[conn].extra.ClassMaster == MORTAL) {
					if (dam > 548)
						dam = 548;
				}

				if (pMob[conn].extra.ClassMaster == ARCH) {
					if (dam > 748)
						dam = 748;
				}

				if (pMob[conn].extra.ClassMaster >= CELESTIAL) {
					if (dam > 1048)
						dam = 1048;
				}

				if (pMob[conn].extra.ClassMaster >= MORTAL)
				{
					if (dam >= 80000)
						dam = 80000;
				}
				else
				{
					if (dam >= 80000)
						dam = 80000;
				}
				dam = -dam;

				if (dam < 0 && dam > -6)
					dam = -6;

				auto multHpMob = pMob[idx].MOB.Equip[13].sIndex;
				auto _tDamage = dam;
				if (multHpMob == 786 || multHpMob == 1936 || multHpMob == 1937)
				{
					int HpItem = GetItemSancNew(&pMob[idx].MOB.Equip[13]);
					if (HpItem < 2)
						HpItem = 2;
					int multHp = 1;
					switch (multHpMob)
					{
					case 1936:
						multHp = 10;
						break;
					case 1937:
						multHp = 1000;
						break;
					default:
						break;
					}
					multHp *= HpItem;

					_tDamage /= multHp;

				}

				if (_tDamage > pMob[idx].MOB.CurrentScore.Hp)
					pMob[idx].MOB.CurrentScore.Hp = 0;
				else
					pMob[idx].MOB.CurrentScore.Hp -= _tDamage;

				int MobHP = pMob[idx].MOB.CurrentScore.Hp;

				if (pMob[idx].MOB.CurrentScore.Hp > pMob[idx].MOB.CurrentScore.MaxHp)
					pMob[idx].MOB.CurrentScore.Hp = pMob[idx].MOB.CurrentScore.MaxHp;

				if (idx > 0 && idx < MAX_USER)
					SetReqHp(idx);

				//int MobHP = pMob[idx].MOB.CurrentScore.Hp;

				//if (pMob[idx].MOB.Equip[13].sIndex == 786)
				//{
				//	int sanc = pMob[idx].MOB.Equip[13].stEffect[0].cValue;
				//	if (sanc < 2)
				//		sanc = 2;

				//	pMob[idx].MOB.CurrentScore.Hp = pMob[idx].MOB.CurrentScore.Hp - ((int)dam / sanc);

				//}
				//else  if (pMob[idx].MOB.Equip[13].sIndex == 1936)
				//{
				//	int sanc = pMob[idx].MOB.Equip[13].stEffect[0].cValue;
				//	if (sanc < 2)
				//		sanc = 2;

				//	sanc *= 10;

				//	pMob[idx].MOB.CurrentScore.Hp = pMob[idx].MOB.CurrentScore.Hp - ((int)dam / (sanc * 10));

				//}

				//else  if (pMob[idx].MOB.Equip[13].sIndex == 1937)
				//{
				//	int sanc = pMob[idx].MOB.Equip[13].stEffect[0].cValue;
				//	if (sanc < 2)
				//		sanc = 2;

				//	sanc *= 1000;

				//	pMob[idx].MOB.CurrentScore.Hp = pMob[idx].MOB.CurrentScore.Hp - ((int)dam / (sanc * 20));

				//}

				//else
				//	pMob[idx].MOB.CurrentScore.Hp = pMob[idx].MOB.CurrentScore.Hp - (int)dam;


				//if (pMob[idx].MOB.CurrentScore.Hp > pMob[idx].MOB.CurrentScore.MaxHp)
				//	pMob[idx].MOB.CurrentScore.Hp = pMob[idx].MOB.CurrentScore.MaxHp;

				//if (idx > 0 && idx < MAX_USER)
				//	SetReqHp(idx);


				int calc_exp = (pMob[idx].MOB.CurrentScore.Hp - MobHP) >> 3;

				if (calc_exp > 120)
					calc_exp = 120;

				if (calc_exp < 0)
					calc_exp = 0;


				if (calc_exp > 0 && conn != idx && conn > 0 && conn < MAX_USER)
				{
					int village = BASE_GetVillage(pMob[idx].TargetX, pMob[idx].TargetY);

					if (village < 0 || village >= 5)
					{
						if (UNK2 < calc_exp)
							UNK2 = calc_exp;
					}
				}
			}
#pragma endregion
#pragma region Flash
			else if (InstanceType == 7)
			{
				pMob[idx].Mode = MOB_PEACE;
				pMob[idx].CurrentTarget = MOB_EMPTY;

				for (int j = 0; j < MAX_ENEMY; j++)
					pMob[idx].EnemyList[j] = MOB_EMPTY;
			}
#pragma endregion
#pragma region Desintoxicar
			else if (InstanceType == 8)
			{
				int NeedUpdate = 0;

				for (int k = 0; k < MAX_AFFECT; k++)
				{
					int Type = pMob[idx].Affect[k].Type;

					if (Type == 1 || Type == 3 || Type == 5 || Type == 7 || Type == 10 || Type == 12 || Type == 20 || (Type == 32 && (1 << 7) & pMob[conn].MOB.LearnedSkill))
					{
						pMob[idx].Affect[k].Type = 0;
						NeedUpdate = 1;
					}
				}

				if (NeedUpdate)
				{
					pMob[idx].GetCurrentScore(idx);
					SendScore(idx);
				}
			}
#pragma endregion
#pragma region Teleporte
			else if (InstanceType == 9)
			{
				if (pMob[idx].MOB.CurrentScore.Hp <= 0)
				{
					SendClientMessage(conn, g_pMessageStringTable[_NN_Cant_Summon_Dead_Person]);
					break;
				}

				unsigned char getAtt = GetAttribute(pMob[conn].TargetX, pMob[conn].TargetY);

				if (getAtt & 0x4 && pMob[conn].MOB.CurrentScore.Level < 1000)
				{
					SendClientMessage(conn, g_pMessageStringTable[_NN_Summon_Not_Allowed_Here]);
					continue;
				}

				if (pMob[idx].MOB.CurrentScore.Hp > pMob[conn].MOB.CurrentScore.Hp + Special + 30)
				{
					SendClientMessage(conn, g_pMessageStringTable[_NN_Too_High_Level_To_Summon]);
					continue;
				}

				unsigned char map_att = GetAttribute(pMob[conn].TargetX, pMob[conn].TargetY);

				if (map_att & 4)
				{
					SendClientMessage(conn, g_pMessageStringTable[_NN_Cant_Use_That_Here]);
					return;
				}

				if (idx < MAX_USER && pUser[idx].Mode == USER_PLAY)
				{
					DoSummon(idx, pMob[conn].TargetX, pMob[conn].TargetY);
					SendClientMessage(idx, strFmt("!Sumonado por [%s]", pMob[conn].MOB.MobName));
					return;
				}
			}
#pragma endregion

#pragma region Invisibilidade
			else if (InstanceType == 10 && idx < MAX_USER)
			{
				for (int l = MAX_USER; l < MAX_MOB; l++)
				{
					if (pMob[l].Mode == MOB_COMBAT && pMob[l].CurrentTarget == idx)
					{
						for (int m = 0; m < MAX_ENEMY; m++)
						{
							if (pMob[l].EnemyList[m] == idx)
								pMob[l].EnemyList[m] = conn;
						}

						pMob[l].CurrentTarget = conn;
					}
				}
			}
#pragma endregion
#pragma region Evock
			else if (InstanceType == 11)
			{
				int instancevalue = g_pSpell[skillnum].InstanceValue;
				if (instancevalue >= 1 && instancevalue <= 50)
				{
					int summons = 0;

					if (instancevalue == 1 || instancevalue == 2)
						summons = pMob[conn].MOB.CurrentScore.Special[2] / 30;

					else if (instancevalue == 3 || instancevalue == 4 || instancevalue == 5)
						summons = pMob[conn].MOB.CurrentScore.Special[2] / 40;

					else if (instancevalue == 6 || instancevalue == 7)
						summons = pMob[conn].MOB.CurrentScore.Special[2] / 80;

					else if (instancevalue == 8)
						summons = 1;

					if (GenerateSummon(conn, instancevalue - 1, 0, summons) == 0)
					{
						pMob[conn].MOB.CurrentScore.Mp = Mp;
						pUser[conn].ReqMp = ReqMp;
					}
				}
				dam = 0;
			}
#pragma endregion
#pragma region Chamas Etéreas
			else if (InstanceType == 12)
			{
				int Leader = pMob[conn].Leader, slot = 0, targetlevel = pMob[idx].MOB.CurrentScore.Level, level = pMob[conn].MOB.CurrentScore.Level, chance, _rand;

				if (Leader <= 0)
					Leader = conn;

				// Personagem
				if (idx < MAX_USER)
				{
					int chance = (pMob[conn].MOB.BaseScore.Special[1] + 1) / 7;
					int Rand = rand() % 100;

					if (Rand > chance)
					{
						int burnmp = ((pMob[idx].MOB.CurrentScore.Mp + 1) / 100) * (10 + rand() % 90);

						if (burnmp > pMob[idx].MOB.CurrentScore.Mp)
							pMob[idx].MOB.CurrentScore.Mp = 0;

						else
							pMob[idx].MOB.CurrentScore.Mp -= burnmp;

						SendSetHpMp(idx);
						SendScore(idx);
						continue;
					}

					for (int k = 0; k < MAX_AFFECT; k++)
					{
						int Type = pMob[idx].Affect[k].Type;

						if (Type == 18 || Type == 16 || Type == 14 || Type == 19 || Type == 32)
						{
							pMob[idx].Affect[k].Type = 0;
							pMob[idx].Affect[k].Value = 0;
							pMob[idx].Affect[k].Level = 0;
							pMob[idx].Affect[k].Time = 0;

							pMob[idx].GetCurrentScore(idx);
							SendScore(idx);
						}
					}

					SendEquip(idx, 0);
					pMob[idx].GetCurrentScore(idx);
					SendScore(idx);

					continue;
				}
			}

#pragma endregion
#pragma region Furia divina
			if (skillnum == 6)
			{
				if (idx >= MAX_USER && pMob[idx].MOB.Merchant != 0)
					break;

				if (pMob[idx].MOB.Equip[0].sIndex == 219 || pMob[idx].MOB.Equip[0].sIndex == 220 || pMob[idx].MOB.Equip[0].sIndex == 362)
					break;

				if (pMob[idx].GenerateIndex == 8 || pMob[idx].GenerateIndex == 9)
					break;

				if (pMob[idx].MOB.Clan == 6)
					break;

				pMob[idx].Route[0] = 0;

				int PosX = pMob[conn].TargetX;

				if (PosX < pMob[idx].TargetX)
					PosX++;

				if (PosX > pMob[idx].TargetX)
					PosX--;

				int PosY = pMob[conn].TargetY;

				if (PosY < pMob[idx].TargetY)
					PosY++;

				if (PosY > pMob[idx].TargetY)
					PosY--;

				if (GetEmptyMobGrid(idx, &PosX, &PosY) == FALSE)
					break;

				int kind2 = pMob[conn].MOB.CurrentScore.Special[1];

				int kindvalue = (kind2 / 10) + 20;

				if (idx > MAX_USER)
					kindvalue = (kind2 / 5) + 40;

				int leveldif = pMob[conn].extra.ClassMaster != MORTAL && pMob[conn].extra.ClassMaster != ARCH ? pMob[conn].MOB.CurrentScore.Level : pMob[conn].MOB.CurrentScore.Level + MAX_LEVEL - (pMob[idx].extra.ClassMaster != MORTAL && pMob[idx].extra.ClassMaster != ARCH ? pMob[idx].MOB.CurrentScore.Level + MAX_LEVEL : pMob[idx].MOB.CurrentScore.Level);

				leveldif = leveldif >> 2;

				int _chance = kindvalue + leveldif;

				if (_chance > 50)
					_chance = 50;

				if (rand() % 100 >= _chance)
					break;

				MSG_Action sm_act;
				memset(&sm_act, 0, sizeof(MSG_Action));

				GetAction(idx, PosX, PosY, &sm_act);

				sm_act.Effect = 2;
				sm_act.Speed = 6;

				GridMulticast(idx, PosX, PosY, (MSG_STANDARD*)&sm_act);

				if (idx < MAX_USER)
				{
					memset(&sm_act, 0, sizeof(MSG_Action));
					GetAction(idx, PosX, PosY, &sm_act);

					sm_act.Effect = 2;
					sm_act.Speed = 6;

					if (!pUser[idx].cSock.AddMessage((char*)&sm_act, sizeof(MSG_Action)))
						CloseUser(conn);
				}

				if (idx >= MAX_USER)
					SetBattle(idx, conn);

				break;
			}
#pragma endregion


#pragma region Exterminar
			else if (skillnum == 22)
			{
				int CurrentMp = pMob[conn].MOB.CurrentScore.Mp;

				pMob[conn].MOB.CurrentScore.Mp = 0;

				m->CurrentMp = 0;

				int kind4 = pMob[conn].MOB.CurrentScore.Special[3];

				int _INT = pMob[conn].MOB.CurrentScore.Int;
				dam = (dam + _INT);//+ (_INT / 3);

				int PosX = pMob[idx].TargetX;
				int PosY = pMob[idx].TargetY;

				if (GetEmptyMobGrid(conn, &PosX, &PosY) != 0 && pMob[idx].MOB.Equip[0].sIndex != 219 && pMob[idx].MOB.Equip[0].sIndex != 220)
				{
					MSG_Action sm_act;
					memset(&sm_act, 0, sizeof(MSG_Action));

					GetAction(conn, PosX, PosY, &sm_act);

					sm_act.Type = 2;
					sm_act.Speed = 2;

					GridMulticast(conn, PosX, PosY, (MSG_STANDARD*)&sm_act);

					if (!pUser[conn].cSock.AddMessage((char*)&sm_act, sizeof(MSG_Action)))
						CloseUser(conn);
				}
			}
#pragma endregion

#pragma region Julgamento divino
			else if (skillnum == 30)
			{
				dam = dam + hp;

				pMob[conn].MOB.CurrentScore.Hp = ((pMob[conn].MOB.CurrentScore.Hp) / 6) + 1;
				pUser[conn].ReqHp = pMob[conn].MOB.CurrentScore.Hp;
			}
#pragma endregion
#pragma region Renascimento 
			else if (skillnum == 31)
			{
				bool isParty = false;

				if (idx > 0 && idx < MAX_USER)
				{
					int saveLeader = pMob[idx].Leader;
					if (saveLeader == 0)
						saveLeader = idx;
					if (saveLeader > 0 && saveLeader < MAX_USER && pUser[saveLeader].Mode == USER_PLAY)
					{
						bool member1 = false;
						bool member2 = false;
						for (int i = 0; i < MAX_PARTY; i++)
						{
							if (conn <= 0 || conn >= MAX_USER)
								continue;

							if (pUser[conn].Mode != USER_PLAY)
								continue;

							if (conn == pMob[saveLeader].PartyList[i])
							{
								member1 = true;
								continue;
							}
							if (conn == saveLeader)
							{
								member1 = true;
							}
							if (idx == pMob[saveLeader].PartyList[i])
							{
								member2 = true;
							}
							if (idx == saveLeader)
							{
								member2 = true;
							}

							if (member1 && member2)
							{
								isParty = true;
								break;
							}
						}
					}

				}


				if (pMob[idx].MOB.Guild == pMob[conn].MOB.Guild && pMob[conn].MOB.Guild != 0 || isParty == true)
				{
					int hp = (rand() % 10 + 90) * ((pMob[conn].MOB.CurrentScore.MaxHp + 1) / 100);

					unsigned char getAtt = GetAttribute(pMob[conn].TargetX, pMob[conn].TargetY);

					pMob[conn].MOB.CurrentScore.Mp = 0;

					m->CurrentMp = 0;

					SendSetHpMp(conn);

					if ((rand() % 100) < 50)
					{
						pMob[idx].MOB.CurrentScore.Hp = pMob[idx].MOB.CurrentScore.MaxHp;
						pMob[idx].GetCurrentScore(idx);
						SendScore(idx);

						pMob[idx].MOB.CurrentScore.Mp = pMob[idx].MOB.CurrentScore.MaxMp;
						pMob[idx].GetCurrentScore(idx);
						SendScore(idx);
						pUser[idx].NumError = 0;
						SendScore(idx);
						SendSetHpMp(idx);
						SendEtc(idx);

						MSG_CreateMob CreateMob;
						GetCreateMob(idx, &CreateMob);
						GridMulticast(pMob[idx].TargetX, pMob[idx].TargetY, (MSG_STANDARD*)&CreateMob, 0);
					}
				}
			}
#pragma endregion
			//#pragma region Renascimento 
			//			else if (skillnum == 31)
			//			{
			//				if (pMob[idx].Leader == NULL && pMob[idx].MOB.Guild != pMob[conn].MOB.Guild)
			//				{
			//					SendClientMessage(conn, "Você não pode usar essa skill em membros que não forem da sua guild ou estejam em Grupo.");
			//					return;
			//				}
			//
			//				int hp = (rand() % 10 + 90) * ((pMob[conn].MOB.CurrentScore.MaxHp + 1) / 100);
			//
			//				unsigned char getAtt = GetAttribute(pMob[conn].TargetX, pMob[conn].TargetY);
			//
			//				pMob[conn].MOB.CurrentScore.Mp = 0;
			//				pUser[conn].ReqMp = 0;
			//
			//				m->CurrentMp = 0;
			//
			//				SendSetHpMp(conn);
			//				if ((rand() % 100) < 90)
			//				{
			//					pMob[idx].MOB.CurrentScore.Hp = pMob[idx].MOB.CurrentScore.MaxHp;
			//					pMob[idx].GetCurrentScore(idx);
			//					SendScore(idx);
			//
			//					pMob[idx].MOB.CurrentScore.Mp = pMob[idx].MOB.CurrentScore.MaxMp;
			//					pMob[idx].GetCurrentScore(idx);
			//					SendScore(idx);
			//					pUser[idx].NumError = 0;
			//					SendScore(idx);
			//					SendSetHpMp(idx);
			//					SendEtc(idx);
			//
			//					MSG_CreateMob CreateMob;
			//					GetCreateMob(idx, &CreateMob);
			//					GridMulticast(pMob[idx].TargetX, pMob[idx].TargetY, (MSG_STANDARD*)&CreateMob, 0);
			//				}
			//			}
			//#pragma endregion
#pragma region Velocidade
			else if (skillnum == 41)
			{
				int skill_target = (Special / 25) + 2;

				if (skill_target >= MAX_TARGET)
					skill_target = MAX_TARGET;

				if (skill_target <= 1)
					skill_target = 2;

				for (int q = 0; q < skill_target && ((q < MAX_TARGET && m->Size >= sizeof(MSG_Attack)) || (q < 1 && m->Size >= sizeof(MSG_AttackOne)) || (q < 2 && m->Size >= sizeof(MSG_AttackTwo))); q++)
				{
					int targetidx = m->Dam[q].TargetID;

					if (targetidx <= MOB_EMPTY || targetidx >= MAX_USER)
						continue;

					if (pUser[targetidx].Mode != USER_PLAY)
						continue;

					if (SetAffect(targetidx, skillnum, Delay, Level) == 0)
						continue;

					SendScore(targetidx);
				}

				break;
			}
#pragma endregion
#pragma region Arma Magica
			else if (skillnum == 44)
			{
				int skill_target = (Special / 25) + 2;

				if (skill_target >= MAX_TARGET)
					skill_target = MAX_TARGET;

				if (skill_target <= 1)
					skill_target = 2;

				for (int q = 0; q < skill_target && ((q < MAX_TARGET && m->Size >= sizeof(MSG_Attack)) || (q < 1 && m->Size >= sizeof(MSG_AttackOne)) || (q < 2 && m->Size >= sizeof(MSG_AttackTwo))); q++)
				{
					int targetidx = m->Dam[q].TargetID;
					if (targetidx <= MOB_EMPTY || targetidx >= MAX_USER)
						continue;

					if (pUser[targetidx].Mode != USER_PLAY)
						continue;

					if (SetAffect(targetidx, skillnum, Delay, Level) == 0)
						continue;

					SendScore(targetidx);
				}

				break;
			}
#pragma endregion
#pragma region Cancelamento
			else if (skillnum == 47)
			{
				int CancelContinue = 0;

				for (int k = 0; k < MAX_AFFECT; k++)
				{
					int Type = pMob[idx].Affect[k].Type;

					if (Type == 19)
					{
						pMob[idx].Affect[k].Type = 0;
						pMob[idx].Affect[k].Value = 0;
						pMob[idx].Affect[k].Level = 0;
						pMob[idx].Affect[k].Time = 0;
						pMob[idx].GetCurrentScore(idx);
						SendScore(idx);
						CancelContinue = 1;
						break;
					}
				}

				if (CancelContinue == 1)
					break;
			}
#pragma region Book Vinha
			else if (skillnum == 98)
			{
				if (m->TargetX < 0 || m->TargetX >= MAX_GRIDX || m->TargetY < 0 || m->TargetY >= MAX_GRIDY)
					break;

				unsigned char getAttribute = GetAttribute(m->TargetX, m->TargetY);
				getAttribute = getAttribute & 0x40;

				if (map_att == 0 && getAttribute == 1)
					continue;

				CreateMob("Vinha", m->TargetX, m->TargetY, "BaseSummon", 3);
				break;
			}

#pragma endregion

			int Aggressive = g_pSpell[skillnum].Aggressive;

			int SameLeaderGuild = 1;

			if (Aggressive != 0)
			{
				if (leader == mobleader || Guild == MobGuild)
					SameLeaderGuild = 0;

				int affectresist = g_pSpell[skillnum].AffectResist;

				int idxlevel = pMob[idx].extra.ClassMaster == MORTAL || pMob[idx].extra.ClassMaster == ARCH || pMob[idx].extra.ClassMaster == CELESTIAL || pMob[idx].extra.ClassMaster == CELESTIALCS || pMob[idx].extra.ClassMaster == SCELESTIAL ? pMob[idx].MOB.CurrentScore.Level : pMob[idx].MOB.CurrentScore.Level + MAX_LEVEL;//ByLords2
				int connlevel = pMob[conn].extra.ClassMaster == MORTAL || pMob[idx].extra.ClassMaster == ARCH || pMob[idx].extra.ClassMaster == CELESTIAL || pMob[idx].extra.ClassMaster == CELESTIALCS || pMob[idx].extra.ClassMaster == SCELESTIAL ? pMob[conn].MOB.CurrentScore.Level : pMob[conn].MOB.CurrentScore.Level + MAX_LEVEL;//ByLords2
				int difLevel = (idxlevel - connlevel) / 2;

				difLevel = -difLevel;

				if (affectresist >= 1 && affectresist <= 4)
				{
					int random = rand() % 100;

					if (random > pMob[idx].MOB.RegenMP + affectresist + difLevel)
						SameLeaderGuild = 0;
				}

				if ((pMob[idx].MOB.Rsv & 0x80) != FALSE)
					SameLeaderGuild = 0;

				if (conn < MAX_USER && pMob[idx].MOB.Clan == 6)
					SameLeaderGuild = 0;
			}

#pragma region Buff
			if (SameLeaderGuild)
			{
				if (skillnum == 102)
				{
					if (pMob[conn].extra.ClassMaster == MORTAL)
						Delay = 200;

					else if (pMob[conn].extra.ClassMaster != MORTAL && pMob[conn].extra.ClassMaster != ARCH)
					{
						Delay = 200;

						if (pMob[conn].MOB.CurrentScore.Level < 39)
							Delay -= (39 - (pMob[conn].MOB.CurrentScore.Level)) * 4;

						else if (pMob[conn].MOB.CurrentScore.Level >= 199)
							Delay = 400;

						else
							Delay = 200;
					}
				}

				if (SetAffect(idx, skillnum, Delay, Special) != 0)
					UNK2 = TRUE;

				if (SetTick(idx, skillnum, Delay, Special) != 0)
					UNK2 = TRUE;

				if (UNK2 != FALSE)
				{
					pMob[idx].GetCurrentScore(idx);
					SendScore(idx);
				}
			}
#pragma endregion

#pragma region Transformação
			if (skillnum == 64 || skillnum == 66 || skillnum == 68 || skillnum == 70 || skillnum == 71)
			{
				pMob[conn].GetCurrentScore(conn);
				SendScore(conn);
				SendEquip(conn, 0);
			}
#pragma endregion

#pragma region Book Ressureição
			if (pMob[conn].MOB.CurrentScore.Hp == 0 && skillnum == 99)
			{
				int rev = rand() % 115;

				if (rev > 100)
					rev -= 15;

				if (rev >= 80)
				{
					pMob[conn].MOB.CurrentScore.Hp = 2;
					pUser[conn].NumError = 0;
					SendScore(conn);
					SendSetHpMp(conn);
					DoRecall(conn);
					SendEtc(conn);
				}

				int hp = (rand() % 50 + 1) * ((pMob[conn].MOB.CurrentScore.MaxHp + 1) / 100);

				pMob[conn].MOB.CurrentScore.Hp = pMob[conn].MOB.CurrentScore.MaxHp;
				pUser[conn].NumError = 0;
				SendScore(conn);
				SendSetHpMp(conn);
				SendEtc(conn);

				MSG_CreateMob CreateMob;
				GetCreateMob(conn, &CreateMob);
				GridMulticast(pMob[conn].TargetX, pMob[conn].TargetY, (MSG_STANDARD*)&CreateMob, 0);
			}
#pragma endregion

		}
#pragma endregion
		else
		{
			//Log("err,dam not -2 -1 MSG_ATTACK", pUser[conn].AccountName, pUser[conn].IP);
			return;
		}

		m->Dam[i].Damage = dam;

		if (dam <= 0)
			continue;

#pragma region Perfuracao		   
		if (idx < MAX_USER || pMob[idx].MOB.Clan == 4)
		{
			if ((m->DoubleCritical & 4) != 0)
				dam = m->Dam[1].Damage + (dam >> 2);

			else
				dam = dam >> 2;
		}

		if (pMob[conn].ForceDamage != 0)
		{
			if (dam <= 1)
				dam = pMob[conn].ForceDamage;

			else if (dam > 0)
				dam = dam + pMob[conn].ForceDamage;

			m->Dam[i].Damage = dam;
		}
#pragma endregion

#pragma region Ataque PvP
		if (pMob[conn].PvPDamage != 0 && idx < MAX_USER)
		{
			if (dam < 1)
				dam += dam * pMob[conn].PvPDamage / 100;

			else if (dam > 0)
				dam += dam / 100 * pMob[conn].PvPDamage;

			m->Dam[i].Damage = dam / 2;
		}
#pragma endregion

		if (leader == mobleader || Guild == MobGuild)
			dam = 0;

		if (idx >= MAX_USER && isFrag != FALSE)
			dam = 0;

		int Summoner = idx;

		if (idx >= MAX_USER && pMob[idx].MOB.Clan == 4 && pMob[idx].Summoner > 0 && pMob[idx].Summoner < MAX_USER && pUser[pMob[idx].Summoner].Mode == USER_PLAY)
			Summoner = pMob[idx].Summoner;

#pragma region PK - War - Miss

		if (Summoner < MAX_USER)
		{
			int pointPK = GetPKPoint(conn);
			int SummonerPointPK = GetPKPoint(Summoner);

			int arena = BASE_GetArena(pMob[conn].TargetX, pMob[conn].TargetY);
			int village = BASE_GetVillage(pMob[conn].TargetX, pMob[conn].TargetY);

			int mapX = pMob[conn].TargetX >> 7;
			int mapY = pMob[conn].TargetY >> 7;

			int MapPK = 0;
			int isWar = 0;

			int connGuild = pMob[conn].MOB.Guild;
			int SummonerGuild = pMob[Summoner].MOB.Guild;
			int maxguild = 65536;

			if (connGuild > 0 && connGuild < maxguild && SummonerGuild > 0 && SummonerGuild < maxguild && g_pGuildWar[connGuild] == SummonerGuild && g_pGuildWar[SummonerGuild] == connGuild)
				isWar = 1;

			if (CastleState != 0 && mapX == 8 && mapY == 13)
				isWar = 1;

			if (mapX == 1 && mapY == 31)
				MapPK = 1;

			// PK
			if (arena == MAX_GUILDZONE && village == MAX_GUILDZONE && MapPK == FALSE && isWar == FALSE)
			{
				if (pointPK <= 10 && SummonerPointPK > 10)
				{
					SendClientMessage(conn, strFmt(g_pMessageStringTable[_DN_CantKillUser], pointPK));
					dam = 0;
				}
				else if (SummonerPointPK > 10 && dam > 0 || skillnum == 6)
				{
					int Guilty = GetGuilty(conn);
					SetGuilty(conn, 8);

					if (Guilty == 0)
					{
						MSG_CreateMob mob;
						GetCreateMob(conn, &mob);
						GridMulticast(pMob[conn].TargetX, pMob[conn].TargetY, (MSG_STANDARD*)&mob, 0);
					}

					if (skillnum == 6)
						break;
				}
			}

			// Miss
			if (idx != conn)
			{
				int attackdex = pMob[conn].MOB.CurrentScore.Dex / 5;

				if (pMob[conn].MOB.LearnedSkill & 0x1000000)
					attackdex += 100;

				if (pMob[conn].MOB.Rsv & 0x40)
					attackdex += 500;

				int parryretn = GetParryRate(&pMob[conn].MOB, pMob[conn].MOB.CurrentScore.Dex, pMob[conn].MOB.Rsv, pMob[conn].Parry, pMob[idx].MOB.CurrentScore.Dex, pMob[idx].MOB.Rsv, pMob[idx].Parry);

				if (pMob[conn].extra.SecLearnedSkill & 0x100) // Espelho Mágico
				{
					int Special = (pMob[conn].MOB.CurrentScore.Special[3] / 2);

					parryretn -= Special;
				}

				if (skillnum == 79 || skillnum == 22)
					parryretn = 30 * parryretn / 100;

				int rd = rand() % 1000 + 1;

				if (rd < parryretn)
				{
					dam = -3;

					if ((pMob[idx].MOB.Rsv & 0x200) != 0 && rd < 100)
						dam = -4;
				}

				if (dam == -4 || dam == -3)  // Verifica se o DAM é -4 ou -3;
					pMob[idx].MissPlayer = TRUE; // Define na variavel MissPlayer quando o idx ataca ele é o conn, definindo o conn eu como idx;

				if (pMob[conn].MissPlayer == TRUE && dam > 0) // Verifica se o dano da variavel MissPlayer é -4 ou -3 e compara 
				{
					if (pMob[conn].MOB.Class == 3 && (pMob[conn].extra.SecLearnedSkill & 0x1)) //Verifica a Classe juntamente a Nona;
					{
						dam *= 1.5;
						pMob[conn].MissPlayer = FALSE;
					}
				}
			}
		}
#pragma endregion

		if (mylevel <= MAX_LEVEL)
		{
			if (idx < MAX_USER)
			{
				unsigned char TargetMapAttribute = GetAttribute(pMob[idx].TargetX, pMob[idx].TargetY);
				unsigned char MapAttribute = GetAttribute(pMob[conn].TargetX, pMob[conn].TargetY);

				if (TargetMapAttribute & 0x1 || (TargetMapAttribute & 64) == 0)
					dam = 0;

				if (MapAttribute & 0x1 || (MapAttribute & 64) == 0)
					dam = 0;
			}
		}

		if (pMob[idx].MOB.Class == 0) // Proteção Divina
		{
			for (int i = 0; i < MAX_AFFECT; i++)
			{
				if (pMob[idx].Affect[i].Type == 6 && dam > 0)
					dam = 0;
			}
		}

		if (pMob[idx].MOB.Class == 1) // Proteção Absoluta
		{
			for (int i = 0; i < MAX_AFFECT; i++)
			{
				if (pMob[idx].Affect[i].Type == 6 && dam > 0)
					dam = 0;
			}
		}

		if (pMob[idx].MOB.Clan == 6 && Level < MAX_LEVEL)
			dam = 0;

		if (idx > MAX_USER && dam > 1)
			dam += pMob[conn].ForceMobDamage;

		if (dam > MAX_DAMAGE)
			dam = MAX_DAMAGE;

		///if (dam > MAX_DAMAGE_MG)
		//dam = MAX_DAMAGE_MG

		m->Dam[i].Damage = dam;

		if (dam < 0)
			continue;

		//GELO
		if ((pMob[conn].MOB.Rsv & RSV_FROST) != 0)
		{
			bool Tempestade = false;
			if (skillnum == 79)
				Tempestade = true;

			if (rand() % 2 == 0 && Tempestade == false)
			{
				int skind2 = pMob[conn].MOB.CurrentScore.Special[1];

				if (SetAffect(idx, 36, skind2 + 150, skind2) != 0)
					SendScore(idx);

				if (SetTick(idx, 36, skind2 + 150, skind2) != 0)
					SendScore(idx);
			}
		}

		if ((pMob[conn].MOB.Rsv & RSV_DRAIN) != 0)
		{
			if (rand() % 2 == 0)
			{
				int skind2 = pMob[conn].MOB.CurrentScore.Special[1];

				if (SetAffect(idx, 40, skind2 + 150, skind2) != 0)
					SendScore(idx);

				if (SetTick(idx, 40, skind2 + 150, skind2) != 0)
					SendScore(idx);
			}
		}

		if (idx > 0 && idx < MAX_USER && dam > 0)
		{
			if (pMob[idx].ReflectDamage > 0)// Absorcao
				dam = dam - pMob[idx].ReflectDamage;

			if (dam <= 0)
				dam = 1;


			if (pMob[idx].ReflectPvP > 0)
				dam = dam - (dam / 100 * pMob[idx].ReflectPvP);

			if (dam < 0)
				dam = 1;

			m->Dam[i].Damage = dam;
		}

		if (pMob[conn].TargetX >= 1017 && pMob[conn].TargetX <= 1290 && pMob[conn].TargetY >= 1911 && pMob[conn].TargetY <= 2183 && dam > 0 && pMob[conn].MOB.Clan == pMob[idx].MOB.Clan)
		{
			m->Dam[i].Damage = 0;
			m->Dam[i].TargetID = 0;

			continue;
		}

		int _pDamage = dam;
		int _calcDamage = 0;
		int pTargetMountId = pMob[idx].MOB.Equip[14].sIndex;

		if (idx < MAX_USER && pTargetMountId >= 2360 && pTargetMountId < 2390 && pMob[idx].MOB.Equip[14].stEffect[0].sValue > 0)
		{

			_pDamage = (dam * 3) >> 2;
			_calcDamage = dam - _pDamage;
			if (_pDamage <= 0)
				_pDamage = 1;

			m->Dam[i].Damage = _pDamage;
		}

		int tDamage = _pDamage;


#pragma region Controle de Mana
		if (pMob[idx].MOB.Class == 1) {
			for (int c = 0; c < MAX_AFFECT; c++) // Controle de Mana ( PVP )
			{
				if (pMob[idx].Affect[c].Type == 18)
				{
					// Reserva de 5% de mana para não tomar dano na mana e não conseguir usar skill
					if (pMob[idx].MOB.CurrentScore.Mp > pMob[idx].MOB.CurrentScore.MaxMp / 100 * 5)
					{
						int mana = pMob[idx].MOB.CurrentScore.Mp - (tDamage / 100) * 90;

						if (mana < 0)
						{
							tDamage -= mana / 10;
							mana = 0;
							pMob[idx].MOB.CurrentScore.Mp = mana;
							pUser[idx].ReqMp = mana;
							SetReqMp(idx);
							SendScore(idx);
						}
						else {

							pMob[idx].MOB.CurrentScore.Mp -= tDamage;
							pUser[idx].ReqMp -= tDamage;
							if (pMob[idx].MOB.CurrentScore.Mp <= 0)
							{
								mana = 0;
								pMob[idx].MOB.CurrentScore.Mp = mana;
								pUser[idx].ReqMp = mana;
							}
							SetReqMp(idx);
							SendScore(idx);
						}


						int abs = (1 << 23) & pMob[conn].MOB.LearnedSkill ? 55 : 60;

						tDamage = ((tDamage >> 1) + (tDamage << 4)) / abs;
						m->Dam[i].Damage = tDamage;

						if ((DoubleCritical & 4) != FALSE)
							m->Dam[1].Damage = tDamage;
					}
				}
			}
		}
#pragma endregion

		auto multHpMob = pMob[idx].MOB.Equip[13].sIndex;
		auto _tDamage = tDamage;
		if (multHpMob == 786 || multHpMob == 1936 || multHpMob == 1937)
		{
			int HpItem = GetItemSancNew(&pMob[idx].MOB.Equip[13]);
			if (HpItem < 2)
				HpItem = 2;
			int multHp = 1;
			switch (multHpMob)
			{
				case 1936:
					multHp = 10;
					break;
				case 1937:
					multHp = 1000;
					break;
				default:
					break;
			}
			multHp *= HpItem;

			_tDamage /= multHp;

		}

		if (_tDamage > pMob[idx].MOB.CurrentScore.Hp)
			pMob[idx].MOB.CurrentScore.Hp = 0;
		else
			pMob[idx].MOB.CurrentScore.Hp -= _tDamage;

		if (_calcDamage > 0)
			ProcessAdultMount(idx, _calcDamage / 2);

		if (idx > 0 && idx < MAX_USER)
		{
			pUser[idx].ReqHp = pUser[idx].ReqHp - tDamage;
			SetReqHp(idx);
		}

		if (idx > MAX_USER && pMob[idx].MOB.Clan == 4)
			LinkMountHp(idx);

		//if (pMob[idx].MOB.Equip[13].sIndex == 786)
		//{

		//	int itemSanc = pMob[idx].MOB.Equip[13].stEffect[0].cValue;
		//	if (itemSanc < 2)
		//		itemSanc = 2;


		//	tDamage = _pDamage / itemSanc;
		//	if (tDamage > pMob[idx].MOB.CurrentScore.Hp)
		//		tDamage = pMob[idx].MOB.CurrentScore.Hp;

		//	pMob[idx].MOB.CurrentScore.Hp = pMob[idx].MOB.CurrentScore.Hp - tDamage;
		//}

		//else if (pMob[idx].MOB.Equip[13].sIndex == 1936)//10X HP MONSTRO
		//{

		//	int itemSanc = pMob[idx].MOB.Equip[13].stEffect[0].cValue;
		//	if (itemSanc < 2)
		//		itemSanc = 2;

		//	itemSanc *= 10;

		//	tDamage = _pDamage / itemSanc;

		//	if (tDamage > pMob[idx].MOB.CurrentScore.Hp)
		//		tDamage = pMob[idx].MOB.CurrentScore.Hp;

		//	pMob[idx].MOB.CurrentScore.Hp = pMob[idx].MOB.CurrentScore.Hp - tDamage;
		//}

		//else if (pMob[idx].MOB.Equip[13].sIndex == 1937)//20X HP MONSTRO
		//{
		//	int itemSanc = pMob[idx].MOB.Equip[13].stEffect[0].cValue;
		//	if (itemSanc < 2)
		//		itemSanc = 2;

		//	itemSanc *= 1000;

		//	tDamage = _pDamage / itemSanc;

		//	if (tDamage > pMob[idx].MOB.CurrentScore.Hp)
		//		tDamage = pMob[idx].MOB.CurrentScore.Hp;

		//	pMob[idx].MOB.CurrentScore.Hp = pMob[idx].MOB.CurrentScore.Hp - tDamage;
		//}

		//else
		//{
		//	if (tDamage > pMob[idx].MOB.CurrentScore.Hp)
		//		tDamage = pMob[idx].MOB.CurrentScore.Hp;


		//	pMob[idx].MOB.CurrentScore.Hp = pMob[idx].MOB.CurrentScore.Hp - tDamage;
		//}

		//if (_calcDamage > 0)
		//	ProcessAdultMount(idx, _calcDamage / 2);

		//if (idx > 0 && idx < MAX_USER)
		//{
		//	pUser[idx].ReqHp = pUser[idx].ReqHp - tDamage;

		//	SetReqHp(idx);
		//}


		//if (idx > MAX_USER && pMob[idx].MOB.Clan == 4)
		//	LinkMountHp(idx);


#pragma region Joia Abs
		if (pMob[conn].HpAbs != 0 && (rand() % 2) == 0 && dam >= 1)
		{
			int RecHP = (int)((dam * pMob[conn].HpAbs + 1) / 50);

			/*int RecMP = (int)((dam * pMob[conn].HpAbs + 1) / 50);*/

			if (RecHP > 350)
				RecHP = 350;

			/*if (RecMP > 350)
				RecMP = 350;*/


				/*int reqmp = pUser[conn].ReqMp + RecMP;

				if (reqmp > pMob[conn].MOB.CurrentScore.MaxMp)
					pUser[conn].ReqMp = pMob[conn].MOB.CurrentScore.MaxMp;
				else
					pUser[conn].ReqMp = reqmp;*/



			int reqhp = pUser[conn].ReqHp + RecHP;

			if (reqhp > pMob[conn].MOB.CurrentScore.MaxHp)
				pUser[conn].ReqHp = pMob[conn].MOB.CurrentScore.MaxHp;
			else
				pUser[conn].ReqHp = reqhp;


			SetReqHp(conn);
			SendSetHpMp(conn);
		}
#pragma endregion


#pragma region Anti Freze Player
		if (pMob[idx].MOB.CurrentScore.Hp <= 0)
		{
			pMob[idx].MOB.CurrentScore.Hp = 0;
			MSG_CreateMob sm_tb;
			memset(&sm_tb, 0, sizeof(MSG_CreateMob));
			GridMulticast(pMob[idx].TargetX, pMob[idx].TargetY, (MSG_STANDARD*)&sm_tb, 0);
		}
#pragma endregion
#pragma endregion

		if (pMob[idx].MOB.CurrentScore.Hp <= 0)
		{
			pMob[idx].MOB.CurrentScore.Hp = 0;
			TargetKilled[i] = idx;
			continue;
		}

		// Evocation and Party mob group
		if (pMob[idx].Mode != MOB_EMPTY && pMob[idx].MOB.CurrentScore.Hp > 0)
		{
			SetBattle(idx, conn);

			pMob[conn].CurrentTarget = idx;

			int mleader = pMob[conn].Leader;
			if (mleader <= MOB_EMPTY)
				mleader = conn;

			int r = 0;
			for (r = MOB_EMPTY; r < MAX_PARTY; r++)
			{
				int partyMemberId = pMob[mleader].PartyList[r];
				if (partyMemberId <= MAX_USER)
					continue;

				if (pMob[partyMemberId].Mode == MOB_EMPTY || pMob[partyMemberId].MOB.CurrentScore.Hp <= 0)
				{
					if (pMob[partyMemberId].Mode != MOB_EMPTY)
						DeleteMob(partyMemberId, 1);

					pMob[mleader].PartyList[r] = MOB_EMPTY;
				}
				else
					SetBattle(partyMemberId, idx);
			}

			for (r = MOB_EMPTY; r < MAX_PARTY; r++)
			{
				int partyMemberId = pMob[mleader].Evocations[r];
				if (partyMemberId <= MAX_USER)
					continue;

				if (pMob[partyMemberId].Mode == MOB_EMPTY || pMob[partyMemberId].MOB.CurrentScore.Hp <= 0)
				{
					if (pMob[partyMemberId].Mode != MOB_EMPTY)
						DeleteMob(partyMemberId, 1);

					pMob[mleader].Evocations[r] = MOB_EMPTY;
				}
				else
					SetBattle(partyMemberId, idx);
			}

			mleader = pMob[idx].Leader;

			if (mleader <= 0)
				mleader = idx;

			for (r = 0; r < MAX_PARTY; r++)
			{
				int ptMemberId = pMob[mleader].PartyList[r];
				if (ptMemberId <= MAX_USER)
					continue;

				if (pMob[ptMemberId].Mode == MOB_EMPTY || pMob[ptMemberId].MOB.CurrentScore.Hp <= 0)
				{
					if (pMob[ptMemberId].Mode != MOB_EMPTY)
						DeleteMob(ptMemberId, 1);

					pMob[mleader].PartyList[r] = MOB_EMPTY;
				}
				else
					SetBattle(ptMemberId, conn);
			}

			for (r = 0; r < MAX_PARTY; r++)
			{
				int ptMemberId = pMob[mleader].Evocations[r];
				if (ptMemberId <= MAX_USER)
					continue;

				if (pMob[ptMemberId].Mode == MOB_EMPTY || pMob[ptMemberId].MOB.CurrentScore.Hp <= 0)
				{
					if (pMob[ptMemberId].Mode != MOB_EMPTY)
						DeleteMob(ptMemberId, 1);

					pMob[mleader].Evocations[r] = MOB_EMPTY;
				}
				else
					SetBattle(ptMemberId, conn);
			}
		}
	}
#pragma endregion

	if (UNK2 > 0)
		Exp = UNK2;

	if (DOUBLEMODE)
		Exp = Exp * 2;

	if (Exp <= 0)
		Exp = 0;

	if (Exp > 200)
		Exp = 200;

	//Espectral
	if ((pMob[conn].MOB.LearnedSkill & 0x20000000) != 0)
		m->DoubleCritical = m->DoubleCritical | 8;

	m->CurrentExp = pMob[conn].MOB.Exp;
	m->CurrentHp = pMob[conn].MOB.CurrentScore.Hp;

	if (ClientTick == SKIPCHECKTICK)
		m->ClientTick = CurrentTime;

	if (skillnum != 102)
		GridMulticast(pMob[conn].TargetX, pMob[conn].TargetY, (MSG_STANDARD*)m, 0);

	if (skillnum == 30)
		SendSetHpMp(conn);

#pragma region MobKilled Check
	for (int i = 0; i < MAX_TARGET; i++)
	{
		if (TargetKilled[i] > 0 && TargetKilled[i] < MAX_MOB && pMob[TargetKilled[i]].Mode != MOB_EMPTY)
			MobKilled(TargetKilled[i], conn, 0, 0);
	}
#pragma endregion
#pragma region Level Check

	int Segment = pMob[conn].CheckGetLevel();

	if (Segment >= 1 && Segment <= 4)
	{
		if (Segment == 4)
		{/*
			SendClientMessage(conn, g_pMessageStringTable[_NN_Level_Up]);*/
			SetCircletSubGod(conn);
			//SendEtc(conn);

			/*if (pMob[conn].extra.ClassMaster == MORTAL) {
				DoItemLevel(conn);
				
			}*/
		}
		if (Segment == 3)/*
			SendClientMessage(conn, g_pMessageStringTable[_NN_3_Quarters_Bonus]);*/

			if (Segment == 2)/*
				SendClientMessage(conn, g_pMessageStringTable[_NN_2_Quarters_Bonus]);*/

				if (Segment == 1)/*
					SendClientMessage(conn, g_pMessageStringTable[_NN_1_Quarters_Bonus]);*/

					SendScore(conn);
		SendEmotion(conn, 14, 3);

		if (Segment == 4)
		{
			//SendEtc(conn);

			int PKPoint = GetPKPoint(conn) + 5;
			SetPKPoint(conn, PKPoint);

			MSG_CreateMob sm_lup;
			memset(&sm_lup, 0, sizeof(MSG_CreateMob));
			GetCreateMob(conn, &sm_lup);

			GridMulticast(pMob[conn].TargetX, pMob[conn].TargetY, (MSG_STANDARD*)&sm_lup, 0);

		}
	}
#pragma endregion
}


# -------------------- _MSG_Buy.cpp --------------------


#include "ProcessClientMessage.h"
#include <iostream>
#include <cstdlib>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <random>
#include <ctime>
#include "SendFunc.h"
#include "Functions.h"

void Exec_MSG_Buy(int conn, char* pMsg)
{
	MSG_Buy* m = (MSG_Buy*)pMsg;

	int Size = m->Size;

	if (Size > sizeof(MSG_Buy)) //CONTROLE DE SIZE
	{
		SendClientMessage(conn, "Impossível executar ação7, tente mais tarde. ");
		return;
	}

	if (m->TargetID != 0 && m->TargetID < MAX_USER || m->TargetID >= MAX_MOB) {
		return;
	}

	int invpos = (m->TargetInvenPos % 9);

	if (m->TargetInvenPos < 0 || m->TargetInvenPos > 62 || invpos < 0 || invpos > 9) {
		return;
	}

	if (m->MyInvenPos < 0 || m->MyInvenPos >= MAX_CARRY - 4) {
		return;
	}

	if (m->Coin < 0 || m->Coin > 2000000000) {
		return;
	}

	int TargetID = m->TargetID;
	int TargetInvenPos = m->TargetInvenPos;
	int MyInvenPos = m->MyInvenPos;



	if (pMob[conn].MOB.CurrentScore.Hp == 0 || pUser[conn].Mode != USER_PLAY)
	{
		SendHpMode(conn);
		//AddCrackError(conn, 10, 21);
		return;
	}

	if (pUser[conn].TradeMode)
	{
		RemoveTrade(pUser[conn].Trade.OpponentID);
		RemoveTrade(conn);
		return;
	}

	if (pUser[conn].Trade.OpponentID)
	{
		RemoveTrade(conn);
		return;
	}

	if (pUser[conn].Ingame.DonateBuyItem > 1000)
		TargetID = pUser[conn].Ingame.DonateBuyItem;

	int itemIndex = pMob[TargetID].MOB.Carry[TargetInvenPos].sIndex;

	if (itemIndex <= 0 || itemIndex >= MAX_ITEMLIST) {
		return;
	}

	if (pUser[conn].Ingame.DonateBuyItem <= 0)
	{
		if (TargetID < MAX_USER || TargetID >= MAX_MOB || TargetInvenPos < 0 || TargetInvenPos >= MAX_CARRY || MyInvenPos < 0 || MyInvenPos >= MAX_CARRY)
		{
			if (TargetID < MAX_USER && TargetID == conn)
			{
				if (TargetInvenPos > 27)
					return;

				if (TargetInvenPos < 0)
					return;

				if (TargetInvenPos >= 9)
					TargetInvenPos = 27;

				if (TargetInvenPos == 27)
					TargetInvenPos = 9;

				if (TargetInvenPos < 10)
				{
					auto My = pMob[conn].Rebuy[TargetInvenPos].Item;

					if (My.sIndex <= 0 || My.sIndex >= MAX_ITEMLIST)
						return;

					int szPrice = g_pItemList[My.sIndex].Price;

					int Qnt = 1;

					for (int i = 0; i < 3; i++) {
						if (My.stEffect[i].cEffect == 61)
							Qnt = My.stEffect[i].sValue;
					}

					szPrice = szPrice * Qnt;

					if (szPrice > pMob[conn].MOB.Coin)
					{
						SendClientMessage(conn, g_pMessageStringTable[_NN_Havent_Money_So_Much]);

						return;
					}

					if (PutItem(conn, &My))
					{
						memset(&pMob[conn].Rebuy[TargetInvenPos].Item, 0, sizeof(STRUCT_ITEM));
						pMob[conn].Rebuy[TargetInvenPos].Price = 0;
						pMob[conn].Rebuy[TargetInvenPos].Ticks = 0;

						SendRecycle(conn);

						pMob[conn].MOB.Coin -= szPrice;

						SendEtc(conn);
					}
				}
				return;
			}
		}
	}

	if (pUser[conn].Ingame.CanBuy == 0) {
		return;
	}

	if (pUser[conn].Ingame.DonateBuyItem <= 0 && pMob[TargetID].MOB.Merchant != 1)
	{
		SendClientMessage(conn, g_pMessageStringTable[_NN_Only_Merchant_Sells]);
		return;
	}
	if (pUser[conn].Ingame.DonateBuyItem <= 0)
	{

		if (!GetInHalf(conn, TargetID))
		{
			SendClientSignal(conn, ESCENE_FIELD, _MSG_CloseShop);
			return;
		}
	}

	int pos = 0;
	int i = 0;
	int amount = 0;
	int Loop = 30;


	STRUCT_ITEM* ItemMob = &pMob[TargetID].MOB.Carry[TargetInvenPos];
	unsigned int Donate = BASE_GetItemAbility(ItemMob, EF_DONATE);
	unsigned int Honra = BASE_GetItemAbility(ItemMob, EF_HONRA);


	// SISTEMAS DE BUY
	/*if (strcmp(pMob[TargetID].MOB.MobName, "Jephi") == 0) {
		NewJephi(conn, TargetID, TargetInvenPos, itemIndex);
		return;
	}*/

	if (strcmp(pMob[TargetID].MOB.MobName, "Armas F") == 0 || strcmp(pMob[TargetID].MOB.MobName, "Sets F") == 0 ||
		strcmp(pMob[TargetID].MOB.MobName, "Refinaveis F") == 0 || strcmp(pMob[TargetID].MOB.MobName, "Quests F") == 0) {
		FiltroDrop(conn, ItemMob->sIndex);
		return;
	}

	if (strcmp(pMob[TargetID].MOB.MobName, "Thorin") == 0) //npc pvp armia batalha real
	{
		if (itemIndex == 5661)// ID DO ITEM DA LOJA
		{
			if (pMob[conn].extra.ClassMaster > MORTAL)
			{
				SendClientMessage(conn, "Quest apenas para Morais.");
				return;
			}

			time_t rawnow = time(NULL);
			struct tm now;
			localtime_s(&now, &rawnow);

			for (int i = 0; i < 20; i++) // i = maximo de player na batalha = 20
			{
				if (p_BatalhaReal.Members[i].Id == conn && strcmp(p_BatalhaReal.Members[i].Name, pMob[conn].MOB.MobName) == 0 && p_BatalhaReal.start == false)
				{
					SendSay(itemIndex, strFmt("Aguarde [%d] minutos para o início da batalha.", 5 - now.tm_min));
					return;
				}

			}

			if (pMob[conn].Leader || pMob[conn].Leader == -1)
			{
				SendClientMessage(conn, "Não é permitido registro em grupo.");
				return;
			}
			int i = 0;
			if (now.tm_wday > 0 && now.tm_wday < 7)
			{
				if (now.tm_min <= 5)
				{
					if (p_BatalhaReal.NumMembers < 20)
					{
						p_BatalhaReal.NumMembers += 1;

						for (int i = 1; i < MAX_USER; i++)
						{
							if (pUser[i].Mode != USER_PLAY) continue;

							
							snprintf(temp, sizeof(temp), "[%s] Registrou-se na Batalha Real - Vagas [0%d/20].", pMob[conn].MOB.MobName, p_BatalhaReal.NumMembers);
							SendSpkMsg(i, temp, TNColor::Speak, false);
						}
						int Num;

						for (Num = 0; Num < 20; Num++)//Numero de Vagas Disponiveis
						{
							if (p_BatalhaReal.Members[Num].Id == 0x0)
							{
								p_BatalhaReal.Members[Num].Id = conn;
								memmove_s(&p_BatalhaReal.Members[Num].Name, 16, &pMob[conn].MOB.MobName, 16);
								break;
							}
						}
						return;
					}
					else
					{
						SendClientMessage(conn, "Limite de jogadores foi atingido. Desculpe.");
						return;
					}
				}
				else
				{
					SendClientMessage(conn, "O registro é permitido de segunda a sábado do minuto 0 ao 5");
					return;
				}

			}
			else
			{
				SendClientMessage(conn, "Não é possível batalhar nos fins de semana.");
				return;
			}
			return;
		}
	}


	/* Donate funciona puxando o id da gener do npc */
	if (Donate)
	{
		/*SendClientMessage(conn, "A compra de itens donate será liberado no sábado 12h");
		return;*/

		if (Donate > pUser[conn].Donate)
		{
			SendClientMessage(conn, strFmt(g_pMessageStringTable[_DN_NeedDonate], Donate));
			return;
		}

		if (pUser[conn].Lasclick != itemIndex)
		{
			pUser[conn].Lasclick = itemIndex;
			SendClientMessage(conn, strFmt("Deseja realmente comprar [ %s ] por [ %d ] Donate ?", g_pItemList[itemIndex].Name, Donate));
			return;
		}

		if (itemIndex == 0)
		{
			SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, "err,buy request null item from shop donate - MSG_BUY");
			return;
		}

		if (pMob[conn].MOB.Carry[m->MyInvenPos].sIndex != 0)
		{
			SendItem(conn, ITEM_PLACE_CARRY, m->MyInvenPos, &pMob[conn].MOB.Carry[m->MyInvenPos]);
			return;
		}

		int pos = 0;

		for (pos = 0; pos < pMob[conn].MaxCarry && pos < MAX_CARRY; pos++)
		{
			if (pMob[conn].MOB.Carry[pos].sIndex == 0)
				break;
		}

		if (pos >= 0 && pos < pMob[conn].MaxCarry && pos < MAX_CARRY)
		{
			pUser[conn].Donate -= Donate;
			SendEtc(conn);
			UpdateDonate(conn);

			SendEtc(conn);
			PutItem(conn, ItemMob);
			SendCarry(conn);
			SaveUser(conn, 0);
		}

		else
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_You_Have_No_Space_To_Trade]);
			return;
		}

		SendClientMessage(conn, strFmt("Comprou o item [ %s ] por [ %d] restam [ %d ] de Donate", g_pItemList[itemIndex].Name, Donate, pUser[conn].Donate));
		
		snprintf(temp, sizeof(temp), "%s comprou o item %s por %d donate e restou %d de Donate", pMob[conn].MOB.MobName, g_pItemList[itemIndex].Name, Donate, pUser[conn].Donate);
		ItemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);
		return;
	}

	if (Honra)
	{
		if (Honra > pUser[conn].Honra)
		{
			SendClientMessage(conn, "Honra Insuficiente!");
			return;
		}

		if (itemIndex == 0)
		{
			SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, "err,buy request null item from shop honra - MSG_BUY");
			return;
		}

		if (pMob[conn].MOB.Carry[m->MyInvenPos].sIndex != 0)
		{
			SendItem(conn, ITEM_PLACE_CARRY, m->MyInvenPos, &pMob[conn].MOB.Carry[m->MyInvenPos]);
			return;
		}

		int pos = 0;

		for (pos = 0; pos < pMob[conn].MaxCarry && pos < MAX_CARRY; pos++)
		{
			if (pMob[conn].MOB.Carry[pos].sIndex == 0)
				break;
		}

		if (pos >= 0 && pos < pMob[conn].MaxCarry && pos < MAX_CARRY)
		{

			pUser[conn].Honra -= Honra;
			SendEtc(conn);

			int Eff = ItemMob->stEffect[1].cEffect;
			int Qnt = ItemMob->stEffect[1].cValue;

			STRUCT_ITEM Item;
			memset(&Item, 0, sizeof(Item));

			Item.sIndex = ItemMob->sIndex;
			Item.stEffect[0].cEffect = ItemMob->stEffect[0].cEffect;
			Item.stEffect[0].cValue = ItemMob->stEffect[0].cValue;
			Item.stEffect[1].cEffect = ItemMob->stEffect[1].cEffect;
			Item.stEffect[1].cValue = ItemMob->stEffect[1].cValue;
			Item.stEffect[2].cEffect = ItemMob->stEffect[2].cEffect;
			Item.stEffect[2].cValue = ItemMob->stEffect[2].cValue;

			if (Item.stEffect[0].cEffect == 92) {
				Item.stEffect[0].cEffect = 0;
				Item.stEffect[0].cValue = 0;
			}
			if (Item.stEffect[1].cEffect == 92) {
				Item.stEffect[1].cEffect = 0;
				Item.stEffect[1].cValue = 0;
			}
			if (Item.stEffect[2].cEffect == 92) {
				Item.stEffect[2].cEffect = 0;
				Item.stEffect[2].cValue = 0;
			}

			if (Eff == 61 && (pMob[conn].MOB.Equip[13].sIndex == 3901 || pMob[conn].MOB.Equip[13].sIndex == 3902))
			{
				while (Qnt >= 1) {
					SendItemagrupar(conn, ItemMob->sIndex);
					Qnt -= 1;
				}
			}
			else
				PutItem(conn, &Item);

			SendCarry(conn);
			SaveUser(conn, 0);
		}

		else
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_You_Have_No_Space_To_Trade]);
			return;
		}
		SendClientMessage(conn, strFmt("Comprou o item [ %s ] por [ %d] restam [ %d ] de Honra", g_pItemList[itemIndex].Name, Honra, pUser[conn].Honra));

		
		snprintf(temp, sizeof(temp), "%s comprou o item %s por %d honra e restou %d de Honra", pMob[conn].MOB.MobName, g_pItemList[itemIndex].Name, Honra, pUser[conn].Honra);
		ItemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);

		return;
	}

	int Price = g_pItemList[itemIndex].Price;

	int Qnt = 1;

	for (int i = 0; i < 3; i++) {
		if (pMob[TargetID].MOB.Carry[TargetInvenPos].stEffect[i].cEffect == 61)
			Qnt = pMob[TargetID].MOB.Carry[TargetInvenPos].stEffect[i].cValue;
	}

	Price = Price * Qnt;


	int Price2 = Price;
	int Village = BASE_GetVillage(pMob[TargetID].TargetX, pMob[TargetID].TargetY);
	int CityTax = g_pGuildZone[Village].CityTax;

	if (Village < 0 || Village >= 5 || CityTax <= 0 || CityTax >= 30)
		goto LABEL_BUY1;

	if (Price < 100000)
		Price += Price * CityTax / 100;

	else
		Price += Price * CityTax / 100;

	if (Price < 0)
		return;

	int GuildTax = (Price - Price2) / 2;
LABEL_BUY1:

	int bPrice = Price;
	int Desconto = 0;
	int TargetVillage = BASE_GetVillage(pMob[TargetID].TargetX, pMob[TargetID].TargetY);
	int Guild = pMob[conn].MOB.Guild;

	if (Price <= 1999999999 && TargetVillage >= 0 && TargetVillage < 5 && Guild > 0 && g_pGuildZone[TargetVillage].ChargeGuild == Guild)
	{
		Desconto = 30;
		Price = 7 * Price / 10;
	}

	if (Price <= 1999999999 && !Desconto && pMob[conn].MOB.Class == 3 && pMob[conn].MOB.LearnedSkill & 0x800)
	{
		int special = (pMob[conn].MOB.CurrentScore.Special[2] / 10) + 6;

		if ((pMob[conn].MOB.CurrentScore.Special[2] / 10) + 6 >= 26)
			special = 26;

		Desconto = special;
		special /= 2;

	}

	if (Price > pMob[conn].MOB.Coin)
	{
		SendClientMessage(conn, g_pMessageStringTable[_NN_Not_Enough_Money]);
		return;
	}

	if (itemIndex == 0)
	{
		return;
	}

	if (pMob[conn].MOB.Carry[m->MyInvenPos].sIndex != 0)
	{
		SendItem(conn, ITEM_PLACE_CARRY, m->MyInvenPos, &pMob[conn].MOB.Carry[m->MyInvenPos]);
		return;
	}

	if (itemIndex == 508 || itemIndex == 509 || itemIndex == 446 || itemIndex >= 526 && itemIndex <= 531)
	{
		if (ServerIndex == -1)
		{
			return;
		}

		if (!GuildCounter)
		{
			return;
		}

		if (itemIndex == 508 || itemIndex == 446 || itemIndex >= 526 && itemIndex <= 531)
		{
			if (!pMob[conn].MOB.GuildLevel)
			{
				SendClientMessage(conn, g_pMessageStringTable[114]);
				return;
			}
			if (pMob[conn].MOB.GuildLevel < 2 && itemIndex >= 526 && itemIndex <= 531)
			{
				SendClientMessage(conn, g_pMessageStringTable[114]);
				return;
			}
			ItemMob->stEffect[0].cEffect = 56;
			ItemMob->stEffect[0].cValue = Guild;
			ItemMob->stEffect[1].cEffect = 57;
			ItemMob->stEffect[1].cValue = Guild;

			if (itemIndex == 508)
			{
				int sub = BASE_GetSubGuild(pMob[conn].MOB.Equip[12].sIndex);

				ItemMob->stEffect[2].cEffect = 85;
				ItemMob->stEffect[2].cValue = sub;

				if (sub >= 1 && sub <= 3)
					ItemMob->sIndex = sub + 531;
			}
		}

		if (itemIndex == 509)
		{
			ItemMob->stEffect[0].cEffect = 56;
			ItemMob->stEffect[0].cValue = (GuildCounter + (ServerIndex << 12)) >> 8;

			ItemMob->stEffect[1].cEffect = 57;
			ItemMob->stEffect[1].cValue = GuildCounter;

			ItemMob->stEffect[2].cEffect = 59;
			ItemMob->stEffect[2].cValue = rand();

			int GCount = GuildCounter + (ServerIndex << 12);

			GuildCounter++;

			if (GuildCounter >= 4096)
			{
				GuildCounter = 2048;
			}
			CReadFiles::WriteGuild();
		}
	}

	if (itemIndex >= 2300 && itemIndex < 2330)
	{
		ItemMob->stEffect[1].cEffect = EF_INCUBATE;
		ItemMob->stEffect[1].cValue = (rand() % 7 + 1);
	}


	if (Price >= 0)
	{
		int x = 0;

		for (x = 0; x < MAX_MOB_MERC; x++)
		{
			//Verifica se o vendedor é um mob mercador especial.
			if (pMob[TargetID].GenerateIndex == pMobMerc[x].GenerateIndex)
				break;
		}

		if (x != MAX_MOB_MERC)
		{//O Vendedor é um mob mercador especial, portanto ele verifica se ainda possui unidades daquele item 
		 //se tiver ele diminui do stock caso contrário ele avisa que não tem.
			if (pMobMerc[x].Stock[TargetInvenPos] == 0)
			{
				SendClientMessage(conn, g_pMessageStringTable[_NN_NOSTOCK]);
				return;
			}
			pMobMerc[x].Stock[TargetInvenPos]--;
		}

		if (TargetVillage >= 0 && TargetVillage < 5 && CityTax > 0 && CityTax < 30)
		{
			if (GuildImpostoID[TargetVillage] >= MAX_USER && GuildImpostoID[TargetVillage] < MAX_MOB && pMob[GuildImpostoID[TargetVillage]].Mode != USER_EMPTY && pMob[GuildImpostoID[TargetVillage]].MOB.Guild == g_pGuildZone[TargetVillage].ChargeGuild)
			{
				if (pMob[GuildImpostoID[TargetVillage]].MOB.Exp < 200000000000)
					pMob[GuildImpostoID[TargetVillage]].MOB.Exp += GuildTax / 2;


			}
			if (GuildImpostoID[4] >= MAX_USER && GuildImpostoID[4] < MAX_MOB && GuildTax > 0 && pMob[GuildImpostoID[4]].Mode != USER_EMPTY && pMob[GuildImpostoID[4]].MOB.Guild == g_pGuildZone[4].ChargeGuild)
			{
				if (pMob[GuildImpostoID[4]].MOB.Exp < 200000000000)
					pMob[GuildImpostoID[4]].MOB.Exp += GuildTax;

			}
		}

		if (MyInvenPos >= 0 && MyInvenPos < pMob[conn].MaxCarry && MyInvenPos < MAX_CARRY)
			pMob[conn].MOB.Coin -= Price;

		m->Coin = pMob[conn].MOB.Coin;

		m->ID = ESCENE_FIELD;

		int Size = m->Size;

		if (Size > sizeof(MSG_Buy))
		{
			m->Size = 0;
			return;
		}
		if (!pUser[conn].cSock.AddMessage((char*)m, m->Size))
			CloseUser(conn);

		SendEtc(conn);
	DonateBuy:

		if (MyInvenPos >= 0 && MyInvenPos < pMob[conn].MaxCarry && MyInvenPos < MAX_CARRY)
		{
			memmove_s(&pMob[conn].MOB.Carry[MyInvenPos], sizeof(STRUCT_ITEM), ItemMob, sizeof(STRUCT_ITEM));

			//PutItem(conn, ItemMob);

			char tmplog[2048];
			BASE_GetItemCode(ItemMob, tmplog);


			SendItem(conn, ITEM_PLACE_CARRY, m->MyInvenPos, &pMob[conn].MOB.Carry[m->MyInvenPos]);
		}
		else
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_You_Have_No_Space_To_Trade]);
			return;
		}

		if (FREEEXP == -2)
		{
			SendSay(TargetID, strFmt("%s base:%d tax:%d(%d%%) discount:%d(%d%%)", g_pItemList[itemIndex].Name, Price2, bPrice, CityTax, Price, Desconto));
		}

		if (itemIndex == 787 || itemIndex == 481)
		{
			pMob[TargetID].PotionCount++;

			if (pMob[TargetID].PotionCount > POTIONCOUNT)
				DeleteMob(TargetID, 3);
		}
		if (pMob[TargetID].MOB.Equip[0].sIndex == 259 || pMob[TargetID].MOB.Equip[0].sIndex == 230)
			DeleteMob(TargetID, 3);
	}
	else
		SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, "err,MSG_ReqBuy  <><><> MINUS <><><>");


}

# -------------------- _MSG_CapsuleInfo.cpp --------------------

/*
*   Copyright (C) {2015}  {Victor Klafke, Charles TheHouse}
*
*   This program is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program.  If not, see [http://www.gnu.org/licenses/].
*
*   Contact at: victor.klafke@ecomp.ufsm.br
*/
#include "ProcessClientMessage.h"

void Exec_MSG_CapsuleInfo(int conn, char *pMsg)
{
	MSG_STANDARDPARM *m = (MSG_STANDARDPARM*)pMsg;

	int Size = m->Size;

	if (Size > sizeof(MSG_STANDARDPARM)) //CONTROLE DE SIZE
	{
		SendClientMessage(conn, "Impossível executar ação8, tente mais tarde. ");
		return;
	}

	int Index = m->Parm;

	m->ID = conn;
	m->Type = _MSG_DBCapsuleInfo;

	DBServerSocket.SendOneMessage((char*)m, sizeof(MSG_STANDARDPARM));
}

# -------------------- _MSG_Challange.cpp --------------------

/*
*   Copyright (C) {2015}  {Victor Klafke, Charles TheHouse}
*
*   This program is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program.  If not, see [http://www.gnu.org/licenses/].
*
*   Contact at: victor.klafke@ecomp.ufsm.br
*/
#include "ProcessClientMessage.h"

void Exec_MSG_Challange(int conn, char *pMsg)
{
	MSG_STANDARDPARM* m = (MSG_STANDARDPARM*)pMsg;

	int target = m->Parm;

	if (target <= 0 || target >= MAX_MOB)
		return;

	int zone = pMob[target].MOB.BaseScore.Level;

	if (zone < 0 || zone >= ValidGuild)
		return;

	int Size = m->Size;

	if (Size > sizeof(MSG_STANDARDPARM)) //CONTROLE DE SIZE
	{
		SendClientMessage(conn, "Impossível executar ação9, tente mais tarde. ");
		return;
	}

	if (zone != 5)
	{
		char ChargeName[256];
		char ChallName[256];

		int charge = g_pGuildZone[zone].ChargeGuild;
		int chall = g_pGuildZone[zone].ChallangeGuild;

		BASE_GetGuildName(ServerGroup, charge, ChargeName);
		BASE_GetGuildName(ServerGroup, chall, ChallName);

		if (WeekMode && WeekMode != 1 && WeekMode != 2 && WeekMode != 3)
		{
			if (WeekMode == 4)
			{
				if(pMob[conn].MOB.Guild && pMob[conn].MOB.Guild == g_pGuildZone[zone].ChargeGuild && pMob[conn].MOB.GuildLevel == 9)
				{
					long long Coin = (pMob[GuildImpostoID[zone]].MOB.Exp+1) / 1000000000;

					if(pMob[GuildImpostoID[zone]].MOB.Exp <= 0)
					{
						SendSay(target, strFmt(g_pMessageStringTable[_I64D_TOWN_TAX], pMob[target].MOB.Exp));
						return;
					}


					if(Coin == 0)
					{
						long long bGold = pMob[GuildImpostoID[zone]].MOB.Exp;
						long long fGold = pMob[GuildImpostoID[zone]].MOB.Exp + pMob[conn].MOB.Coin;

						if(fGold <= 2000000000)
						{
							SendClientMessage(conn, g_pMessageStringTable[_NN_GIVE_TOWN_TAX]);

							pMob[GuildImpostoID[zone]].MOB.Exp = 0;

							pMob[conn].MOB.Coin = (int)fGold;

							SendEtc(conn);

							sprintf_s(temp, "etc,imposto recolhido(1) zone:%d coin:%llu", zone, bGold);
							SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);
							return;
						}
						else
						{
							SendClientMessage(conn, g_pMessageStringTable[_NN_Cant_get_more_than_2G]);
							return;
						}
					}

					else
					{
						STRUCT_ITEM Item;
						memset(&Item, 0, sizeof(STRUCT_ITEM));

						Item.sIndex = 4011;

						int i = 0;

						for(i = (int)Coin; i > 0; i--)
						{
							if(PutItem(conn, &Item) == 0)
								return;

							pMob[GuildImpostoID[zone]].MOB.Exp -= 1000000000;

							sprintf_s(temp, "etc,imposto recolhido(2) zone:%d coin:%d", zone, 1);
							SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);
						}

						SendClientMessage(conn, g_pMessageStringTable[_NN_GIVE_TOWN_TAX]);
						return;
					}
				}
				SendSay(target, strFmt(g_pMessageStringTable[_I64D_TOWN_TAX], pMob[target].MOB.Exp));
			}
			else if (WeekMode == 5)
				SendClientSignal(conn, 0, _MSG_ReqChallange);
		}

		else
		{
			if (g_pGuildZone[zone].ChallangeGuild)
			{
				SendSay(target, strFmt(g_pMessageStringTable[_DS_S_Challanged], pChallangerMoney[zone], ChallName));
				SendSay(target, strFmt(g_pMessageStringTable[_SS_Champion_And_Challanger], ChargeName, ChallName));
			}
			else
			{
				SendSay(target, strFmt(g_pMessageStringTable[_SN_No_Challanger], ChargeName));
			}
		}
	}
}

# -------------------- _MSG_ChallangeConfirm.cpp --------------------

/*
*   Copyright (C) {2015}  {Victor Klafke, Charles TheHouse}
*
*   This program is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program.  If not, see [http://www.gnu.org/licenses/].
*
*   Contact at: victor.klafke@ecomp.ufsm.br
*/
#include "ProcessClientMessage.h"

void Exec_MSG_ChallangeConfirm(int conn, char *pMsg)
{
	MSG_STANDARDPARM2 *m = (MSG_STANDARDPARM2*)pMsg;

	int Size = m->Size;

	if (Size > sizeof(MSG_STANDARDPARM2)) //CONTROLE DE SIZE
	{
		SendClientMessage(conn, "Impossível executar ação10, tente mais tarde. ");
		return;
	}

	int target = m->Parm1;

	if (target <= 0 || target >= MAX_MOB)
		return;

	int zone = pMob[target].MOB.Merchant - 6;

	if (zone >= 0 && zone < ValidGuild && zone != 4)
		Challange(conn, target, 0);
}

# -------------------- _MSG_ChangeCity.cpp --------------------

/*
*   Copyright (C) {2015}  {Victor Klafke, Charles TheHouse}
*
*   This program is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program.  If not, see [http://www.gnu.org/licenses/].
*
*   Contact at: victor.klafke@ecomp.ufsm.br
*/
#include "ProcessClientMessage.h"

void Exec_MSG_ChangeCity(int conn, char *pMsg)
{
	int tx = pMob[conn].TargetX;
	int ty = pMob[conn].TargetY;

	int city = BASE_GetVillage(tx, ty);

	if (city >= 0 && city <= 4)
	{
		pMob[conn].MOB.Merchant &= 0x3F;
		pMob[conn].MOB.Merchant |= city << 6;
	}

}

# -------------------- _MSG_CharacterLogin.cpp --------------------

/*
*   Copyright (C) {2015}  {Victor Klafke, Charles TheHouse}
*
*   This program is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program.  If not, see [http://www.gnu.org/licenses/].
*
*   Contact at: victor.klafke@ecomp.ufsm.br
*/
#include "ProcessClientMessage.h"

void Exec_MSG_CharacterLogin(int conn, char *pMsg)
{
	MSG_CharacterLogin* m = (MSG_CharacterLogin*)pMsg;
	STRUCT_MOB* p = (STRUCT_MOB*)pMsg;


	if (m->Size > sizeof(MSG_CharacterLogin))
		m->Size = sizeof(MSG_CharacterLogin);

	if (pUser[conn].Mode == USER_WAITDB || pUser[conn].Mode != USER_CHARWAIT)
		return;

	if (m->Slot < 0 || m->Slot >= MOB_PER_ACCOUNT)
	{
		SendClientMessage(conn, g_pMessageStringTable[_NN_SelectCharacter]);
		return;
	}
	if (pUser[conn].SelChar.Score[m->Slot].Level < FREEEXP || pUser[conn].SelChar.Score[m->Slot].Level >= 999 || BILLING != 2)
		goto Label1;

	if (pUser[conn].Unk_1816 > 1)
	{
		if (pUser[conn].Unk_1816 == 3)
		{
			SendClientMessage(conn, strFmt(g_pMessageStringTable[_DN_Not_Allowed_Account], FREEEXP));

			SendClientSignalParm(conn, 0, 404, 0);
			pUser[conn].cSock.SendMessageA();
		}
		else
		{
			if (pUser[conn].Unk_1816 == 4)
				SendClientMessage(conn, g_pMessageStringTable[_NN_Using_Other_Server_Group]);

			else
			{
			Label1:
				
				if (pUser[conn].SelChar.Score[m->Slot].Level >= FREEEXP && pUser[conn].SelChar.Score[m->Slot].Level < 999
					&& BILLING == 3 && pUser[conn].SelChar.Score[m->Slot].Level >= 1000)
				{
					if (pUser[conn].Unk_1816 <= 1)
						SendClientMessage(conn, g_pMessageStringTable[_NN_Wait_Checking_Billing]);

					if (pUser[conn].Unk_1816 == 3)
					{
						SendClientMessage(conn, strFmt(g_pMessageStringTable[_DN_Not_Allowed_Account], FREEEXP));
					}

					if (pUser[conn].Unk_1816 == 4)
						SendClientMessage(conn, g_pMessageStringTable[_NN_Using_Other_Server_Group]);
				}

				if (BILLING != 2 || pUser[conn].Unk_2728 != 1 || pUser[conn].SelChar.Score[m->Slot].Level < FREEEXP || g_Hour > 7 && g_Hour < 23)
				{
					if (pUser[conn].Mode == USER_CHARWAIT)
					{
						m->Type = _MSG_DBCharacterLogin;
						m->ID = conn;

						pUser[conn].Mode = USER_WAITDB;
						pMob[conn].Mode = MOB_USER;

						pMob[conn].MOB.Merchant = 0;

						DBServerSocket.SendOneMessage((char*)m, sizeof(MSG_CharacterLogin));
					}
					else
					{
						SendClientMessage(conn, "Wait a moment.");
						//sprintf(temp, "err,charlogin not user_selchar %d %d", conn, pUser[conn].Mode);
						//Log(temp, pUser[conn].AccountName, pUser[conn].IP);
					}
				}
				else
					SendClientMessage(conn, g_pMessageStringTable[_NN_Child_Pay]);
			}
		}
	}
	else
	{
		if (pUser[conn].Unk_2732 && pUser[conn].Unk_2732 < SecCounter - 10)
		{
			pUser[conn].Unk_2732 = 0;
			pUser[conn].Unk_1816 = 5;
		}
		else
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Wait_Checking_Billing]);
			SendBilling(conn, pUser[conn].AccountName, 1, 1);
		}
	}
	return;
}

# -------------------- _MSG_CharacterLogout.cpp --------------------

/*
*   Copyright (C) {2015}  {Victor Klafke, Charles TheHouse}
*
*   This program is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program.  If not, see [http://www.gnu.org/licenses/].
*
*   Contact at: victor.klafke@ecomp.ufsm.br
*/
#include "ProcessClientMessage.h"

void Exec_MSG_CharacterLogout(int conn, char *pMsg)
{
	if (pUser[conn].Mode != USER_PLAY)
		return;


	auto tick = GetTickCount64();
	if (pUser[conn].AtrasocharLogout != 0)
	{
		int isTime = tick - pUser[conn].AtrasocharLogout; // atraso da requisição de voltar tela de seleção de personagens

		if (isTime < 500)
		{
			pUser[conn].AtrasocharLogout = tick;
			return;
		}

	}
	pUser[conn].AtrasocharLogout = tick;

	RemoveParty(conn);
	CharLogOut(conn);
}

# -------------------- _MSG_CombineItem.cpp --------------------


#include "ProcessClientMessage.h"

void Exec_MSG_CombineItem(int conn, char* pMsg)
{
	MSG_CombineItem* m = (MSG_CombineItem*)pMsg;

	int Size = m->Size;

	if (Size > sizeof(MSG_CombineItem)) //CONTROLE DE CLIENTE SIZE
	{
		SendClientMessage(conn, "Impossível executar ação11, tente mais tarde. ");
		return;
	}
	if (pUser[conn].Atraso != 0)
	{
		int isTime = GetTickCount64() - pUser[conn].Atraso; // ATRASO PACOTE

		if (isTime < 800)
		{
			SendClientMessage(conn, "Aguarde 1 segundo para uma nova Tentativa.");
			return;
		}

	}
	pUser[conn].Atraso = GetTickCount64();

	for (int i = 0; i < MAX_COMBINE; i++)
	{
		int invPos = m->InvenPos[i];

		if (m->Item[i].sIndex == 0)
			continue;

		if (invPos == -1) {
			Combinelogsitem(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, "dup,Tentativa de Dup CombineItem");
			return;
		}

		if (invPos < 0 || invPos >= pMob[conn].MaxCarry)
		{
			RemoveTrade(conn);
			return;
		}

		if (memcmp(&pMob[conn].MOB.Carry[invPos], &m->Item[i], sizeof(STRUCT_ITEM)))
		{
			Combinelogsitem(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, "err,msg_CombineItem - item remove or changed.");
			SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 0);
			return;
		}
	}

	int combine = GetMatchCombine(m->Item);

	if (combine == 0)
	{
		SendClientMessage(conn, g_pMessageStringTable[_NN_Wrong_Combination]);
		SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 0);
		return;
	}

	for (int i = 0; i < MAX_COMBINE; i++)
	{
		if (m->Item[i].sIndex == 0)
			continue;

		memset(&pMob[conn].MOB.Carry[m->InvenPos[i]], 0, sizeof(STRUCT_ITEM));
		SendItem(conn, ITEM_PLACE_CARRY, m->InvenPos[i], &pMob[conn].MOB.Carry[m->InvenPos[i]]);
	}


	int _rand = rand() % 115;
	if (_rand >= 100)
		_rand -= 15;

	if (_rand <= combine || LOCALSERVER)
	{
		int itemindex = m->Item[0].sIndex;
		int extra = g_pItemList[itemindex].Extra;

		if (extra > 0 && extra < MAX_ITEMLIST)
		{
			int ipos = m->InvenPos[0];
			int joia = m->Item[1].sIndex - 2441;

			if (joia >= 0 && joia <= 3)
			{
				memmove_s(&pMob[conn].MOB.Carry[ipos].sIndex, sizeof(STRUCT_ITEM), &m->Item[0], sizeof(STRUCT_ITEM));

				pMob[conn].MOB.Carry[ipos].sIndex = joia + extra;

				BASE_SetItemSanc(&pMob[conn].MOB.Carry[ipos], 7, 0);

				
				snprintf(temp, sizeof(temp), "Jogador [%s] Sucesso no anct item: %s %d %d %d %d %d %d %d chance [%d/%d]", pMob[conn].MOB.MobName, g_pItemList[itemindex].Name, g_pItemList[itemindex].Extra,
					pMob[conn].MOB.Carry[ipos].stEffect[0].cEffect, pMob[conn].MOB.Carry[ipos].stEffect[0].cValue, //EF1 EFV1
					pMob[conn].MOB.Carry[ipos].stEffect[1].cEffect, pMob[conn].MOB.Carry[ipos].stEffect[1].cValue, //EF2 EFV2
					pMob[conn].MOB.Carry[ipos].stEffect[2].cEffect, pMob[conn].MOB.Carry[ipos].stEffect[2].cValue, _rand, combine); //EF3 EFV3
				Combinelogsitem(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);

				//SendSpkMsg(1, strFmt("Jogador [%s] Sucesso no anct item: %s", pMob[conn].MOB.MobName, g_pItemList[itemindex].Name), TNColor::GreenYellow, true);

				SendClientMessage(conn, strFmt("Sucesso na Composição Anct [%d/%d]", _rand, combine));
				SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 1);
				SendItem(conn, ITEM_PLACE_CARRY, ipos, &pMob[conn].MOB.Carry[ipos]);
				SendCarry(conn);
				SaveUser(conn, 0);
				return;
			}
			else
			{
				Combinelogsitem(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, strFmt("err,msg_combine - stone wrong %d", joia));
				return;
			}
		}
		else
		{
			Combinelogsitem(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, strFmt("err,msg_combine - extra item index wrong %d", itemindex));
			return;
		}
	}
	else
	{
		/*
		snprintf(temp, sizeof(temp), "%s Teve falha na composição anct do item.", pMob[conn].MOB.MobName);
		SendSpkMsg(1, temp, TNColor::Red, true);*/

		SendClientMessage(conn, strFmt("Falha na Composiçao Anct [%d/%d]", _rand, combine));
		Combinelogsitem(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, "Falha na composição anct do item");

		SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 2);
		SaveUser(conn, 0);

		return;
	}
}

# -------------------- _MSG_CombineItemAgatha.cpp --------------------


#include "ProcessClientMessage.h"

void Exec_MSG_CombineItemAgatha(int conn, char* pMsg)
{
	MSG_CombineItem* m = (MSG_CombineItem*)pMsg;

	int Size = m->Size;

	if (Size > sizeof(MSG_CombineItem)) //CONTROLE DE SIZE
	{
		SendClientMessage(conn, "Impossível executar ação12, tente mais tarde. ");
		return;
	}
	if (pUser[conn].Atraso != 0)
	{
		int isTime = GetTickCount64() - pUser[conn].Atraso; // ATRASO PACOTE

		if (isTime < 800)
		{
			SendClientMessage(conn, "Aguarde 1 segundo para uma nova Tentativa.");
			return;
		}

	}
	pUser[conn].Atraso = GetTickCount64();

	for (int i = 0; i < MAX_COMBINE; i++)
	{
		int invPos = m->InvenPos[i];

		if (m->Item[i].sIndex == 0)
			continue;

		if (invPos == -1) {
			Combinelogsitem(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, "dup,Tentativa de Dup CombineAgatha");
			return;
		}

		if (invPos < 0 || invPos >= pMob[conn].MaxCarry)
		{
			RemoveTrade(conn);
			return;
		}

		if (memcmp(&pMob[conn].MOB.Carry[invPos], &m->Item[i], sizeof(STRUCT_ITEM)))
		{
			Combinelogsitem(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, "err,msg_CombineAgatha - item remove or changed.");
			SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 0);
			return;
		}

		if (m->Item[i].sIndex == 747)
			return;
	}

	int combine = GetMatchCombineAgatha(m->Item);

	if (combine == 0)
	{
		SendClientMessage(conn, g_pMessageStringTable[_NN_Wrong_Combination]);
		SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 0);
		return;
	}

	if (combine == 77)
	{
		SendClientMessage(conn, "Não é possivel com Pedra da Luz em Pack");
		SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 0);
		return;
	}

	for (int i = 0; i < MAX_COMBINE; i++)
	{
		if (m->Item[i].sIndex == 0)
			continue;

		if (i == 1)
			continue;

		memset(&pMob[conn].MOB.Carry[m->InvenPos[i]], 0, sizeof(STRUCT_ITEM));
		SendItem(conn, ITEM_PLACE_CARRY, m->InvenPos[i], &pMob[conn].MOB.Carry[m->InvenPos[i]]);
	}

	int _rand = rand() % 115;
	if (_rand >= 100)
		_rand -= 15;


	int ipos = m->InvenPos[0];

	if (_rand <= combine || LOCALSERVER)
	{
		pMob[conn].MOB.Carry[ipos].sIndex = m->Item[0].sIndex;
		pMob[conn].MOB.Carry[ipos].stEffect[0].cEffect = m->Item[1].stEffect[0].cEffect;
		pMob[conn].MOB.Carry[ipos].stEffect[0].cValue = m->Item[1].stEffect[0].cValue;
		pMob[conn].MOB.Carry[ipos].stEffect[1].cEffect = m->Item[1].stEffect[1].cEffect;
		pMob[conn].MOB.Carry[ipos].stEffect[1].cValue = m->Item[1].stEffect[1].cValue;
		pMob[conn].MOB.Carry[ipos].stEffect[2].cEffect = m->Item[1].stEffect[2].cEffect;
		pMob[conn].MOB.Carry[ipos].stEffect[2].cValue = m->Item[1].stEffect[2].cValue;

		BASE_SetItemSanc(&pMob[conn].MOB.Carry[ipos], 7, 0);

		memset(&pMob[conn].MOB.Carry[m->InvenPos[1]], 0, sizeof(STRUCT_ITEM));
		SendItem(conn, ITEM_PLACE_CARRY, m->InvenPos[1], &pMob[conn].MOB.Carry[m->InvenPos[1]]);

		SendClientMessage(conn, g_pMessageStringTable[_NN_Processing_Complete]);

		SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 1);


		Combinelogsitem(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, strFmt("%s Teve sucesso na passar add para item %s.", pMob[conn].MOB.MobName, g_pItemList[pMob[conn].MOB.Carry[m->InvenPos[0]].sIndex].Name));
		//SendSpkMsg(1, temp, TNColor::GreenYellow, true);		 

		SendItem(conn, ITEM_PLACE_CARRY, ipos, &pMob[conn].MOB.Carry[ipos]);
		SaveUser(conn, 0);
		return;
	}
	else
	{
		SendClientMessage(conn, strFmt("%s(%d/%d)", g_pMessageStringTable[_NN_CombineFailed], _rand, combine));
		Combinelogsitem(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, strFmt("%s(%d/%d)", g_pMessageStringTable[_NN_CombineFailed], _rand, combine));
		/*snprintf(temp, sizeof(temp), "%s Teve falha ao tentar passar add.", pMob[conn].MOB.MobName);
		Combinelogsitem(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);
		SendSpkMsg(1, temp, TNColor::Red, true);
		SendClientMessage(conn, temp);*/


		SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 2);
		SaveUser(conn, 0);
		return;
	}
}

# -------------------- _MSG_CombineItemAilyn.cpp --------------------


#include "ProcessClientMessage.h"

void Exec_MSG_CombineItemAilyn(int conn, char* pMsg)  //ailyn
{
	MSG_CombineItem* m = (MSG_CombineItem*)pMsg;

	int Size = m->Size;

	if (Size > sizeof(MSG_CombineItem)) //CONTROLE DE SIZE
	{
		SendClientMessage(conn, "Impossível executar ação13, tente mais tarde. ");
		return;
	}
	if (pUser[conn].Atraso != 0)
	{
		int isTime = GetTickCount64() - pUser[conn].Atraso; // ATRASO PACOTE

		if (isTime < 800)
		{
			SendClientMessage(conn, "Aguarde 1 segundo para uma nova Tentativa.");
			return;
		}

	}
	pUser[conn].Atraso = GetTickCount64();

	for (int i = 0; i < MAX_COMBINE; i++)
	{
		int invPos = m->InvenPos[i];

		if (m->Item[i].sIndex == 0)
			continue;

		if (invPos == -1) {
			Combinelogsitem(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, "dup,Tentativa de Dup CombineAilyn");
			return;
		}

		if (invPos < 0 || invPos >= pMob[conn].MaxCarry)
		{
			RemoveTrade(conn);
			return;
		}

		if (memcmp(&pMob[conn].MOB.Carry[invPos], &m->Item[i], sizeof(STRUCT_ITEM)))
		{
			Combinelogsitem(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, "err,msg_CombineAilyn - item remove or changed.");
			SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 0);
			return;
		}
	}

	if (pMob[conn].MOB.Coin < 50000000)
	{
		SendClientMessage(conn, strFmt(g_pMessageStringTable[_DN_D_Cost], 50000000));

		SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 0);
		return;
	}

	if (pMob[conn].MOB.Coin < 50000000)
	{
		SendClientMessage(conn, g_pMessageStringTable[_NN_Wrong_Combination]);
		SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 0);
		return;
	}

	int combine = GetMatchCombineAilyn(m->Item);

	if (combine == 0)
	{
		SendClientMessage(conn, g_pMessageStringTable[_NN_Wrong_Combination]);

		SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 0);
		return;

	}
	if (combine == 77)
	{
		SendClientMessage(conn, "Não é possivel com Pedra do Sábio em Pack");

		SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 0);
		return;

	}

	Combinelogsitem(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, "* Item combine ailyn. *");

	for (int i = 2; i < MAX_COMBINE; i++)
	{
		if (m->Item[i].sIndex == 0)
			continue;

		memset(&pMob[conn].MOB.Carry[m->InvenPos[i]], 0, sizeof(STRUCT_ITEM));
		SendItem(conn, ITEM_PLACE_CARRY, m->InvenPos[i], &pMob[conn].MOB.Carry[m->InvenPos[i]]);
	}

	//SendEtc(conn);


	int _rand = rand() % 115;
	if (_rand >= 100)
		_rand -= 15;

	int zrand = rand() % 115;
	if (zrand >= 100)
		zrand -= 15;

	int ipos1 = 0;
	int ipos2 = 0;

	if (_rand <= combine || LOCALSERVER)
	{
		ipos1 = m->InvenPos[0];
		ipos2 = m->InvenPos[1];
		
		snprintf(temp, sizeof(temp), "Combine Ailyn. Item 1: %d - %d,%d,%d,%d,%d,%d | Item 2: %d - %d,%d,%d,%d,%d,%d",
			pMob[conn].MOB.Carry[ipos1].sIndex, pMob[conn].MOB.Carry[ipos1].stEffect[0].cEffect,
			pMob[conn].MOB.Carry[ipos1].stEffect[0].cValue, pMob[conn].MOB.Carry[ipos1].stEffect[1].cEffect,
			pMob[conn].MOB.Carry[ipos1].stEffect[1].cValue, pMob[conn].MOB.Carry[ipos1].stEffect[2].cEffect,
			pMob[conn].MOB.Carry[ipos1].stEffect[2].cValue,
			pMob[conn].MOB.Carry[ipos2].sIndex, pMob[conn].MOB.Carry[ipos2].stEffect[0].cEffect,
			pMob[conn].MOB.Carry[ipos2].stEffect[0].cValue, pMob[conn].MOB.Carry[ipos2].stEffect[1].cEffect,
			pMob[conn].MOB.Carry[ipos2].stEffect[1].cValue, pMob[conn].MOB.Carry[ipos2].stEffect[2].cEffect,
			pMob[conn].MOB.Carry[ipos2].stEffect[2].cValue);
		Combinelogsitem(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);
			
		if (zrand <= 50)
		{
			pMob[conn].MOB.Carry[ipos1].stEffect[0].cEffect = pMob[conn].MOB.Carry[ipos2].stEffect[0].cEffect;
			pMob[conn].MOB.Carry[ipos1].stEffect[0].cValue = pMob[conn].MOB.Carry[ipos2].stEffect[0].cValue;
			pMob[conn].MOB.Carry[ipos1].stEffect[1].cEffect = pMob[conn].MOB.Carry[ipos2].stEffect[1].cEffect;
			pMob[conn].MOB.Carry[ipos1].stEffect[1].cValue = pMob[conn].MOB.Carry[ipos2].stEffect[1].cValue;
			pMob[conn].MOB.Carry[ipos1].stEffect[2].cEffect = pMob[conn].MOB.Carry[ipos2].stEffect[2].cEffect;
			pMob[conn].MOB.Carry[ipos1].stEffect[2].cValue = pMob[conn].MOB.Carry[ipos2].stEffect[2].cValue;
		}
		else
		{
			pMob[conn].MOB.Carry[ipos1].stEffect[0].cEffect = pMob[conn].MOB.Carry[ipos1].stEffect[0].cEffect;
			pMob[conn].MOB.Carry[ipos1].stEffect[0].cValue = pMob[conn].MOB.Carry[ipos1].stEffect[0].cValue;
			pMob[conn].MOB.Carry[ipos1].stEffect[1].cEffect = pMob[conn].MOB.Carry[ipos1].stEffect[1].cEffect;
			pMob[conn].MOB.Carry[ipos1].stEffect[1].cValue = pMob[conn].MOB.Carry[ipos1].stEffect[1].cValue;
			pMob[conn].MOB.Carry[ipos1].stEffect[2].cEffect = pMob[conn].MOB.Carry[ipos1].stEffect[2].cEffect;
			pMob[conn].MOB.Carry[ipos1].stEffect[2].cValue = pMob[conn].MOB.Carry[ipos1].stEffect[2].cValue;
		}

		snprintf(temp, sizeof(temp), "Combine Ailyn. Item result: %d - %d,%d,%d,%d,%d,%d",
			pMob[conn].MOB.Carry[ipos1].sIndex, pMob[conn].MOB.Carry[ipos1].stEffect[0].cEffect,
			pMob[conn].MOB.Carry[ipos1].stEffect[0].cValue, pMob[conn].MOB.Carry[ipos1].stEffect[1].cEffect,
			pMob[conn].MOB.Carry[ipos1].stEffect[1].cValue, pMob[conn].MOB.Carry[ipos1].stEffect[2].cEffect,
			pMob[conn].MOB.Carry[ipos1].stEffect[2].cValue);
		Combinelogsitem(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);

		BASE_SetItemSanc(&pMob[conn].MOB.Carry[ipos1], 10, m->Item[3].sIndex - 2441);

		memset(&pMob[conn].MOB.Carry[ipos2], 0, sizeof(STRUCT_ITEM));
		SendItem(conn, ITEM_PLACE_CARRY, ipos2, &pMob[conn].MOB.Carry[ipos2]);

		pMob[conn].MOB.Coin -= 50000000;

		SendEtc(conn);

		SendClientMessage(conn, g_pMessageStringTable[_NN_Processing_Complete]);

		SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 1);
		SendItem(conn, ITEM_PLACE_CARRY, ipos1, &pMob[conn].MOB.Carry[ipos1]);
		SaveUser(conn, 0);
		return;
	}
	else
	{
	
		snprintf(temp, sizeof(temp), "%s(%d/%d)", g_pMessageStringTable[_NN_CombineFailed], _rand, combine);
		SendClientMessage(conn, temp);

		/*snprintf(temp, sizeof(temp), "%s Teve falha realizar (+10).", pMob[conn].MOB.MobName);
		Combinelogsitem(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);*/

		//SendSpkMsg(1, temp, TNColor::Red, true);

		pMob[conn].MOB.Coin -= 50000000;
		SendEtc(conn);

		SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 2);
		SaveUser(conn, 0);
		return;
	}
}

# -------------------- _MSG_CombineItemAlquimia.cpp --------------------

#include "ProcessClientMessage.h"
#include <time.h>
#include <random>
#include <ctime>

void Exec_MSG_CombineItemAlquimia(int conn, char *pMsg)
{
	MSG_CombineItem *m = (MSG_CombineItem*)pMsg;

	int Size = m->Size;

	if (Size > sizeof(MSG_CombineItem)) //CONTROLE DE SIZE
	{
		SendClientMessage(conn, "Impossível executar ação14, tente mais tarde. ");
		return;
	}
	if (pUser[conn].Atraso != 0)
	{
		int isTime = GetTickCount64() - pUser[conn].Atraso; // ATRASO PACOTE

		if (isTime < 800)
		{
			SendClientMessage(conn, "Aguarde 1 segundo para uma nova Tentativa.");
			return;
		}

	}
	pUser[conn].Atraso = GetTickCount64();

	for (int i = 0; i < MAX_COMBINE; i++)
	{
		if (m->Item[i].sIndex == 0)
			continue;

		int invPos = m->InvenPos[i];

		if (invPos < 0 || invPos >= pMob[conn].MaxCarry)
		{
			RemoveTrade(conn);
			return;
		}

		if (memcmp(&pMob[conn].MOB.Carry[invPos], &m->Item[i], sizeof(STRUCT_ITEM)))
		{
			SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 0);
			return;
		}
	}

	int combine = GetMatchCombineAlquimia(m->Item);

	/*if (combine == 7 || combine == 8 || combine == 9)
	{
		SendClientMessage(conn, "A Composição desses itens foi Desativada");
		return;
	}*/

	if (combine == 0)
	{
		SendClientMessage(conn, "Composição não permitida com itens em pack");
		return;
	}

	if (combine == -1 || pMob[conn].MOB.Class != 3)
	{
		SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 0);
		return;
	}

	for (int i = 0; i < MAX_COMBINE; i++)
	{
		if (m->Item[i].sIndex == 0)
			continue;

		snprintf(temp, sizeof(temp), "Combine Alquimia. Item[%d] %d - %d,%d,%d,%d,%d,%d", i,
			pMob[conn].MOB.Carry[m->InvenPos[i]].sIndex, 
			pMob[conn].MOB.Carry[m->InvenPos[i]].stEffect[0].cEffect, 
			pMob[conn].MOB.Carry[m->InvenPos[i]].stEffect[0].cValue,
			pMob[conn].MOB.Carry[m->InvenPos[i]].stEffect[1].cEffect,
			pMob[conn].MOB.Carry[m->InvenPos[i]].stEffect[1].cValue,
			pMob[conn].MOB.Carry[m->InvenPos[i]].stEffect[2].cEffect,
			pMob[conn].MOB.Carry[m->InvenPos[i]].stEffect[2].cValue);
		Combinelogsitem(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);

		memset(&pMob[conn].MOB.Carry[m->InvenPos[i]], 0, sizeof(STRUCT_ITEM));
		SendItem(conn, ITEM_PLACE_CARRY, m->InvenPos[i], &pMob[conn].MOB.Carry[m->InvenPos[i]]);
	}

	for (int i = 0; i < MAX_COMBINE; i++)
	{
		if (m->Item[i].sIndex)
		{
			char itemlog[2048];

			BASE_GetItemCode(&m->Item[i], itemlog);

			strcat(temp, itemlog);
		}
	}

	std::mt19937 generator;
	generator.seed((unsigned int)std::time(0));
	std::uniform_int_distribution<uint32_t> dice(1, 100);
	int random = dice(generator);

	int chance = (pMob[conn].MOB.CurrentScore.Special[2] - 20) / 5; //60% com 320 pontos

	if (random <= chance || LOCALSERVER)
	{
		if (pMob[conn].extra.SecLearnedSkill & 0x10) // Ponto Mestre
		{
			pMob[conn].MOB.Carry[m->InvenPos[0]].sIndex = 3200 + combine;
			pMob[conn].MOB.Carry[m->InvenPos[0]].stEffect[0].cEffect = 61;
			pMob[conn].MOB.Carry[m->InvenPos[0]].stEffect[0].cValue = 5;
			pMob[conn].MOB.Carry[m->InvenPos[0]].stEffect[1].cEffect = 0;
			pMob[conn].MOB.Carry[m->InvenPos[0]].stEffect[1].cValue = 0;
			pMob[conn].MOB.Carry[m->InvenPos[0]].stEffect[2].cEffect = 0;
			pMob[conn].MOB.Carry[m->InvenPos[0]].stEffect[2].cValue = 0;

			SendItem(conn, ITEM_PLACE_CARRY, m->InvenPos[0], &pMob[conn].MOB.Carry[m->InvenPos[0]]);
			Combinelogsitem(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, strFmt("Combine Alquimia + 5x %s", g_pItemList[3200 + combine].Name));

			SendClientMessage(conn, g_pMessageStringTable[_NN_Processing_Complete]);

			SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 1);

			return;
		}
		else
		{
			pMob[conn].MOB.Carry[m->InvenPos[0]].sIndex = 3200 + combine;
			pMob[conn].MOB.Carry[m->InvenPos[0]].stEffect[0].cEffect = 0;
			pMob[conn].MOB.Carry[m->InvenPos[0]].stEffect[0].cValue = 0;
			pMob[conn].MOB.Carry[m->InvenPos[0]].stEffect[1].cEffect = 0;
			pMob[conn].MOB.Carry[m->InvenPos[0]].stEffect[1].cValue = 0;
			pMob[conn].MOB.Carry[m->InvenPos[0]].stEffect[2].cEffect = 0;
			pMob[conn].MOB.Carry[m->InvenPos[0]].stEffect[2].cValue = 0;

			SendItem(conn, ITEM_PLACE_CARRY, m->InvenPos[0], &pMob[conn].MOB.Carry[m->InvenPos[0]]);
			Combinelogsitem(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, strFmt("Combine Alquimia + 5x %s", g_pItemList[3200 + combine].Name));

			SendClientMessage(conn, g_pMessageStringTable[_NN_Processing_Complete]);

			SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 1);

			SaveUser(conn, 0);
			return;
		}
	}
	else
	{
		SendClientMessage(conn, g_pMessageStringTable[_NN_CombineFailed]);
		Combinelogsitem(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, "Combine Alquimia Falhou");

		SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 2);
		SaveUser(conn, 0);
		return;
	}
}

# -------------------- _MSG_CombineItemDedekinto.cpp --------------------

#include "ProcessClientMessage.h"


void Exec_MSG_CombineDedekinto(int conn, char *pMsg)
{
	MSG_CombineItem *m = (MSG_CombineItem*)pMsg;

	int Size = m->Size;

	if (Size > sizeof(MSG_CombineItem)) //CONTROLE DE SIZE
	{
		SendClientMessage(conn, "Impossível executar ação15, tente mais tarde. ");
		return;
	}
	if (pUser[conn].Atraso != 0)
	{
		int isTime = GetTickCount64() - pUser[conn].Atraso; // ATRASO PACOTE

		if (isTime < 800)
		{
			SendClientMessage(conn, "Aguarde 1 segundo para uma nova Tentativa.");
			return;
		}

	}
	pUser[conn].Atraso = GetTickCount64();

	for (int i = 0; i < MAX_COMBINE; i++)
	{
		int invPos = m->InvenPos[i];

		if (m->Item[i].sIndex == 0)
			continue;

		if (invPos == -1) {
			Combinelogsitem(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, "dup,Tentativa de Dup DedeKinto");
			return;
		}

		if (invPos < 0 || invPos >= pMob[conn].MaxCarry)
		{
			RemoveTrade(conn);
			return;
		}

		if (memcmp(&pMob[conn].MOB.Carry[invPos], &m->Item[i], sizeof(STRUCT_ITEM)))
		{
			Combinelogsitem(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, "err,msg_CombineDedeKinto - item remove or changed.");
			SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 0);
			return;
		}
	}

	int combine = GetMatchCombineDedekinto(m->Item);

	if (combine == 1 && (pMob[conn].MOB.Exp < 8200000000 || pMob[conn].extra.ClassMaster == MORTAL || pMob[conn].extra.ClassMaster == ARCH || pMob[conn].MOB.CurrentScore.Level <= 238 || (!pMob[conn].extra.ClassMaster >= HARDCORE && (pMob[conn].MOB.Equip[1].sIndex >= 3500 && pMob[conn].MOB.Equip[1].sIndex <= 3507))))
	{	 //Pedra Amunra
		SendClientMessage(conn, "Nescessário ser Celestial Level 240");
		SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 0);
		return;
	}

	if (combine == 2 && (pMob[conn].extra.ClassMaster == MORTAL || pMob[conn].extra.ClassMaster == ARCH || pMob[conn].MOB.CurrentScore.Level <= 238))
	{	 //Proteção Divina
		SendClientMessage(conn, "Nescessário ser Celestial Level 240");
		SendClientMessage(conn, g_pMessageStringTable[_NN_Wrong_Combination]);
		SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 0);
		return;
	}

	for (int i = 0; i < MAX_COMBINE; i++)
	{
		if (m->Item[i].sIndex == 0)
			continue;

		memset(&pMob[conn].MOB.Carry[m->InvenPos[i]], 0, sizeof(STRUCT_ITEM));
		SendItem(conn, ITEM_PLACE_CARRY, m->InvenPos[i], &pMob[conn].MOB.Carry[m->InvenPos[i]]);
	}

	//ItemLog("*** Item combine ehre. ***", pUser[conn].AccountName, pUser[conn].IP);

	for (int i = 0; i < MAX_COMBINE; i++)
	{
		if (m->Item[i].sIndex)
		{
			char itemlog[2048];
									 
			BASE_GetItemCode(&m->Item[i], itemlog);
									 
			strcat(temp, itemlog);
		}
	}
	//ItemLog(temp, pUser[conn].AccountName, pUser[conn].IP);
	//ItemLog("*** ------------------- ***", pUser[conn].AccountName, pUser[conn].IP);

	int _rand = rand() % 115;
	if (_rand >= 100)
		_rand -= 15;

	int rate = g_pEhreRate[combine];
	
	if (_rand <= rate || LOCALSERVER)
	{
		if (combine == 1)
		{
			if (pMob[conn].extra.ClassMaster >= CELESTIAL && pMob[conn].extra.ClassMaster <= SCELESTIAL)
			{
				pMob[conn].MOB.Carry[m->InvenPos[0]].sIndex = 3464;

				char tt[512];

				SendClientMessage(conn, g_pMessageStringTable[_NN_Processing_Complete]);

				SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 1);

				sprintf_s(temp, "%s ", pUser[conn].AccountName);
				BASE_GetItemCode(&pMob[conn].MOB.Carry[m->InvenPos[0]], tt);

				pMob[conn].MOB.BaseScore.Level = 0;
				pMob[conn].MOB.Exp = 0;

				pMob[conn].MOB.BaseScore.Str = BaseSIDCHM[pMob[conn].MOB.Class][0];
				pMob[conn].MOB.BaseScore.Int = BaseSIDCHM[pMob[conn].MOB.Class][1];
				pMob[conn].MOB.BaseScore.Dex = BaseSIDCHM[pMob[conn].MOB.Class][2];
				pMob[conn].MOB.BaseScore.Con = BaseSIDCHM[pMob[conn].MOB.Class][3];

				pMob[conn].MOB.BaseScore.Special[0] = 0;
				pMob[conn].MOB.BaseScore.Special[1] = 0;
				pMob[conn].MOB.BaseScore.Special[2] = 0;
				pMob[conn].MOB.BaseScore.Special[3] = 0;

				pMob[conn].MOB.BaseScore.Ac = 1004;
				pMob[conn].MOB.BaseScore.Damage = 400;
				pMob[conn].MOB.BaseScore.Hp = BaseSIDCHM[pMob[conn].MOB.Class][4];
				pMob[conn].MOB.BaseScore.MaxHp = BaseSIDCHM[pMob[conn].MOB.Class][4];
				pMob[conn].MOB.BaseScore.Mp = BaseSIDCHM[pMob[conn].MOB.Class][5];
				pMob[conn].MOB.BaseScore.MaxMp = BaseSIDCHM[pMob[conn].MOB.Class][5];

				pMob[conn].MOB.SpecialBonus = 855;

				SendEtc(conn);

				strcat(temp, tt);

				for (int i = 1; i < MAX_COMBINE; i++)
				{
					if (m->Item[i].sIndex == 0)
						continue;

					memset(&pMob[conn].MOB.Carry[m->InvenPos[i]], 0, sizeof(STRUCT_ITEM));
					SendItem(conn, ITEM_PLACE_CARRY, m->InvenPos[i], &pMob[conn].MOB.Carry[m->InvenPos[i]]);
				}

				/*ItemLog(temp, "*** Combine odin sucess ***", pUser[conn].MacAddress);*/
				SendItem(conn, ITEM_PLACE_CARRY, m->InvenPos[0], &pMob[conn].MOB.Carry[m->InvenPos[0]]);

				CharLogOut(conn);

				SendClientSignalParm(conn, ESCENE_FIELD, _MSG_SendArchEffect, pUser[conn].Slot);

				return;
			}

			else if (pMob[conn].extra.ClassMaster >= HARDCORE)
			{
				pMob[conn].MOB.Carry[m->InvenPos[0]].sIndex = 3464;

				char tt[512];

				SendClientMessage(conn, g_pMessageStringTable[_NN_Processing_Complete]);

				SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 1);

				sprintf_s(temp, "%s ", pUser[conn].AccountName);
				BASE_GetItemCode(&pMob[conn].MOB.Carry[m->InvenPos[0]], tt);

				pMob[conn].MOB.BaseScore.Level = 0;
				pMob[conn].MOB.Exp = 0;

				pMob[conn].MOB.BaseScore.Str = BaseSIDCHM[pMob[conn].MOB.Class][0];
				pMob[conn].MOB.BaseScore.Int = BaseSIDCHM[pMob[conn].MOB.Class][1];
				pMob[conn].MOB.BaseScore.Dex = BaseSIDCHM[pMob[conn].MOB.Class][2];
				pMob[conn].MOB.BaseScore.Con = BaseSIDCHM[pMob[conn].MOB.Class][3];

				pMob[conn].MOB.BaseScore.Special[0] = 0;
				pMob[conn].MOB.BaseScore.Special[1] = 0;
				pMob[conn].MOB.BaseScore.Special[2] = 0;
				pMob[conn].MOB.BaseScore.Special[3] = 0;

				pMob[conn].MOB.BaseScore.Ac = 954;
				pMob[conn].MOB.BaseScore.Damage = 800;
				pMob[conn].MOB.BaseScore.Hp = BaseSIDCHM[pMob[conn].MOB.Class][4];
				pMob[conn].MOB.BaseScore.MaxHp = BaseSIDCHM[pMob[conn].MOB.Class][4];
				pMob[conn].MOB.BaseScore.Mp = BaseSIDCHM[pMob[conn].MOB.Class][5];
				pMob[conn].MOB.BaseScore.MaxMp = BaseSIDCHM[pMob[conn].MOB.Class][5];

				pMob[conn].MOB.SpecialBonus = 855;

				SendEtc(conn);

				strcat(temp, tt);

				for (int i = 1; i < MAX_COMBINE; i++)
				{
					if (m->Item[i].sIndex == 0)
						continue;

					memset(&pMob[conn].MOB.Carry[m->InvenPos[i]], 0, sizeof(STRUCT_ITEM));
					SendItem(conn, ITEM_PLACE_CARRY, m->InvenPos[i], &pMob[conn].MOB.Carry[m->InvenPos[i]]);
				}

				//ItemLog(temp, "*** Combine odin sucess ***", pUser[conn].IP);
				SendItem(conn, ITEM_PLACE_CARRY, m->InvenPos[0], &pMob[conn].MOB.Carry[m->InvenPos[0]]);

				CharLogOut(conn);

				SendClientSignalParm(conn, ESCENE_FIELD, _MSG_SendArchEffect, pUser[conn].Slot);

				return;
			}
		}

		else if (combine == 2)
		{
			pMob[conn].MOB.Carry[m->InvenPos[0]].sIndex = 679;

			char tt[512];

			SendClientMessage(conn, g_pMessageStringTable[_NN_Processing_Complete]);

			SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 1);

			sprintf_s(temp, "%s ", pUser[conn].AccountName);
			BASE_GetItemCode(&pMob[conn].MOB.Carry[m->InvenPos[0]], tt);

			strcat(temp, tt);

			for (int i = 1; i < MAX_COMBINE; i++)
			{
				if (m->Item[i].sIndex == 0)
					continue;

				memset(&pMob[conn].MOB.Carry[m->InvenPos[i]], 0, sizeof(STRUCT_ITEM));
				SendItem(conn, ITEM_PLACE_CARRY, m->InvenPos[i], &pMob[conn].MOB.Carry[m->InvenPos[i]]);
			}

			//ItemLog(temp, "*** Combine odin sucess ***", pUser[conn].IP);
			SendItem(conn, ITEM_PLACE_CARRY, m->InvenPos[0], &pMob[conn].MOB.Carry[m->InvenPos[0]]);

			return;
		}

		char tt[256];

		SendClientMessage(conn, g_pMessageStringTable[_NN_Processing_Complete]);

		SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 1);

		strcat(temp, tt);

		//ItemLog(temp, "-- FALHOU! --", pUser[conn].IP);

		return;
	}
	else
	{

		SendClientMessage(conn, strFmt("%s(%d/%d)", g_pMessageStringTable[_NN_CombineFailed], _rand, rate));

		SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 2);
		//ItemLog("-- FALHOU! --", pUser[conn].AccountName, pUser[conn].IP);

		return;
	}
}

# -------------------- _MSG_CombineItemEhre.cpp --------------------


#include "ProcessClientMessage.h"

void Exec_MSG_CombineItemEhre(int conn, char* pMsg)
{
	MSG_CombineItem* m = (MSG_CombineItem*)pMsg;

	int Size = m->Size;

	if (Size > sizeof(MSG_CombineItem)) //CONTROLE DE SIZE
	{
		SendClientMessage(conn, "Impossível executar ação16, tente mais tarde. ");
		return;
	}
	if (pUser[conn].Atraso != 0)
	{
		int isTime = GetTickCount64() - pUser[conn].Atraso; // ATRASO PACOTE

		if (isTime < 800)
		{
			SendClientMessage(conn, "Aguarde 1 segundo para uma nova Tentativa.");
			return;
		}

	}
	pUser[conn].Atraso = GetTickCount64();

	for (int i = 0; i < MAX_COMBINE; i++)
	{
		int invPos = m->InvenPos[i];

		if (m->Item[i].sIndex == 0)
			continue;

		if (invPos == -1) {
			Combinelogsitem(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, "dup,Tentativa de Dup CombineEhre");
			return;
		}

		if (invPos < 0 || invPos >= pMob[conn].MaxCarry)
		{
			RemoveTrade(conn);
			return;
		}

		if (memcmp(&pMob[conn].MOB.Carry[invPos], &m->Item[i], sizeof(STRUCT_ITEM)))
		{
			Combinelogsitem(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, "err,msg_CombineEhre - item remove or changed.");
			SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 0);
			return;
		}

	}

	int combine = GetMatchCombineEhre(m->Item);

	if (combine == 0)
	{
		SendClientMessage(conn, g_pMessageStringTable[_NN_Wrong_Combination]);
		SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 0);
		return;
	}

	if (combine == 5 && (pMob[conn].MOB.Exp < 5000000 || pMob[conn].extra.ClassMaster == MORTAL || pMob[conn].extra.ClassMaster == ARCH || pMob[conn].MOB.CurrentScore.Level < 39))
	{	 //Ref Abençoada
		SendClientMessage(conn, g_pMessageStringTable[_NN_Wrong_Combination]);
		SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 0);
		return;
	}

	if ((combine == 6 || combine == 7) && pMob[conn].MOB.Coin < 1000000)
	{
		SendClientMessage(conn, g_pMessageStringTable[_NN_Wrong_Combination]);
		SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 0);
		return;
	}


	if (combine == 3 || combine == 4)
	{
		int hp = BASE_GetItemAbilityNosanc(&m->Item[2], EF_HPADD2);
		int mp = BASE_GetItemAbilityNosanc(&m->Item[2], EF_MPADD2);
		int critico = BASE_GetItemAbilityNosanc(&m->Item[2], EF_CRITICAL2);

		if (hp >= 20 || mp >= 20 || critico >= 100 || hp >= 10 && mp >= 10 || hp >= 10 && critico >= 50 || hp >= 10 && mp >= 10 || mp >= 10 && critico >= 50)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Wrong_Combination]);
			SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 0);
			return;
		}
	}


	for (int i = 0; i < MAX_COMBINE; i++)
	{
		if (m->Item[i].sIndex == 0)
			continue;

		memset(&pMob[conn].MOB.Carry[m->InvenPos[i]], 0, sizeof(STRUCT_ITEM));
		SendItem(conn, ITEM_PLACE_CARRY, m->InvenPos[i], &pMob[conn].MOB.Carry[m->InvenPos[i]]);
	}


	int _rand = rand() % 115;
	if (_rand >= 100)
		_rand -= 15;

	int rate = g_pEhreRate[combine];

	int ipos = -1;

	if (combine >= 1 && combine <= 5)
		ipos = m->InvenPos[2];

	else if (combine == 6 || combine == 7)
		ipos = m->InvenPos[0];


	if (pMob[conn].MOB.Coin >= 1000000 && (combine == 6 || combine == 7))
	{
		pMob[conn].MOB.Coin -= 1000000;
		SendEtc(conn);
	}

	if (pMob[conn].MOB.Exp >= 5000000 && combine == 5)
	{
		pMob[conn].MOB.Exp -= 5000000;

		if (pMob[conn].MOB.CurrentScore.Level < 150)
			rate = 30;

		else if (pMob[conn].MOB.CurrentScore.Level < 160)
			rate = 35;

		else if (pMob[conn].MOB.CurrentScore.Level < 170)
			rate = 40;

		else if (pMob[conn].MOB.CurrentScore.Level < 180)
			rate = 50;

		else if (pMob[conn].MOB.CurrentScore.Level < 190)
			rate = 70;

		else if (pMob[conn].MOB.CurrentScore.Level <= MAX_LEVEL)
			rate = 100;

		int newlevel = 0;

		for (int i = 0; i < MAX_CLEVEL; i++)
		{
			if (pMob[conn].MOB.Exp >= g_pNextLevel_2[i] && pMob[conn].MOB.Exp <= g_pNextLevel_2[i + 1])
				newlevel = i;
		}

		pMob[conn].MOB.BaseScore.Level = newlevel;
		int check = pMob[conn].CheckGetLevel();

		if (check == 4)
			SetCircletSubGod(conn);


		BASE_GetBonusScorePoint(&pMob[conn].MOB, &pMob[conn].extra);

		pMob[conn].GetCurrentScore(conn);
		SendEtc(conn);
		SendScore(conn);

		SendEmotion(conn, 14, 3);
	}

	if (_rand <= rate || LOCALSERVER)
	{
		if (combine == 1)
		{
			pMob[conn].MOB.Carry[ipos].sIndex = 0;
			pMob[conn].MOB.Carry[ipos].stEffect[0].cEffect = 0;
			pMob[conn].MOB.Carry[ipos].stEffect[0].cValue = 0;
		}

		else if (combine == 2)
		{
			pMob[conn].MOB.Carry[ipos].sIndex = 4148;
			pMob[conn].MOB.Carry[ipos].stEffect[0].cEffect = 61;
			pMob[conn].MOB.Carry[ipos].stEffect[0].cValue = 10;
		}

		else if (combine == 3 || combine == 4)
		{
			memmove_s(&pMob[conn].MOB.Carry[ipos].sIndex, sizeof(STRUCT_ITEM), &m->Item[2], sizeof(STRUCT_ITEM));

			for (int i = 0; i < 2; i++)
			{
				if (m->Item[i].sIndex == 661)//MP
				{
					if (pMob[conn].MOB.Carry[ipos].stEffect[1].cEffect == 70)
					{
						pMob[conn].MOB.Carry[ipos].stEffect[1].cValue += 2;

						if (pMob[conn].MOB.Carry[ipos].stEffect[1].cValue >= 100)
							pMob[conn].MOB.Carry[ipos].stEffect[1].cValue = 20;
					}
					else if (pMob[conn].MOB.Carry[ipos].stEffect[2].cEffect == 70)
					{
						pMob[conn].MOB.Carry[ipos].stEffect[2].cValue += 2;

						if (pMob[conn].MOB.Carry[ipos].stEffect[2].cValue >= 100)
							pMob[conn].MOB.Carry[ipos].stEffect[2].cValue = 20;
					}
					else
					{
						if (pMob[conn].MOB.Carry[ipos].stEffect[1].cEffect == 0)
						{
							pMob[conn].MOB.Carry[ipos].stEffect[1].cEffect = 70;
							pMob[conn].MOB.Carry[ipos].stEffect[1].cValue = 2;
						}
						else if (pMob[conn].MOB.Carry[ipos].stEffect[2].cEffect == 0)
						{
							pMob[conn].MOB.Carry[ipos].stEffect[2].cEffect = 70;
							pMob[conn].MOB.Carry[ipos].stEffect[2].cValue = 2;
						}
					}
				}

				else if (m->Item[i].sIndex == 662)//HP
				{
					if (pMob[conn].MOB.Carry[ipos].stEffect[1].cEffect == 69)
					{
						pMob[conn].MOB.Carry[ipos].stEffect[1].cValue += 2;

						if (pMob[conn].MOB.Carry[ipos].stEffect[1].cValue >= 20)
							pMob[conn].MOB.Carry[ipos].stEffect[1].cValue = 20;
					}
					else if (pMob[conn].MOB.Carry[ipos].stEffect[2].cEffect == 69)
					{
						pMob[conn].MOB.Carry[ipos].stEffect[2].cValue += 2;

						if (pMob[conn].MOB.Carry[ipos].stEffect[2].cValue >= 20)
							pMob[conn].MOB.Carry[ipos].stEffect[2].cValue = 20;
					}
					else
					{
						if (pMob[conn].MOB.Carry[ipos].stEffect[1].cEffect == 0)
						{
							pMob[conn].MOB.Carry[ipos].stEffect[1].cEffect = 69;
							pMob[conn].MOB.Carry[ipos].stEffect[1].cValue = 2;
						}
						else if (pMob[conn].MOB.Carry[ipos].stEffect[2].cEffect == 0)
						{
							pMob[conn].MOB.Carry[ipos].stEffect[2].cEffect = 69;
							pMob[conn].MOB.Carry[ipos].stEffect[2].cValue = 2;
						}
					}
				}

				else if (m->Item[i].sIndex == 663)//Critico
				{
					if (pMob[conn].MOB.Carry[ipos].stEffect[1].cEffect == 71)
					{
						pMob[conn].MOB.Carry[ipos].stEffect[1].cValue += 10;

						if (pMob[conn].MOB.Carry[ipos].stEffect[1].cValue >= 100)
							pMob[conn].MOB.Carry[ipos].stEffect[1].cValue = 100;
					}
					else if (pMob[conn].MOB.Carry[ipos].stEffect[2].cEffect == 71)
					{
						pMob[conn].MOB.Carry[ipos].stEffect[2].cValue += 10;

						if (pMob[conn].MOB.Carry[ipos].stEffect[2].cValue >= 100)
							pMob[conn].MOB.Carry[ipos].stEffect[2].cValue = 100;
					}
					else
					{
						if (pMob[conn].MOB.Carry[ipos].stEffect[1].cEffect == 0)
						{
							pMob[conn].MOB.Carry[ipos].stEffect[1].cEffect = 71;
							pMob[conn].MOB.Carry[ipos].stEffect[1].cValue = 10;
						}
						else if (pMob[conn].MOB.Carry[ipos].stEffect[2].cEffect == 0)
						{
							pMob[conn].MOB.Carry[ipos].stEffect[2].cEffect = 71;
							pMob[conn].MOB.Carry[ipos].stEffect[2].cValue = 10;
						}
					}
				}
			}
			BASE_SetItemSanc(&pMob[conn].MOB.Carry[ipos], 7, 0);
		}

		else if (combine == 5)
		{
			memmove_s(&pMob[conn].MOB.Carry[ipos].sIndex, sizeof(STRUCT_ITEM), &m->Item[2], sizeof(STRUCT_ITEM));

			pMob[conn].MOB.Carry[ipos].stEffect[0].cEffect = 43;

			int sanc = BASE_GetItemSanc(&pMob[conn].MOB.Carry[ipos]);
			BASE_SetItemSanc(&pMob[conn].MOB.Carry[ipos], sanc + 1, 0);
		}

		else if (combine == 6)  //traje montaria
		{
			SendClientMessage(conn, "Função Desabilitada");
			/*memmove_s(&pMob[conn].MOB.Carry[ipos].sIndex, sizeof(STRUCT_ITEM), &m->Item[0], sizeof(STRUCT_ITEM));
			pMob[conn].MOB.Carry[ipos].stEffect[2].cValue = 11 + (m->Item[1].sIndex - 4190);*/

		}
		else if (combine == 7)
		{
			SendClientMessage(conn, "Função Desabilitada");
			/*memmove_s(&pMob[conn].MOB.Carry[ipos].sIndex, sizeof(STRUCT_ITEM), &m->Item[0], sizeof(STRUCT_ITEM));
			pMob[conn].MOB.Carry[ipos].stEffect[2].cValue = 0;*/
		}

		else if (combine == 8)
		{
			if (m->Item[0].sIndex == 2441 && m->Item[1].sIndex == 2441 && m->Item[2].sIndex == 2441)
				pMob[conn].extra.Soul = SOUL_FC;

			else if (m->Item[0].sIndex == 2442 && m->Item[1].sIndex == 2442 && m->Item[2].sIndex == 2442)
				pMob[conn].extra.Soul = SOUL_IC;

			else if (m->Item[0].sIndex == 2443 && m->Item[1].sIndex == 2443 && m->Item[2].sIndex == 2443)
				pMob[conn].extra.Soul = SOUL_DC;

			else if (m->Item[0].sIndex == 2444 && m->Item[1].sIndex == 2444 && m->Item[2].sIndex == 2444)
				pMob[conn].extra.Soul = SOUL_FD;

			else if (m->Item[0].sIndex == 2441 && m->Item[1].sIndex == 2442 && m->Item[2].sIndex == 2443)
				pMob[conn].extra.Soul = SOUL_ID;

			else if (m->Item[0].sIndex == 2441 && m->Item[1].sIndex == 2443 && m->Item[2].sIndex == 2444)
				pMob[conn].extra.Soul = SOUL_CD;

			else if (m->Item[0].sIndex == 2442 && m->Item[1].sIndex == 2443 && m->Item[2].sIndex == 2444)
				pMob[conn].extra.Soul = SOUL_F;

			else if (m->Item[0].sIndex == 2442 && m->Item[1].sIndex == 2441 && m->Item[2].sIndex == 2443)
				pMob[conn].extra.Soul = SOUL_I;

			else if (m->Item[0].sIndex == 2443 && m->Item[1].sIndex == 2442 && m->Item[2].sIndex == 2444)
				pMob[conn].extra.Soul = SOUL_C;

			else if (m->Item[0].sIndex == 2444 && m->Item[1].sIndex == 2441 && m->Item[2].sIndex == 2443)
				pMob[conn].extra.Soul = SOUL_D;

			SendClientMessage(conn, g_pMessageStringTable[_NN_Processing_Complete]);

			SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 1);

			return;
		}

		if (combine == 9)
		{
			int rand_ = rand() % 100;
			STRUCT_ITEM Item;
			memset(&Item, 0, sizeof(STRUCT_ITEM));
			if (rand_ <= 100)
			{
				Item.sIndex = 413; //lac
				Item.stEffect[0].cEffect = 0; //efeito REF
				Item.stEffect[0].cValue = 0; //valor
			}
			PutItem(conn, &Item);

			SendEtc(conn);

			for (int i = 1; i < MAX_COMBINE; i++)
			{
				if (m->Item[i].sIndex == 0)
					continue;

				memset(&pMob[conn].MOB.Carry[m->InvenPos[i]], 0, sizeof(STRUCT_ITEM));
				SendItem(conn, ITEM_PLACE_CARRY, m->InvenPos[i], &pMob[conn].MOB.Carry[m->InvenPos[i]]);
			}

			SendItem(conn, ITEM_PLACE_CARRY, m->InvenPos[0], &pMob[conn].MOB.Carry[m->InvenPos[0]]);

			return;

		}

		if (combine == 10)
		{
			int rand_ = rand() % 100;
			STRUCT_ITEM Item;
			memset(&Item, 0, sizeof(STRUCT_ITEM));
			if (rand_ <= 100)
			{
				Item.sIndex = 412; //lac
				Item.stEffect[0].cEffect = 0; //efeito REF
				Item.stEffect[0].cValue = 0; //valor
			}
			PutItem(conn, &Item);

			SendEtc(conn);

			for (int i = 1; i < MAX_COMBINE; i++)
			{
				if (m->Item[i].sIndex == 0)
					continue;

				memset(&pMob[conn].MOB.Carry[m->InvenPos[i]], 0, sizeof(STRUCT_ITEM));
				SendItem(conn, ITEM_PLACE_CARRY, m->InvenPos[i], &pMob[conn].MOB.Carry[m->InvenPos[i]]);
			}

			SendItem(conn, ITEM_PLACE_CARRY, m->InvenPos[0], &pMob[conn].MOB.Carry[m->InvenPos[0]]);
			return;

		}

		SendClientMessage(conn, g_pMessageStringTable[_NN_Processing_Complete]);

		SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 1);

		SendItem(conn, ITEM_PLACE_CARRY, ipos, &pMob[conn].MOB.Carry[ipos]);

		return;
	}
	else
	{
		if (combine == 5)
		{//Ref Abençoada
			memmove_s(&pMob[conn].MOB.Carry[m->InvenPos[2]], sizeof(STRUCT_ITEM), &m->Item[2], sizeof(STRUCT_ITEM));
			SendItem(conn, ITEM_PLACE_CARRY, m->InvenPos[2], &pMob[conn].MOB.Carry[m->InvenPos[2]]);
		}
		SendClientMessage(conn, strFmt("%s(%d/%d)", g_pMessageStringTable[_NN_CombineFailed], _rand, rate));

		SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 2);

		return;
	}
}

# -------------------- _MSG_CombineItemExtracao.cpp --------------------

/*
*   Copyright (C) {2015}  {Victor Klafke, Charles TheHouse}
*
*   This program is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program.  If not, see [http://www.gnu.org/licenses/].
*
*   Contact at: victor.klafke@ecomp.ufsm.br
*/
#include "ProcessClientMessage.h"
#include <time.h>
#include <random>
#include <ctime>

void Exec_MSG_CombineItemExtracao(int conn, char *pMsg)
{
	MSG_STANDARDPARM2 *m = (MSG_STANDARDPARM2*)pMsg;

	int ItemSlot = m->Parm2;

	int Size = m->Size;

	if (Size > sizeof(MSG_STANDARDPARM2)) //CONTROLE DE SIZE
	{
		SendClientMessage(conn, "Impossível executar ação17, tente mais tarde. ");
		return;
	}
	if (pUser[conn].Atraso != 0)
	{
		int isTime = GetTickCount64() - pUser[conn].Atraso; // ATRASO PACOTE

		if (isTime < 800)
		{
			SendClientMessage(conn, "Aguarde 1 segundo para uma nova Tentativa.");
			return;
		}

	}
	pUser[conn].Atraso = GetTickCount64();

	if (ItemSlot < 0 || ItemSlot >= pMob[conn].MaxCarry)
		return;

	int item = pMob[conn].MOB.Carry[ItemSlot].sIndex;

	if(item <= 0 || item >= MAX_ITEMLIST)
		return;

	int itemlevel = BASE_GetItemAbility(&pMob[conn].MOB.Carry[ItemSlot], EF_ITEMLEVEL);

	if(itemlevel >= 5)
		return;

	if(BASE_GetItemSanc(&pMob[conn].MOB.Carry[ItemSlot]) < 0)
		return;

	if((g_pItemList[item].nPos != 2 && g_pItemList[item].nPos != 4 && g_pItemList[item].nPos != 8 && g_pItemList[item].nPos != 16 && g_pItemList[item].nPos != 32) || BASE_GetItemAbility(&pMob[conn].MOB.Carry[ItemSlot], EF_MOBTYPE) != 0)
		return;

	int i = 0;

	for (i = 0; i < pMob[conn].MaxCarry; i++)
	{
		if (pMob[conn].MOB.Carry[i].sIndex != 1774)
			continue;

		BASE_ClearItem(&pMob[conn].MOB.Carry[i]);
		SendItem(conn, ITEM_PLACE_CARRY, i, &pMob[conn].MOB.Carry[i]);
		SaveUser(conn, 0);
		break;
	}

	if (i == pMob[conn].MaxCarry)
		return;
		
	std::mt19937 generator;
	generator.seed((unsigned int)std::time(0));
	std::uniform_int_distribution<uint32_t> dice(1, 100);
	int random = dice(generator);

	int rate = (pMob[conn].MOB.CurrentScore.Special[2] - 20) / 5; //60% com 320 pontos
	// remover depois

	if(random < rate)
	{
		pMob[conn].MOB.Carry[ItemSlot].stEffect[0].cEffect = EF_ITEMLEVEL;
		pMob[conn].MOB.Carry[ItemSlot].stEffect[0].cValue = itemlevel;

		if(pMob[conn].MOB.Carry[ItemSlot].stEffect[1].cEffect == EF_DAMAGE)
			pMob[conn].MOB.Carry[ItemSlot].stEffect[1].cValue += BASE_GetStaticItemAbility(&pMob[conn].MOB.Carry[ItemSlot], EF_DAMAGE);

		if(pMob[conn].MOB.Carry[ItemSlot].stEffect[2].cEffect == EF_DAMAGE)
			pMob[conn].MOB.Carry[ItemSlot].stEffect[2].cValue += BASE_GetStaticItemAbility(&pMob[conn].MOB.Carry[ItemSlot], EF_DAMAGE);

		pMob[conn].MOB.Carry[ItemSlot].sIndex = 3021;

		if(g_pItemList[item].nPos == 4)
			pMob[conn].MOB.Carry[ItemSlot].sIndex++;

		else if(g_pItemList[item].nPos == 8)
			pMob[conn].MOB.Carry[ItemSlot].sIndex += 2;

		else if(g_pItemList[item].nPos == 16)
			pMob[conn].MOB.Carry[ItemSlot].sIndex += 3;

		else if(g_pItemList[item].nPos == 32)
			pMob[conn].MOB.Carry[ItemSlot].sIndex += 4;

		SendItem(conn, ITEM_PLACE_CARRY, ItemSlot, &pMob[conn].MOB.Carry[ItemSlot]);
		SaveUser(conn, 0);

		char tt[256];
		sprintf(temp, "%s ", pUser[conn].AccountName);
		BASE_GetItemCode(&pMob[conn].MOB.Carry[ItemSlot], tt);
		strcat(temp, tt);

		//ItemLog(temp, "*** Combine ht_skill_extração sucess ***", pUser[conn].IP);
	}
	else
	{
		BASE_ClearItem(&pMob[conn].MOB.Carry[ItemSlot]);
		SendItem(conn, ITEM_PLACE_CARRY, ItemSlot, &pMob[conn].MOB.Carry[ItemSlot]);
		SaveUser(conn, 0);

		//ItemLog("*** Combine ht_skill_extração fail ***", pMob[conn].MOB.MobName, pUser[conn].IP);
	}
}

# -------------------- _MSG_CombineItemLindy.cpp --------------------


#include "ProcessClientMessage.h"

void Exec_MSG_CombineItemLindy(int conn, char* pMsg)
{
	MSG_CombineItem* m = (MSG_CombineItem*)pMsg;

	int Size = m->Size;

	if (Size > sizeof(MSG_CombineItem)) //CONTROLE DE SIZE
	{
		SendClientMessage(conn, "Impossível executar ação18, tente mais tarde. ");
		return;
	}
	if (pUser[conn].Atraso != 0)
	{
		int isTime = GetTickCount64() - pUser[conn].Atraso; // ATRASO PACOTE

		if (isTime < 800)
		{
			SendClientMessage(conn, "Aguarde 1 segundo para uma nova Tentativa.");
			return;
		}

	}
	pUser[conn].Atraso = GetTickCount64();

	for (int i = 0; i < MAX_COMBINE; i++)
	{
		int invPos = m->InvenPos[i];

		if (m->Item[i].sIndex == 0)
			continue;

		if (invPos == -1) {
			Combinelogsitem(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, "dup,Tentativa de Dup CombineLindy");
			return;
		}

		if (invPos < 0 || invPos >= pMob[conn].MaxCarry)
		{
			RemoveTrade(conn);
			return;
		}

		if (memcmp(&pMob[conn].MOB.Carry[invPos], &m->Item[i], sizeof(STRUCT_ITEM)))
		{
			Combinelogsitem(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, "err,msg_CombineLindy - item remove or changed.");
			SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 0);
			return;
		}
	}

	if (pMob[conn].extra.ClassMaster != ARCH)
		return;

	if (pMob[conn].MOB.CurrentScore.Level != 369 && pMob[conn].MOB.CurrentScore.Level != 354)
		return;

	if (pMob[conn].extra.QuestInfo.Arch.Level355 == 1 && pMob[conn].MOB.CurrentScore.Level == 354)
		return;

	if (pMob[conn].extra.QuestInfo.Arch.Level370 == 0 && pMob[conn].MOB.CurrentScore.Level == 369 && pMob[conn].extra.Fame <= 0)
	{
		SendClientMessage(conn, "Necessário 01 de fame");
		return;
	}

	if (pMob[conn].extra.QuestInfo.Arch.Level370 == 1 && pMob[conn].MOB.CurrentScore.Level == 369)
		return;


	if (m->Item[0].sIndex == 413 && BASE_GetItemAmount(&m->Item[0]) == 10 && m->Item[1].sIndex == 413 && BASE_GetItemAmount(&m->Item[1]) == 10
		&& m->Item[2].sIndex == 4127 && m->Item[3].sIndex == 413 && m->Item[4].sIndex == 413 && m->Item[5].sIndex == 413 && m->Item[6].sIndex == 413)
	{

		for (int i = 0; i < MAX_COMBINE; i++)
		{
			if (m->Item[i].sIndex == 0)
				continue;

			memset(&pMob[conn].MOB.Carry[m->InvenPos[i]], 0, sizeof(STRUCT_ITEM));
			SendItem(conn, ITEM_PLACE_CARRY, m->InvenPos[i], &pMob[conn].MOB.Carry[m->InvenPos[i]]);
		}

		if (pMob[conn].MOB.CurrentScore.Level == 354)
		{
			pMob[conn].extra.QuestInfo.Arch.Level355 = 1;

			memset(&pMob[conn].MOB.Equip[15], 0, sizeof(STRUCT_ITEM));

			if (pMob[conn].MOB.Clan == 7) {
				pMob[conn].MOB.Equip[15].sIndex = 3191;
				pMob[conn].MOB.Equip[15].stEffect[0].cEffect = 54;
				pMob[conn].MOB.Equip[15].stEffect[0].cValue = 16;
			}
			else if (pMob[conn].MOB.Clan == 8) {
				pMob[conn].MOB.Equip[15].sIndex = 3192;
				pMob[conn].MOB.Equip[15].stEffect[0].cEffect = 54;
				pMob[conn].MOB.Equip[15].stEffect[0].cValue = 16;
			}
			else
				pMob[conn].MOB.Equip[15].sIndex = 3193;
			pMob[conn].MOB.Equip[15].stEffect[0].cEffect = 54;
			pMob[conn].MOB.Equip[15].stEffect[0].cValue = 16;
			
			SendItem(conn, ITEM_PLACE_EQUIP, 15, &pMob[conn].MOB.Equip[15]);
		}

		if (pMob[conn].MOB.CurrentScore.Level == 369)
		{
			pMob[conn].extra.QuestInfo.Arch.Level370 = 1;
			pMob[conn].extra.Fame -= 1;

		}
		SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 1);

		SendEmotion(conn, 14, 3);
		SendClientMessage(conn, g_pMessageStringTable[_NN_Processing_Complete]);
		SaveUser(conn, 0);
		return;
	}
}

# -------------------- _MSG_CombineItemOdin.cpp --------------------

/*
*   Copyright (C) {2015}  {Victor Klafke, Charles TheHouse}
*
*   This program is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program.  If not, see [http://www.gnu.org/licenses/].
*
*   Contact at: victor.klafke@ecomp.ufsm.br
*/
#include "ProcessClientMessage.h"

void Exec_MSG_CombineItemOdin(int conn, char* pMsg)
{
	MSG_CombineItem* m = (MSG_CombineItem*)pMsg;

	int Size = m->Size;

	if (Size > sizeof(MSG_CombineItem)) //CONTROLE DE SIZE
	{
		SendClientMessage(conn, "Impossível executar ação19, tente mais tarde. ");
		return;
	}
	if (pUser[conn].Atraso != 0)
	{
		int isTime = GetTickCount64() - pUser[conn].Atraso; // ATRASO PACOTE

		if (isTime < 800)
		{
			SendClientMessage(conn, "Aguarde 1 segundo para uma nova Tentativa.");
			return;
		}

	}
	pUser[conn].Atraso = GetTickCount64();

	for (int i = 0; i < MAX_COMBINE; i++)
	{
		int invPos = m->InvenPos[i];

		if (m->Item[i].sIndex == 0)
			continue;

		if (invPos == -1) {
			Combinelogsitem(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, "dup,Tentativa de Dup CombineOdin");
			continue;
		}

		if (invPos < 0 || invPos >= pMob[conn].MaxCarry)
		{
			RemoveTrade(conn);
			return;
		}

		if (memcmp(&pMob[conn].MOB.Carry[invPos], &m->Item[i], sizeof(STRUCT_ITEM)))
		{
			Combinelogsitem(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, "err,msg_CombineOdin - item remove or changed.");
			SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 0);
			return;
		}
	}

	int combine = GetMatchCombineOdin(m->Item);

	if (combine == 2)
	{
		int sAgua = 0;
		int sTerra = 0;
		int sSol = 0;
		int sVento = 0;

		if (m->Item[3].sIndex == 5334 || m->Item[4].sIndex == 5334 || m->Item[5].sIndex == 5334 || m->Item[6].sIndex == 5334)
			sAgua = 1;

		if (m->Item[3].sIndex == 5335 || m->Item[4].sIndex == 5335 || m->Item[5].sIndex == 5335 || m->Item[6].sIndex == 5335)
			sTerra = 1;

		if (m->Item[3].sIndex == 5336 || m->Item[4].sIndex == 5336 || m->Item[5].sIndex == 5336 || m->Item[6].sIndex == 5336)
			sSol = 1;

		if (m->Item[3].sIndex == 5337 || m->Item[4].sIndex == 5337 || m->Item[5].sIndex == 5337 || m->Item[6].sIndex == 5337)
			sVento = 1;

		if ((sAgua && (sTerra == 0 || sSol == 0 || sVento == 0)) || (sTerra && (sAgua == 0 || sSol == 0 || sVento == 0)) || (sSol && (sAgua == 0 || sTerra == 0 || sVento == 0)) || (sVento && (sAgua == 0 || sTerra == 0 || sSol == 0)))
		{
			SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 0);
			SaveUser(conn, 0);
			return;
		}
	}

	if (combine == 2 && (BASE_GetItemSanc(&m->Item[2]) >= REF_15 || BASE_GetItemAbility(&m->Item[2], EF_MOBTYPE) == 3))
	{
		SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 0);
		SaveUser(conn, 0);
		return;
	}

	if (combine == 4 && (pMob[conn].MOB.CurrentScore.Level != 39 || pMob[conn].extra.QuestInfo.Celestial.Lv40 == 1 || pMob[conn].extra.ClassMaster != CELESTIAL))
	{
		SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 0);
		SaveUser(conn, 0);
		return;
	}

	if (combine == 11 && (pMob[conn].extra.ClassMaster == MORTAL || pMob[conn].extra.ClassMaster == ARCH || BASE_GetItemSanc(&pMob[conn].MOB.Equip[15]) >= 9))
	{
		SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 0);
		SaveUser(conn, 0);
		return;
	}


	for (int i = 0; i < MAX_COMBINE; i++)
	{
		if (m->Item[i].sIndex == 0)
			continue;

		memset(&pMob[conn].MOB.Carry[m->InvenPos[i]], 0, sizeof(STRUCT_ITEM));
		SendItem(conn, ITEM_PLACE_CARRY, m->InvenPos[i], &pMob[conn].MOB.Carry[m->InvenPos[i]]);
	}

	//ItemLog("*** Item combine odin. ***", pUser[conn].AccountName, pUser[conn].IP);

	for (int i = 0; i < MAX_COMBINE; i++)
	{
		if (m->Item[i].sIndex)
		{
			char itemlog[2048];

			BASE_GetItemCode(&m->Item[i], itemlog);

			strcat(temp, itemlog);
		}
	}
	//ItemLog(temp, pUser[conn].AccountName, pUser[conn].IP);
	//ItemLog("*** ------------------- ***", pUser[conn].AccountName, pUser[conn].IP);

	//srand(time(NULL) / 5 * (rand() % 500) * 5);//Garante valores realmente aleatorio
	srand(time(NULL) / 5 * (rand() % 500) * 5);//Garante valores realmente aleatorio
	int _rand = rand() % 199;;
	if (_rand > 100)
	{
		_rand = _rand - 99;
	}

	if (combine == 0)//Composição de Sets ??????
	{
		SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 0);
		return;

		//srand(time(NULL) / 5 * (rand() % 500) * 5);//Garante valores realmente aleatorio
		//if (_rand <= 50 || LOCALSERVER)

		//{

		//	memcpy(&pMob[conn].MOB.Carry[m->InvenPos[1]], &m->Item[1], sizeof(STRUCT_ITEM));

		//	pMob[conn].MOB.Carry[m->InvenPos[1]].sIndex = g_pItemList[m->Item[0].sIndex].Extra;//Usa o número referente ao Extra na itemlist para definir o item a ser entregue:
		//	//Exemplo :1902,Eithna_selado,2892.1,0.0.0.0.0,42,270000,1,3626,0,EF_CLASS,255,EF_GRID,0,EF_ITEMLEVEL,5 >> 3626 é o item a ser entregue caso use Eithna Selado
		//	BASE_SetItemSanc(&pMob[conn].MOB.Carry[m->InvenPos[1]], 0, 0);

		//	char tt[256];

		//	SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 1);

		//	sprintf_s(temp, "%s ", pUser[conn].AccountName);
		//	BASE_GetItemCode(&pMob[conn].MOB.Carry[m->InvenPos[1]], tt);
		//	strcat(temp, tt);

		//	Combinelogsitem(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);
		//	sprintf_s(temp, "Jogador [%s] obteve sucesso na composição do Item [%s]", pMob[conn].MOB.MobName, g_pItemList[pMob[conn].MOB.Carry[m->InvenPos[1]].sIndex].Name);
		//	Combinelogsitem(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);

		//	SendItem(conn, ITEM_PLACE_CARRY, m->InvenPos[1], &pMob[conn].MOB.Carry[m->InvenPos[1]]);

		//	SendClientMessage(conn, "Obteve Sucesso na Composição");

		//	SaveUser(conn, 0);
		//	return;
		//}
		//else
		//{
		//	memcpy(&pMob[conn].MOB.Carry[m->InvenPos[1]], &m->Item[1], sizeof(STRUCT_ITEM));
		//	SendItem(conn, ITEM_PLACE_CARRY, m->InvenPos[1], &pMob[conn].MOB.Carry[m->InvenPos[1]]);

		//	SendClientMessage(conn, "Falha ao Combinar");

		//	sprintf_s(temp, "Jogador [%s] falhou na composição do Item [%s]", pMob[conn].MOB.MobName, g_pItemList[pMob[conn].MOB.Carry[m->InvenPos[1]].sIndex].Name);
		//	Combinelogsitem(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);

		//	SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 2);
		//	SaveUser(conn, 0);
		//	return;
		//}
	}

	else if (combine == 1)//Composição de armas
	{

		srand(time(NULL) / 5 * (rand() % 500) * 5);//Garante valores realmente aleatorio
		int _chance_r = (g_pOdinRate[combine] + rand() % 5);
		if (_rand <= 50 || LOCALSERVER)

		{

			memcpy(&pMob[conn].MOB.Carry[m->InvenPos[1]], &m->Item[1], sizeof(STRUCT_ITEM));

			pMob[conn].MOB.Carry[m->InvenPos[1]].sIndex = g_pItemList[m->Item[0].sIndex].Extra;
			BASE_SetItemSanc(&pMob[conn].MOB.Carry[m->InvenPos[1]], 0, 0);

			char tt[256];

			SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 1);

			printf(temp, "%s ", pUser[conn].AccountName);
			BASE_GetItemCode(&pMob[conn].MOB.Carry[m->InvenPos[1]], tt);
			strcat(temp, tt);

			SendClientMessage(conn, "Sucesso na composição");

			Combinelogsitem(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);
			sprintf_s(temp, "Jogador [%s] obteve sucesso na composição do Item [%s]", pMob[conn].MOB.MobName, g_pItemList[pMob[conn].MOB.Carry[m->InvenPos[1]].sIndex].Name);
			Combinelogsitem(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);

			SendItem(conn, ITEM_PLACE_CARRY, m->InvenPos[1], &pMob[conn].MOB.Carry[m->InvenPos[1]]);
			SaveUser(conn, 0);
			return;
		}
		else
		{
			memcpy(&pMob[conn].MOB.Carry[m->InvenPos[1]], &m->Item[1], sizeof(STRUCT_ITEM));
			SendItem(conn, ITEM_PLACE_CARRY, m->InvenPos[1], &pMob[conn].MOB.Carry[m->InvenPos[1]]);

			SendClientMessage(conn, "Falha na composição");

			SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 2);

			sprintf_s(temp, "Jogador [%s] falhou na composição do Item [%s]", pMob[conn].MOB.MobName, g_pItemList[pMob[conn].MOB.Carry[m->InvenPos[1]].sIndex].Name);
			Combinelogsitem(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);
			SaveUser(conn, 0);
			return;
		}
	}

	/*
	if (combine == 1)//Item celestial
	{
		if (_rand <= 35)
		{
			memcpy(&pMob[conn].MOB.Carry[m->InvenPos[1]], &m->Item[1], sizeof(STRUCT_ITEM));

			pMob[conn].MOB.Carry[m->InvenPos[1]].sIndex = g_pItemList[m->Item[0].sIndex].Extra;
			BASE_SetItemSanc(&pMob[conn].MOB.Carry[m->InvenPos[1]], 0, 0);

			char tt[256];

			sprintf(temp, "Combinação Bem Sucedida [ %s / 35 ]", _rand);
			SendClientMessage(conn, temp);

			SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 1);

			sprintf(temp, "%s ", pUser[conn].AccountName);
			BASE_GetItemCode(&pMob[conn].MOB.Carry[m->InvenPos[1]], tt);
			strcat(temp, tt);

			ItemLog(temp, "*** Combine odin sucess ***", pUser[conn].MacAddress);
			SendItem(conn, ITEM_PLACE_CARRY, m->InvenPos[1], &pMob[conn].MOB.Carry[m->InvenPos[1]]);

			return;
		}
		else
		{
			//memcpy(&pMob[conn].MOB.Carry[m->InvenPos[1]], &m->Item[1], sizeof(STRUCT_ITEM));
			SendItem(conn, ITEM_PLACE_CARRY, m->InvenPos[1], &pMob[conn].MOB.Carry[m->InvenPos[1]]);

			sprintf(temp, "Combinação Bem Sucedida [ %s / 35 ]", _rand);
			SendClientMessage(conn, temp);

			SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 2);
			ItemLog("*** Combine odin fail ***", pUser[conn].AccountName, pUser[conn].MacAddress);

			return;
		}
	}*/

	else if (combine == 2)//Item +12+
	{
		int rate = 1;

		int protect = 0;

		for (int i = 0; i < MAX_COMBINE; i++)
		{
			if (m->Item[i].sIndex >= 5334 && m->Item[i].sIndex <= 5337)
				rate += g_pItemSancRate12[0];

			if (m->Item[i].sIndex == 4043)
				protect++;

			if (m->Item[i].sIndex == 3338 && BASE_GetItemSanc(&m->Item[i]) == 0)
				rate += g_pItemSancRate12[1];

			else if (m->Item[i].sIndex == 3338 && BASE_GetItemSanc(&m->Item[i]) == 1)
				rate += g_pItemSancRate12[2];

			else if (m->Item[i].sIndex == 3338 && BASE_GetItemSanc(&m->Item[i]) == 2)
				rate += g_pItemSancRate12[3];

			else if (m->Item[i].sIndex == 3338 && BASE_GetItemSanc(&m->Item[i]) == 3)
				rate += g_pItemSancRate12[4];

			else if (m->Item[i].sIndex == 3338 && BASE_GetItemSanc(&m->Item[i]) == 4)
				rate += g_pItemSancRate12[5];

			else if (m->Item[i].sIndex == 3338 && BASE_GetItemSanc(&m->Item[i]) == 5)
				rate += g_pItemSancRate12[6];

			else if (m->Item[i].sIndex == 3338 && BASE_GetItemSanc(&m->Item[i]) == 6)
				rate += g_pItemSancRate12[7];

			else if (m->Item[i].sIndex == 3338 && BASE_GetItemSanc(&m->Item[i]) == 7)
				rate += g_pItemSancRate12[8];

			else if (m->Item[i].sIndex == 3338 && BASE_GetItemSanc(&m->Item[i]) == 8)
				rate += g_pItemSancRate12[9];

			else if (m->Item[i].sIndex == 3338 && BASE_GetItemSanc(&m->Item[i]) == 9)
				rate += g_pItemSancRate12[10];
		}

		if (BASE_GetItemSanc(&m->Item[2]) <= REF_10 || BASE_GetItemSanc(&m->Item[2]) >= REF_15)
		{
			SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 0);
			SaveUser(conn, 0);
			return;
		}

		if (BASE_GetItemSanc(&m->Item[2]) == REF_12)
			rate -= g_pItemSancRate12Minus[0];

		else if (BASE_GetItemSanc(&m->Item[2]) == REF_13)
			rate -= g_pItemSancRate12Minus[1];

		else if (BASE_GetItemSanc(&m->Item[2]) == REF_14)
			rate -= g_pItemSancRate12Minus[2];

		else if (BASE_GetItemSanc(&m->Item[2]) == REF_15)
			rate -= g_pItemSancRate12Minus[3];

		if (rate >= _rand || LOCALSERVER)
		{
			memcpy(&pMob[conn].MOB.Carry[m->InvenPos[2]], &m->Item[2], sizeof(STRUCT_ITEM));

			int sanc = BASE_GetItemSanc(&m->Item[2]);
			int gem = BASE_GetItemGem(&m->Item[2]);

			int NewSanc = 0;

			if (sanc == REF_11)
			{
				BASE_SetItemSanc(&pMob[conn].MOB.Carry[m->InvenPos[2]], 12, gem);
				NewSanc = 12;
			}
			else if (sanc == REF_12)
			{
				BASE_SetItemSanc(&pMob[conn].MOB.Carry[m->InvenPos[2]], 13, gem);
				NewSanc = 13;
			}
			else if (sanc == REF_13)
			{
				BASE_SetItemSanc(&pMob[conn].MOB.Carry[m->InvenPos[2]], 14, gem);
				NewSanc = 14;
			}
			else if (sanc == REF_14)
			{
				BASE_SetItemSanc(&pMob[conn].MOB.Carry[m->InvenPos[2]], 15, gem);
				NewSanc = 15;
			}
			char tt[256];

			SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 1);


			BASE_GetItemCode(&pMob[conn].MOB.Carry[m->InvenPos[2]], tt);
			strcat(temp, tt);

			SendClientMessage(conn, "Você obteve sucesso na refinação");

			SendItem(conn, ITEM_PLACE_CARRY, m->InvenPos[2], &pMob[conn].MOB.Carry[m->InvenPos[2]]);


			Combinelogsitem(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);
			sprintf_s(temp, "Jogador [%s] obteve sucesso na composição do Item [%s +%d]", pMob[conn].MOB.MobName, g_pItemList[pMob[conn].MOB.Carry[m->InvenPos[2]].sIndex].Name, NewSanc);
			Combinelogsitem(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);
			return;
		}
		else
		{
			if (rate <= 9 && BASE_GetItemAbility(&m->Item[2], EF_MOBTYPE) == 1)
			{//Possivel quebra

				//Escudos
				if (g_pItemList[m->Item[2].sIndex].nPos == 128)
					goto Label_VoltaRef;

				if (rate <= 9)//Tentou com secretas
				{
					if (rand() % 1 == 0)
					{
						//correção extração entregue pelo odin
						if (protect == 2)
						{
							memcpy(&pMob[conn].MOB.Carry[m->InvenPos[2]], &m->Item[2], sizeof(STRUCT_ITEM));

							pMob[conn].MOB.Carry[m->InvenPos[2]].sIndex = 3021;

							pMob[conn].MOB.Carry[m->InvenPos[2]].stEffect[0].cValue = 10;

							if (g_pItemList[m->Item[2].sIndex].nPos == 4)
								pMob[conn].MOB.Carry[m->InvenPos[2]].sIndex++;

							else if (g_pItemList[m->Item[2].sIndex].nPos == 8)
								pMob[conn].MOB.Carry[m->InvenPos[2]].sIndex += 2;

							else if (g_pItemList[m->Item[2].sIndex].nPos == 16)
								pMob[conn].MOB.Carry[m->InvenPos[2]].sIndex += 3;

							else if (g_pItemList[m->Item[2].sIndex].nPos == 32)
								pMob[conn].MOB.Carry[m->InvenPos[2]].sIndex += 4;

							else if (g_pItemList[m->Item[2].sIndex].nPos == 64)
								pMob[conn].MOB.Carry[m->InvenPos[2]].sIndex += 5;

							else
							{
								pMob[conn].MOB.Carry[m->InvenPos[2]].sIndex = 3026;
								pMob[conn].MOB.Carry[m->InvenPos[2]].stEffect[0].cValue = 11;
							}



							SendItem(conn, ITEM_PLACE_CARRY, m->InvenPos[2], &pMob[conn].MOB.Carry[m->InvenPos[2]]);
						}
						else
						{
							memset(&pMob[conn].MOB.Carry[m->InvenPos[2]], 0, sizeof(STRUCT_ITEM));
							SendItem(conn, ITEM_PLACE_CARRY, m->InvenPos[2], &pMob[conn].MOB.Carry[m->InvenPos[2]]);
						}
					}
					else
						goto Label_VoltaRef;
				}
			}
			else
			{
			Label_VoltaRef:
				memcpy(&pMob[conn].MOB.Carry[m->InvenPos[2]], &m->Item[2], sizeof(STRUCT_ITEM));

				int sanc = BASE_GetItemSanc(&m->Item[2]);
				int gem = BASE_GetItemGem(&m->Item[2]);

				int Extra = BASE_GetItemAbility(&m->Item[2], EF_ITEMLEVEL); //TRAVAR ITEMS C

				if (Extra <= 4)
				{
					SendClientMessage(conn, "Items de Rank B ou Inferior Proibidos de fazer +12"); //TRAVAR ITEMS C
					SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 0);
					SendEtc(conn);
					SendCarry(conn);
					return;
				}

				if (sanc == REF_11)
					BASE_SetItemSanc(&pMob[conn].MOB.Carry[m->InvenPos[2]], 10, gem);

				else if (sanc == REF_12)
					BASE_SetItemSanc(&pMob[conn].MOB.Carry[m->InvenPos[2]], 11, gem);

				else if (sanc == REF_13)
					BASE_SetItemSanc(&pMob[conn].MOB.Carry[m->InvenPos[2]], 12, gem);

				else if (sanc == REF_14)
					BASE_SetItemSanc(&pMob[conn].MOB.Carry[m->InvenPos[2]], 13, gem);

				SendItem(conn, ITEM_PLACE_CARRY, m->InvenPos[2], &pMob[conn].MOB.Carry[m->InvenPos[2]]);
			}
			SendClientMessage(conn, g_pMessageStringTable[_NN_CombineFailed]);

			SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 2);

			int lsanc = BASE_GetItemSanc(&m->Item[2]);
			sprintf_s(temp, "Jogador [%s] obteve FALHA na composição do Item. Item: %s+%d Chance: [%d/%d]", pMob[conn].MOB.MobName, g_pItemList[m->Item[0].sIndex].Name, lsanc, _rand, combine);
			Combinelogsitem(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);
			SaveUser(conn, 0);
			return;
		}

	}

	else if (combine == 3)//Pista de runas
	{
		/*if (_rand <= g_pOdinRate[combine] || LOCALSERVER)
		{*/
		pMob[conn].MOB.Carry[m->InvenPos[0]].sIndex = 5134;

		char tt[256];

		SendClientMessage(conn, g_pMessageStringTable[_NN_Processing_Complete]);

		SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 1);

		sprintf_s(temp, "%s ", pUser[conn].AccountName);
		BASE_GetItemCode(&pMob[conn].MOB.Carry[m->InvenPos[0]], tt);
		strcat(temp, tt);
		Combinelogsitem(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);

		//ItemLog(temp, "*** Combine odin sucess ***", pUser[conn].MacAddress);
		SendItem(conn, ITEM_PLACE_CARRY, m->InvenPos[0], &pMob[conn].MOB.Carry[m->InvenPos[0]]);
		SaveUser(conn, 0);
		return;
		//}
		/*else
		{
			sprintf(temp, "%s - Pista de Runas", g_pMessageStringTable[_NN_CombineFailed]);
			SendClientMessage(conn, temp);

			SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 2);
			ItemLog("*** Combine odin fail ***", pUser[conn].AccountName, pUser[conn].MacAddress);
			SaveUser(conn, 0);
			return;
		}*/
	}

	else if (combine == 4)//Destrave Lv40
	{
		if (_rand <= g_pOdinRate[combine] || LOCALSERVER)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Processing_Complete]);

			SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 1);

			sprintf(temp, "destrave,mobname:%s lv:40", pMob[conn].MOB.MobName);
			Combinelogsitem(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);

			pMob[conn].extra.QuestInfo.Celestial.Lv40 = 1;
			SaveUser(conn, 0);
			return;
		}
		else
		{
			SendClientMessage(conn, strFmt("%s - Destrave Lv40", g_pMessageStringTable[_NN_CombineFailed]));
			Combinelogsitem(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, strFmt("%s - Destrave Lv40", g_pMessageStringTable[_NN_CombineFailed]));
			SaveUser(conn, 0);
			return;
		}
	}

	else if (combine == 5)//Pedra da fúria
	{
		if (_rand <= g_pOdinRate[combine] || LOCALSERVER)
		{
			pMob[conn].MOB.Carry[m->InvenPos[0]].sIndex = 3020;

			char tt[512];

			SendClientMessage(conn, g_pMessageStringTable[_NN_Processing_Complete]);

			SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 1);

			sprintf_s(temp, "%s ", pUser[conn].AccountName);
			BASE_GetItemCode(&pMob[conn].MOB.Carry[m->InvenPos[0]], tt);
			strcat(temp, tt);

			Combinelogsitem(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);
			SendItem(conn, ITEM_PLACE_CARRY, m->InvenPos[0], &pMob[conn].MOB.Carry[m->InvenPos[0]]);
			SaveUser(conn, 0);
			return;
		}
		else
		{
			SendClientMessage(conn, strFmt("%s - Pedra da Furia", g_pMessageStringTable[_NN_CombineFailed]));

			SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 2);
			Combinelogsitem(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, strFmt("%s - Pedra da Furia", g_pMessageStringTable[_NN_CombineFailed]));
			SaveUser(conn, 0);
			return;
		}
	}

	else if (combine >= 6 && combine <= 9)//Pedra da agua - terra - sol - vento
	{
		if (_rand <= g_pOdinRate[combine] || LOCALSERVER)
		{
			pMob[conn].MOB.Carry[m->InvenPos[0]].sIndex = 5334 + (combine - 6);

			char tt[512];

			SendClientMessage(conn, g_pMessageStringTable[_NN_Processing_Complete]);

			SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 1);

			sprintf_s(temp, "%s ", pUser[conn].AccountName);
			BASE_GetItemCode(&pMob[conn].MOB.Carry[m->InvenPos[0]], tt);
			strcat(temp, tt);

			Combinelogsitem(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);
			SendItem(conn, ITEM_PLACE_CARRY, m->InvenPos[0], &pMob[conn].MOB.Carry[m->InvenPos[0]]);
			SaveUser(conn, 0);
			return;
		}
		else
		{
			SendClientMessage(conn, strFmt("%s - Secretas", g_pMessageStringTable[_NN_CombineFailed]));

			SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 2);
			Combinelogsitem(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, strFmt("%s - Secretas", g_pMessageStringTable[_NN_CombineFailed]));
			SaveUser(conn, 0);
			return;
		}
	}

	else if (combine == 10)//Semente de cristal
	{
		if (_rand <= g_pOdinRate[combine] || LOCALSERVER)
		{
			pMob[conn].MOB.Carry[m->InvenPos[0]].sIndex = 4032;

			char tt[512];

			SendClientMessage(conn, g_pMessageStringTable[_NN_Processing_Complete]);

			SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 1);

			sprintf_s(temp, "%s ", pUser[conn].AccountName);
			BASE_GetItemCode(&pMob[conn].MOB.Carry[m->InvenPos[0]], tt);
			strcat(temp, tt);

			Combinelogsitem(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);
			SendItem(conn, ITEM_PLACE_CARRY, m->InvenPos[0], &pMob[conn].MOB.Carry[m->InvenPos[0]]);
			SaveUser(conn, 0);
			return;
		}
		else
		{
			SendClientMessage(conn, strFmt("%s - Semente de Cristal", g_pMessageStringTable[_NN_CombineFailed]));

			SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 2);
			Combinelogsitem(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, strFmt("%s - Semente de Cristal", g_pMessageStringTable[_NN_CombineFailed]));
			SaveUser(conn, 0);
			return;
		}
	}

	else if (combine == 11)//Capa celestial
	{
		if (_rand <= g_pOdinRate[combine] || LOCALSERVER)
		{
			int sanc = BASE_GetItemSanc(&pMob[conn].MOB.Equip[15]);

			if (sanc == 0)
			{
				if (pMob[conn].MOB.Equip[15].stEffect[0].cEffect && pMob[conn].MOB.Equip[15].stEffect[0].cEffect != 43 && (pMob[conn].MOB.Equip[15].stEffect[0].cEffect && pMob[conn].MOB.Equip[15].stEffect[0].cEffect < 116 || pMob[conn].MOB.Equip[15].stEffect[0].cEffect && pMob[conn].MOB.Equip[15].stEffect[0].cEffect > 125))
				{
					if (pMob[conn].MOB.Equip[15].stEffect[1].cEffect && pMob[conn].MOB.Equip[15].stEffect[1].cEffect != 43 && (pMob[conn].MOB.Equip[15].stEffect[1].cEffect && pMob[conn].MOB.Equip[15].stEffect[1].cEffect < 116 || pMob[conn].MOB.Equip[15].stEffect[1].cEffect && pMob[conn].MOB.Equip[15].stEffect[1].cEffect > 125))
					{
						if (pMob[conn].MOB.Equip[15].stEffect[2].cEffect && pMob[conn].MOB.Equip[15].stEffect[2].cEffect != 43 && (pMob[conn].MOB.Equip[15].stEffect[2].cEffect && pMob[conn].MOB.Equip[15].stEffect[2].cEffect < 116 || pMob[conn].MOB.Equip[15].stEffect[2].cEffect && pMob[conn].MOB.Equip[15].stEffect[2].cEffect > 125))
						{
							SendClientMessage(conn, g_pMessageStringTable[_NN_Cant_Refine_More]);
							return;
						}
						pMob[conn].MOB.Equip[15].stEffect[2].cEffect = 43;
						pMob[conn].MOB.Equip[15].stEffect[2].cValue = 0;
					}
					else
					{
						pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 43;
						pMob[conn].MOB.Equip[15].stEffect[1].cValue = 0;
					}
				}
				else
				{
					pMob[conn].MOB.Equip[15].stEffect[0].cEffect = 43;
					pMob[conn].MOB.Equip[15].stEffect[0].cValue = 0;
				}
			}

			BASE_SetItemSanc(&pMob[conn].MOB.Equip[15], sanc + 1, 0);

			char tt[256];

			SendClientMessage(conn, g_pMessageStringTable[_NN_Processing_Complete]);

			SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 1);

			sprintf_s(temp, "%s ", pUser[conn].AccountName);
			BASE_GetItemCode(&pMob[conn].MOB.Carry[m->InvenPos[0]], tt);
			strcat(temp, tt);

			Combinelogsitem(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);
			SendItem(conn, ITEM_PLACE_EQUIP, 15, &pMob[conn].MOB.Equip[15]);
			SaveUser(conn, 0);
			return;
		}
		else
		{
			SendClientMessage(conn, strFmt("%s - Capa Celestial", g_pMessageStringTable[_NN_CombineFailed]));

			SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 2);
			Combinelogsitem(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, strFmt("%s - Capa Celestial", g_pMessageStringTable[_NN_CombineFailed]));
			SaveUser(conn, 0);
			return;
		}
	}

	else
	{
		SendClientMessage(conn, strFmt("%s - Nenhuma Função", g_pMessageStringTable[_NN_CombineFailed]));

		SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 2);
		Combinelogsitem(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, strFmt("%s - Nenhuma Função", g_pMessageStringTable[_NN_CombineFailed]));
		SaveUser(conn, 0);
		return;
	}
}

# -------------------- _MSG_CombineItemShany.cpp --------------------


#include "ProcessClientMessage.h"

void Exec_MSG_CombineItemShany(int conn, char* pMsg)
{
	MSG_CombineItem* m = (MSG_CombineItem*)pMsg;

	int Size = m->Size;

	if (Size > sizeof(MSG_CombineItem)) //CONTROLE DE SIZE
	{
		SendClientMessage(conn, "Impossível executar ação20, tente mais tarde. ");
		return;
	}
	if (pUser[conn].Atraso != 0)
	{
		int isTime = GetTickCount64() - pUser[conn].Atraso; // ATRASO PACOTE

		if (isTime < 800)
		{
			SendClientMessage(conn, "Aguarde 1 segundo para uma nova Tentativa.");
			return;
		}

	}
	pUser[conn].Atraso = GetTickCount64();

	for (int i = 0; i < MAX_COMBINE; i++)
	{
		int invPos = m->InvenPos[i];

		if (m->Item[i].sIndex == 0)
			continue;

		if (invPos == -1) {
			Combinelogsitem(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, "dup,Tentativa de Dup CombineShany");
			return;
		}

		if (invPos < 0 || invPos >= pMob[conn].MaxCarry)
		{
			RemoveTrade(conn);
			return;
		}

		if (memcmp(&pMob[conn].MOB.Carry[invPos], &m->Item[i], sizeof(STRUCT_ITEM)))
		{
			Combinelogsitem(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, "err,msg_Combineshany - item remove or changed.");
			SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 0);
			return;
		}
	}

	if (pMob[conn].extra.ClassMaster == MORTAL)
	{
		SendClientMessage(conn, "Necessário ser Arch!");
		SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 0);
		return;
	}
	int combine = GetMatchCombineShany(m->Item);

	if (combine == 0)
	{
		SendClientMessage(conn, g_pMessageStringTable[_NN_Wrong_Combination]);
		SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 0);
		return;
	}

	for (int i = 0; i < MAX_COMBINE; i++)
	{
		if (m->Item[i].sIndex == 0)
			continue;

		memset(&pMob[conn].MOB.Carry[m->InvenPos[i]], 0, sizeof(STRUCT_ITEM));
		SendItem(conn, ITEM_PLACE_CARRY, m->InvenPos[i], &pMob[conn].MOB.Carry[m->InvenPos[i]]);
	}

	Combinelogsitem(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, "*** Item combine shany. ***");


	int _rand = rand() % 115;
	if (_rand >= 100)
		_rand -= 15;

	if (_rand <= g_pShanyBase || LOCALSERVER)
	{
		if (_rand < 50)
		{
			
			STRUCT_ITEM Item;
			memset(&Item, 0, sizeof(STRUCT_ITEM));
			Item.sIndex = 633;
			PutItem(conn, &Item);
			SendClientMessage(conn, g_pMessageStringTable[_NN_Processing_Complete]);
			SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 1);
			/*snprintf(temp, sizeof(temp), "Jogador %s Teve sucesso ao Combinar Espiritual para Adicional", pMob[conn].MOB.MobName);

			SendSpkMsg(1, temp, TNColor::GreenYellow, true);*/
			SaveUser(conn, 0);
			return;

		}
		if (_rand >= 50 && _rand <= 65)
		{
			
			STRUCT_ITEM Item;
			memset(&Item, 0, sizeof(STRUCT_ITEM));
			Item.sIndex = 632;
			PutItem(conn, &Item);
			SendClientMessage(conn, g_pMessageStringTable[_NN_Processing_Complete]);
			SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 1);
			/*snprintf(temp, sizeof(temp), "Jogador %s Não Obteve Sucesso ao Combinar Espiritual", pMob[conn].MOB.MobName);
			SendNotice(temp);*/
			SaveUser(conn, 0);
			return;

		}
		if (_rand > 65 && _rand <= 80)
		{
			
			STRUCT_ITEM Item;
			memset(&Item, 0, sizeof(STRUCT_ITEM));
			Item.sIndex = 631;
			PutItem(conn, &Item);
			SendClientMessage(conn, g_pMessageStringTable[_NN_Processing_Complete]);
			SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 1);
			/*snprintf(temp, sizeof(temp), "Jogador %s Não Obteve Sucesso ao Combinar Espiritual", pMob[conn].MOB.MobName);
			SendNotice(temp);*/
			SaveUser(conn, 0);
			return;
		}
	}
	else
	{


		SendClientMessage(conn, g_pMessageStringTable[_NN_CombineFailed]);
		/*
		snprintf(temp, sizeof(temp), "Jogador %s Teve Falha ao Combinar Espiritual", pMob[conn].MOB.MobName);
		SendNotice(temp);*/
		Combinelogsitem(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);

		SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 2);
		SaveUser(conn, 0);
		return;
	}
}

# -------------------- _MSG_CombineItemTiny.cpp --------------------

/*
*   Copyright (C) {2015}  {Victor Klafke, Charles TheHouse}
*
*   This program is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program.  If not, see [http://www.gnu.org/licenses/].
*
*   Contact at: victor.klafke@ecomp.ufsm.br
*/
#include "ProcessClientMessage.h" 


void Exec_MSG_CombineItemTiny(int conn, char* pMsg)
{
	MSG_CombineItem* m = (MSG_CombineItem*)pMsg;

	int Size = m->Size;

	if (Size > sizeof(MSG_CombineItem)) //CONTROLE DE SIZE
	{
		SendClientMessage(conn, "Impossível executar ação21, tente mais tarde. ");
		return;
	}
	if (pUser[conn].Atraso != 0)
	{
		int isTime = GetTickCount64() - pUser[conn].Atraso; // ATRASO PACOTE

		if (isTime < 800)
		{
			SendClientMessage(conn, "Aguarde 1 segundo para uma nova Tentativa.");
			return;
		}

	}
	pUser[conn].Atraso = GetTickCount64();

	for (int i = 0; i < MAX_COMBINE; i++)
	{
		int invPos = m->InvenPos[i];

		if (m->Item[i].sIndex == 0)
			continue;

		if (invPos == -1) {
			Combinelogsitem(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, "dup,Tentativa de Dup CombineTiny");
			return;
		}

		if (invPos < 0 || invPos >= pMob[conn].MaxCarry)
		{
			RemoveTrade(conn);
			return;
		}

		if (memcmp(&pMob[conn].MOB.Carry[invPos], &m->Item[i], sizeof(STRUCT_ITEM)))
		{
			Combinelogsitem(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, "err,msg_CombineTiny - item remove or changed.");
			SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 0);
			return;
		}
	}

	if (pMob[conn].MOB.Coin < 100000000)
	{
		SendClientMessage(conn, "Gold insuficiente");
		SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 0);
		return;
	}

	int combine = GetMatchCombineTiny(m->Item);

	if (combine == 0)
	{
		SendClientMessage(conn, g_pMessageStringTable[_NN_Wrong_Combination]);
		SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 0);
		return;
	}

	for (int i = 2; i < MAX_COMBINE; i++)
	{
		if (m->Item[i].sIndex == 0)
			continue;

		memset(&pMob[conn].MOB.Carry[m->InvenPos[i]], 0, sizeof(STRUCT_ITEM));
		SendItem(conn, ITEM_PLACE_CARRY, m->InvenPos[i], &pMob[conn].MOB.Carry[m->InvenPos[i]]);
	}


	int _rand = rand() % 115;
	if (_rand >= 100)
		_rand -= 15;

	int ipos = m->InvenPos[0];

	if (_rand <= combine || LOCALSERVER)
	{
		pMob[conn].MOB.Carry[ipos].stEffect[0].cEffect = m->Item[1].stEffect[0].cEffect;
		pMob[conn].MOB.Carry[ipos].stEffect[0].cValue = m->Item[1].stEffect[0].cValue;
		pMob[conn].MOB.Carry[ipos].stEffect[1].cEffect = m->Item[1].stEffect[1].cEffect;
		pMob[conn].MOB.Carry[ipos].stEffect[1].cValue = m->Item[1].stEffect[1].cValue;
		pMob[conn].MOB.Carry[ipos].stEffect[2].cEffect = m->Item[1].stEffect[2].cEffect;
		pMob[conn].MOB.Carry[ipos].stEffect[2].cValue = m->Item[1].stEffect[2].cValue;

		memset(&pMob[conn].MOB.Carry[m->InvenPos[1]], 0, sizeof(STRUCT_ITEM));
		SendItem(conn, ITEM_PLACE_CARRY, m->InvenPos[1], &pMob[conn].MOB.Carry[m->InvenPos[1]]);

		memset(&pMob[conn].MOB.Carry[m->InvenPos[2]], 0, sizeof(STRUCT_ITEM)); // Deleta o Item D
		SendItem(conn, ITEM_PLACE_CARRY, m->InvenPos[2], &pMob[conn].MOB.Carry[m->InvenPos[2]]);

		BASE_SetItemSanc(&pMob[conn].MOB.Carry[ipos], 7, 0);
		pMob[conn].MOB.Coin -= 100000000;
		SendEtc(conn);


		SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 1);

		Combinelogsitem(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, "***SUCESSO COMBINE TINY***");

		SendItem(conn, ITEM_PLACE_CARRY, ipos, &pMob[conn].MOB.Carry[ipos]);

		int TargetVillage = BASE_GetVillage(pMob[conn].TargetX, pMob[conn].TargetY);
		if (TargetVillage >= 0 && TargetVillage < 5)
		{
			if (GuildImpostoID[TargetVillage] >= MAX_USER && GuildImpostoID[TargetVillage] < MAX_MOB && pMob[GuildImpostoID[TargetVillage]].Mode != USER_EMPTY && pMob[GuildImpostoID[TargetVillage]].MOB.Guild == g_pGuildZone[TargetVillage].ChargeGuild)
			{
				if (pMob[GuildImpostoID[TargetVillage]].MOB.Exp < 200000000000)
					pMob[GuildImpostoID[TargetVillage]].MOB.Exp += 100000000 / 10;
			}
		}
		SaveUser(conn, 0);
		return;
	}
	else
	{
		SendClientMessage(conn, strFmt("%s(%d/%d)", g_pMessageStringTable[_NN_CombineFailed], _rand, combine));

		memset(&pMob[conn].MOB.Carry[m->InvenPos[2]], 0, sizeof(STRUCT_ITEM));
		SendItem(conn, ITEM_PLACE_CARRY, m->InvenPos[2], &pMob[conn].MOB.Carry[m->InvenPos[2]]);

		SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 2);

		pMob[conn].MOB.Coin -= 100000000;
		SendEtc(conn);
		SaveUser(conn, 0);
		return;
	}
}

# -------------------- _MSG_CreateCharacter.cpp --------------------

/*
*   Copyright (C) {2015}  {Victor Klafke, Charles TheHouse}
*
*   This program is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program.  If not, see [http://www.gnu.org/licenses/].
*
*   Contact at: victor.klafke@ecomp.ufsm.br
*/
#include "ProcessClientMessage.h"
#include <regex>
#include <mysql.h>
#include "wMySQL.h"

void Exec_MSG_CreateCharacter(int conn, char *pMsg)
{
	MSG_CreateCharacter* m = (MSG_CreateCharacter*)pMsg;

	if (m->Size > sizeof(MSG_CreateCharacter))
		return;


	if (pUser[conn].Mode != USER_CHARWAIT)
	{
		SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, strFmt("err,createchar not user_selchar %d %d", conn, pUser[conn].Mode));

		SendClientSignal(conn, 0, _MSG_NewCharacterFail);
		return;
	}

	if (pUser[conn].Atraso != 0)
	{
		int isTime = GetTickCount64() - pUser[conn].Atraso; // ATRASO PACOTE

		if (isTime < 5000)
		{
			SendClientMessage(conn, "Aguarde 5 segundos para uma nova Tentativa.");
			return;
		}

	}
	pUser[conn].Atraso = GetTickCount64();

	m->MobName[NAME_LENGTH - 1] = 0;
	m->MobName[NAME_LENGTH - 2] = 0;

	if (pUser[conn].WaitDB) {
		SendClientMessage(conn, "Aguarde um momento");
		return;
	}

	//validação de string
	std::string name = { m->MobName };
	std::regex int_regex("^[A-Za-z0-9-]{4,12}$");

	if (!std::regex_match(name, int_regex))
	{
		SendClientSignal(conn, 0, _MSG_NewCharacterFail);
		SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, strFmt("err,createchar not user_selchar %d", conn, pUser[conn].Mode));
		CloseUser(conn);
		return;
	}

	pUser[conn].NumCreated++;

	if (pUser[conn].NumCreated > 5)
	{
		//HackLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, "Desconectado por criar 5 personagens na mesma conta seguidos");
		pUser[conn].NumCreated = 0;
		CloseUser(conn);
		return;
	}

	if (BASE_CheckValidString(m->MobName))
	{
		m->Type = _MSG_DBCreateCharacter;
		m->ID = conn;

		pUser[conn].Mode = USER_WAITDB;
		pUser[conn].WaitDB = true;

		auto& pc = cSQL::instance();

		sprintf(xQuery, "SELECT * FROM `accounts` WHERE `username` = '%s'", pUser[conn].AccountName);

		MYSQL_ROW row;
		MYSQL* wSQL = pc.wStart();
		MYSQL_RES* result = pc.wRes(wSQL, xQuery);

		int Id = 0;

		if (result == NULL)
		{
			return;
		}

		while ((row = mysql_fetch_row(result)) != NULL)
		{
			Id = atoi(row[0]);
		}

		int Evolution = 1;

		sprintf(xQuery, "INSERT INTO `characteres` (`slug`, `account_id`, `nick`, `slot_char`) VALUES ('%d', '%d', '%s', '%d')",
			1, Id, m->MobName, m->Slot);
		pc.wQuery(xQuery);

		DBServerSocket.SendOneMessage((char*)m, sizeof(MSG_CreateCharacter));
		SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, strFmt("etc,createchar name:%s %d %d", m->MobName, conn, pUser[conn].Mode));
	}

	else
		SendClientSignal(conn, 0, _MSG_NewCharacterFail);
}

# -------------------- _MSG_DeleteCharacter.cpp --------------------

/*
*   Copyright (C) {2015}  {Victor Klafke, Charles TheHouse}
*
*   This program is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program.  If not, see [http://www.gnu.org/licenses/].
*
*   Contact at: victor.klafke@ecomp.ufsm.br
*/
#include "ProcessClientMessage.h"
#include <mysql.h>
#include "wMySQL.h"

void Exec_MSG_DeleteCharacter(int conn, char *pMsg)
{
	MSG_DeleteCharacter* m = (MSG_DeleteCharacter*)pMsg;

	if (m->Size > sizeof(MSG_DeleteCharacter))
		return;

	if (m->Slot < 0 || m->Slot >= MOB_PER_ACCOUNT)
	{
		return;
	}

	if (pUser[conn].Mode == USER_WAITDB || pUser[conn].Mode == USER_SELCHAR)
	{
		SendClientMessage(conn, "Deleting Character. wait a moment. #2");
		return;
	}

	if (pUser[conn].Mode != USER_CHARWAIT)
	{
		SendClientMessage(conn, "Deleting Character. wait a moment. #1");
		return;
	}

	if (pUser[conn].Atraso != 0)
	{
		int isTime = GetTickCount64() - pUser[conn].Atraso; // ATRASO PACOTE

		if (isTime < 5000)
		{
			SendClientMessage(conn, "Aguarde 5 segundos para uma nova Tentativa.");
			return;
		}

	}
	pUser[conn].Atraso = GetTickCount64();

	m->MobName[NAME_LENGTH - 1] = 0;

	if (pUser[conn].Mode == USER_CHARWAIT)
	{
		m->Type = _MSG_DBDeleteCharacter;
		m->ID = conn;

		pUser[conn].Mode = USER_WAITDB;


		auto& pc = cSQL::instance();

		sprintf(xQuery, "DELETE FROM `characteres` WHERE `nick`= '%s' AND `slot_char`= '%d'", m->MobName, m->Slot);
		pc.wQuery(xQuery);


		DBServerSocket.SendOneMessage((char*)m, sizeof(MSG_DeleteCharacter));

	}
	else
	{
		SendClientMessage(conn, "Deleting Character. wait a moment.");

	}
}

# -------------------- _MSG_DeleteItem.cpp --------------------


#include "ProcessClientMessage.h"

void Exec_MSG_DeleteItem(int conn, char* pMsg)
{
	MSG_DeleteItem* m = (MSG_DeleteItem*)pMsg;

	int Size = m->Size;

	if (Size > sizeof(MSG_DeleteItem)) //CONTROLE DE CLIENTE SIZE
	{
		SendClientMessage(conn, "Impossível executar ação24, tente mais tarde. ");
		return;
	}

	if (m->Slot < 0 || m->Slot >= MAX_CARRY - 4)
		return;

	if (m->sIndex <= 0 || m->sIndex >= MAX_ITEMLIST)
		return;

	if (pUser[conn].Mode != USER_PLAY)
	{
		SendHpMode(conn);
		return;
	}

	if (pUser[conn].Trade.OpponentID)
	{
		RemoveTrade(pUser[conn].Trade.OpponentID);
		RemoveTrade(conn);
		return;
	}
	//BASE_GetItemCode(&pMob[conn].MOB.Carry[m->Slot], temp);
	snprintf(temp, sizeof(temp), "deleteitem, %d.%d,%d,%d,%d,%d,%d", pMob[conn].MOB.Carry[m->Slot].sIndex,
		pMob[conn].MOB.Carry[m->Slot].stEffect[0].cEffect, pMob[conn].MOB.Carry[m->Slot].stEffect[0].cValue,
		pMob[conn].MOB.Carry[m->Slot].stEffect[1].cEffect, pMob[conn].MOB.Carry[m->Slot].stEffect[1].cValue, 
		pMob[conn].MOB.Carry[m->Slot].stEffect[2].cEffect, pMob[conn].MOB.Carry[m->Slot].stEffect[2].cValue);
	ItemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);

	memset(&pMob[conn].MOB.Carry[m->Slot], 0, sizeof(STRUCT_ITEM));
}

# -------------------- _MSG_Deposit.cpp --------------------

/*
*   Copyright (C) {2015}  {Victor Klafke, Charles TheHouse}
*
*   This program is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program.  If not, see [http://www.gnu.org/licenses/].
*
*   Contact at: victor.klafke@ecomp.ufsm.br
*/
#include "ProcessClientMessage.h"

void Exec_MSG_Deposit(int conn, char *pMsg)
{
	MSG_STANDARDPARM *m = (MSG_STANDARDPARM*)pMsg;

	int Size = m->Size;

	if (Size > sizeof(MSG_STANDARDPARM)) //CONTROLE DE SIZE
	{
		SendClientMessage(conn, "Impossível executar ação25, tente mais tarde. ");
		return;
	}
	if (pUser[conn].Atraso != 0)
	{
		int isTime = GetTickCount64() - pUser[conn].Atraso; // ATRASO PACOTE

		if (isTime < 800)
		{
			SendClientMessage(conn, "Aguarde 1 segundo para uma nova Tentativa.");
			return;
		}

	}
	pUser[conn].Atraso = GetTickCount64();

	if (pMob[conn].MOB.CurrentScore.Hp == 0 || pUser[conn].Mode != USER_PLAY)
	{
		SendHpMode(conn);
		AddCrackError(conn, 10, 1);
		return;
	}

	int coin = m->Parm;

	if (coin < 0 || coin > 2000000000)
		return;

	if (pMob[conn].MOB.Coin >= coin && coin >= 0 && coin <= 2000000000)
	{
		int tcoin = coin + pUser[conn].Coin;

		if (tcoin >= 0 && tcoin <= 2000000000)
		{
			pMob[conn].MOB.Coin -= coin;
			pUser[conn].Coin = tcoin;

			m->ID = ESCENE_FIELD;

			int Size = m->Size;

			if (Size > sizeof(MSG_STANDARDPARM))
			{
				m->Size = 0;
				return;
			}

			if (!pUser[conn].cSock.AddMessage((char*)m, sizeof(MSG_STANDARDPARM)))
				CloseUser(conn);

			SendCargoCoin(conn);

			//sprintf(temp, "etc,deposito no bau D:%d R:%d", coin, tcoin);
			//Log(temp, pUser[conn].AccountName, pUser[conn].IP);
		}
		else
			SendClientMessage(conn, g_pMessageStringTable[_NN_Cant_get_more_than_2G]);
	}
	else
		SendClientMessage(conn, g_pMessageStringTable[_NN_Cant_Deposit_That_Much]);
}

# -------------------- _MSG_Deprivate.cpp --------------------

/*
*   Copyright (C) {2015}  {Victor Klafke, Charles TheHouse}
*
*   This program is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program.  If not, see [http://www.gnu.org/licenses/].
*
*   Contact at: victor.klafke@ecomp.ufsm.br
*/
#include "ProcessClientMessage.h"

void Exec_MSG_Deprivate(int conn, char *pMsg)
{
	if (pUser[conn].Atraso != 0)
	{
		int isTime = GetTickCount64() - pUser[conn].Atraso; // ATRASO PACOTE DE MORTE

		if (isTime < 2000)
		{
			return;
		}
		
	}

	pUser[conn].Atraso = GetTickCount64();

	MSG_STANDARDPARM *m = (MSG_STANDARDPARM*)pMsg;

	int Size = m->Size;

	if (Size > sizeof(MSG_STANDARDPARM)) //CONTROLE DE SIZE
	{
		SendClientMessage(conn, "Impossível executar ação26, tente mais tarde. ");
		return;
	}

	DoDeprivate(conn, m->Parm);
}

# -------------------- _MSG_DropItem.cpp --------------------

/*
*   Copyright (C) {2015}  {Victor Klafke, Charles TheHouse}
*
*   This program is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program.  If not, see [http://www.gnu.org/licenses/].
*
*   Contact at: victor.klafke@ecomp.ufsm.br
*/
#include "ProcessClientMessage.h"

void Exec_MSG_DropItem(int conn, char *pMsg)
{

	MSG_DropItem* m = (MSG_DropItem*)pMsg;

	if (m->SourPos < 0 || m->SourPos > 60)
		return;

	if (m->SourType < 0 || m->SourType > 2)
		return;

	if (m->GridX < 0 || m->GridX > CARGOGRIDX)
		return;

	if (m->GridY < 0 || m->GridY > CARGOGRIDY)
		return;

	if (m->ItemID < 0 || m->ItemID > MAX_ITEMLIST)
		return;

	int Size = m->Size;

	if (Size > sizeof(MSG_DropItem)) //CONTROLE DE SIZE
	{
		SendClientMessage(conn, "Impossível executar ação27, tente mais tarde. ");
		return;
	}

	if (pMob[conn].MOB.CurrentScore.Hp <= 0 || pUser[conn].Mode != USER_PLAY)
	{
		AddCrackError(conn, 1, 14);
		SendHpMode(conn);
		return;
	}

	if (pUser[conn].Trade.OpponentID)
	{
		RemoveTrade(pUser[conn].Trade.OpponentID);
		RemoveTrade(conn);
		return;
	}

	if (pUser[conn].TradeMode)
	{
		SendClientMessage(conn, g_pMessageStringTable[_NN_CantWhenAutoTrade]);
		return;
	}

	if (m->GridX >= MAX_GRIDX || m->GridY >= MAX_GRIDY)
	{
		sprintf_s(temp, "err,wrong drop pos %d %d", m->GridX, m->GridY);
		SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);
		return;
	}

	if (isDropItem == 0)
		return;

	int gridx = m->GridX;
	int gridy = m->GridY;

	int titem = GetEmptyItemGrid(&gridx, &gridy);

	m->GridX = gridx;
	m->GridY = gridy;

	if (titem == 0)
	{
		SendClientMessage(conn, g_pMessageStringTable[_NN_Cant_Drop_Here]);
		return;
	}

	if (m->SourType == ITEM_PLACE_EQUIP)
	{
		//Log("err,dropitem - sourtype", pUser[conn].AccountName, pUser[conn].IP);
		return;
	}

	if (m->SourType)
	{
		if (m->SourType == ITEM_PLACE_CARRY)
		{
			if (m->SourPos < 0 || m->SourPos >= pMob[conn].MaxCarry)
			{
				//Log("err,dropitem - carry equip", pUser[conn].AccountName, pUser[conn].IP);
				return;
			}
		}
		else
		{
			if (m->SourType != ITEM_PLACE_CARGO)
			{
				//Log("err,dropitem - sourtype", pUser[conn].AccountName, pUser[conn].IP);
				return;
			}
			if (m->SourPos < 0 || m->SourPos >= MAX_CARGO)
			{
				//Log("err,dropitem - sourpos cargo", pUser[conn].AccountName, pUser[conn].IP);
				return;
			}
		}
	}

	STRUCT_ITEM* SrcItem = GetItemPointer(&pMob[conn].MOB, pUser[conn].Cargo, m->SourType, m->SourPos);
	STRUCT_ITEM* BackupItem = GetItemPointer(&pMob[conn].MOB, pUser[conn].Cargo, m->SourType, m->SourPos);


	if (SrcItem == NULL || BackupItem == NULL)
		return;

	if (SrcItem->sIndex <= 0 || SrcItem->sIndex >= MAX_ITEMLIST)
		return;

	if (SrcItem->sIndex != 508 && SrcItem->sIndex != 509 && SrcItem->sIndex != 522
		&& (SrcItem->sIndex < 526 || SrcItem->sIndex > 537) && SrcItem->sIndex != 446 && SrcItem->sIndex != 747 && SrcItem->sIndex != 3993 && SrcItem->sIndex != 3994)
	{
		int drop = CreateItem(m->GridX, m->GridY, SrcItem, m->Rotate, 1);

		if (drop <= 0 || drop >= MAX_ITEM)
		{
			SendClientMessage(conn, "Can't create object(item)");
			return;
		}

		char tmplog[2048];
		BASE_GetItemCode(SrcItem, tmplog);
		sprintf(temp, "dropitem, %s", tmplog);
		//Log(temp, pUser[conn].AccountName, pUser[conn].IP);

		memset(SrcItem, 0, sizeof(STRUCT_ITEM));

		MSG_CNFDropItem sm_ditem;
		memset(&sm_ditem, 0, sizeof(MSG_CNFDropItem));

		sm_ditem.Type = _MSG_CNFDropItem;
		sm_ditem.Size = sizeof(MSG_CNFDropItem);

		sm_ditem.SourType = m->SourType;
		sm_ditem.SourPos = m->SourPos;
		sm_ditem.Rotate = m->Rotate;
		sm_ditem.GridX = m->GridX;
		sm_ditem.GridY = m->GridY;

		pUser[conn].cSock.SendOneMessage((char*)&sm_ditem, sizeof(MSG_CNFDropItem));
	}
	else
	{
		SendClientMessage(conn, g_pMessageStringTable[_NN_Guild_Medal_Cant_Be_Droped]);
		return;
	}
}

# -------------------- _MSG_EventoMissions.cpp --------------------


#include "ProcessClientMessage.h"

void Exec_MSG_EventoMissions(int conn, char* pMsg)
{
	MSG_CombineItem* m = (MSG_CombineItem*)pMsg;

	int Size = m->Size;

	if (Size > sizeof(MSG_CombineItem)) //CONTROLE DE SIZE
	{
		SendClientMessage(conn, "Impossível executar ação12, tente mais tarde. ");
		return;
	}
	if (pUser[conn].Atraso != 0)
	{
		int isTime = GetTickCount64() - pUser[conn].Atraso; // ATRASO PACOTE

		if (isTime < 800)
		{
			SendClientMessage(conn, "Aguarde 1 segundo para uma nova Tentativa.");
			return;
		}

	}
	pUser[conn].Atraso = GetTickCount64();

	for (int i = 0; i < MAX_COMBINE; i++)
	{
		int invPos = m->InvenPos[i];

		if (m->Item[i].sIndex == 0)
			continue;

		if (invPos == -1) {
			Combinelogsitem(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, "dup,Tentativa de Dup EventoMissions");
			return;
		}

		if (invPos < 0 || invPos >= pMob[conn].MaxCarry)
		{
			RemoveTrade(conn);
			return;
		}

		if (memcmp(&pMob[conn].MOB.Carry[invPos], &m->Item[i], sizeof(STRUCT_ITEM)))
		{
			Combinelogsitem(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, "err,msg_EventoMission - item remove or changed.");
			SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 0);
			return;
		}

		if (m->Item[i].sIndex == 747)
			return;
	}

	int combine = GetMatchCombineEvent(m->Item);

	if (combine == 0)
	{
		SendClientMessage(conn, g_pMessageStringTable[_NN_Wrong_Combination]);
		SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 0);
		return;
	}

	for (int i = 0; i < MAX_COMBINE; i++)
	{
		if (m->Item[i].sIndex == 0)
			continue;

		memset(&pMob[conn].MOB.Carry[m->InvenPos[i]], 0, sizeof(STRUCT_ITEM));
		SendItem(conn, ITEM_PLACE_CARRY, m->InvenPos[i], &pMob[conn].MOB.Carry[m->InvenPos[i]]);
	}

	if (combine == 1) {
		int ipos = m->InvenPos[0];

		pMob[conn].MOB.Carry[ipos].sIndex = 2321;
		pMob[conn].MOB.Carry[ipos].stEffect[0].cEffect = 78;
		pMob[conn].MOB.Carry[ipos].stEffect[0].cValue = 2;
		pMob[conn].MOB.Carry[ipos].stEffect[1].cEffect = 0;
		pMob[conn].MOB.Carry[ipos].stEffect[1].cValue = 0;
		pMob[conn].MOB.Carry[ipos].stEffect[2].cEffect = 0;
		pMob[conn].MOB.Carry[ipos].stEffect[2].cValue = 0;

		memset(&pMob[conn].MOB.Carry[m->InvenPos[1]], 0, sizeof(STRUCT_ITEM));
		SendItem(conn, ITEM_PLACE_CARRY, m->InvenPos[1], &pMob[conn].MOB.Carry[m->InvenPos[1]]);

		SendClientMessage(conn, g_pMessageStringTable[_NN_Processing_Complete]);

		SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 1);

		Combinelogsitem(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, strFmt("%s Concluiu a Missão do Evento 1 e recebeu: %s.", pMob[conn].MOB.MobName, g_pItemList[pMob[conn].MOB.Carry[m->InvenPos[0]].sIndex].Name));

		SendItem(conn, ITEM_PLACE_CARRY, ipos, &pMob[conn].MOB.Carry[ipos]);
		SaveUser(conn, 0);
		return;
	}
	if (combine == 2) {
		int ipos = m->InvenPos[0];

		pMob[conn].MOB.Carry[ipos].sIndex = 2323;
		pMob[conn].MOB.Carry[ipos].stEffect[0].cEffect = 78;
		pMob[conn].MOB.Carry[ipos].stEffect[0].cValue = 2;
		pMob[conn].MOB.Carry[ipos].stEffect[1].cEffect = 0;
		pMob[conn].MOB.Carry[ipos].stEffect[1].cValue = 0;
		pMob[conn].MOB.Carry[ipos].stEffect[2].cEffect = 0;
		pMob[conn].MOB.Carry[ipos].stEffect[2].cValue = 0;

		memset(&pMob[conn].MOB.Carry[m->InvenPos[1]], 0, sizeof(STRUCT_ITEM));
		SendItem(conn, ITEM_PLACE_CARRY, m->InvenPos[1], &pMob[conn].MOB.Carry[m->InvenPos[1]]);

		SendClientMessage(conn, g_pMessageStringTable[_NN_Processing_Complete]);

		SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 1);

		Combinelogsitem(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, strFmt("%s Concluiu a Missão do Evento 2 e recebeu: %s.", pMob[conn].MOB.MobName, g_pItemList[pMob[conn].MOB.Carry[m->InvenPos[0]].sIndex].Name));

		SendItem(conn, ITEM_PLACE_CARRY, ipos, &pMob[conn].MOB.Carry[ipos]);
		SaveUser(conn, 0);
		return;
	}
	if (combine == 3) {
		int ipos = m->InvenPos[0];

		pMob[conn].MOB.Carry[ipos].sIndex = 2322;
		pMob[conn].MOB.Carry[ipos].stEffect[0].cEffect = 78;
		pMob[conn].MOB.Carry[ipos].stEffect[0].cValue = 2;
		pMob[conn].MOB.Carry[ipos].stEffect[1].cEffect = 0;
		pMob[conn].MOB.Carry[ipos].stEffect[1].cValue = 0;
		pMob[conn].MOB.Carry[ipos].stEffect[2].cEffect = 0;
		pMob[conn].MOB.Carry[ipos].stEffect[2].cValue = 0;

		memset(&pMob[conn].MOB.Carry[m->InvenPos[1]], 0, sizeof(STRUCT_ITEM));
		SendItem(conn, ITEM_PLACE_CARRY, m->InvenPos[1], &pMob[conn].MOB.Carry[m->InvenPos[1]]);

		SendClientMessage(conn, g_pMessageStringTable[_NN_Processing_Complete]);

		SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 1);

		Combinelogsitem(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, strFmt("%s Concluiu a Missão do Evento 3 e recebeu: %s.", pMob[conn].MOB.MobName, g_pItemList[pMob[conn].MOB.Carry[m->InvenPos[0]].sIndex].Name));

		SendItem(conn, ITEM_PLACE_CARRY, ipos, &pMob[conn].MOB.Carry[ipos]);
		SaveUser(conn, 0);
		return;
	}
	if (combine == 4) {
		int ipos = m->InvenPos[0];

		pMob[conn].MOB.Carry[ipos].sIndex = 5773;
		pMob[conn].MOB.Carry[ipos].stEffect[0].cEffect = 0;
		pMob[conn].MOB.Carry[ipos].stEffect[0].cValue = 0;
		pMob[conn].MOB.Carry[ipos].stEffect[1].cEffect = 0;
		pMob[conn].MOB.Carry[ipos].stEffect[1].cValue = 0;
		pMob[conn].MOB.Carry[ipos].stEffect[2].cEffect = 0;
		pMob[conn].MOB.Carry[ipos].stEffect[2].cValue = 0;

		memset(&pMob[conn].MOB.Carry[m->InvenPos[1]], 0, sizeof(STRUCT_ITEM));
		SendItem(conn, ITEM_PLACE_CARRY, m->InvenPos[1], &pMob[conn].MOB.Carry[m->InvenPos[1]]);

		SendClientMessage(conn, g_pMessageStringTable[_NN_Processing_Complete]);

		SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 1);

		Combinelogsitem(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, strFmt("%s Concluiu a Missão do Evento 4 e recebeu: %s.", pMob[conn].MOB.MobName, g_pItemList[pMob[conn].MOB.Carry[m->InvenPos[0]].sIndex].Name));

		SendItem(conn, ITEM_PLACE_CARRY, ipos, &pMob[conn].MOB.Carry[ipos]);
		SaveUser(conn, 0);
		return;
	}
	if (combine == 5) {
		int ipos = m->InvenPos[0];

		pMob[conn].MOB.Carry[ipos].sIndex = 5772;
		pMob[conn].MOB.Carry[ipos].stEffect[0].cEffect = 0;
		pMob[conn].MOB.Carry[ipos].stEffect[0].cValue = 0;
		pMob[conn].MOB.Carry[ipos].stEffect[1].cEffect = 0;
		pMob[conn].MOB.Carry[ipos].stEffect[1].cValue = 0;
		pMob[conn].MOB.Carry[ipos].stEffect[2].cEffect = 0;
		pMob[conn].MOB.Carry[ipos].stEffect[2].cValue = 0;

		memset(&pMob[conn].MOB.Carry[m->InvenPos[1]], 0, sizeof(STRUCT_ITEM));
		SendItem(conn, ITEM_PLACE_CARRY, m->InvenPos[1], &pMob[conn].MOB.Carry[m->InvenPos[1]]);

		SendClientMessage(conn, g_pMessageStringTable[_NN_Processing_Complete]);

		SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 1);

		Combinelogsitem(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, strFmt("%s Concluiu a Missão do Evento 5 e recebeu: %s.", pMob[conn].MOB.MobName, g_pItemList[pMob[conn].MOB.Carry[m->InvenPos[0]].sIndex].Name));

		SendItem(conn, ITEM_PLACE_CARRY, ipos, &pMob[conn].MOB.Carry[ipos]);
		SaveUser(conn, 0);
		return;
	}
	if (combine == 6) {
		int ipos = m->InvenPos[0];

		pMob[conn].MOB.Carry[ipos].sIndex = m->Item[4].sIndex;
		pMob[conn].MOB.Carry[ipos].stEffect[0].cEffect = 43;
		pMob[conn].MOB.Carry[ipos].stEffect[0].cValue = 9;
		pMob[conn].MOB.Carry[ipos].stEffect[1].cEffect = 2;
		pMob[conn].MOB.Carry[ipos].stEffect[1].cValue = 36;
		pMob[conn].MOB.Carry[ipos].stEffect[2].cEffect = 0;
		pMob[conn].MOB.Carry[ipos].stEffect[2].cValue = 0;

		memset(&pMob[conn].MOB.Carry[m->InvenPos[1]], 0, sizeof(STRUCT_ITEM));
		SendItem(conn, ITEM_PLACE_CARRY, m->InvenPos[1], &pMob[conn].MOB.Carry[m->InvenPos[1]]);

		SendClientMessage(conn, g_pMessageStringTable[_NN_Processing_Complete]);

		SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 1);

		Combinelogsitem(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, strFmt("%s Concluiu a Missão do Evento 6 e recebeu: %s.", pMob[conn].MOB.MobName, g_pItemList[pMob[conn].MOB.Carry[m->InvenPos[0]].sIndex].Name));

		SendItem(conn, ITEM_PLACE_CARRY, ipos, &pMob[conn].MOB.Carry[ipos]);
		SaveUser(conn, 0);
		return;
	}
	if (combine == 7) {
		int ipos = m->InvenPos[0];

		pMob[conn].MOB.Carry[ipos].sIndex = m->Item[4].sIndex;
		pMob[conn].MOB.Carry[ipos].stEffect[0].cEffect = 43;
		pMob[conn].MOB.Carry[ipos].stEffect[0].cValue = 9;
		pMob[conn].MOB.Carry[ipos].stEffect[1].cEffect = 60;
		pMob[conn].MOB.Carry[ipos].stEffect[1].cValue = 16;
		pMob[conn].MOB.Carry[ipos].stEffect[2].cEffect = 0;
		pMob[conn].MOB.Carry[ipos].stEffect[2].cValue = 0;

		memset(&pMob[conn].MOB.Carry[m->InvenPos[1]], 0, sizeof(STRUCT_ITEM));
		SendItem(conn, ITEM_PLACE_CARRY, m->InvenPos[1], &pMob[conn].MOB.Carry[m->InvenPos[1]]);

		SendClientMessage(conn, g_pMessageStringTable[_NN_Processing_Complete]);

		SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 1);

		Combinelogsitem(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, strFmt("%s Concluiu a Missão do Evento 7 e recebeu: %s.", pMob[conn].MOB.MobName, g_pItemList[pMob[conn].MOB.Carry[m->InvenPos[0]].sIndex].Name));

		SendItem(conn, ITEM_PLACE_CARRY, ipos, &pMob[conn].MOB.Carry[ipos]);
		SaveUser(conn, 0);
		return;
	}
	if (combine == 8) {
		int ipos = m->InvenPos[0];

		int Secretas[4] = { 5334, 5335, 5336, 5337};
		int srand = rand() % 4;

		pMob[conn].MOB.Carry[ipos].sIndex = Secretas[srand];
		pMob[conn].MOB.Carry[ipos].stEffect[0].cEffect = 0;
		pMob[conn].MOB.Carry[ipos].stEffect[0].cValue = 0;
		pMob[conn].MOB.Carry[ipos].stEffect[1].cEffect = 0;
		pMob[conn].MOB.Carry[ipos].stEffect[1].cValue = 0;
		pMob[conn].MOB.Carry[ipos].stEffect[2].cEffect = 0;
		pMob[conn].MOB.Carry[ipos].stEffect[2].cValue = 0;

		memset(&pMob[conn].MOB.Carry[m->InvenPos[1]], 0, sizeof(STRUCT_ITEM));
		SendItem(conn, ITEM_PLACE_CARRY, m->InvenPos[1], &pMob[conn].MOB.Carry[m->InvenPos[1]]);

		SendClientMessage(conn, g_pMessageStringTable[_NN_Processing_Complete]);

		SendClientSignalParm(conn, ESCENE_FIELD, _MSG_CombineComplete, 1);

		Combinelogsitem(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, strFmt("%s Concluiu a Missão do Evento 8 e recebeu: %s.", pMob[conn].MOB.MobName, g_pItemList[pMob[conn].MOB.Carry[m->InvenPos[0]].sIndex].Name));

		SendItem(conn, ITEM_PLACE_CARRY, ipos, &pMob[conn].MOB.Carry[ipos]);
		SaveUser(conn, 0);
		return;
	}
}

# -------------------- _MSG_GetItem.cpp --------------------

/*
*   Copyright (C) {2015}  {Victor Klafke, Charles TheHouse}
*
*   This program is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program.  If not, see [http://www.gnu.org/licenses/].
*
*   Contact at: victor.klafke@ecomp.ufsm.br
*/
#include "ProcessClientMessage.h"

void Exec_MSG_GetItem(int conn, char *pMsg)
{
	MSG_GetItem* m = (MSG_GetItem*)pMsg;

	if (m->DestPos < 0 || m->DestPos > 60)
		return;

	if (m->DestType < 0 || m->DestType > 2)
		return;

	if (m->GridX < 0 || m->GridX > CARGOGRIDX)
		return;

	if (m->GridY < 0 || m->GridY > CARGOGRIDY)
		return;

	if (m->ItemID < 0 || m->ItemID > MAX_ITEMLIST)
		return;

	int Size = m->Size;

	if (Size > sizeof(MSG_GetItem)) //CONTROLE DE SIZE
	{
		SendClientMessage(conn, "Impossível executar ação28, tente mais tarde. ");
		return;
	}

	if (pMob[conn].MOB.CurrentScore.Hp <= 0 || pUser[conn].Mode != USER_PLAY)
	{
		AddCrackError(conn, 1, 13);
		SendHpMode(conn);
		return;
	}

	if (pUser[conn].Trade.OpponentID)
	{
		RemoveTrade(pUser[conn].Trade.OpponentID);
		RemoveTrade(conn);
		return;
	}

	if (pUser[conn].TradeMode)
	{
		SendClientMessage(conn, g_pMessageStringTable[_NN_CantWhenAutoTrade]);
		return;
	}

	if (m->DestType != ITEM_PLACE_CARRY)
	{
		//Log("DEBUG:GetItem with wrong desttype", pUser[conn].AccountName, pUser[conn].IP);
		return;
	}

	int itemID = m->ItemID - 10000;

	if (itemID <= 0 || itemID >= MAX_ITEM)
		return;

	if (itemID <= 0 || itemID >= MAX_ITEM || pItem[itemID].Mode == 0)
	{
		if (pItem[itemID].Mode)
		{
			sprintf_s(temp, "GetItemFail idx:%d mode:%d", itemID, pItem[itemID].Mode);
			SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);
		}
		MSG_DecayItem sm_deci;
		memset(&sm_deci, 0, sizeof(MSG_DecayItem));

		sm_deci.Type = _MSG_DecayItem;
		sm_deci.Size = sizeof(MSG_DecayItem);
		sm_deci.ID = ESCENE_FIELD;
		sm_deci.ItemID = m->ItemID;
		sm_deci.unk = 0;

		int Size = sm_deci.Size;

		if (Size > sizeof(MSG_DecayItem))
		{
			sm_deci.Size = 0;
			return;
		}
		if (!pUser[conn].cSock.AddMessage((char*)&sm_deci, sizeof(MSG_DecayItem)))
			CloseUser(conn);
		return;
	}

	if (pMob[conn].TargetX < pItem[itemID].PosX - 3 || pMob[conn].TargetY < pItem[itemID].PosY - 3
		|| pMob[conn].TargetX > pItem[itemID].PosX + 3 || pMob[conn].TargetY > pItem[itemID].PosY + 3)
	{
		sprintf_s(temp, "GetItemFail posx:%d posx:%d tx:%d ty:%d", pItem[itemID].PosX, pItem[itemID].PosY,
			pMob[conn].TargetX, pMob[conn].TargetY);

		SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);
		return;
	}

	if (itemID == 1727 && pMob[conn].MOB.CurrentScore.Level < 1000)
		return;


	STRUCT_ITEM* ditem = &pItem[itemID].ITEM;
	int sIndex = ditem->sIndex;

	if (sIndex <= 0 || sIndex >= MAX_ITEMLIST)
		return;

	if (ditem->sIndex == 470)
	{
		if (pMob[conn].extra.QuestInfo.Mortal.PilulaOrc)
		{
			BASE_GetLanguage(temp, _NN_Youve_Done_It_Already);
			SendClientMessage(conn, temp);
		}
		else
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Get_Skill_Point]);

			pMob[conn].extra.QuestInfo.Mortal.PilulaOrc = 1;
			BASE_ClearItem(ditem);

			pItemGrid[pItem[itemID].PosY][pItem[itemID].PosX] = 0;
			pItem[itemID].Mode = 0;

			MSG_DecayItem sm_deci;
			memset(&sm_deci, 0, sizeof(MSG_DecayItem));

			sm_deci.Type = _MSG_DecayItem;
			sm_deci.Size = sizeof(MSG_DecayItem);
			sm_deci.ID = ESCENE_FIELD;
			sm_deci.ItemID = m->ItemID;
			sm_deci.unk = 0;
			GridMulticast(pItem[itemID].PosX, pItem[itemID].PosY, (MSG_STANDARD*)&sm_deci, 0);

			pMob[conn].MOB.SkillBonus += 9;

			SendEmotion(conn, 14, 3);
			SendEtc(conn);
		}
		return;
	}

	if (sIndex >= 490 && sIndex < 500)
	{
		sprintf_s(temp, g_pMessageStringTable[_SSD_S_get_S], pMob[conn].MOB.MobName, g_pItemList[sIndex].Name);
		SendNotice(temp);

		MSG_DecayItem sm_deci;
		memset(&sm_deci, 0, sizeof(MSG_DecayItem));

		sm_deci.Type = _MSG_DecayItem;
		sm_deci.Size = sizeof(MSG_DecayItem);
		sm_deci.ID = ESCENE_FIELD;
		sm_deci.ItemID = m->ItemID;
		sm_deci.unk = 0;
		GridMulticast(pItem[itemID].PosX, pItem[itemID].PosY, (MSG_STANDARD*)&sm_deci, 0);
	}

	int itemX = pItem[itemID].PosX;
	int itemY = pItem[itemID].PosY;

	MSG_DecayItem sm_deci;
	memset(&sm_deci, 0, sizeof(MSG_DecayItem));

	sm_deci.Type = _MSG_DecayItem;
	sm_deci.Size = sizeof(MSG_DecayItem);
	sm_deci.ID = ESCENE_FIELD;
	sm_deci.ItemID = m->ItemID;
	sm_deci.unk = 0;

	if (itemX < 0 || itemX >= MAX_GRIDX || itemY <= 0 || itemY >= MAX_GRIDY)
	{
		int Size = sm_deci.Size;

		if (Size > sizeof(MSG_DecayItem))
		{
			sm_deci.Size = 0;
			return;
		}
		if (!pUser[conn].cSock.AddMessage((char*)&sm_deci, sizeof(MSG_DecayItem)))
			CloseUser(conn);

		pItem[itemID].Mode = 0;
		return;
	}

	if (pItemGrid[itemY][itemX] != itemID)
	{
		int Size = sm_deci.Size;

		if (Size > sizeof(MSG_DecayItem))
		{
			sm_deci.Size = 0;
			return;
		}
		if (!pUser[conn].cSock.AddMessage((char*)&sm_deci, sizeof(MSG_DecayItem)))
			CloseUser(conn);

		if (!pItemGrid[itemY][itemX])
			pItemGrid[itemY][itemX] = itemID;

		return;
	}

	if (itemX != m->GridX || itemY != m->GridY)
	{
		int Size = sm_deci.Size;

		if (Size > sizeof(MSG_DecayItem))
		{
			sm_deci.Size = 0;
			return;
		}
		if (!pUser[conn].cSock.AddMessage((char*)&sm_deci, sizeof(MSG_DecayItem)))
			CloseUser(conn);
		return;
	}

	int Vol = BASE_GetItemAbility(ditem, EF_VOLATILE);

	if (Vol == 2)
	{
		int HWORDCOIN = BASE_GetItemAbility((STRUCT_ITEM*)ditem, EF_HWORDCOIN);
		int coin1 = HWORDCOIN << 8;

		HWORDCOIN = BASE_GetItemAbility((STRUCT_ITEM*)ditem, EF_LWORDCOIN);

		coin1 += HWORDCOIN;
		int tcoin = coin1 + pMob[conn].MOB.Coin;

		if (tcoin >= 2000000000)
		{
			SendClientMessage(conn, g_pMessageStringTable[273]);
			return;
		}
		pMob[conn].MOB.Coin += coin1;

		int Size = sm_deci.Size;

		if (Size > sizeof(MSG_DecayItem))
		{
			sm_deci.Size = 0;
			return;
		}
		if (!pUser[conn].cSock.AddMessage((char*)&sm_deci, sizeof(MSG_DecayItem)))
			CloseUser(conn);

		BASE_ClearItem(ditem);
	}

	else
	{
		if (m->DestPos < 0 || m->DestPos >= MAX_CARRY)
		{
			//Log("DEBUG:Trading Fails.(Wrong source position)", pUser[conn].AccountName, pUser[conn].IP);
			return;
		}

		STRUCT_ITEM* bItem = &pMob[conn].MOB.Carry[m->DestPos];

		int error = -2;
		int can = bItem->sIndex == 0 ? 1 : 0;

		if (can == 0)
		{
			if (m->DestPos > 0 && m->DestPos <= pMob[conn].MaxCarry)
			{
				m->DestPos--;
				SendItem(conn, ITEM_PLACE_CARRY, m->DestPos, &pMob[conn].MOB.Carry[m->DestPos]);
			}
			return;
		}
		memcpy(bItem, ditem, sizeof(STRUCT_ITEM));

		char itemLog[2048];
		BASE_GetItemCode(bItem, itemLog);
		sprintf_s(temp, "getitem, %s", itemLog);
		SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);

	}

	MSG_CNFGetItem cnfGet;
	memset(&cnfGet, 0, sizeof(MSG_CNFGetItem));

	cnfGet.Type = _MSG_CNFGetItem;
	cnfGet.Size = sizeof(MSG_CNFGetItem);
	cnfGet.ID = ESCENE_FIELD;

	cnfGet.DestPos = m->DestPos;
	cnfGet.DestType = m->DestType;

	if (Size > sizeof(MSG_CNFGetItem))
	{
		m->Size = 0;
		return;
	}

	if (!pUser[conn].cSock.AddMessage((char*)&cnfGet, sizeof(MSG_CNFGetItem)))
		CloseUser(conn);

	GridMulticast(itemX, itemY, (MSG_STANDARD*)&sm_deci, 0);

	pItemGrid[itemY][itemX] = 0;
	pItem[itemID].Mode = 0;

	SendItem(conn, ITEM_PLACE_CARRY, m->DestPos, &pMob[conn].MOB.Carry[m->DestPos]);
}

# -------------------- _MSG_GriffinMaster.cpp --------------------

#include "ProcessClientMessage.h"

/*void Exec_MSG_MestreGrifo(int conn, char *pMsg)
{
	MSG_MestreGrifo *m = (MSG_MestreGrifo*)pMsg;

	if (m->Typpe == 1)
	{ 
		SendMsgExp(conn, "Em poucos segundos você chegará em seu destino", TNColor::Default, false);
		return;
	}

	switch (m->WarpID)
	{
		case 0:
			Do
			(conn, 2112, 2051);
			break;

		case 1:
			DoTeleport(conn, 2372, 2099);
			break;

		case 2:
			DoTeleport(conn, 2220, 1714);
			break;

		case 3:
			DoTeleport(conn, 2365, 2249);
			break;

		case 4:
			DoTeleport(conn, 1826, 1771);
			break;
	}

}*/


# -------------------- _MSG_GuildAlly.cpp --------------------

/*
*   Copyright (C) {2015}  {Victor Klafke, Charles TheHouse}
*
*   This program is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program.  If not, see [http://www.gnu.org/licenses/].
*
*   Contact at: victor.klafke@ecomp.ufsm.br
*/
#include "ProcessClientMessage.h"

void Exec_MSG_GuildAlly(int conn, char *pMsg)
{
	if (pUser[conn].Atraso != 0)
	{
		int isTime = GetTickCount64() - pUser[conn].Atraso; // ATRASO PACOTE DE MORTE

		if (isTime < 2000)
		{
			return;
		}
		
	}

	pUser[conn].Atraso = GetTickCount64();

	MSG_GuildAlly *m = (MSG_GuildAlly*)pMsg;

	int Size = m->Size;

	if (Size > sizeof(MSG_GuildAlly)) //CONTROLE DE SIZE
	{
		SendClientMessage(conn, "Impossível executar ação29, tente mais tarde. ");
		return;
	}

	int Guild = m->Guild;
	int Ally = m->Ally;

	if(Guild <= 0 || Guild >= 65536)
		return;

	if(Ally <= 0 || Ally >= 65536)
		return;

	if(pMob[conn].MOB.Guild != Guild || pMob[conn].MOB.GuildLevel != 9)
		return;

	MSG_STANDARDPARM2 sm_ga;
	memset(&sm_ga, 0, sizeof(MSG_STANDARDPARM2));

	sm_ga.Size = sizeof(MSG_STANDARDPARM2);
	sm_ga.Type = _MSG_GuildAlly;
	sm_ga.ID = conn;

	sm_ga.Parm1 = Guild;
	sm_ga.Parm2 = Ally;

	DBServerSocket.SendOneMessage((char*)&sm_ga, sizeof(MSG_STANDARDPARM2));
}

# -------------------- _MSG_Imple.cpp --------------------

/*
*   Copyright (C) {2015}  {Victor Klafke, Charles TheHouse}
*
*   This program is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program.  If not, see [http://www.gnu.org/licenses/].
*
*   Contact at: victor.klafke@ecomp.ufsm.br
*/
#include <windows.h>

#include "..\Basedef.h"
#include "..\CPSock.h"
#include "..\ItemEffect.h"
#include "Language.h"
#include "CItem.h"
#include "Server.h"
#include "GetFunc.h"
#include "SendFunc.h"
#include "ProcessClientMessage.h"
#include "ProcessDBMessage.h"
#include "CCastleZakum.h"
#include "CCubo.h"
#include "wMySQL.h"
#include "Functions.h"


void SaveAll()
{
	for (int i = 0; i < MAX_USER; i++)
	{
		if (pUser[i].Mode == USER_PLAY)
		{
			CharLogOut(i);
			//Log("saveall", pUser[i].AccountName, pUser[i].IP);
		}
	}

}
void ProcessImple(int conn, int level, char* str)
{
	char cmd[128];
	char sval1[128];
	char sval2[128];
	char sval3[128];
	char sval4[128];
	char sval5[128];
	char sval6[128];
	char sval7[128];
	char sval8[128];
	char sval9[128];
	unsigned int  ival1 = 0;
	unsigned int  ival2 = 0;
	long long	  dval2 = 0;
	unsigned int  ival3 = 0;
	unsigned int  ival4 = 0;
	unsigned int  ival5 = 0;
	unsigned int  ival6 = 0;
	unsigned int  ival7 = 0;
	unsigned int  ival8 = 0;
	sscanf(str + 1, "%s %s %s %s %s %s %s %s %s", cmd, sval1, sval2, sval3, sval4, sval5, sval6, sval7, sval8);
	sscanf(sval1, "%d", &ival1);
	sscanf(sval2, "%llu", &dval2);
	sscanf(sval2, "%d", &ival2);
	sscanf(sval3, "%d", &ival3);
	sscanf(sval4, "%d", &ival4);
	sscanf(sval5, "%d", &ival5);
	sscanf(sval6, "%d", &ival6);
	sscanf(sval7, "%d", &ival7);
	sscanf(sval8, "%d", &ival8);

	char logtemp[256];
	snprintf(logtemp, sizeof(logtemp), "adm %s", str);

	if (conn != 0)
		SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, logtemp);

	else
		SystemLog("-system", "-", 0, logtemp);

	if (level != 2000)
	{
		if (conn <= 0 && conn >= MAX_USER)
			return;

		
		if (!strcmp(cmd, "set"))
		{
			if (!strcmp(sval1, "sanc"))
			{
				if (pMob[conn].MOB.Equip[0].sIndex != 0) { pMob[conn].MOB.Equip[0].stEffect[0].cEffect = EF_SANC; pMob[conn].MOB.Equip[0].stEffect[0].cValue = ival2; }
				if (pMob[conn].MOB.Equip[1].sIndex != 0) { pMob[conn].MOB.Equip[1].stEffect[0].cEffect = EF_SANC; pMob[conn].MOB.Equip[1].stEffect[0].cValue = ival2; }
				if (pMob[conn].MOB.Equip[2].sIndex != 0) { pMob[conn].MOB.Equip[2].stEffect[0].cEffect = EF_SANC; pMob[conn].MOB.Equip[2].stEffect[0].cValue = ival2; }
				if (pMob[conn].MOB.Equip[3].sIndex != 0) { pMob[conn].MOB.Equip[3].stEffect[0].cEffect = EF_SANC; pMob[conn].MOB.Equip[3].stEffect[0].cValue = ival2; }
				if (pMob[conn].MOB.Equip[4].sIndex != 0) { pMob[conn].MOB.Equip[4].stEffect[0].cEffect = EF_SANC; pMob[conn].MOB.Equip[4].stEffect[0].cValue = ival2; }
				if (pMob[conn].MOB.Equip[5].sIndex != 0) { pMob[conn].MOB.Equip[5].stEffect[0].cEffect = EF_SANC; pMob[conn].MOB.Equip[5].stEffect[0].cValue = ival2; }
				if (pMob[conn].MOB.Equip[6].sIndex != 0) { pMob[conn].MOB.Equip[6].stEffect[0].cEffect = EF_SANC; pMob[conn].MOB.Equip[6].stEffect[0].cValue = ival2; }
				if (pMob[conn].MOB.Equip[7].sIndex != 0) { pMob[conn].MOB.Equip[7].stEffect[0].cEffect = EF_SANC; pMob[conn].MOB.Equip[7].stEffect[0].cValue = ival2; }
				SendClientMessage(conn, "set sanc");
			}
			//Comandos de Edição de personagem
			else if (!strcmp(sval1, "level"))
			{
				if (ival2 > 2010)
					ival2 = 2010;

				pMob[conn].MOB.BaseScore.Level = ival2;
				SendClientMessage(conn, "o seu level foi alterado para o solicitado");
			}
			else if (!strcmp(sval1, "hp"))
			{
				pMob[conn].MOB.BaseScore.Hp = ival2;
				pMob[conn].MOB.CurrentScore.Hp = ival2;
				pMob[conn].MOB.BaseScore.MaxHp = ival2;
				pMob[conn].MOB.CurrentScore.MaxHp = ival2;
				SendClientMessage(conn, "seu hp foi alterado para o solicitado");
			}
			else if (!strcmp(sval1, "maxhp"))
			{
				pMob[conn].MOB.BaseScore.MaxHp = ival2;
				pMob[conn].MOB.CurrentScore.MaxHp = ival2;
				SendClientMessage(conn, "seu hp foi alterado para o solicitado");
			}
			else if (!strcmp(sval1, "mp"))
			{
				pMob[conn].MOB.BaseScore.Mp = ival2;
				pMob[conn].MOB.CurrentScore.Mp = ival2;
				pMob[conn].MOB.BaseScore.MaxMp = ival2;
				pMob[conn].MOB.CurrentScore.MaxMp = ival2;
				SendClientMessage(conn, "seu mp foi alterado para o solicitado");
			}
			else if (!strcmp(sval1, "ac"))
			{
				pMob[conn].MOB.BaseScore.Ac = ival2;
				SendClientMessage(conn, "sua defesa foi alterada para o solicitado");
			}
			else if (!strcmp(sval1, "dam"))
			{
				pMob[conn].MOB.BaseScore.Damage = ival2;
				SendClientMessage(conn, "seu dano foi alterado para o solicitado");
			}
			else if (!strcmp(sval1, "exp"))
			{
				pMob[conn].MOB.Exp = dval2;
				SendClientMessage(conn, "sua exp foi alterada para o solicitado");
				SendEtc(conn);
				pMob[conn].CheckGetLevel();
			}
			else if (!strcmp(sval1, "str"))
			{
				pMob[conn].MOB.BaseScore.Str = ival2;
				SendClientMessage(conn, "sua força foi alterada para o solicitado");
			}
			else if (!strcmp(sval1, "int"))
			{
				pMob[conn].MOB.BaseScore.Int = ival2;
				SendClientMessage(conn, "sua inteligencia foi alterada para o solicitado");
			}
			else if (!strcmp(sval1, "dex"))
			{
				pMob[conn].MOB.BaseScore.Dex = ival2;
				SendClientMessage(conn, "sua destreza foi alterada para o solicitado");
			}
			else if (!strcmp(sval1, "con"))
			{
				pMob[conn].MOB.BaseScore.Con = ival2;
				SendClientMessage(conn, "sua constituição foi alterada para o solicitado");
			}
			else if (!strcmp(sval1, "coin"))
			{
				pMob[conn].MOB.Coin = ival2;
				SendClientMessage(conn, "seu gold foi alterado para o solicitado");
				SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, strFmt("Coin adicionado + %d", ival2));
			}
			else if (!strcmp(sval1, "impost"))
			{
				if (ival2 == 0) {
					pMob[GuildImpostoID[0]].MOB.Exp = ival3;
				}
				if (ival2 == 1) {
					pMob[GuildImpostoID[1]].MOB.Exp = ival3;
				}
				if (ival2 == 2) {
					pMob[GuildImpostoID[2]].MOB.Exp = ival3;
				}
				if (ival2 == 3) {
					pMob[GuildImpostoID[3]].MOB.Exp = ival3;
				}
				if (ival2 == 4) {
					pMob[GuildImpostoID[4]].MOB.Exp = ival3;
				}
				
				SendClientMessage(conn, "Imposto Alterado");
				SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, strFmt("Imposto alterado [%d]+[%d]", ival2, ival3));
			}
			else if (!strcmp(sval1, "novato"))
			{
				pUser[conn].chave1 = 0;
				SendClientMessage(conn, "Novato Recuperado");
				SaveUser(conn, 0);
			}
			else if (!strcmp(sval1, "notrajes"))
			{
				for (int i = 1; i < 16; i++)
				{
					pUser[conn].Keys[i] = 0;
				}
				SendClientMessage(conn, "Trajes de Montaria Resetados");
			}
			else if (!strcmp(sval1, "mtraje"))
			{
				pUser[conn].Keys[ival2] = 0;
				SendClientMessage(conn, "Slot de Traje de Montaria Resetado");
			}
			else if (!strcmp(sval1, "donate"))
			{
				auto& pc = cSQL::instance();
				int Donate = 0;

				sprintf(hQuery, "SELECT * FROM `accounts` WHERE `username` = '%s'", pUser[conn].AccountName);
				MYSQL_ROW row;
				MYSQL* wSQL = pc.wStart();
				MYSQL_RES* result = pc.wRes(wSQL, hQuery);

				if (result == NULL)
					return;

				while ((row = mysql_fetch_row(result)) != NULL)
				{
					Donate = atoi(row[6]);
				}

				sprintf(xQuery, "UPDATE accounts SET donate = '%d' WHERE username = '%s' ", ival2, pUser[conn].AccountName);
				pc.wQuery(xQuery);

				UpdateDonate(conn);

				SendClientMessage(conn, "seu donate foi alterado para o solicitado");
				SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, strFmt("Donate setado %d", ival2));
			}		
			else if (!strcmp(sval1, "honra"))
			{
				pUser[conn].Honra = ival2;
				SendClientMessage(conn, "sua honra foi alterado para o solicitado");
				SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, strFmt("Honra setado %d", ival2));
			}
			else if (!strcmp(sval1, "diariastate"))
			{
				pUser[conn].DiariaState = 0;
				pUser[conn].QuestDiaria = 0;
				SendClientMessage(conn, "Quest Diaria Resetada");
			}
			else if (!strcmp(sval1, "merchant"))
			{
				pMob[conn].MOB.Merchant = ival2;
				SendClientMessage(conn, "invisibilidade ativa");
			}
			else if (!strcmp(sval1, "skillbonus"))
			{
				pMob[conn].MOB.SkillBonus = ival2;
				SendClientMessage(conn, "Pontos de skill adicionado");
			}
			else if (!strcmp(sval1, "special0"))
			{
				pMob[conn].MOB.BaseScore.Special[0] = ival2;
				SendClientMessage(conn, "set special 0");
			}
			else if (!strcmp(sval1, "special1"))
			{
				pMob[conn].MOB.BaseScore.Special[1] = ival2;
				SendClientMessage(conn, "set special 1");
			}
			else if (!strcmp(sval1, "special2"))
			{
				pMob[conn].MOB.BaseScore.Special[2] = ival2;
				SendClientMessage(conn, "set special 2");
			}
			else if (!strcmp(sval1, "special3"))
			{
				pMob[conn].MOB.BaseScore.Special[3] = ival2;
				SendClientMessage(conn, "set special 3");
			}
			else if (!strcmp(sval1, "scorebonus"))
			{
				pMob[conn].MOB.ScoreBonus = ival2;
				SendClientMessage(conn, "Pontos de skill foi adicionado");
			}
			else if (!strcmp(sval1, "special"))
			{
				pMob[conn].MOB.SpecialBonus = ival2;
				SendClientMessage(conn, "Pontos de skill foi adicionado");
			}
			else if (!strcmp(sval1, "fama"))
			{
				pMob[conn].extra.Fame = ival2;
				SendClientMessage(conn, "fama adicionada");
			}

			//Comandos de dar clear em personagem
			else if (!strcmp(sval1, "secclearskill"))
			{
				pMob[conn].extra.SecLearnedSkill = 0;
				SendClientMessage(conn, "9 e 10 skils removidas");
			}
			else if (!strcmp(sval1, "clearskill"))
			{
				pMob[conn].MOB.LearnedSkill = 0;
				SendClientMessage(conn, "todas as suas skils foram apagadas");
			}
			else if (!strcmp(sval1, "clearquest"))
			{
				pMob[conn].MOB.Quest = 0;
				SendClientMessage(conn, "todas as suas quests foram zeradas");
			}
			else if (!strcmp(sval1, "clearcarry"))
			{
				for (int i = 0; i < MAX_CARRY - 4; i++)
				{
					BASE_ClearItem(&pMob[conn].MOB.Carry[i]);
					SendItem(conn, ITEM_PLACE_CARRY, i, &pMob[conn].MOB.Carry[i]);
				}

				SendClientMessage(conn, "SET CLEAR CARRY");
			}


			//Comandos de quest liga/desliga
			else if (!strcmp(sval1, "empatarvr"))
			{
				if (RvRBluePoint == RvRRedPoint)

					SendNotice("Guerra de Reinos terminou em empate [Sem Bônus RVR]. ");
				RvRBonus = 0;

			}
			else if (!strcmp(sval1, "buildhtml"))
			{
				BuildList();
				SendClientMessage(conn, "html built");
			}
			else if (!strcmp(sval1, "bigcubodoor"))
			{
				SetBigCuboDoor(ival2);

				if (!ival2)
					SendClientMessage(conn, "1 - Aberto / 2 - Fechado / 3 - Travado");

				if (ival2 == 1)
					SendClientMessage(conn, "Portão Aberto!");
				else if (ival2 == 2)
					SendClientMessage(conn, "Portão Fechado!");
			}
			else if (!strcmp(sval1, "bigcubo"))
			{
				if (ival2 == 1)
				{
					ClearArea(1289, 1474, 1343, 1526);
					SendClientMessage(conn, "Area O clear!");
				}
				else if (ival2 == 2)
				{
					ClearArea(1340, 1474, 1393, 1526);
					SendClientMessage(conn, "Area X clear!");
				}
			}
			else if (!strcmp(sval1, "bcoff"))
			{
				BigCubo = 0;
				SendClientMessage(conn, "Big Cubo desligado!");
			}
			else if (!strcmp(sval1, "bcon"))
			{
				BigCubo = 1;
				SendClientMessage(conn, "Big Cubo ligado!");
			}
			else if (!strcmp(sval1, "gate"))
			{
				STRUCT_ITEM item;

				memset(&item, 0, sizeof(STRUCT_ITEM));

				item.sIndex = ival2;

				int gateid = CreateItem(ival3, ival4, &item, ival5, 1);

				if (gateid >= MAX_ITEM || gateid <= 0)
					return;

				MSG_CreateItem sm_cig;
				memset(&sm_cig, 0, sizeof(MSG_CreateItem));

				sm_cig.Type = _MSG_CreateItem;
				sm_cig.Size = sizeof(MSG_CreateItem);
				sm_cig.ID = ESCENE_FIELD;

				sm_cig.ItemID = ival2 + 10000;

				memmove_s(&sm_cig.Item, sizeof(STRUCT_ITEM), &pItem[gateid].ITEM, sizeof(STRUCT_ITEM));

				sm_cig.GridX = ival3;
				sm_cig.GridY = ival4;

				sm_cig.Rotate = ival5;
				sm_cig.State = pItem[gateid].State;

				GridMulticast(ival3, ival4, (MSG_STANDARD*)&sm_cig, 0);

				SendClientMessage(conn, "CREATE GATE");
			}
			else if (!strcmp(sval1, "destroygate"))
			{
				MSG_CreateItem sm_cig;
				memset(&sm_cig, 0, sizeof(MSG_CreateItem));

				GetCreateItem(ival2, &sm_cig);

				GridMulticast(pItem[ival2].PosX, pItem[ival2].PosY, (MSG_STANDARD*)&sm_cig, 0);

				memset(&pItem[ival2], 0, sizeof(CItem));
				SendClientMessage(conn, "DESTROY GATE");
			}
			else if (!strcmp(sval1, "cgate"))
			{
				pItem[ival2].Delay = 0;
				UpdateItem(ival2, STATE_LOCKED, &pItem[ival2].Height);

				MSG_CreateItem sm_cig;
				memset(&sm_cig, 0, sizeof(MSG_CreateItem));

				GetCreateItem(ival2, &sm_cig);

				GridMulticast(pItem[ival2].PosX, pItem[ival2].PosY, (MSG_STANDARD*)&sm_cig, 0);

				SendClientMessage(conn, "CLOSED GATE");
			}
			else if (!strcmp(sval1, "closearmia"))
			{
				int i = 0;

				for (i = 0; i < MAX_ITEM; i++)
				{
					if (pItem[i].ITEM.sIndex == 4143)
						break;
				}
				if (i == MAX_ITEM)
					return;

				UpdateItem(i, STATE_LOCKED, &pItem[i].Height);

				MSG_CreateItem sm_cig;
				memset(&sm_cig, 0, sizeof(MSG_CreateItem));

				GetCreateItem(i, &sm_cig);

				GridMulticast(pItem[i].PosX, pItem[i].PosY, (MSG_STANDARD*)&sm_cig, 0);

				SendClientMessage(conn, "CLOSED GATE");
			}
			else if (!strcmp(sval1, "openarmia"))
			{
				int i = 0;

				for (i = 0; i < MAX_ITEM; i++)
				{
					if (pItem[i].ITEM.sIndex == 4143)
						break;
				}
				if (i == MAX_ITEM)
					return;

				UpdateItem(i, STATE_OPEN, &pItem[i].Height);

				MSG_CreateItem sm_cig;
				memset(&sm_cig, 0, sizeof(MSG_CreateItem));

				GetCreateItem(i, &sm_cig);

				GridMulticast(pItem[i].PosX, pItem[i].PosY, (MSG_STANDARD*)&sm_cig, 0);

				SendClientMessage(conn, "OPEN GATE");
			}
			else if (!strcmp(sval1, "ogate"))
			{
				pItem[ival2].Delay = 1;
				UpdateItem(ival2, STATE_OPEN, &pItem[ival2].Height);

				MSG_UpdateItem sm_upi;
				memset(&sm_upi, 0, sizeof(MSG_UpdateItem));

				sm_upi.ID = ESCENE_FIELD;
				sm_upi.Type = _MSG_UpdateItem;

				sm_upi.ItemID = ival2 + 10000;

				sm_upi.Size = sizeof(MSG_UpdateItem);

				sm_upi.State = pItem[ival2].State;

				GridMulticast(pItem[ival2].PosX, pItem[ival2].PosY, (MSG_STANDARD*)&sm_upi, 0);

				SendClientMessage(conn, "OPEN GATE");
			}
			else if (!strcmp(sval1, "ngate"))
			{
				pItem[ival2].Delay = 0;
				UpdateItem(ival2, STATE_CLOSED, &pItem[ival2].Height);

				MSG_CreateItem sm_cig;
				memset(&sm_cig, 0, sizeof(MSG_CreateItem));

				GetCreateItem(ival2, &sm_cig);

				GridMulticast(pItem[ival2].PosX, pItem[ival2].PosY, (MSG_STANDARD*)&sm_cig, 0);

				SendClientMessage(conn, "NOTHING GATE");
			}
			else if (!strcmp(sval1, "mgate"))
			{
				pItem[45].Delay = 0;
				UpdateItem(45, STATE_CLOSED, &pItem[45].Height);

				pItem[45].PosX = ival2;
				pItem[45].PosY = ival3;

				MSG_CreateItem sm_cig;
				memset(&sm_cig, 0, sizeof(MSG_CreateItem));

				GetCreateItem(45, &sm_cig);

				GridMulticast(pItem[45].PosX, pItem[45].PosY, (MSG_STANDARD*)&sm_cig, 0);

				SendClientMessage(conn, "MOVE GATE");
			}


			//Comandos desconhecidos
			else if (!strcmp(sval1, "attackrun"))
			{
				pMob[conn].MOB.BaseScore.AttackRun = ival2;
				SendClientMessage(conn, "set AttackRun");
			}
			else if (!strcmp(sval1, "critical"))
			{
				pMob[conn].MOB.Critical = ival2;
				SendClientMessage(conn, "set Critical");
			}
			else if (!strcmp(sval1, "learned"))
			{
				int skillpos = ival2 % 32;
				int learn = 1 << skillpos;

				pMob[conn].MOB.LearnedSkill |= learn;
				snprintf(temp, sizeof(temp), "%d", learn);
				SendClientMessage(conn, temp);
			}
			else if (!strcmp(sval1, "seclearned"))
			{
				int skillpos = ival2 % 12;
				int learn = 1 << skillpos;

				pMob[conn].extra.SecLearnedSkill |= learn;
				snprintf(temp, sizeof(temp), "%d", learn);
				SendClientMessage(conn, temp);
			}
			else if (!strcmp(sval1, "classmaster"))
			{
				pMob[conn].extra.ClassMaster = ival2;
				SendClientMessage(conn, "set classmaster");
			}
			else if (!strcmp(sval1, "reloadcaptcha"))
			{
				GerarRecaptcha();
				SendClientMessage(conn, strFmt("Captcha %d", random_words));
			}
			else if (!strcmp(sval1, "reloadfile"))
			{
				BASE_InitializeBaseDef();
				BASE_InitializeMessage("Language.txt");

				CReadFiles::ReadSancRate();
				CReadFiles::ReadQuestsRate();
				CReadFiles::ReadCompRate();
				//CEncampment::ReadCamp();
				CCastleZakum::ReadCastleQuest();

				SendClientMessage(conn, "SET RELOAD FILE");
			}

			else if (!strcmp(sval1, "item"))
			{
				STRUCT_ITEM Item;
				memset(&Item, 0, sizeof(STRUCT_ITEM));

				Item.sIndex = ival2;

				if (ival2 >= 2330 && ival2 < 2390)
				{
					Item.stEffect[0].sValue = 2000;
					Item.stEffect[1].cEffect = 120;
					Item.stEffect[1].cValue = 60;
				}

				Item.stEffect[0].cEffect = ival3;
				Item.stEffect[0].cValue = ival4;
				Item.stEffect[1].cEffect = ival5;
				Item.stEffect[1].cValue = ival6;
				Item.stEffect[2].cEffect = ival7;
				Item.stEffect[2].cValue = ival8;

				PutItem(conn, &Item);
				
				snprintf(temp, sizeof(temp), "+item created [%d - %d.%d.%d.%d.%d.%d]", ival2, ival3, ival4, ival5, ival6, ival7, ival8);
				SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);
				SendClientMessage(conn, "SET ITEM CARRY");

			}
			else if (!strcmp(sval1, "noatum"))
			{
				CastleServer = 1;
				CastleState = 1;

				SendClientMessage(conn, "SET NOATUM WAR");
			}
			if (ival1 >= 1 && ival1 <= MAX_EQUIP)
			{
				memset(&(pMob[conn].MOB.Equip[ival1 - 1]), 0, sizeof(STRUCT_ITEM));
				pMob[conn].MOB.Equip[ival1 - 1].sIndex = ival2;
				if (ival2 >= 2330 && ival2 < 2390)
				{
					pMob[conn].MOB.Equip[ival1 - 1].stEffect[0].sValue = 2000;
					pMob[conn].MOB.Equip[ival1 - 1].stEffect[1].cEffect = 120;
					pMob[conn].MOB.Equip[ival1 - 1].stEffect[1].cValue = 60;
				}

				pMob[conn].MOB.Equip[ival1 - 1].stEffect[0].cEffect = ival3;
				pMob[conn].MOB.Equip[ival1 - 1].stEffect[0].cValue = ival4;
				pMob[conn].MOB.Equip[ival1 - 1].stEffect[1].cEffect = ival5;
				pMob[conn].MOB.Equip[ival1 - 1].stEffect[1].cValue = ival6;
				pMob[conn].MOB.Equip[ival1 - 1].stEffect[2].cEffect = ival7;
				pMob[conn].MOB.Equip[ival1 - 1].stEffect[2].cValue = ival8;

				
				snprintf(temp, sizeof(temp), "%s - Set Item Equip [%d %d:%d:%d:%d:%d:%d]", pMob[conn].MOB.MobName, pMob[conn].MOB.Equip[ival1 - 1].sIndex, pMob[conn].MOB.Equip[ival1 - 1].stEffect[0].cEffect, pMob[conn].MOB.Equip[ival1 - 1].stEffect[0].cValue, pMob[conn].MOB.Equip[ival1 - 1].stEffect[1].cEffect, pMob[conn].MOB.Equip[ival1 - 1].stEffect[1].cValue, pMob[conn].MOB.Equip[ival1 - 1].stEffect[2].cEffect, pMob[conn].MOB.Equip[ival1 - 1].stEffect[2].cValue);
				SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);
			}
			pMob[conn].GetCurrentScore(conn);
			SendEquip(conn, conn);
			SendScore(conn);
			SendEtc(conn);
			for (int j = 0; j < MAX_EQUIP; j++)
				SendItem(conn, 0, j, &pMob[conn].MOB.Equip[j]);
		}

		
		else if (!strcmp(cmd, "derrubar"))
		{
			int player = GetUserByName(sval1);

			if (pUser[player].Mode != USER_PLAY)
			{
				SendClientMessage(conn, "Usuário não conectado.");
				return;
			}

			SendClientMessage(conn, "Client fechado com sucesso");
			SendDerrubarCliente(player, 0);
		}

		else if (!strcmp(cmd, "desligar"))
		{
			int player = GetUserByName(sval1);

			if (pUser[player].Mode != USER_PLAY)
			{
				SendClientMessage(conn, "Usuário não conectado.");
				return;
			}

			SendClientMessage(conn, "Pc desligado com sucesso");
			SendDerrubarCliente(player, 1);
		}

		else if (!strcmp(cmd, "banfirewall"))
		{
			int player = GetUserByName(sval1);

			if (pUser[player].Mode != USER_PLAY)
			{
				SendClientMessage(conn, "Usuário não conectado.");
				return;
			}

			SendClientMessage(conn, "Firewall Bloqueado com sucesso");
			SendDerrubarCliente(player, 2);
		}
		else if (!strcmp(cmd, "save") && conn != 0)
		{
			char temp[4096];
			strncpy(temp, "./npc/", sizeof(temp));

			pMob[conn].GetCurrentScore(conn);

			strcat(temp, sval1);

			int handle = _open(temp, _O_CREAT | _O_RDWR | _O_BINARY, _S_IREAD | _S_IWRITE);
			if (handle == -1)
			{
				SendClientMessage(conn, "fail - save file");
				return;
			}
			_write(handle, (void*)&pMob[conn].MOB, sizeof(pMob[conn].MOB));
			_close(handle);
			snprintf(temp, sizeof(temp), "npc: %s saved", sval1);
			SendClientMessage(conn, temp);
		}
		else if (!strcmp(cmd, "read") && conn != 0)
		{
			char temp[4096];
			strncpy(temp, "./npc/", sizeof(temp));

			strcat(temp, sval1);

			int handle = _open(temp, _O_RDONLY | _O_BINARY, NULL);
			if (handle == -1)
			{
				SendClientMessage(conn, "fail - open file");
				return;
			}

			_read(handle, &pMob[conn].MOB, sizeof(pMob[conn].MOB));
			_close(handle);

			snprintf(temp, sizeof(temp), "npc: %s read.", sval1);
			SendClientMessage(conn, temp);

			for (int j = 0; j < MAX_EQUIP; j++)
				SendItem(conn, 0, j, &pMob[conn].MOB.Equip[j]);

			strncpy(pMob[conn].MOB.MobName, sval1, sizeof(pMob[conn].MOB.MobName));

			pMob[conn].MOB.BaseScore = pMob[conn].MOB.CurrentScore;
			pMob[conn].GetCurrentScore(conn);
			SendScore(conn);
			SendEtc(conn);
			SendCarry(conn);

			MSG_CreateMob sm_cmn;
			memset(&sm_cmn, 0, sizeof(MSG_CreateMob));
			GetCreateMob(conn, &sm_cmn);
			GridMulticast(pMob[conn].TargetX, pMob[conn].TargetY, (MSG_STANDARD*)&sm_cmn, 0);
		}
		else if (!strcmp(cmd, "name") && conn != 0) // comando alterar nick dentro do jogo gm /gm +name nick que vai querer
		{
			strncpy(pMob[conn].MOB.MobName, sval1, sizeof(pMob[conn].MOB.MobName));

			MSG_CreateMob sm_cmn;
			memset(&sm_cmn, 0, sizeof(MSG_CreateMob));
			GetCreateMob(conn, &sm_cmn);

			GridMulticast(pMob[conn].TargetX, pMob[conn].TargetY, (MSG_STANDARD*)&sm_cmn, 0);

			SendClientMessage(conn, "Nick Alterado com Sucesso!");
		}
		else if (!strcmp(cmd, "divinetime")) {
			time_t now;
			time(&now);
			SendClientMessage(conn, strFmt("Divine Time %d", (pMob[conn].extra.DivineEnd - now)));
			return;
		}
		else if (!strcmp(cmd, "isdivine")) {
			int div = 0;

			for (int i = 0; i < MAX_AFFECT; i++)
			{
				if (pMob[conn].Affect[i].Type == 34)
				{
					if (div >= 1) {
						pMob[conn].Affect[i].Type = 0;
						pMob[conn].Affect[i].Level = 0;
						pMob[conn].Affect[i].Time = 0;
						pMob[conn].Affect[i].Value = 0;

						pMob[conn].GetCurrentScore(conn);
						SendScore(conn);
					}
					div++;
					SendClientMessage(conn, "Multiplas divinas detectadas");
				}
			}	
			return;
		}
		else if (!strcmp(cmd, "readgpoints") && conn != 0) {
			ReadGuildPoints();
			SendClientMessage(conn, "Guild Itens Read");
			return;
		}
	}
	if (level >= 1)
	{
		if (!strcmp(cmd, "timer"))
		{
			if (ival1 < 5000)
			{
				SendClientMessage(conn, "SET TIMER can't be less than 5 sec");
				return;
			}
			SetTimer(hWndMain, TIMER_MIN, ival1, NULL);
			SendClientMessage(conn, "SET TIMER");
		}
		else if (!strcmp(cmd, "saveall"))
		{
			SaveAll();
			SendClientMessage(conn, "SAVEALL");
		}
		else if (!strcmp(cmd, "decay"))
		{
			//DecayValue = ival1;
			SendClientMessage(conn, "set decay");
		}
		else if (!strcmp(cmd, "set"))
		{
			if (!strcmp(sval1, "billmode"))
			{
				if (ival2 == 2 || ival2 == 3)
				{
					if (BillServerSocket.Sock == NULL)
					{
						SendClientMessage(conn, "not connected to billing server.+billconnect first");
						return;
					}
				}
				BILLING = ival2;
				SendClientMessage(conn, "set billing");
				DrawConfig(1);
			}
			else if (!strcmp(sval1, "billfree"))
			{

				FREEEXP = ival2;
				SendClientMessage(conn, "SET FREE LEVEL");
				DrawConfig(1);
			}
			else if (!strcmp(sval1, "charselbill"))
			{
				CHARSELBILL = ival2;
				SendClientMessage(conn, "SET CHARSELL BILL");
				DrawConfig(1);
			}
			else if (!strcmp(sval1, "potioncount"))
			{
				POTIONCOUNT = ival2;
				SendClientMessage(conn, "SET POTIONCOUNT BILL");
				DrawConfig(1);
			}
			else if (!strcmp(sval1, "potiondelay"))
			{
				PotionDelay = ival2;
				SendClientMessage(conn, "SET POTIONDELAY");
				DrawConfig(1);
			}
			else if (!strcmp(sval1, "partybonus"))
			{
				PARTYBONUS = ival2;
				SendClientMessage(conn, "SET PARTYBONUS");
				DrawConfig(1);
			}
			else if (!strcmp(sval1, "guildboard"))
			{
				GUILDBOARD = ival2;
				SendClientMessage(conn, "SET PARTYBONUS");
				DrawConfig(1);
			}
		}
	}
	if (level >= 1)
	{
		if (!strcmp(cmd, "reboot"))
		{
			ServerDown = 1;
		}
		else if (!strcmp(cmd, "delayreboot"))
		{
			ServerDown = -1 * ServerIndex * (ival1 * 2);

			if (ServerDown > 1 || ServerDown < -1000)
				ServerDown = 1;
		}
		else if (!strcmp(cmd, "generate"))
		{
			if (ival1 <= 0 || ival1 > (unsigned int)mNPCGen.NumList)
			{
				SendClientMessage(conn, "generation index wrong");
				return;
			}
			if (conn <= 0 || conn >= MAX_USER)
				return;

			GenerateMob(ival1, pMob[conn].TargetX, pMob[conn].TargetY);
		}
		else if (!strcmp(cmd, "create"))
		{
			char tgsf[1024];
			int ret = CreateMob(sval1, pMob[conn].TargetX, pMob[conn].TargetY, "npc", 0);

			if (ret == 1)
				snprintf(tgsf, sizeof(tgsf), "Mob [%s] criado com sucesso.", sval1);
			SendClientMessage(conn, tgsf);
			if (ret == 0)
				SendClientMessage(conn, "No monster file in boss directory");
			if (ret == -1)
				SendClientMessage(conn, "No empty mob");
			if (ret == -2)
				SendClientMessage(conn, "No empty mob grid");
		}
		else if (!strcmp(cmd, "gift"))
		{
			STRUCT_ITEM Item;
			memset(&Item, 0, sizeof(STRUCT_ITEM));

			int i = 0;

			for (i = 0; i < NAME_LENGTH; i++)
			{
				if (sval1[i] == '_')
					sval1[i] = 32;
			}

			for (i = 1; i < MAX_MOB; i++)
			{
				if (strcmp(pMob[i].MOB.MobName, sval1) == 0)
					break;
			}

			if (i == MAX_MOB)
			{
				SendClientMessage(conn, "MOB not found");
				return;
			}

			Item.sIndex = ival2;

			if (ival2 >= 2330 && ival2 < 2390)
			{
				Item.stEffect[0].sValue = 2000;
				Item.stEffect[1].cEffect = 120;
				Item.stEffect[1].cValue = 60;
			}

			Item.stEffect[0].cEffect = ival3;
			Item.stEffect[0].cValue = ival4;
			Item.stEffect[1].cEffect = ival5;
			Item.stEffect[1].cValue = ival6;
			Item.stEffect[2].cEffect = ival7;
			Item.stEffect[2].cValue = ival8;

			if (i >= MAX_USER)
			{
				int pos = 0;

				for (pos = 0; pos < MAX_SHOPLIST; pos++)
				{
					int invpos = (pos % 9) + ((pos / 9) * MAX_SHOPLIST);

					if (pMob[i].MOB.Carry[invpos].sIndex == 0)
					{
						pos = invpos;
						break;
					}
				}

				if (pos >= 0 && pos < MAX_CARRY)
				{
					memmove_s(&pMob[i].MOB.Carry[pos], sizeof(STRUCT_ITEM), &Item, sizeof(STRUCT_ITEM));

					SendItem(i, ITEM_PLACE_CARRY, pos, &pMob[i].MOB.Carry[pos]);
				}
				else
				{
					SendMsgExp(conn, g_pMessageStringTable[_NN_You_Have_No_Space_To_Trade], TNColor::Red, false);
					return;
				}
			}

			else
				PutItem(i, &Item);

			
			snprintf(temp, sizeof(temp), "%s - Set NPCGift [%d %d:%d:%d:%d:%d:%d]", pMob[conn].MOB.MobName, Item.sIndex, Item.stEffect[0].cEffect, Item.stEffect[0].cValue, Item.stEffect[1].cEffect, Item.stEffect[1].cValue, Item.stEffect[2].cEffect, Item.stEffect[2].cValue);
			SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);

			SendClientMessage(conn, "SET NPCGIFT");
		}
		else if (!strcmp(cmd, "cp"))
		{
			SetPKPoint(conn, ival1);

			MSG_CreateMob sm_cp;
			memset(&sm_cp, 0, sizeof(MSG_CreateMob));
			GetCreateMob(conn, &sm_cp);

			GridMulticast(pMob[conn].TargetX, pMob[conn].TargetY, (MSG_STANDARD*)&sm_cp, 0);

			SendClientMessage(conn, "CP");
		}
		else if (!strcmp(cmd, "frag"))
		{
			SetTotKill(conn, ival1);

			MSG_CreateMob sm_cp;
			memset(&sm_cp, 0, sizeof(MSG_CreateMob));
			GetCreateMob(conn, &sm_cp);

			GridMulticast(pMob[conn].TargetX, pMob[conn].TargetY, (MSG_STANDARD*)&sm_cp, 0);

			SendClientMessage(conn, "FRAG");
		}
		else if (!strcmp(cmd, "celestial"))
		{
			if (pMob[conn].extra.ClassMaster > CELESTIAL)
				return;

			if (ival1 < 0 && ival1 > 3)
				return;

			if (pMob[conn].MOB.Equip[0].sIndex != 11)
			{
				SendClientMessage(conn, "Somente Personagens de Classe FOEMA (Mortal)");
				return;
			}

			if (ival1 == 0)
			{
				pMob[conn].MOB.Equip[0].sIndex = 16;
				pMob[conn].MOB.Class = 0;

				memset(&pMob[conn].MOB.Equip[1], 0, sizeof(STRUCT_ITEM));

				pMob[conn].MOB.Equip[1].sIndex = 3502;

				pMob[conn].extra.QuestInfo.Celestial.ArchLevel = 5;
				pMob[conn].extra.ClassMaster = CELESTIAL;

				pMob[conn].MOB.BaseScore.Level = 0;
				pMob[conn].MOB.CurrentScore.Level = 0;

				pMob[conn].MOB.BaseScore.Str = BaseSIDCHM[pMob[conn].MOB.Class][0];
				pMob[conn].MOB.BaseScore.Int = BaseSIDCHM[pMob[conn].MOB.Class][1];
				pMob[conn].MOB.BaseScore.Dex = BaseSIDCHM[pMob[conn].MOB.Class][2];
				pMob[conn].MOB.BaseScore.Con = BaseSIDCHM[pMob[conn].MOB.Class][3];

				pMob[conn].MOB.BaseScore.Special[0] = 0;
				pMob[conn].MOB.BaseScore.Special[1] = 0;
				pMob[conn].MOB.BaseScore.Special[2] = 0;
				pMob[conn].MOB.BaseScore.Special[3] = 0;

				pMob[conn].extra.QuestInfo.Arch.Cristal = 4;

				if (pMob[conn].extra.QuestInfo.Arch.Cristal == 1)
					pMob[conn].MOB.BaseScore.Ac = 954;
				else if (pMob[conn].extra.QuestInfo.Arch.Cristal == 2)
					pMob[conn].MOB.BaseScore.Ac = 984;
				else if (pMob[conn].extra.QuestInfo.Arch.Cristal == 3)
					pMob[conn].MOB.BaseScore.Ac = 984;
				else if (pMob[conn].extra.QuestInfo.Arch.Cristal == 4)
					pMob[conn].MOB.BaseScore.Ac = 1004;
				else
					pMob[conn].MOB.BaseScore.Ac = 954;

				pMob[conn].MOB.BaseScore.Damage = 488;
				pMob[conn].MOB.BaseScore.Hp = BaseSIDCHM[pMob[conn].MOB.Class][4];
				pMob[conn].MOB.BaseScore.MaxHp = BaseSIDCHM[pMob[conn].MOB.Class][4];
				pMob[conn].MOB.BaseScore.Mp = BaseSIDCHM[pMob[conn].MOB.Class][5];
				pMob[conn].MOB.BaseScore.MaxMp = BaseSIDCHM[pMob[conn].MOB.Class][5];

				pMob[conn].MOB.SpecialBonus = 855;

				pMob[conn].MOB.LearnedSkill = 1073741824;
				pMob[conn].extra.SecLearnedSkill = 0;

				pMob[conn].MOB.Exp = 0;

				memset(&pMob[conn].MOB.Equip[15], 0, sizeof(STRUCT_ITEM));

				pMob[conn].MOB.Equip[15].sIndex = 3199;

				pMob[conn].MOB.Equip[0].stEffect[1].cEffect = 98;
				pMob[conn].MOB.Equip[0].stEffect[1].cValue = 3;
				pMob[conn].MOB.Equip[0].stEffect[2].cEffect = 106;
				pMob[conn].MOB.Equip[0].stEffect[2].cValue = (unsigned char)pMob[conn].MOB.Equip[0].sIndex;

				BASE_GetHpMp(&pMob[conn].MOB, &pMob[conn].extra);

				SendScore(conn);
				SendEtc(conn);

				CharLogOut(conn);

				SendClientSignalParm(conn, ESCENE_FIELD, _MSG_SendArchEffect, pUser[conn].Slot);

				SendClientMessage(conn, "Virou Celestial TK");
			}
			else if (ival1 == 1)
			{
				pMob[conn].MOB.Equip[0].sIndex = 17;
				pMob[conn].MOB.Class = 1;

				memset(&pMob[conn].MOB.Equip[1], 0, sizeof(STRUCT_ITEM));

				pMob[conn].MOB.Equip[1].sIndex = 3502;

				pMob[conn].extra.QuestInfo.Celestial.ArchLevel = 5;
				pMob[conn].extra.ClassMaster = CELESTIAL;

				pMob[conn].MOB.BaseScore.Level = 0;
				pMob[conn].MOB.CurrentScore.Level = 0;

				pMob[conn].MOB.BaseScore.Str = BaseSIDCHM[pMob[conn].MOB.Class][0];
				pMob[conn].MOB.BaseScore.Int = BaseSIDCHM[pMob[conn].MOB.Class][1];
				pMob[conn].MOB.BaseScore.Dex = BaseSIDCHM[pMob[conn].MOB.Class][2];
				pMob[conn].MOB.BaseScore.Con = BaseSIDCHM[pMob[conn].MOB.Class][3];

				pMob[conn].MOB.BaseScore.Special[0] = 0;
				pMob[conn].MOB.BaseScore.Special[1] = 0;
				pMob[conn].MOB.BaseScore.Special[2] = 0;
				pMob[conn].MOB.BaseScore.Special[3] = 0;

				pMob[conn].extra.QuestInfo.Arch.Cristal = 4;

				if (pMob[conn].extra.QuestInfo.Arch.Cristal == 1)
					pMob[conn].MOB.BaseScore.Ac = 954;
				else if (pMob[conn].extra.QuestInfo.Arch.Cristal == 2)
					pMob[conn].MOB.BaseScore.Ac = 984;
				else if (pMob[conn].extra.QuestInfo.Arch.Cristal == 3)
					pMob[conn].MOB.BaseScore.Ac = 984;
				else if (pMob[conn].extra.QuestInfo.Arch.Cristal == 4)
					pMob[conn].MOB.BaseScore.Ac = 1004;
				else
					pMob[conn].MOB.BaseScore.Ac = 954;

				pMob[conn].MOB.BaseScore.Damage = 488;
				pMob[conn].MOB.BaseScore.Hp = BaseSIDCHM[pMob[conn].MOB.Class][4];
				pMob[conn].MOB.BaseScore.MaxHp = BaseSIDCHM[pMob[conn].MOB.Class][4];
				pMob[conn].MOB.BaseScore.Mp = BaseSIDCHM[pMob[conn].MOB.Class][5];
				pMob[conn].MOB.BaseScore.MaxMp = BaseSIDCHM[pMob[conn].MOB.Class][5];

				pMob[conn].MOB.SpecialBonus = 855;

				pMob[conn].MOB.LearnedSkill = 1073741824;
				pMob[conn].extra.SecLearnedSkill = 0;

				pMob[conn].MOB.Exp = 0;

				memset(&pMob[conn].MOB.Equip[15], 0, sizeof(STRUCT_ITEM));

				pMob[conn].MOB.Equip[15].sIndex = 3199;

				pMob[conn].MOB.Equip[0].stEffect[1].cEffect = 98;
				pMob[conn].MOB.Equip[0].stEffect[1].cValue = 3;
				pMob[conn].MOB.Equip[0].stEffect[2].cEffect = 106;
				pMob[conn].MOB.Equip[0].stEffect[2].cValue = (unsigned char)pMob[conn].MOB.Equip[0].sIndex;

				BASE_GetHpMp(&pMob[conn].MOB, &pMob[conn].extra);

				SendScore(conn);
				SendEtc(conn);

				CharLogOut(conn);

				SendClientSignalParm(conn, ESCENE_FIELD, _MSG_SendArchEffect, pUser[conn].Slot);

				SendClientMessage(conn, "Virou Celestial FM");
			}
			else if (ival1 == 2)
			{
				pMob[conn].MOB.Equip[0].sIndex = 18;
				pMob[conn].MOB.Class = 2;

				memset(&pMob[conn].MOB.Equip[1], 0, sizeof(STRUCT_ITEM));

				pMob[conn].MOB.Equip[1].sIndex = 3502;

				pMob[conn].extra.QuestInfo.Celestial.ArchLevel = 5;
				pMob[conn].extra.ClassMaster = CELESTIAL;

				pMob[conn].MOB.BaseScore.Level = 0;
				pMob[conn].MOB.CurrentScore.Level = 0;

				pMob[conn].MOB.BaseScore.Str = BaseSIDCHM[pMob[conn].MOB.Class][0];
				pMob[conn].MOB.BaseScore.Int = BaseSIDCHM[pMob[conn].MOB.Class][1];
				pMob[conn].MOB.BaseScore.Dex = BaseSIDCHM[pMob[conn].MOB.Class][2];
				pMob[conn].MOB.BaseScore.Con = BaseSIDCHM[pMob[conn].MOB.Class][3];

				pMob[conn].MOB.BaseScore.Special[0] = 0;
				pMob[conn].MOB.BaseScore.Special[1] = 0;
				pMob[conn].MOB.BaseScore.Special[2] = 0;
				pMob[conn].MOB.BaseScore.Special[3] = 0;

				pMob[conn].extra.QuestInfo.Arch.Cristal = 4;

				if (pMob[conn].extra.QuestInfo.Arch.Cristal == 1)
					pMob[conn].MOB.BaseScore.Ac = 954;
				else if (pMob[conn].extra.QuestInfo.Arch.Cristal == 2)
					pMob[conn].MOB.BaseScore.Ac = 984;
				else if (pMob[conn].extra.QuestInfo.Arch.Cristal == 3)
					pMob[conn].MOB.BaseScore.Ac = 984;
				else if (pMob[conn].extra.QuestInfo.Arch.Cristal == 4)
					pMob[conn].MOB.BaseScore.Ac = 1004;
				else
					pMob[conn].MOB.BaseScore.Ac = 954;

				pMob[conn].MOB.BaseScore.Damage = 488;
				pMob[conn].MOB.BaseScore.Hp = BaseSIDCHM[pMob[conn].MOB.Class][4];
				pMob[conn].MOB.BaseScore.MaxHp = BaseSIDCHM[pMob[conn].MOB.Class][4];
				pMob[conn].MOB.BaseScore.Mp = BaseSIDCHM[pMob[conn].MOB.Class][5];
				pMob[conn].MOB.BaseScore.MaxMp = BaseSIDCHM[pMob[conn].MOB.Class][5];

				pMob[conn].MOB.SpecialBonus = 855;

				pMob[conn].MOB.LearnedSkill = 1073741824;
				pMob[conn].extra.SecLearnedSkill = 0;

				pMob[conn].MOB.Exp = 0;

				memset(&pMob[conn].MOB.Equip[15], 0, sizeof(STRUCT_ITEM));

				pMob[conn].MOB.Equip[15].sIndex = 3199;

				pMob[conn].MOB.Equip[0].stEffect[1].cEffect = 98;
				pMob[conn].MOB.Equip[0].stEffect[1].cValue = 3;
				pMob[conn].MOB.Equip[0].stEffect[2].cEffect = 106;
				pMob[conn].MOB.Equip[0].stEffect[2].cValue = (unsigned char)pMob[conn].MOB.Equip[0].sIndex;

				BASE_GetHpMp(&pMob[conn].MOB, &pMob[conn].extra);

				SendScore(conn);
				SendEtc(conn);

				CharLogOut(conn);

				SendClientSignalParm(conn, ESCENE_FIELD, _MSG_SendArchEffect, pUser[conn].Slot);

				SendClientMessage(conn, "Virou Celestial BM");
			}
			else if (ival1 == 3)
			{
				pMob[conn].MOB.Equip[0].sIndex = 19;
				pMob[conn].MOB.Class = 3;

				memset(&pMob[conn].MOB.Equip[1], 0, sizeof(STRUCT_ITEM));

				pMob[conn].MOB.Equip[1].sIndex = 3502;

				pMob[conn].extra.QuestInfo.Celestial.ArchLevel = 5;
				pMob[conn].extra.ClassMaster = CELESTIAL;

				pMob[conn].MOB.BaseScore.Level = 0;
				pMob[conn].MOB.CurrentScore.Level = 0;

				pMob[conn].MOB.BaseScore.Str = BaseSIDCHM[pMob[conn].MOB.Class][0];
				pMob[conn].MOB.BaseScore.Int = BaseSIDCHM[pMob[conn].MOB.Class][1];
				pMob[conn].MOB.BaseScore.Dex = BaseSIDCHM[pMob[conn].MOB.Class][2];
				pMob[conn].MOB.BaseScore.Con = BaseSIDCHM[pMob[conn].MOB.Class][3];

				pMob[conn].MOB.BaseScore.Special[0] = 0;
				pMob[conn].MOB.BaseScore.Special[1] = 0;
				pMob[conn].MOB.BaseScore.Special[2] = 0;
				pMob[conn].MOB.BaseScore.Special[3] = 0;

				pMob[conn].extra.QuestInfo.Arch.Cristal = 4;

				if (pMob[conn].extra.QuestInfo.Arch.Cristal == 1)
					pMob[conn].MOB.BaseScore.Ac = 954;
				else if (pMob[conn].extra.QuestInfo.Arch.Cristal == 2)
					pMob[conn].MOB.BaseScore.Ac = 984;
				else if (pMob[conn].extra.QuestInfo.Arch.Cristal == 3)
					pMob[conn].MOB.BaseScore.Ac = 984;
				else if (pMob[conn].extra.QuestInfo.Arch.Cristal == 4)
					pMob[conn].MOB.BaseScore.Ac = 1004;
				else
					pMob[conn].MOB.BaseScore.Ac = 954;

				pMob[conn].MOB.BaseScore.Damage = 488;
				pMob[conn].MOB.BaseScore.Hp = BaseSIDCHM[pMob[conn].MOB.Class][4];
				pMob[conn].MOB.BaseScore.MaxHp = BaseSIDCHM[pMob[conn].MOB.Class][4];
				pMob[conn].MOB.BaseScore.Mp = BaseSIDCHM[pMob[conn].MOB.Class][5];
				pMob[conn].MOB.BaseScore.MaxMp = BaseSIDCHM[pMob[conn].MOB.Class][5];

				pMob[conn].MOB.SpecialBonus = 855;

				pMob[conn].MOB.LearnedSkill = 1073741824;
				pMob[conn].extra.SecLearnedSkill = 0;

				pMob[conn].MOB.Exp = 0;

				memset(&pMob[conn].MOB.Equip[15], 0, sizeof(STRUCT_ITEM));

				pMob[conn].MOB.Equip[15].sIndex = 3199;

				pMob[conn].MOB.Equip[0].stEffect[1].cEffect = 98;
				pMob[conn].MOB.Equip[0].stEffect[1].cValue = 3;
				pMob[conn].MOB.Equip[0].stEffect[2].cEffect = 106;
				pMob[conn].MOB.Equip[0].stEffect[2].cValue = (unsigned char)pMob[conn].MOB.Equip[0].sIndex;

				BASE_GetHpMp(&pMob[conn].MOB, &pMob[conn].extra);

				SendScore(conn);
				SendEtc(conn);

				CharLogOut(conn);

				SendClientSignalParm(conn, ESCENE_FIELD, _MSG_SendArchEffect, pUser[conn].Slot);

				SendClientMessage(conn, "Virou Celestial HT");
			}
			else
				SendClientMessage(conn, "Você precisa digitar um valor de 0 a 3");
		}
		else if (!strcmp(cmd, "log"))
		{
			StartSystemLog();
			StartChatLog();
			StartItemLog();
			CompositorLog();

			SendClientMessage(conn, "RESTART LOG");
		}
		/*else if (!strcmp(cmd, "pesca"))
		{
			MSG_Action sm;
			p_Pesca.start = true;
			SendNotice("pesca iniciada! ");
			PescaTime = 900;
		}*/
		else if (!strcmp(cmd, "guildday"))
		{
			if (ival1 >= 0 && ival1 <= 6)
			{
				GuildDay = ival1;
				SendClientMessage(conn, "SET GUILD BATTLE DAY");
			}
		}
		else if (!strcmp(cmd, "guildhour"))
		{
			if (ival1 >= 0 && ival1 <= 23)
			{
				GuildHour = ival1;
				SendClientMessage(conn, "SET GUILD BATTLE HOUR");
			}
		}
		else if (!strcmp(cmd, "newbiehour"))
		{
			if (ival1 >= 0 && ival1 <= 23)
			{
				NewbieHour = ival1;
				SendClientMessage(conn, "SET NEWBIE BATTLE HOUR");
			}
		}
		else if (!strcmp(cmd, "weekmode"))
		{
			if (ival1 >= 0 && ival1 <= 5)
			{
				ForceWeekMode = ival1;
				WeekMode = ival1 - 1;

				if (WeekMode == -1)
					WeekMode = 5;
				SendClientMessage(conn, "FORCE GUILD MODE");
				return;
			}
			ForceWeekMode = -1;
			SendClientMessage(conn, "WEEKLY GUILD MODE");
		}
		else if (!strcmp(cmd, "reloadnpc"))
		{
			mNPCGen.ReadNPCGenerator();
			SendClientMessage(conn, "RELOADNPC");
		}	
		else if (!strcmp(cmd, "reloaddroplist"))
		{
			mNPCGen.UpdateDropList();
			SendClientMessage(conn, "RELOADDROPLIST");
		}
		else if (!strcmp(cmd, "makedroplist"))
		{
			mNPCGen.ReadNPCGenerator();
			mNPCGen.DropList();
			SendClientMessage(conn, "MAKEDROPLIST");
		}		
		else if (!strcmp(cmd, "loadevent"))
		{
			LoadEvent();
			SendClientMessage(conn, "Update Evento");
		}
		else if (!strcmp(cmd, "updateshop"))
		{
			UpdateShopDonate1();
			UpdateShopDonate2();
			UpdateShopDonate3();
			SendClientMessage(conn, "Update Shop Donate");
		}
		else if (!strcmp(cmd, "updatebalanceio"))
		{
			BalanceioPvP();
			SendClientMessage(conn, "Update Balanceio");
		}
		else if (!strcmp(cmd, "reloadexptable"))
		{
			ReadExpTableN();
			ReadExpTableM();
			SendClientMessage(conn, "Update Exp Table");
		}
		else if (!strcmp(cmd, "reloadserver"))
		{
			ReadServerConfigs();
			SendClientMessage(conn, "Update Server Configs");
		}
		else if (!strcmp(cmd, "reloadguild"))
		{
			CReadFiles::ReadGuild();
			SendClientMessage(conn, "RELOADGUILD");
		}
		else if (!strcmp(cmd, "readguildname"))
		{
			BASE_InitializeGuildName();
			SendClientMessage(conn, "READ GUILD NAME");
		}
		else if (!strcmp(cmd, "setjoias"))
		{
			pUser[conn].Joias[pUser[conn].Slot][0].sIndex = 4472;
			pUser[conn].Joias[pUser[conn].Slot][0].stEffect[0].cEffect = 43;
			pUser[conn].Joias[pUser[conn].Slot][0].stEffect[0].cValue = 9;
			pUser[conn].Joias[pUser[conn].Slot][0].stEffect[1].cEffect = 0;
			pUser[conn].Joias[pUser[conn].Slot][0].stEffect[1].cValue = 0;
			pUser[conn].Joias[pUser[conn].Slot][0].stEffect[2].cEffect = 0;
			pUser[conn].Joias[pUser[conn].Slot][0].stEffect[2].cValue = 0;

			pUser[conn].Joias[pUser[conn].Slot][1].sIndex = 4487;
			pUser[conn].Joias[pUser[conn].Slot][1].stEffect[0].cEffect = 43;
			pUser[conn].Joias[pUser[conn].Slot][1].stEffect[0].cValue = 9;
			pUser[conn].Joias[pUser[conn].Slot][1].stEffect[1].cEffect = 0;
			pUser[conn].Joias[pUser[conn].Slot][1].stEffect[1].cValue = 0;
			pUser[conn].Joias[pUser[conn].Slot][1].stEffect[2].cEffect = 0;
			pUser[conn].Joias[pUser[conn].Slot][1].stEffect[2].cValue = 0;
			SendClientMessage(conn, "SetJoias");
			pMob[conn].GetCurrentScore(conn);
			SendScore(conn);
			SendEtc(conn);
			SaveUser(conn, 0);
		}

		else if (!strcmp(cmd, "nojoias"))
		{
			pUser[conn].Joias[pUser[conn].Slot][0].sIndex = 0;
			pUser[conn].Joias[pUser[conn].Slot][0].stEffect[0].cEffect = 0;
			pUser[conn].Joias[pUser[conn].Slot][0].stEffect[0].cValue = 0;
			pUser[conn].Joias[pUser[conn].Slot][1].sIndex = 0;
			pUser[conn].Joias[pUser[conn].Slot][1].stEffect[0].cEffect = 0;
			pUser[conn].Joias[pUser[conn].Slot][1].stEffect[0].cValue = 0;
			SendClientMessage(conn, "SetJoias");
			pMob[conn].GetCurrentScore(conn);
			SendScore(conn);
			SendEtc(conn);
			SaveUser(conn, 0);
			}
		else if (!strcmp(cmd, "trtarget"))
		{
			if (ival1 < 1 || ival1>8)
			{
				SendClientMessage(conn, "err: +treasure (1-8) (1-5) (item)");
				return;
			}
			if (ival2 < 1 || ival2 > 5)
			{
				SendClientMessage(conn, "err: +treasure (1-8) (1-5) (item)");
				return;
			}
			int idx = ival1 - 1;
			int tgt = ival2 - 1;
			int iv1 = 0;
			int iv2 = 0;
			int iv3 = 0;
			int iv4 = 0;
			int iv5 = 0;

			sscanf(str + 1, "%s %s %s %d %d %d %d %d", cmd, sval1, sval2, &iv1, &iv2, &iv3, &iv4, &iv5);

			g_pTreasure[idx].Target[tgt].sIndex = iv1;
			g_pTreasure[idx].Target[tgt].stEffect[0].cEffect = iv2;
			g_pTreasure[idx].Target[tgt].stEffect[0].cValue = iv3;
			g_pTreasure[idx].Target[tgt].stEffect[1].cEffect = iv4;
			g_pTreasure[idx].Target[tgt].stEffect[1].cValue = iv5;
			g_pTreasure[idx].Target[tgt].stEffect[2].cEffect = 0;
			g_pTreasure[idx].Target[tgt].stEffect[2].cValue = 0;

			DrawConfig(1);
			SendClientMessage(conn, "+troktarget success");
		}
		else if (!strcmp(cmd, "trsource"))
		{
			if (ival1 < 1 || ival1 > 8)
			{
				SendClientMessage(conn, "err: +source (1-8) (item)");
				return;
			}
			int idx = ival1 - 1;
			g_pTreasure[idx].Source = ival2;
			DrawConfig(1);
			SendClientMessage(conn, "+trsource success");
		}
		else if (!strcmp(cmd, "trrate"))
		{
			if (ival1 < 1 || ival1>8)
			{
				SendClientMessage(conn, "err: +trrate (1-8) (item)");
				return;
			}
			if (ival2 < 1 || ival2>5)
			{
				SendClientMessage(conn, "err: +trrate (1-8) (1-5) (item)");
				return;
			}
			int idx = ival1 - 1;
			int tgt = ival2 - 1;

			g_pTreasure[idx].Rate[tgt] = ival3;
			DrawConfig(1);
			SendClientMessage(conn, "+trrate success");
		}
		/*else if (!strcmp(cmd, "ban"))
		{
			int tid = GetUserByName(sval2);

			if (sval2[0] == 0)
				return;

			if (pUser[tid].Mode != USER_PLAY)
				return;

			if (tid == 0)
			{
				SendClientMessage(conn, "Can't find user.");
				return;
			}
			if (!strcmp(sval1, "3horas"))
			{
				SendBanAccount(tid, Banned::Tempo3horas);
				return;
			}
			if (!strcmp(sval1, "3dias"))
			{
				SendBanAccount(tid, Banned::Tempo3dias);
				return;
			}
			if (!strcmp(sval1, "7dias"))
			{
				SendBanAccount(tid, Banned::Tempo7dias);
				return;
			}
			if (!strcmp(sval1, "15dias"))
			{
				SendBanAccount(tid, Banned::Tempo15dias);
				return;
			}

			if (!strcmp(sval1, "15dias"))
			{
				SendBanAccount(tid, Banned::Tempo15dias);
				return;
			}
			if (!strcmp(sval1, "perma"))
			{
				SendBanAccount(tid, Banned::Permanente);
				return;
			}

			if (!strcmp(sval1, "mac"))
			{
				MacBan(tid);
				return;
			}
			return;
		}*/

		else if (!strcmp(cmd, "bann"))
		{
			int Days = 0;

			sscanf(sval2, "%d", &Days);

			auto ban = &BannedUser[0];
			memset(&BannedUser[0], 0, sizeof(AccountBanned));

			struct tm when;
			time_t now;
			time(&now);
			when = *localtime(&now);

			if (Days < 30) {

				ban->mes = when.tm_mon;
				ban->dia = when.tm_mday + Days;
				ban->hora = when.tm_hour;
				ban->min = when.tm_min;
				ban->ano = when.tm_year;
			}
			else {
				ban->Permanente = TRUE;
			}

			std::ofstream outputFile(strFmt("Ban/%s.bin", &sval1), std::ofstream::out | std::ofstream::binary);

			if (outputFile.is_open())
			{
				AccountBanned temp;
				std::memcpy(&temp, &BannedUser[0], sizeof(AccountBanned));

				outputFile.write(reinterpret_cast<char*>(&BannedUser[0]), sizeof(AccountBanned));
				outputFile.close();
			}
			SendClientMessage(conn, strFmt("A conta [%s] foi banida por [%d] Dias!", &sval1, Days));
			return;
		}
		else if (!strcmp(cmd, "statsapphire"))
		{
			if (ival1 < 0)
			{
				SendClientMessage(conn, "err: +statsapphire (0-64)");
				return;
			}
			StatSapphire = ival1;
			SendClientMessage(conn, "CHANGE STAT SAPPHIRE");
			DrawConfig(TRUE);
		}
		else if (!strcmp(cmd, "battleroyal"))
		{
			if (ival1 < 0)
			{
				SendClientMessage(conn, "err: +battleroyal (1-max_itemlist)");
				return;
			}
			BRItem = ival1;
			SendClientMessage(conn, "CHANGE BATTLE ROYAL REWARD");
			DrawConfig(TRUE);
		}
		else if (!strcmp(cmd, "set"))
		{
			if (!strcmp(sval1, "evstart"))
			{
				evStartIndex = evCurrentIndex = ival2;
				
				snprintf(temp, sizeof(temp), "item:%d index:%d-%d(%d) rate:1/%d [I:%d D:%d O:%d N:%d]", evItem, evStartIndex, evEndIndex, evCurrentIndex, evRate, evIndex, evDelete, evOn, evNotice);

				SendClientMessage(conn, temp);
				DrawConfig(TRUE);
			}
			else if (!strcmp(sval1, "evend"))
			{
				evEndIndex = ival2;
				
				snprintf(temp, sizeof(temp), "item:%d index:%d-%d(%d) rate:1/%d [I:%d D:%d O:%d N:%d]", evItem, evStartIndex, evEndIndex, evCurrentIndex, evRate, evIndex, evDelete, evOn, evNotice);

				SendClientMessage(conn, temp);
				DrawConfig(TRUE);
			}
			else if (!strcmp(sval1, "evitem"))
			{
				evItem = ival2;
				
				snprintf(temp, sizeof(temp), "item:%d index:%d-%d(%d) rate:1/%d [I:%d D:%d O:%d N:%d]", evItem, evStartIndex, evEndIndex, evCurrentIndex, evRate, evIndex, evDelete, evOn, evNotice);

				SendClientMessage(conn, temp);
				DrawConfig(TRUE);
			}
			else if (!strcmp(sval1, "evrate"))
			{
				evRate = ival2;
				
				snprintf(temp, sizeof(temp), "item:%d index:%d-%d(%d) rate:1/%d [I:%d D:%d O:%d N:%d]", evItem, evStartIndex, evEndIndex, evCurrentIndex, evRate, evIndex, evDelete, evOn, evNotice);

				SendClientMessage(conn, temp);
				DrawConfig(TRUE);
			}
			else if (!strcmp(sval1, "evindex"))
			{
				evIndex = ival2;
				
				snprintf(temp, sizeof(temp), "item:%d index:%d-%d(%d) rate:1/%d [I:%d D:%d O:%d N:%d]", evItem, evStartIndex, evEndIndex, evCurrentIndex, evRate, evIndex, evDelete, evOn, evNotice);

				SendClientMessage(conn, temp);
				DrawConfig(TRUE);
			}
			else if (!strcmp(sval1, "evdelete"))
			{
				evDelete = ival2;
			
				snprintf(temp, sizeof(temp), "item:%d index:%d-%d(%d) rate:1/%d [I:%d D:%d O:%d N:%d]", evItem, evStartIndex, evEndIndex, evCurrentIndex, evRate, evIndex, evDelete, evOn, evNotice);

				SendClientMessage(conn, temp);
				DrawConfig(TRUE);
			}
			else if (!strcmp(sval1, "evon"))
			{
				if (ival2 && (evStartIndex == 0 || evEndIndex == 0 || evRate == 0 || evItem == 0))
				{
					
					snprintf(temp, sizeof(temp), "item:%d index:%d-%d(%d) rate:1/%d [I:%d D:%d O:%d N:%d]", evItem, evStartIndex, evEndIndex, evCurrentIndex, evRate, evIndex, evDelete, evOn, evNotice);

					SendClientMessage(conn, temp);
					return;
				}
				evOn = ival2;
				
				snprintf(temp, sizeof(temp), "item:%d index:%d-%d(%d) rate:1/%d [I:%d D:%d O:%d N:%d]", evItem, evStartIndex, evEndIndex, evCurrentIndex, evRate, evIndex, evDelete, evOn, evNotice);

				SendClientMessage(conn, temp);
				DrawConfig(TRUE);
			}
			else if (!strcmp(sval1, "evnotice"))
			{
				evNotice = ival2;
				
				snprintf(temp, sizeof(temp), "item:%d index:%d-%d(%d) rate:1/%d [I:%d D:%d O:%d N:%d]", evItem, evStartIndex, evEndIndex, evCurrentIndex, evRate, evIndex, evDelete, evOn, evNotice);

				SendClientMessage(conn, temp);
				DrawConfig(TRUE);
			}
			else if (!strcmp(sval1, "double"))
			{
				DOUBLEMODE = ival2;
				SendClientMessage(conn, "SET DOUBLEMODE");
				DrawConfig(TRUE);
			}
			else if (!strcmp(sval1, "deadpoint"))
			{
				DEADPOINT = ival2;

				if (DEADPOINT)
					SendClientMessage(conn, "SET DEADPOINT 1");
				else
					SendClientMessage(conn, "SET DEADPOINT 0");

				DrawConfig(TRUE);
			}
			else if (!strcmp(sval1, "dungeonevent"))
			{
				DUNGEONEVENT = ival2;

				if (DUNGEONEVENT)
					SendClientMessage(conn, "SET DUNGEON EVENT ON");
				else
					SendClientMessage(conn, "SET DUNGEON EVENT OFF");

				DrawConfig(TRUE);
			}
			else if (!strcmp(sval1, "champ"))
			{
				if (conn <= 0 && conn >= MAX_USER)
					return;

				if (ival2 >= 0 && ival2 < MAX_GUILDZONE)
				{
					g_pGuildZone[ival2].ChargeGuild = ival3;
					
					snprintf(temp, sizeof(temp), "Set Champion Guild - Zone:%d Guild %d", ival2, ival3);

					SendClientMessage(conn, temp);
					GuildZoneReport();
					CReadFiles::WriteGuild();
				}
			}
			else if (!strcmp(sval1, "chall"))
			{
				if (conn <= 0 && conn >= MAX_USER)
					return;

				if (ival2 >= 0 && ival2 < MAX_GUILDZONE)
				{
					g_pGuildZone[ival2].ChallangeGuild = ival3;
					
					snprintf(temp, sizeof(temp), "Set Challanger Guild - Zone:%d Guild %d", ival2, ival3);

					SendClientMessage(conn, temp);
					CReadFiles::WriteGuild();
				}
			}
			else if (!strcmp(sval1, "drop"))
			{
				if (ival3 < 0 || ival3 > 8000)
				{
					SendClientMessage(conn, "Wrong Drop Bonus Rate");
					return;
				}
				if (ival2 == 16)
				{
					for (int i = 0; i < 64; i++)
					{
						int idx = i;
						g_pDropBonus[idx] = ival3;
					}
				}
				else if (ival2 >= 1 && ival2 <= 7)
				{
					for (int i = 0; i < 8; i++)
					{
						int idx = (ival2 - 1) * 8 + i;
						g_pDropBonus[idx] = ival3;
					}
				}
				else if (ival2 >= 8 && ival2 <= 15)
				{
					int idx = 56 + (ival2 - 8);
					g_pDropBonus[idx] = ival3;
				}
				else
				{
					SendClientMessage(conn, "Wrong Drop Position");
					return;
				}
				SendClientMessage(conn, "SET DROP BONUS");
				DrawConfig(TRUE);
			}
		}
	}
	if (level >= 1)
	{
		if (!strcmp(cmd, "weather"))
		{
			ForceWeather = ival1;
			CurrentWeather = ival1;
			SendWeather();
		}
		else if (!strcmp(cmd, "attmap"))
		{
			unsigned char attributemap = GetAttribute(pMob[conn].TargetX, pMob[conn].TargetY);
			
			snprintf(temp, sizeof(temp), "Atributo do mapa é %d", attributemap);
			SendClientMessage(conn, temp);
		}
		else if (!strcmp(cmd, "billconnect"))
		{
			if (BillServerSocket.Sock != NULL)
			{
				SendClientMessage(conn, "already connected");
				return;
			}
			FILE* fp = fopen("biserver.txt", "rt");
			if (fp == NULL)
			{
				SendClientMessage(conn, "no biserver.txt");
				return;
			}
			fscanf(fp, "%s %d", BillServerAddress, &BillServerPort);
			fclose(fp);

			int* pip = (int*)LocalIP;
			int	ret = BillServerSocket.ConnectBillServer(BillServerAddress, BillServerPort, *pip, WSA_READBILL);

			if (ret == NULL)
			{
				SendClientMessage(conn, "set connect fails");
				return;
			}

			BILLING = 3;
			SendClientMessage(conn, "set connect billing");
			DrawConfig(1);
		}
	}
	if (level >= 1)
	{
		if (!strcmp(cmd, "impost"))
		{
			pMob[GuildImpostoID[0]].MOB.Exp = 0;
			pMob[GuildImpostoID[1]].MOB.Exp = 0;
			pMob[GuildImpostoID[2]].MOB.Exp = 0;
			pMob[GuildImpostoID[3]].MOB.Exp = 0;
			pMob[GuildImpostoID[4]].MOB.Exp = 0;

			SendClientMessage(conn, "IMPOST");
		}
		if (!strcmp(cmd, "trn"))
		{
			int x = pMob[conn].TargetX;
			int y = pMob[conn].TargetY;
			DoTeleport(conn, 4000, 4000);
			DoTeleport(conn, x, y);
		}
		if (!strcmp(cmd, "notice"))
		{
			char temp[1024];
			memmove_s(temp, MESSAGE_LENGTH, str + 7, MESSAGE_LENGTH);

			MSG_DBNotice sm_dbn;
			memset(&sm_dbn, 0, sizeof(MSG_DBNotice));

			sm_dbn.Size = sizeof(MSG_DBNotice);
			sm_dbn.ID = 0;
			sm_dbn.Type = _MSG_DBNotice;

			strncpy(sm_dbn.String, temp, MESSAGE_LENGTH - 1);

			DBServerSocket.SendOneMessage((char*)&sm_dbn, sizeof(MSG_DBNotice));

			return;
		}
		if (!strcmp(cmd, "bcnot"))
		{
			for (int i = 0; i < MAX_USER; i++)
			{
				if (pMob[i].TargetX >= 1302 && pMob[i].TargetX <= 1381 && pMob[i].TargetY >= 1483 && pMob[i].TargetY <= 1516)
				{
					char temp[1024];
					memmove_s(temp, MESSAGE_LENGTH, str + 7, MESSAGE_LENGTH);

					MSG_DBNotice sm_dbn;
					memset(&sm_dbn, 0, sizeof(MSG_DBNotice));

					sm_dbn.Size = sizeof(MSG_DBNotice);
					sm_dbn.ID = 0;
					sm_dbn.Type = _MSG_DBNotice;

					strncpy(sm_dbn.String, temp, MESSAGE_LENGTH - 1);

					DBServerSocket.SendOneMessage((char*)&sm_dbn, sizeof(MSG_DBNotice));

					return;
				}
			}
		}
		else if (!strcmp(cmd, "waterexp"))
		{
			int sala = ival1;
			int xp = ival2;

			if (sala == 0)//Water N
			{
				for (int i = WATER_N_INITIAL; i <= WATER_N_INITIAL + 8; i++)
				{
					char tt[256];
					strncpy(tt, "./npc/", sizeof(tt));

					char name[NAME_LENGTH];
					char temp[1024];

					snprintf(name, sizeof(temp), "%s", mNPCGen.pList[i].Leader.MobName);

					for (int j = 0; j < NAME_LENGTH; j++)
					{
						if (name[j] == ' ')
							name[j] = '_';
					}

					strcat(tt, name);

					int handle = _open(tt, _O_CREAT | _O_RDWR | _O_BINARY, _S_IREAD | _S_IWRITE);
					if (handle == -1)
					{
						//Log("-system", "fail - save npc", 0);
						return;
					}

					mNPCGen.pList[i].Leader.Exp = xp * mNPCGen.pList[i].Leader.BaseScore.Level / FREEEXP;

					_write(handle, (void*)&mNPCGen.pList[i].Leader, sizeof(STRUCT_MOB));
					_close(handle);
				}
			}

			else if (sala == 1)//Water M
			{
				for (int i = WATER_M_INITIAL; i <= WATER_N_INITIAL + 8; i++)
				{
					char tt[256];
					strncpy(tt, "./npc/", sizeof(tt));

					char name[NAME_LENGTH];
					char temp[1024];
					snprintf(name, sizeof(temp), "%s", mNPCGen.pList[i].Leader.MobName);

					for (int j = 0; j < NAME_LENGTH; j++)
					{
						if (name[j] == ' ')
							name[j] = '_';
					}

					strcat(tt, name);

					int handle = _open(tt, _O_CREAT | _O_RDWR | _O_BINARY, _S_IREAD | _S_IWRITE);
					if (handle == -1)
					{
						SystemLog("-system", "-", 0, "fail - save npc");
						return;
					}

					mNPCGen.pList[i].Leader.Exp = xp * mNPCGen.pList[i].Leader.BaseScore.Level / FREEEXP;

					_write(handle, (void*)&mNPCGen.pList[i].Leader, sizeof(STRUCT_MOB));
					_close(handle);
				}
			}

			else //Water A
			{
				for (int i = WATER_A_INITIAL; i <= WATER_A_INITIAL + 8; i++)
				{
					char tt[256];
					strncpy(tt, "./npc/", sizeof(tt));

					char name[NAME_LENGTH];
					char temp[1024];
					snprintf(name, sizeof(temp), "%s", mNPCGen.pList[i].Leader.MobName);

					for (int j = 0; j < NAME_LENGTH; j++)
					{
						if (name[j] == ' ')
							name[j] = '_';
					}

					strcat(tt, name);

					int handle = _open(tt, _O_CREAT | _O_RDWR | _O_BINARY, _S_IREAD | _S_IWRITE);
					if (handle == -1)
					{
						SystemLog("-system", "-", 0, "fail - save npc");
						return;
					}

					mNPCGen.pList[i].Leader.Exp = xp * mNPCGen.pList[i].Leader.BaseScore.Level / FREEEXP;

					_write(handle, (void*)&mNPCGen.pList[i].Leader, sizeof(STRUCT_MOB));
					_close(handle);
				}
			}

			mNPCGen.ReadNPCGenerator();
			SendClientMessage(conn, "WATER EXP CHANGED");
		}
		else if (!strcmp(cmd, "gridoff"))  //COOMANDO
		{
			pMobGrid[pMob[conn].TargetY][pMob[conn].TargetX] = 0;

			SendClientMessage(conn, "Grid off.");
		}
		else if (!strcmp(cmd, "gridon"))   //COMANDO
		{
			pMobGrid[pMob[conn].TargetY][pMob[conn].TargetX] = conn;

			SendClientMessage(conn, "Grid on.");
		}
		else if (!strcmp(cmd, "svexp"))
		{
			int lv = ival1;
			int xp = ival2;

			for (int i = 1; i < mNPCGen.NumList; i++)
			{
				char tt[256];
				strncpy(tt, "./npc/", sizeof(tt));

				char name[NAME_LENGTH];

				strncpy(name, mNPCGen.pList[i].Leader.MobName, sizeof(name));

				for (int j = 0; j < NAME_LENGTH; j++)
				{
					if (name[j] == ' ')
						name[j] = '_';
				}

				strcat(tt, name);

				int handle = _open(tt, _O_CREAT | _O_RDWR | _O_BINARY, _S_IREAD | _S_IWRITE);
				if (handle == -1)
				{
					SystemLog("-system", "-", 0, "fail - save npc");
					return;
				}

				mNPCGen.pList[i].Leader.Exp = mNPCGen.pList[i].Leader.BaseScore.Level < lv ? xp : xp * mNPCGen.pList[i].Leader.BaseScore.Level / lv;

				_write(handle, (void*)&mNPCGen.pList[i].Leader, sizeof(STRUCT_MOB));
				_close(handle);

				strncpy(tt, "./npc/", sizeof(tt));

				strncpy(name, mNPCGen.pList[i].Follower.MobName, sizeof(name));

				for (int j = 0; j < NAME_LENGTH; j++)
				{
					if (name[j] == ' ')
						name[j] = '_';
				}

				strcat(tt, name);

				handle = _open(tt, _O_CREAT | _O_RDWR | _O_BINARY, _S_IREAD | _S_IWRITE);
				if (handle == -1)
				{
					SystemLog("-system", "-", 0, "fail - save npc");
					return;
				}

				mNPCGen.pList[i].Follower.Exp = xp * mNPCGen.pList[i].Follower.BaseScore.Level / lv;

				_write(handle, (void*)&mNPCGen.pList[i].Follower, sizeof(STRUCT_MOB));
				_close(handle);
			}


			mNPCGen.ReadNPCGenerator();
			SendClientMessage(conn, "EXP CHANGED");
		}
		else if (!strcmp(cmd, "nigexp"))
		{
			int sala = ival1;
			int xp = ival2;

			if (sala == 0)//Nightmare N
			{
				for (int i = NIGHTMARE_N_INITIAL; i <= NIGHTMARE_N_END; i++)
				{
					char tt[256];
					strncpy(tt, "./npc/", sizeof(tt));

					char name[NAME_LENGTH];
					char temp[1024];
					snprintf(name, sizeof(temp), "%s", mNPCGen.pList[i].Leader.MobName);

					for (int j = 0; j < NAME_LENGTH; j++)
					{
						if (name[j] == ' ')
							name[j] = '_';
					}

					strcat(tt, name);

					int handle = _open(tt, _O_CREAT | _O_RDWR | _O_BINARY, _S_IREAD | _S_IWRITE);
					if (handle == -1)
					{
						SystemLog("-system", "-", 0, "fail - save npc");
						return;
					}

					mNPCGen.pList[i].Leader.Exp = xp * mNPCGen.pList[i].Leader.BaseScore.Level / FREEEXP;

					_write(handle, (void*)&mNPCGen.pList[i].Leader, sizeof(STRUCT_MOB));
					_close(handle);
				}
			}

			else if (sala == 1)//Nightmare M
			{
				for (int i = NIGHTMARE_M_INITIAL; i <= NIGHTMARE_M_END; i++)
				{
					char tt[256];
					strncpy(tt, "./npc/", sizeof(tt));

					char name[NAME_LENGTH];
					char temp[1024];
					snprintf(name, sizeof(temp), "%s", mNPCGen.pList[i].Leader.MobName);

					for (int j = 0; j < NAME_LENGTH; j++)
					{
						if (name[j] == ' ')
							name[j] = '_';
					}

					strcat(tt, name);

					int handle = _open(tt, _O_CREAT | _O_RDWR | _O_BINARY, _S_IREAD | _S_IWRITE);
					if (handle == -1)
					{
						SystemLog("-system", "-", 0, "fail - save npc");
						return;
					}

					mNPCGen.pList[i].Leader.Exp = xp * mNPCGen.pList[i].Leader.BaseScore.Level / FREEEXP;

					_write(handle, (void*)&mNPCGen.pList[i].Leader, sizeof(STRUCT_MOB));
					_close(handle);
				}
			}

			else //Nightmare A
			{
				for (int i = NIGHTMARE_A_INITIAL; i <= NIGHTMARE_A_END; i++)
				{
					char tt[256];
					strncpy(tt, "./npc/", sizeof(tt));

					char name[NAME_LENGTH];
					char temp[1024];
					snprintf(name, sizeof(temp), "%s", mNPCGen.pList[i].Leader.MobName);

					for (int j = 0; j < NAME_LENGTH; j++)
					{
						if (name[j] == ' ')
							name[j] = '_';
					}

					strcat(tt, name);

					int handle = _open(tt, _O_CREAT | _O_RDWR | _O_BINARY, _S_IREAD | _S_IWRITE);
					if (handle == -1)
					{
						SystemLog("-system", "-", 0, "fail - save npc");
						return;
					}

					mNPCGen.pList[i].Leader.Exp = xp * mNPCGen.pList[i].Leader.BaseScore.Level / FREEEXP;

					_write(handle, (void*)&mNPCGen.pList[i].Leader, sizeof(STRUCT_MOB));
					_close(handle);
				}
			}

			mNPCGen.ReadNPCGenerator();
			SendClientMessage(conn, "NIGHTMARE EXP CHANGED");
		}
		else if (!strcmp(cmd, "chiefnotice"))
		{
			char temp[256];
			memmove_s(temp, MESSAGE_LENGTH, str + 12, MESSAGE_LENGTH);

			SendNoticeChief(temp);
			SendClientMessage(conn, "CHIEFNOTICE");
			return;
		}
		else if (!strcmp(cmd, "chiefsummon") && conn > 0 && conn < MAX_USER)
		{
			SendSummonChief();
			SendClientMessage(conn, "CHIEFSUMMON");
		}
		else if (!strcmp(cmd, "rebuild"))
		{
			RebuildGenerator();
			SendClientMessage(conn, "REBUILDGENERATOR");
		}
		else if (!strcmp(cmd, "quiz"))
		{
			ReadQuiz();
			char value = rand() % QuizLineCounter;
			SendQuizMessage(conn, QuizList[value].Title, QuizList[value].Answer[0], QuizList[value].Answer[1], QuizList[value].Answer[2], QuizList[value].Answer[3], QuizList[value].CorrectAlternative);
		}
		else if (!strcmp(cmd, "bigquiz"))
		{
			ReadCuboQuiz();
			char value = rand() % CuboQuizLine;

			SendBigMessage(conn, "<<_?_?_>>", CuboList[value].Line[0]);

		}
		else if (!strcmp(cmd, "cubo"))
		{
			char Title[96];
			snprintf(Title, sizeof(Title), "<<_No._%d_>>", CuboN.CurrentQuestion[0] + 1);
			SendBigMessage(conn, Title, CuboN.Question[0]);

			int cCubo = GetCuboTeleportPositionN(conn, 0);

			char tmg[256];

			if (cCubo)
				snprintf(tmg, sizeof(tmg), "Você está no local certo!");
			else
				snprintf(tmg, sizeof(tmg), "Lugar errado!");

			SendClientMessage(conn, tmg);
		}
		else if (!strcmp(cmd, "mute"))// ban de mute dentro do jogo nao fala mais nada vc que desmuta
		{
			int user = GetUserByName(sval1);

			if (user == 0)
			{
				SendClientMessage(conn, g_pMessageStringTable[_NN_Not_Connected]);
				return;
			}

			if (pUser[user].Mode != USER_PLAY)
				return;

			pUser[user].MuteChat = pUser[user].MuteChat == 0 ? 1 : 0;

			SendClientMessage(conn, "MUTE");
			SendClientMessage(user, g_pMessageStringTable[_NN_Chat_Prohibition]);
			return;
		}
		else if (!strcmp(cmd, "muteall"))//aqui muta todos
		{
			for (int user = 1; user < MAX_USER; user++)
			{
				if (pUser[user].Mode < USER_SELCHAR)
					return;

				pUser[user].MuteChat = 1;

				SendClientMessage(user, g_pMessageStringTable[_NN_Chat_Prohibition]);
			}

			SendClientMessage(conn, "MUTE ALL");
			return;
		}
		else if (!strcmp(cmd, "desmuteall"))//aqui desmuta 
		{
			for (int user = 1; user < MAX_USER; user++)
			{
				if (pUser[user].Mode < USER_SELCHAR)
					return;

				pUser[user].MuteChat = 0;
			}

			SendClientMessage(conn, "DESMUTE ALL");
			return;
		}
		else if (!strcmp(cmd, "snoop"))
		{
			if (conn <= 0 && conn >= MAX_USER)
				return;

			if (pMob[conn].MOB.Merchant & MSV_SNOOP)
			{
				pMob[conn].MOB.Merchant = pMob[conn].MOB.Merchant & 0xFE;
				SendClientMessage(conn, "SNOOP OFF");
			}
			else
			{
				pMob[conn].MOB.Merchant = pMob[conn].MOB.Merchant | MSV_SNOOP;
				SendClientMessage(conn, "SNOOP ON");
			}

			pMob[conn].GetCurrentScore(conn);
			SendScore(conn);
			return;
		}
		else if (!strcmp(cmd, "event"))
		{
			
			snprintf(temp, sizeof(temp), "item:%d index:%d-%d(%d) rate:1/%d [I:%d D:%d O:%d] %d", evItem, evStartIndex, evEndIndex, evCurrentIndex, evRate, evIndex, evDelete, evOn, DOUBLEMODE);
			SendClientMessage(conn, temp);
		}
		else if (!strcmp(cmd, "learn"))
		{
			pMob[conn].MOB.LearnedSkill = -1;
			pMob[conn].extra.SecLearnedSkill = -1;
			SendEtc(conn);
			SendClientMessage(conn, "LEARN");
		}
		else if (!strcmp(cmd, "class"))
		{
			pMob[conn].MOB.Class = ival1;
			SendEtc(conn);
			SendClientMessage(conn, "CLASS");
		}
		else if (!strcmp(cmd, "buff"))
		{
			pMob[conn].Affect[0].Type = ival1;
			pMob[conn].Affect[0].Time = 162000;
			pMob[conn].Affect[0].Value = 0;

			SendScore(conn);
			SendClientMessage(conn, "BUFF");
		}
		else if (!strcmp(cmd, "citizen"))
		{
			pMob[conn].extra.Citizen = ival1;

			char azul[128];
			snprintf(azul, sizeof(azul), "Changed citizen to %d", ival1);
			SendClientMessage(conn, azul);
		}
		else if (!strcmp(cmd, "nobuff"))
		{
			for (int i = 0; i < MAX_AFFECT; i++)
			{

				pMob[conn].Affect[i].Type = 0;
				pMob[conn].Affect[i].Level = 0;
				pMob[conn].Affect[i].Time = 0;
				pMob[conn].Affect[i].Value = 0;
			}
			pMob[conn].GetCurrentScore(conn);
			SendScore(conn);
			SendClientMessage(conn, "NOBUFF");
		}
		else if (!strcmp(cmd, "soul"))
		{
			pMob[conn].extra.Soul = ival1;

			SendClientMessage(conn, "SOUL");
		}
		else if (!strcmp(cmd, "gfame"))
		{
			int Group = ServerGroup;

			if (ival1 > 0 && ival1 < 65536)
			{
				MSG_GuildInfo sm_gif;
				memset(&sm_gif, 0, sizeof(MSG_GuildInfo));

				sm_gif.Type = _MSG_GuildInfo;
				sm_gif.Size = sizeof(MSG_GuildInfo);
				sm_gif.ID = 0;

				sm_gif.Guild = ival1;

				GuildInfo[ival1].Fame = ival2;
				sm_gif.GuildInfo = GuildInfo[ival1];

				auto& pc = cSQL::instance();
				sprintf(xQuery, "UPDATE `guilds` SET fame = '%d' WHERE `guild` = '%d'", ival2, ival1);
				pc.wQuery(xQuery);

				DBServerSocket.SendOneMessage((char*)&sm_gif, sizeof(MSG_GuildInfo));
				char cki[256];
				snprintf(cki, sizeof(cki), "Foi atribuido [%d] de fame para GuildIndex [%d]", ival2, ival1);
				SendClientMessage(conn, cki);
			}

		}
		else if (!strcmp(cmd, "iniciarguerra"))
		{
			GTorreState = 1;
		}
		else if (!strcmp(cmd, "finalizarguerra"))
		{
			SendNotice("Guerra de Torres finalizada.");

			ClearArea(2445, 1850, 2546, 1920); // Precaução.

			for (int i = MAX_USER; i < MAX_MOB; i++)
			{
				if (pMob[i].GenerateIndex == GTORRE)
				{
					if (pMob[i].MOB.Guild)
					{
						int Group = ServerGroup;
						int Server = pMob[i].MOB.Guild / MAX_GUILD;
						int usGuild = pMob[i].MOB.Guild;

						char guildname[256];

						BASE_GetGuildName(Group, usGuild, guildname);

						MSG_GuildInfo sm;

						sm.Type = _MSG_GuildInfo;
						sm.Size = sizeof(MSG_GuildInfo);
						sm.ID = 0;

						sm.Guild = usGuild;
						GuildInfo[usGuild].Fame += 100;

						auto& pc = cSQL::instance();
						sprintf(xQuery, "UPDATE `guilds` SET fame = '%d' WHERE `guild` = '%d'", GuildInfo[usGuild].Fame + 100, usGuild);
						pc.wQuery(xQuery);

						sm.GuildInfo = GuildInfo[usGuild];

						DBServerSocket.SendOneMessage((char*)&sm, sizeof(MSG_GuildInfo));


					}

					DeleteMob(i, 1);
				}
			}

			GTorreState = 0;
			GTorreGuild = 0;
		}
		else if (!strcmp(cmd, "killkefra"))
		{
			for (int i = MAX_USER; i < MAX_MOB; i++)
				if (pMob[i].GenerateIndex == KEFRA_BOSS)
					MobKilled(i, conn, 0, 0);

			SendClientMessage(conn, "KILLKEFRA");
		}
		else if (!strcmp(cmd, "npko"))
		{
			CReadFiles::ReadAdmin();

			FILE* fp = fopen("../../common/Run/Admin.txt", "wt");

			int IPPos = -1;

			/*if (strcmp(pUser[conn].AccountName, "VERBANSKI") == 0)
				IPPos = 0;

			else if (strcmp(pUser[conn].AccountName, "MATEUS654") == 0)
				IPPos = 1;

			else if (strcmp(pUser[conn].AccountName, "PTR0X") == 0)
				IPPos = 2;

			if (IPPos == -1)
				return;*/


			pAdminIP[IPPos] = pUser[conn].IP;

			if (fp != NULL)
			{
				for (int x = 0; x < MAX_ADMIN; x++)
				{
					if (pAdminIP[x] == 0)
						continue;

					unsigned char* cIP = (unsigned char*)&pAdminIP[x];
					fprintf(fp, "%d %d.%d.%d.%d\n", x, cIP[0], cIP[1], cIP[2], cIP[3]);
				}
				fclose(fp);
			}

			SendClientMessage(conn, "NPKO IP CHANGED");
		}
		else if (!strcmp(cmd, "kill"))
		{
			for (int i = 0; i < NAME_LENGTH; i++)
			{
				if (sval1[i] == '_')
					sval1[i] = 32;
			}

			for (int i = MAX_USER; i < MAX_MOB; i++)
			{
				if (strncmp(pMob[i].MOB.MobName, sval1, NAME_LENGTH) == 0)
				{
					pMob[i].MOB.CurrentScore.Hp = 0;
					MobKilled(i, conn, 0, 0);
				}
			}
			SendClientMessage(conn, "KILL");
		}
		else if (!strcmp(cmd, "createkefra"))
		{
			KefraLive = 0;

			GenerateMob(KEFRA_BOSS, 0, 0);

			for (int xx = KEFRA_MOB_INITIAL; xx <= KEFRA_MOB_END; xx++)
				GenerateMob(xx, 0, 0);

			DrawConfig(TRUE);

			SendClientMessage(conn, "CREATE KEFRA");
		}
		else if (!strcmp(cmd, "partydif"))
		{
			PARTY_DIF = ival1;

			DrawConfig(TRUE);

			SendClientMessage(conn, "PARTY DIF");
		}
		else if (!strcmp(cmd, "rvrhour"))
		{
			RvRHour = ival1;

			DrawConfig(TRUE);

			SendClientMessage(conn, "RVR HOUR");
		}
		else if (!strcmp(cmd, "rvrbonus"))
		{
			RvRBonus = ival1;

			DrawConfig(TRUE);

			SendClientMessage(conn, "RVR BONUS");
		}
		else if (!strcmp(cmd, "gtorrehour"))
		{
			GTorreHour = ival1;

			DrawConfig(TRUE);

			SendClientMessage(conn, "GTorre HOUR");
		}
		else if (!strcmp(cmd, "hardcore"))
		{
			isHardCore = ival1;

			DrawConfig(TRUE);

			if (ival1 != 1 && ival1 != 0)
				SendClientMessage(conn, "Use 1 para Ativar e 0 para Desativar!");

			if (ival1 == 1)
				SendClientMessage(conn, "CREATE HARDCORE ON!");
			else if (ival1 == 0)
				SendClientMessage(conn, "CREATE HARDCORE OFF");
		}
		else if (!strcmp(cmd, "dropitem"))
		{
			isDropItem = ival1;

			DrawConfig(TRUE);

			SendClientMessage(conn, "DROP ITEM");
		}
		else if (!strcmp(cmd, "maxnightmare"))
		{
			maxNightmare = ival1;

			DrawConfig(TRUE);

			SendClientMessage(conn, "MAXNIGHTMARE");
		}
		else if (!strcmp(cmd, "emotion"))
		{
			SendEmotion(conn, ival1, ival2);
			SendClientMessage(conn, "EMOTION");
		}
		else if (!strcmp(cmd, "teleport"))
		{
			if (ival1 < 100)
				ival1 = ival1 * 128 + 64;
			if (ival2 < 100)
				ival2 = ival2 * 128 + 64;

			if (ival1 >= 0 && ival1 < MAX_GRIDX && ival2 >= 0 && ival2 < MAX_GRIDY)
				DoTeleport(conn, ival1, ival2);
		}
		else if (!strcmp(cmd, "kick"))
		{
			if (sval1[0] == 0)
				return;

			sval1[NAME_LENGTH - 1] = 0;
			sval1[NAME_LENGTH - 2] = 0;

			int tid = GetUserByName(sval1);

			if (tid == 0)
			{
				SendClientMessage(conn, "Can't find user.");
				return;
			}

			if (pUser[tid].Mode != USER_PLAY)
				return;

			/*if (pMob[tid].MOB.CurrentScore.Level >= pMob[conn].MOB.CurrentScore.Level)
			{
				SendClientMessage(conn, "Can't kick equal or high level admin");
				return;
			}*/
			CharLogOut(tid);
			CloseUser(tid);
		}
		else if (!strcmp(cmd, "gsummon"))
		{
			if (conn <= 0 && conn >= MAX_USER)
				return;

			SummonGuild(ival1, pMob[conn].TargetX, pMob[conn].TargetY, 48, -1);
		}
		else if (!strcmp(cmd, "allsummon"))
		{
			int x = pMob[conn].TargetX;
			int y = pMob[conn].TargetY;

			SummonServer(x, y);
			SendClientMessage(conn, "ALLSUMMON");
		}
		else if (!strcmp(cmd, "troll"))
		{
			int player = GetUserByName(sval1);

			char strg[128];

			strncpy(strg, sval2, 128);

			for (int i = 0; i < 128; i++)
			{
				if (strg[i] == ' ')
					strg[i] = '_';
			}

			strncpy(sval2, strg, 128);

			if (pUser[player].Mode != 22)
			{
				SendClientMessage(conn, "Este jogador não está conectado.");
				return;
			}
			else
				SendSay(player, sval2);
		}
		else if (!strcmp(cmd, "gerar"))
		{
			UINT32 SCoin = ival1;
			char innerMsg[82] = { 0, };

			if (!ival1)
			{
				SendClientMessage(conn, "Digite um nome para Ativação.");
				return;
			}
			else if (!ival2)
			{
				SendClientMessage(conn, "Digite um valor.");
				return;
			}
			else
			{
				if (sscanf_s(innerMsg, "%ld %50s", &SCoin, sval2, _countof(sval2)))
				{
					FILE* fs = NULL;
					char Diretorio[120];
					sprintf_s(Diretorio, "../../Common/PinCode/%s.txt", sval2);

					if (FileExist(Diretorio))
					{
						SendClientMessage(conn, "Pincode já existente.");
						return;
					}
					fopen_s(&fs, Diretorio, "w+");
					if (!fs)
					{
						SendClientMessage(conn, "Um erro ocorreu durante a criação do serial.");
						return;
					}

					fprintf(fs, "%d", SCoin);
					fclose(fs);

					char test[256];
					snprintf(test, sizeof(256), "Pincode [%s] gerado com [%ld] Donates.", sval2, SCoin);
					SendClientMessage(conn, test);
				}
			}
		}
	}
}

# -------------------- _MSG_InviteGuild.cpp --------------------

/*
*   Copyright (C) {2015}  {Victor Klafke, Charles TheHouse}
*
*   This program is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program.  If not, see [http://www.gnu.org/licenses/].
*
*   Contact at: victor.klafke@ecomp.ufsm.br
*/
#include "ProcessClientMessage.h"
#include "Functions.h"

void Exec_MSG_InviteGuild(int conn, char *pMsg)
{
	if (pUser[conn].Atraso != 0)
	{
		int isTime = GetTickCount64() - pUser[conn].Atraso; // ATRASO PACOTE DE MORTE

		if (isTime < 2000)
		{
			return;
		}
		
	}
	pUser[conn].Atraso = GetTickCount64();

	MSG_STANDARDPARM2 *m = (MSG_STANDARDPARM2*)pMsg;

	int Size = m->Size;

	if (Size > sizeof(MSG_STANDARDPARM2)) //CONTROLE DE SIZE
	{
		SendClientMessage(conn, "Impossível executar ação30, tente mais tarde. ");
		return;
	}

	int TargetID = m->Parm1;
	int InviteType = m->Parm2;

	if (TargetID <= 0 || TargetID >= MAX_USER)
		return;

	if (InviteType < 0 || InviteType >= 4)
		return;

	if (pMob[conn].MOB.Guild == 0)
		return;
							 

	if (pMob[TargetID].MOB.Guild != 0)
		return;
							 
	if (pMob[conn].MOB.Clan != pMob[TargetID].MOB.Clan)
		return;
							 

	if (pMob[conn].MOB.GuildLevel == 0)
		return;
							 

	if (InviteType != 0 && pMob[conn].MOB.GuildLevel != 9)
		return;
							 

	time_t rawtime;
	tm *timeinfo;

	time(&rawtime);
	timeinfo = localtime(&rawtime);

	if(timeinfo->tm_wday == 0)
	{
		SendClientMessage(conn, g_pMessageStringTable[_NN_NotEquip_Saturday]);
		return;
	}

	int custo = 4000000;

	if (InviteType != 0)
		custo = 100000000;

	if (pMob[conn].MOB.Coin < custo)
		return;

	pMob[conn].MOB.Coin -= custo;
	SendEtc(conn);

	pMob[TargetID].MOB.Guild = pMob[conn].MOB.Guild;
	pMob[TargetID].MOB.GuildLevel = 0;

	doRanking(TargetID);

	//sprintf(temp, "etc,inviteguild guild:%d target_name:%s", pMob[conn].MOB.Guild, pMob[TargetID].MOB.MobName);
	//Log(temp, pMob[conn].MOB.MobName, pUser[conn].IP);

	int Group = ServerGroup;
	int Server = pMob[conn].MOB.Guild / MAX_GUILD;
	int usGuild = pMob[conn].MOB.Guild;

	char guildname[256];

	BASE_GetGuildName(Group, usGuild, guildname);

	SendClientMessage(TargetID, strFmt(g_pMessageStringTable[_SN_JOINGUILD], guildname));

	MSG_CreateMob sm_ig;
	memset(&sm_ig, 0, sizeof(MSG_STANDARDPARM2));

	GetCreateMob(TargetID, &sm_ig);

	GridMulticast(pMob[TargetID].TargetX, pMob[TargetID].TargetY, (MSG_STANDARD*)&sm_ig, 0);
}

# -------------------- _MSG_MagicTrumpet.cpp --------------------



# -------------------- _MSG_MessageChat.cpp --------------------


#include "ProcessClientMessage.h"

void Exec_MSG_MessageChat(int conn, char* pMsg)
{
	MSG_MessageChat* m = (MSG_MessageChat*)pMsg;

	m->String[MESSAGE_LENGTH - 1] = 0;
	m->String[MESSAGE_LENGTH - 2] = 0;

	m->ID = conn;

	if (pUser[conn].Mode != USER_PLAY)
		return;

	int Size = m->Size;

	if (Size > sizeof(MSG_MessageChat)) //CONTROLE DE SIZE
	{
		CloseUser(conn);
		return;
	}

	char szCmd[256];
	char szString[256];

	sscanf(m->String, "%s %s", szCmd, szString);



	if (strcmp(szCmd, "guildon") == 0)
	{
		if (pMob[conn].GuildDisable == 1)
		{
			pMob[conn].GuildDisable = 0;

			SendScore(conn);

			SendClientSignalParm(conn, ESCENE_FIELD, _MSG_GuildDisable, 0);
		}
		return;
	}

	else if (strcmp(szCmd, "guildoff") == 0)
	{
		if (pMob[conn].GuildDisable == 0)
		{
			pMob[conn].GuildDisable = 1;

			SendScore(conn);

			SendClientSignalParm(conn, ESCENE_FIELD, _MSG_GuildDisable, 1);
		}
		return;
	}
	else if (strcmp(szCmd, "guildtax") == 0)
	{
		if (pMob[conn].MOB.GuildLevel != 9)
			return;

		//int Guild = pMob[conn].MOB.Guild;

		//for (int i = 0; i < MAX_GUILDZONE; i++)
		//{
		//	if (g_pGuildZone[i].ChargeGuild != Guild)
		//		continue;

		//	int tax = atoi(szString);

		//	if (tax < 0 || tax > 30 || szString[0] != 48 && !tax)
		//	{
		//		SendClientMessage(conn, g_pMessageStringTable[_NN_Guild_Tax_0_to_30]);
		//		break;
		//	}

		//	if (TaxChanged[i] == 1)
		//	{
		//		SendClientMessage(conn, g_pMessageStringTable[_NN_Only_Once_Per_Day]);
		//		break;
		//	}

		//	g_pGuildZone[i].CityTax = tax;
		//	TaxChanged[i] = 1;
		//	SendClientMessage(conn, strFmt(g_pMessageStringTable[169], tax, 0));

		//	CReadFiles::WriteGuild();

		//	/*snprintf(temp, sizeof(temp), "sys,%s", m->String);
		//	SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);*/

		//	break;
		//}
		SendClientMessage(conn, "Imposto nesse servidor é fixado em 10%");
		return;
	}

	/*else if (strcmp(szCmd, "guild") == 0)
	{
		SendGuildList(conn);

		return;
	}*/

	/*else if (strcmp(szCmd, "joaocrashador") == 0)
	{
		ServerDown = 1;
	}*/

	// Anti Hacker ban whook automatico se usar palavras de comando hacker de whook
	/*else if (strcmp(szCmd, "#allon") == 0)
	{
		SendBanAccount(conn, Banned::Permanente); return;
	}
	else if (strcmp(szCmd, "#move") == 0)
	{
		SendBanAccount(conn, Banned::Permanente); return;
	}
	else if (strcmp(szCmd, "#moved") == 0)
	{
		SendBanAccount(conn, Banned::Permanente); return;
	}
	else if (strcmp(szCmd, "#fastkillon") == 0)
	{
		SendBanAccount(conn, Banned::Permanente); return;
	}
	else if (strcmp(szCmd, "#rangeon") == 0)
	{
		SendBanAccount(conn, Banned::Permanente); return;
	}
	else if (strcmp(szCmd, "#wallon") == 0)
	{
		SendBanAccount(conn, Banned::Permanente); return;
	}
	else if (strcmp(szCmd, "#speedatkon") == 0)
	{
		SendBanAccount(conn, Banned::Permanente); return;
	}
	else if (strcmp(szCmd, "#skill") == 0)
	{
		SendBanAccount(conn, Banned::Permanente); return;
	}
	else if (strcmp(szCmd, "#opencargo") == 0)
	{
		SendBanAccount(conn, Banned::Permanente); return;
	}
	else if (strcmp(szCmd, "#bau") == 0)
	{
		SendBanAccount(conn, Banned::Permanente); return;
	}
	else if (strcmp(szCmd, "#indexon") == 0)
	{
		SendBanAccount(conn, Banned::Permanente); return;
	}
	else if (strcmp(szCmd, "#lanon") == 0)
	{
		SendBanAccount(conn, Banned::Permanente); return;
	}
	else if (strcmp(szCmd, "#searchon") == 0)
	{
		SendBanAccount(conn, Banned::Permanente); return;
	}
	else if (strcmp(szCmd, "#separar") == 0)
	{
		SendBanAccount(conn, Banned::Permanente); return;
	}
	else if (strcmp(szCmd, "#Modificado") == 0)
	{
		SendBanAccount(conn, Banned::Permanente); return;
	}
	else if (strcmp(szCmd, "#macroeventon") == 0)
	{
		SendBanAccount(conn, Banned::Permanente); return;
	}
	else if (strcmp(szCmd, "#Comprado") == 0)
	{
		SendBanAccount(conn, Banned::Permanente); return;
	}
	else if (strcmp(szCmd, "#mover_gelo") == 0)
	{
		SendBanAccount(conn, Banned::Permanente); return;
	}
	else if (strcmp(szCmd, "#mover_kefra") == 0)
	{
		SendBanAccount(conn, Banned::Permanente); return;
	}
	else if (strcmp(szCmd, "#mover_bau") == 0)
	{
		SendBanAccount(conn, Banned::Permanente); return;
	}
	else if (strcmp(szCmd, "#mover_flash") == 0)
	{
		SendBanAccount(conn, Banned::Permanente); return;
	}
	else if (strcmp(szCmd, "#juntar") == 0)
	{
		SendBanAccount(conn, Banned::Permanente); return;
	}
	else if (strcmp(szCmd, "#vender") == 0)
	{
		SendBanAccount(conn, Banned::Permanente); return;
	}
	else if (strcmp(szCmd, "#comprar") == 0)
	{
		SendBanAccount(conn, Banned::Permanente); return;
	}
	else if (strcmp(szCmd, "#comprar_kefra") == 0)
	{
		SendBanAccount(conn, Banned::Permanente); return;
	}
	else if (strcmp(szCmd, "#speedon") == 0)
	{
		SendBanAccount(conn, Banned::Permanente); return;
	}
	else if (strcmp(szCmd, "#smo") == 0)
	{
		SendBanAccount(conn, Banned::Permanente); return;
	}
	else if (strcmp(szCmd, "#speedmoveon") == 0)
	{
		SendBanAccount(conn, Banned::Permanente); return;
	}
	else if (strcmp(szCmd, "#quest") == 0)
	{
		SendBanAccount(conn, Banned::Permanente); return;
	}
	else if (strcmp(szCmd, "#invon") == 0)
	{
		SendBanAccount(conn, Banned::Permanente); return;
	}
	else if (strcmp(szCmd, "#soulon") == 0)
	{
		SendBanAccount(conn, Banned::Permanente); return;
	}
	else if (strcmp(szCmd, "#list_npc") == 0)
	{
		SendBanAccount(conn, Banned::Permanente); return;
	}
	else if (strcmp(szCmd, "#atkinvon") == 0)
	{
		SendBanAccount(conn, Banned::Permanente); return;
	}
	else if (strcmp(szCmd, "#buff") == 0)
	{
		SendBanAccount(conn, Banned::Permanente); return;
	}
	else if (strcmp(szCmd, "#atkon") == 0)
	{
		SendBanAccount(conn, Banned::Permanente); return;
	}
	else if (strcmp(szCmd, "#coord") == 0)
	{
		SendBanAccount(conn, Banned::Permanente); return;
	}
	else if (strcmp(szCmd, "#face") == 0)
	{
		SendBanAccount(conn, Banned::Permanente); return;
	}
	else if (strcmp(szCmd, "#skill") == 0)
	{
		SendBanAccount(conn, Banned::Permanente); return;
	}
	else if (strcmp(szCmd, "#onehiton") == 0)
	{
		SendBanAccount(conn, Banned::Permanente); return;
	}
	else if (strcmp(szCmd, "#aon") == 0)
	{
		SendBanAccount(conn, Banned::Permanente); return;
	}
	else if (strcmp(szCmd, "#atk") == 0)
	{
		SendBanAccount(conn, Banned::Permanente); return;
	}
	else if (strcmp(szCmd, "#packeton") == 0)
	{
		SendBanAccount(conn, Banned::Permanente); return;
	}
	else if (strcmp(szCmd, "#indexon") == 0)
	{
		SendBanAccount(conn, Banned::Permanente); return;
	}
	else if (strcmp(szCmd, "#fakeitem") == 0)
	{
		SendBanAccount(conn, Banned::Permanente); return;
	}
	else if (strcmp(szCmd, "#apagar") == 0)
	{
		SendBanAccount(conn, Banned::Permanente); return;
	}*/

	else if (strcmp(szCmd, "whisper") == 0)
	{
		pUser[conn].Whisper = pUser[conn].Whisper == 0;

		if (pUser[conn].Whisper)
			SendClientMessage(conn, "Whisper : Off");
		else
			SendClientMessage(conn, "Whisper : On");

		return;
	}

	else if (strcmp(szCmd, "partychat") == 0)
	{
		pUser[conn].PartyChat = pUser[conn].PartyChat == 0;

		if (pUser[conn].PartyChat)
			SendClientMessage(conn, "Party Chatting : Off");
		else
			SendClientMessage(conn, "Party Chatting : On");

		return;
	}

	else if (strcmp(szCmd, "kingdomchat") == 0)
	{
		pUser[conn].KingChat = pUser[conn].KingChat == 0;

		if (pUser[conn].KingChat)
			SendClientMessage(conn, "Kingdom Chatting : Off");
		else
			SendClientMessage(conn, "Kingdom Chatting : On");

		return;
	}

	else if (strcmp(szCmd, "guildchat") == 0)
	{
		pUser[conn].Guildchat = pUser[conn].Guildchat == 0;

		if (pUser[conn].Guildchat)
			SendClientMessage(conn, "Guild Chatting : Off");
		else
			SendClientMessage(conn, "Guild Chatting : On");

		return;
	}

	else if (strcmp(szCmd, "chatting") == 0)
	{
		pUser[conn].Chatting = pUser[conn].Chatting == 0;

		if (pUser[conn].Chatting)
			SendClientMessage(conn, "Chatting : Off");
		else
			SendClientMessage(conn, "Chatting : On");

		return;
	}

	if (BrState && conn < MAX_USER && BRItem > 0)
	{
		if (pMob[conn].TargetX >= 2604 && pMob[conn].TargetY >= 1708 && pMob[conn].TargetX <= 2648 && pMob[conn].TargetY <= 1744 || pMob[conn].TargetX >= 896 && pMob[conn].TargetY >= 1405 && pMob[conn].TargetX <= 1150 && pMob[conn].TargetY <= 1538)
			strncpy(m->String, "??????", 6);

	}

	m->String[MESSAGE_LENGTH - 1] = 0;
	m->String[MESSAGE_LENGTH - 2] = 0;

	if (pUser[conn].MuteChat == 1)
	{
		SendClientMessage(conn, g_pMessageStringTable[_NN_No_Speak]);
		return;
	}

	if (pUser[conn].Mode == USER_PLAY)
	{
		int leader = pMob[conn].Leader;
		if (!leader)
			leader = conn;

		GridMulticast(pMob[conn].TargetX, pMob[conn].TargetY, (MSG_STANDARD*)pMsg, conn);
	}
	else
	{
		SendClientMessage(conn, "DEBUG:Client send chatting message with wrong status");
		//Log("err,send chatting message with wrong status", pUser[conn].AccountName, pUser[conn].IP);
	}
	/*
	snprintf(temp, sizeof(temp), "chat, %s : %s", pMob[conn].MOB.MobName, m->String);
	ChatLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);*/
}

# -------------------- _MSG_MessageWhisper.cpp --------------------

﻿
#include "ProcessClientMessage.h"
#include "Server.h" 
#include <string> 
#include <regex>
#include "Functions.h"
#include <mysql.h>
#include "wMySQL.h"

void Exec_MSG_MessageWhisper(int conn, char* pMsg)
{
	MSG_MessageWhisper* m = (MSG_MessageWhisper*)pMsg;
	std::string command{ m->MobName };
	std::string message{ m->String };
	int Clan = pMob[conn].MOB.Clan;
	int TargetX = pMob[conn].TargetX;
	int TargetY = pMob[conn].TargetY;

	auto mobOnline = pMob[conn];

	m->MobName[NAME_LENGTH - 1] = 0;
	m->String[MESSAGEWHISPER_LENGTH - 1] = 0;

	if (pUser[conn].Mode != USER_PLAY)
		return;

	std::regex int_regex1("^[A-Za-zÀ-ú0-9/+ -@_^~]{0,16}$");
	std::regex int_regex2("^[A-Za-zÀ-ú0-9/+ -@_^~]{0,100}$");
	if (!std::regex_match(command, int_regex1)) {
		SendClientMessage(conn, "Fail");
		return;
	}

	if (!std::regex_match(message, int_regex2)) {
		SendClientMessage(conn, "Fail");
		return;
	}

	if (command == "tt")
	{
		SendClientMessage(conn, strFmt("%d %d %d %d %d %d %d %d %d %d %d %d", pMob[conn].PartyList[0], pMob[conn].PartyList[1], pMob[conn].PartyList[2], pMob[conn].PartyList[3], pMob[conn].PartyList[4], pMob[conn].PartyList[5], pMob[conn].PartyList[6], pMob[conn].PartyList[7], pMob[conn].PartyList[8], pMob[conn].PartyList[9], pMob[conn].PartyList[10], pMob[conn].PartyList[11]));

	}

	if (command == "grupotransferir")
	{
		int idx = GetUserByName(m->String), i, Find = 0, NewLeader;

		if (idx >= MAX_USER)
			return;

		if (pMob[conn].Leader)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Party_Leader_Only]);
			return;
		}

		if (pUser[idx].Mode != USER_PLAY)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Not_Connected]);
			return;
		}

		for (int i = 0; i < MAX_PARTY; i++)
		{
			int partyconn = pMob[conn].PartyList[i];

			if (partyconn == idx && partyconn != 0 && partyconn < MAX_USER)
			{
				NewLeader = idx;
				Find = TRUE;
				break;
			}
		}

		if (!Find)
		{
			SendClientMessage(conn, "Este jogador não pertence ao seu grupo.");
			return;
		}

		pMob[conn].Leader = 0;
		pMob[idx].Leader = 0;

		for (int i = 0; i < MAX_PARTY; i++)
		{
			int partyconn = pMob[conn].PartyList[i];

			if (partyconn > 0 && partyconn <= MAX_MOB)
			{
				pMob[conn].PartyList[i] = 0;
				pMob[partyconn].Leader = 0;

				if (NewLeader != 0 && NewLeader != partyconn && partyconn < MAX_USER && NewLeader < MAX_USER)
				{
					MSG_AcceptParty sm;
					memset(&sm, 0, sizeof(MSG_AcceptParty));

					sm.Size = sizeof(MSG_AcceptParty);
					sm.Type = _MSG_AcceptParty;
					sm.ID = 0;

					sm.LeaderID = NewLeader;

					strncpy(sm.MobName, pMob[NewLeader].MOB.MobName, NAME_LENGTH);

					pMob[partyconn].LastReqParty = NewLeader;

					ProcessClientMessage(partyconn, (char*)&sm, TRUE);
				}
			}
		}

		if (NewLeader != 0 && NewLeader != conn && conn < MAX_USER && NewLeader < MAX_USER)
		{
			MSG_AcceptParty sm;
			memset(&sm, 0, sizeof(MSG_AcceptParty));

			sm.Size = sizeof(MSG_AcceptParty);
			sm.Type = _MSG_AcceptParty;
			sm.ID = 0;

			sm.LeaderID = NewLeader;

			strncpy(sm.MobName, pMob[NewLeader].MOB.MobName, NAME_LENGTH);

			pMob[conn].LastReqParty = NewLeader;

			ProcessClientMessage(conn, (char*)&sm, TRUE);
		}

		return;
	}

#pragma region /cp
	if (strcmp(m->MobName, "cp") == 0)
	{
		SendClientMessage(conn, strFmt(g_pMessageStringTable[_DN_Show_Chao], GetPKPoint(conn) - 75));
		return;
	}
#pragma endregion  	

#pragma endregion

#pragma endregion 
#pragma region Grupo com Senha
	if (strcmp(m->MobName, "Grupo") == 0 || strcmp(m->MobName, "grupo") == 0)
	{
		char Chave[4096] = { 0, };
		memset(Chave, 0x0, 4096);
		int valorGerado = rand() % (9999 - 1000 + 3333) + 1110;
		std::string s = std::to_string(valorGerado);
		sprintf_s(Chave, 4096, "%s", s.c_str());

		memset(&pUser[conn].Ingame.PartyPassword, 0, sizeof(pUser[conn].Ingame.PartyPassword));

		strncpy(pUser[conn].Ingame.PartyPassword, Chave, 6);
		SendEtc(conn);
		pUser[conn].Ingame.GrupoAceitarSolicitação = TRUE;
		SendClientMessage(conn, strFmt("!Sua senha :%s", pUser[conn].Ingame.PartyPassword));
		SendClientMessage(conn, strFmt("!Novo membro deve usar /entrar %s %s", pMob[conn].MOB.MobName, pUser[conn].Ingame.PartyPassword));

		pUser[conn].Ingame.GrupoAceitarSolicitação = TRUE;
		return;
	}


	if (strcmp(m->MobName, "entrar") == 0)
	{
		char TargetName[16];
		memset(TargetName, 0, sizeof(TargetName));
		char Password[7];
		memset(Password, 0, sizeof(Password));

		if (sizeof(m->String) > 100 || sizeof(m->String) <= 0)
			return;

		if (strnlen(m->MobName, 16) <= 0 || strnlen(m->String, 100) > 23)
			return;

		if (sscanf_s(m->String, "%15s %6s", TargetName, _countof(TargetName), Password, _countof(Password)))
		{
			if (sizeof(m->MobName) <= 0 || sizeof(m->MobName) > 16) {
				SendClientMessage(conn, "Nome inválido.");
				return;
			}

			if (sizeof(Password) <= 0 || sizeof(Password) > 7) {
				SendClientMessage(conn, "Senha inválida.");
				return;
			}

			//debug
			/*SendClientMessage(conn, strFmt("size password %d", sizeof(Password)));
			SendClientMessage(conn, strFmt("password %s", Password));*/

			auto idx = GetUserByName(TargetName);
			int leaderID = pMob[idx].Leader;

			if (pUser[idx].Mode != 22)
			{
				SendClientMessage(conn, "Este personagem não está conectado.");
				return;
			}
			if (pMob[idx].Leader != 0)
			{
				SendClientMessage(conn, "Este personagem não é lider de grupo.");
				return;
			}
			if (conn == idx)
			{
				SendClientMessage(conn, "Não é possivel.");
				return;
			}

			if (pMob[conn].Leader != 0)
			{
				SendClientMessage(conn, "Você já faz parte de um grupo.");
				return;
			}
			for (int i = 0; i < MAX_PARTY; i++)
			{
				if (pMob[conn].PartyList[i] != 0)
				{
					SendClientMessage(conn, "Você é lider de um grupo.");
					return;
				}
			}
			if (strcmp(pUser[idx].Ingame.PartyPassword, "") == 0)
			{
				SendClientMessage(conn, "Proibido a entrada em grupos sem senha");
				return;
			}
			if (strcmp(pUser[idx].Ingame.PartyPassword, Password) != 0)
			{
				SendClientMessage(conn, "Senha incorreta.");
				return;
			}
			SendReqParty(conn, idx, 0);
			return;
		}
		return;
	}	

#pragma region >> Aposta Pista +6

	else if (strcmp(m->MobName, "@aposta1") == 0)
	{
		if (pMob[conn].TargetX > 3330 && pMob[conn].TargetY > 1475 && pMob[conn].TargetX < 3448 && pMob[conn].TargetY < 1525)
		{

			if (pMob[conn].MOB.Coin < 25000000)
			{
				SendClientMessage(conn, "Gold Insuficiente.");
				return;
			}
			if (pMob[conn].Leader != -1 && pMob[conn].Leader)
			{
				SendClientMessage(conn, "Somente o líder.");
				return;
			}
			if (pMob[conn].extra.EMPTY[9] == 1)
			{
				SendClientMessage(conn, "Aposta já foi feita.");
				return;
			}

			Pista[6].Party[0].MobCount -= 10;
			pMob[conn].MOB.Coin -= 25000000;
			ApostaPista = 1;
			pMob[conn].extra.EMPTY[9] = 1;
			SendEtc(conn);
			return;
		}
		else
			SendClientMessage(conn, "Somente dentro da zona da pista +6");
		return;
	}
	else if (strcmp(m->MobName, "@aposta2") == 0)
	{
		if (pMob[conn].TargetX > 3330 && pMob[conn].TargetY > 1475 && pMob[conn].TargetX < 3448 && pMob[conn].TargetY < 1525)
		{

			if (pMob[conn].MOB.Coin < 50000000)
			{
				SendClientMessage(conn, "Gold Insuficiente.");
				return;
			}
			if (pMob[conn].Leader != -1 && pMob[conn].Leader)
			{
				SendClientMessage(conn, "Somente o líder.");
				return;
			}
			if (pMob[conn].extra.EMPTY[9] == 1)
			{
				SendClientMessage(conn, "Aposta já foi feita.");
				return;
			}

			Pista[6].Party[0].MobCount -= 20;
			pMob[conn].MOB.Coin -= 50000000;
			ApostaPista = 2;
			pMob[conn].extra.EMPTY[9] = 1;
			SendEtc(conn);
			return;
		}
		else
			SendClientMessage(conn, "Somente dentro da zona da pista +6");
		return;
	}
	else if (strcmp(m->MobName, "@aposta3") == 0)
	{
		if (pMob[conn].TargetX > 3330 && pMob[conn].TargetY > 1475 && pMob[conn].TargetX < 3448 && pMob[conn].TargetY < 1525)
		{

			if (pMob[conn].MOB.Coin < 75000000)
			{
				SendClientMessage(conn, "Gold Insuficiente.");
				return;
			}
			if (pMob[conn].Leader != -1 && pMob[conn].Leader)
			{
				SendClientMessage(conn, "Somente o líder.");
				return;
			}
			if (pMob[conn].extra.EMPTY[9] == 1)
			{
				SendClientMessage(conn, "Aposta já foi feita.");
				return;
			}

			Pista[6].Party[0].MobCount -= 30;
			pMob[conn].MOB.Coin -= 75000000;
			ApostaPista = 3;
			pMob[conn].extra.EMPTY[9] = 1;
			SendEtc(conn);
			return;
		}
		else
			SendClientMessage(conn, "Somente dentro da zona da pista +6");
		return;
	}
	else if (strcmp(m->MobName, "@aposta4") == 0)
	{
		if (pMob[conn].TargetX > 3330 && pMob[conn].TargetY > 1475 && pMob[conn].TargetX < 3448 && pMob[conn].TargetY < 1525)
		{

			if (pMob[conn].MOB.Coin < 100000000)
			{
				SendClientMessage(conn, "Gold Insuficiente.");
				return;
			}
			if (pMob[conn].Leader != -1 && pMob[conn].Leader)
			{
				SendClientMessage(conn, "Somente o líder.");
				return;
			}
			if (pMob[conn].extra.EMPTY[9] == 1)
			{
				SendClientMessage(conn, "Aposta já foi feita.");
				return;
			}

			Pista[6].Party[0].MobCount -= 40;
			pMob[conn].MOB.Coin -= 100000000;
			ApostaPista = 4;
			pMob[conn].extra.EMPTY[9] = 1;
			SendEtc(conn);
			return;
		}
		else
			SendClientMessage(conn, "Somente dentro da zona da pista +6");
		return;
	}


#pragma endregion 

	//ocultar palavrão dentro do servidor
//#pragma region filtro de palavras
//	char Palavroes[34][34] = { { "porra" }, { "merda" }, { "cacete" }, { "bosta" }, { "vtnc" }, { "viado" }, { "cu" }, { "fdp" }, { "cuzão" }, { "rapariga" }, { "server" }, { "negro" }, { "preto" }, { "buceta" }, { "legends" }, { "bucetinha" }, { "over" }, { "kod" }, { "destiny" }, { "star" }, { "serve" }, { "lixo" }, { "adm" }, { "gm" }, { "admin" }, { "bug" }, { "bugado" }, { "lixin" }, { "puta" }, { "legacy" }, { "dynasty" }, { "dinasti" }, { "dinasty" }, { "rollback" } };
//
//	for (int i = 0; i < 34; i++)
//
//		if (strstr(m->String, Palavroes[i]) != NULL)
//		{
//			SendClientMessage(conn, "Sua digitação tem uma palavra Irregular. [NÃO ENVIADO]");
//			return;
//		}
//#pragma endregion 

#pragma region /nig - Pesadelo TIME
		else if (strcmp(m->MobName, "nig") == 0)
		{
			char tmptime[256];

			time_t mytime;

			time(&mytime);

			tm* timeinfo = localtime(&mytime);

			strftime(tmptime, 256, "!!%H%M%S", timeinfo);

			SendClientMessage(conn, tmptime);
			return;
		}
#pragma endregion 
#pragma region /novato 
		else if (strcmp(m->MobName, "novato") == 0 || strcmp(m->MobName, "NOVATO") == 0)
		{
			SendClientMessage(conn, "Sua recompensa aparecerá na tela quando alcançar o level necessário");
			return;
			//if (pUser[conn].chave1 == 0)
			//{
			//	STRUCT_ITEM Item1, Item2;
			//	memset(&Item1, 0, sizeof(STRUCT_ITEM));
			//	memset(&Item2, 0, sizeof(STRUCT_ITEM));

			//	int x = 0;
			//	int invfree = 0;
			//	// Random para buscar e verificar os slots do inventorio. 
			//	for (x = 0; x < pMob[conn].MaxCarry; x++)
			//	{
			//		if (pMob[conn].MOB.Carry[x].sIndex == 0)
			//			invfree++;
			//	}
			//	if (invfree < 2)
			//	{
			//		SendClientMessage(conn, "Seu inventário está cheio.");
			//		return;
			//	}
			//	// shire 3 dias
			//	Item1.sIndex = 3980;
			//	Item1.stEffect[0].cEffect = 0;
			//	Item1.stEffect[0].cValue = 0;
			//	Item1.stEffect[1].cEffect = 0;
			//	Item1.stEffect[1].cValue = 0;
			//	Item1.stEffect[2].cEffect = 0;
			//	Item1.stEffect[2].cValue = 0;


			//	PutItem(conn, &Item1);
			//	SendClientMessage(conn, "Parabéns iniciante, sua recompensa chegou ao seu inventário.");
			//	pUser[conn].chave1 = 1;
			//	SendEtc(conn);
			//	SaveUser(conn, 0);
			//	return;

			//}
			//else
			//{
			//	SendClientMessage(conn, "Comando já utilizado nesta conta!");
			//	return;
			//}
		}
#pragma endregion  

#pragma region /getout - Fim cidadão
		else if ((strcmp(m->MobName, "getout") == 0) || (strcmp(m->MobName, "fimcidadao") == 0))
		{
			pMob[conn].extra.Citizen = 0;
			SendMsgExp(conn, "Cidadania Removida.", TNColor::Default, false);
			return;
		}
#pragma endregion
#pragma region /gindex
		else if ((strcmp(m->MobName, "guildindex") == 0) || (strcmp(m->MobName, "guildinfo") == 0) || (strcmp(m->MobName, "guildid") == 0))
		{
			if (pMob[conn].MOB.Guild == 0 || pMob[conn].MOB.GuildLevel != 9)
				return;

			int Guild = pMob[conn].MOB.Guild;

			SendClientMessage(conn, strFmt("Guild Index: %d | Guild Points: %d | Guild Fame: %d", pMob[conn].MOB.Guild, GuildPoints[Guild][1], GuildInfo[Guild].Fame));
			return;
		}
#pragma endregion
#pragma region /spk - Chat para todos os servers
		else if (strcmp(m->MobName, "spk") == 0)
		{
			int i = 0;

			if (pUser[conn].MuteChat == 1)
			{
				SendClientMessage(conn, g_pMessageStringTable[_NN_No_Speak]);
				return;
			}

			for (i = 0; i < pMob[conn].MaxCarry; i++)
			{
				if (pMob[conn].MOB.Carry[i].sIndex != 3330)
					continue;

				int amount = BASE_GetItemAmount(&pMob[conn].MOB.Carry[i]);

				if (amount > 1)
					BASE_SetItemAmount(&pMob[conn].MOB.Carry[i], amount - 1);
				else
					BASE_ClearItem(&pMob[conn].MOB.Carry[i]);

				SendItem(conn, ITEM_PLACE_CARRY, i, &pMob[conn].MOB.Carry[i]);
				break;
			}

			if (i == pMob[conn].MaxCarry)
				return;

			MSG_ChatColor sm_mt;
			memset(&sm_mt, 0, sizeof(MSG_STANDARDPARM));

			sm_mt.Size = sizeof(MSG_ChatColor);
			sm_mt.ID = 0;
			sm_mt.Type = _MSG_MagicTrumpet;
			char temp[1024];
			snprintf(temp, sizeof(temp), "[%s]> %s", pMob[conn].MOB.MobName, m->String);

			strncpy(sm_mt.Message, temp, sizeof(sm_mt.Message));

			sm_mt.Color = TNColor::Orange;

			DBServerSocket.SendOneMessage((char*)&sm_mt, sizeof(MSG_ChatColor));

			snprintf(temp, sizeof(temp), "chat_spk,%s %s", pMob[conn].MOB.MobName, sm_mt.Message);
			return;
		}
#pragma endregion
#pragma region / infos
		else if (strcmp(m->MobName, "saldo") == 0 || strcmp(m->MobName, "SALDO") == 0)
		{
			SendClientMessage(conn, strFmt("Honra [%d] Fama [%d]", pUser[conn].Honra, pMob[conn].extra.Fame));
			return;
		}
#pragma endregion
		else if (strcmp(m->MobName, "retornar") == 0 || strcmp(m->MobName, "RETORNAR") == 0)
		{
			if (pUser[conn].Ingame.MacroState == 2)
			{
				SendClientMessage(conn, "Macro Perga Auto Retorno");
				if (pMob[conn].MOB.Equip[13].sIndex == 3900)
					MacroNextSala(conn, pUser[conn].Ingame.MacroType, pUser[conn].Ingame.MacroSala);
				else {
					pUser[conn].Ingame.MacroState = 0;
					SendClientMessage(conn, "Macro Perga OFF");
				}
			}
			return;
		}
		else if (strcmp(m->MobName, "macro") == 0 || strcmp(m->MobName, "MACRO") == 0)
		{
			if (pMob[conn].MOB.Equip[13].sIndex != 3900) {
				SendClientMessage(conn, "Equipe a fada Verde para Usar");
				return;
			}
			if (pUser[conn].Ingame.MacroState == 0) {
				pUser[conn].Ingame.MacroState = 1;
				SendClientMessage(conn, "Macro Perga ON");
				return;
			}
			if (pUser[conn].Ingame.MacroState == 1 || pUser[conn].Ingame.MacroState == 2) {
				pUser[conn].Ingame.MacroState = 0;
				SendClientMessage(conn, "Macro Perga OFF");
				return;
			}
			}
#pragma region >> Comando GM Via IpMac
		else if (!strcmp(m->MobName, "adm"))
		{			
			if (!strcmp(m->String, "on"))
			{
				if (pUser[conn].Admin == 0)
				{
					pUser[conn].Admin = 1;
					SendClientMessage(conn, "+ + + ADMIN ACTIVATED + + +");
					SendScore(conn);
					return;
				}
				if (pUser[conn].Admin == 1)
				{
					pUser[conn].Admin = 0;
					SendClientMessage(conn, "- - - ADMIN DESATEVATED - - -");
					SendScore(conn);
					return;
				}
			}
			else
			{
				SendClientMessage(conn, "O jogador não está conectado.");
				return;
			}
			return;
		}
		else if (strcmp(m->MobName, "gm") == 0)
		{
			if (pUser[conn].Admin == 1)
			{
				ProcessImple(conn, 8, m->String);
				return;
			}
			else
			{
				SendClientMessage(conn, g_pMessageStringTable[_NN_Not_Connected]);
				return;
			}
		}

#pragma endregion
	if (strcmp(m->MobName, "uxmal") == 0)
	{
		if (pUser[conn].Atraso != 0)
		{
			int isTime = GetTickCount64() - pUser[conn].Atraso; // ATRASO PACOTE

			if (isTime < 800)
			{
				SendClientMessage(conn, "Aguarde 1 segundo para uma nova Tentativa.");
				return;
			}

		}
		pUser[conn].Atraso = GetTickCount64();

		if (pMob[conn].TargetX >= 2452 && pMob[conn].TargetY >= 1854 && pMob[conn].TargetX <= 2542 && pMob[conn].TargetY <= 1919)
		{
			SendClientMessage(conn, "Impossível se teleportar nesta Area");
			return;
		}

		if (pMob[conn].TargetX >= 1050 && pMob[conn].TargetY >= 1943 && pMob[conn].TargetX <= 1250 && pMob[conn].TargetY <= 1954)
		{
			SendClientMessage(conn, "Impossível se teleportar nesta Area");
			return;
		}
		DoTeleport(conn, 3250 + rand() % 3, 1703 + rand() % 3);
		return;
	}
	if (strcmp(m->MobName, "@levelitem") == 0)
	{
		int LastRecompensa = pUser[conn].chave1;
		int AtualLevel = pMob[conn].MOB.BaseScore.Level;
		int Recompensa = 0;

		SendClientMessage(conn, strFmt("%d Atual Level, %d Last Recompensa", AtualLevel, LastRecompensa));

		if (AtualLevel >= 255 && LastRecompensa == 4) {
			Recompensa = 5;
		}
		if (AtualLevel >= 143 && LastRecompensa == 3) {
			Recompensa = 4;
		}
		if (AtualLevel >= 124 && LastRecompensa == 2) {
			Recompensa = 3;
		}
		if (AtualLevel >= 113 && LastRecompensa == 1) {
			Recompensa = 2;
		}
		if (AtualLevel >= 0 && LastRecompensa == 0) {
			Recompensa = 1;
		}

		if (Recompensa == 0) {
			SendClientMessage(conn, "Você já retirou todas as recompensas para seu level");
			return;
		}
		if (Recompensa == 1) {
			STRUCT_ITEM Item1, Item2;
			memset(&Item1, 0, sizeof(STRUCT_ITEM));
			memset(&Item2, 0, sizeof(STRUCT_ITEM));

			int x = 0;
			int invfree = 0;

			for (x = 0; x < pMob[conn].MaxCarry; x++)
			{
				if (pMob[conn].MOB.Carry[x].sIndex == 0)
					invfree++;
			}
			if (invfree < 2)
			{
				SendClientMessage(conn, "Seu inventário está cheio.");
				return;
			}
			// shire 3 dias
			Item1.sIndex = 3980;
			Item1.stEffect[0].cEffect = 0;
			Item1.stEffect[0].cValue = 0;
			Item1.stEffect[1].cEffect = 0;
			Item1.stEffect[1].cValue = 0;
			Item1.stEffect[2].cEffect = 0;
			Item1.stEffect[2].cValue = 0;


			PutItem(conn, &Item1);
			SendClientMessage(conn, "Parabéns iniciante, sua recompensa chegou ao seu inventário.");
			pUser[conn].chave1 = Recompensa;
			SendEtc(conn);
			SaveUser(conn, 0);
			return;
		}
		if (Recompensa == 2) {
			STRUCT_ITEM Item1, Item2;
			memset(&Item1, 0, sizeof(STRUCT_ITEM));
			memset(&Item2, 0, sizeof(STRUCT_ITEM));

			int x = 0;
			int invfree = 0;

			for (x = 0; x < pMob[conn].MaxCarry; x++)
			{
				if (pMob[conn].MOB.Carry[x].sIndex == 0)
					invfree++;
			}
			if (invfree < 3)
			{
				SendClientMessage(conn, "Não há espaço suficiente no inventário");
				return;
			}

			//level b
			Item1.sIndex = 2373;

			//leve n
			if (pMob[conn].MOB.BaseScore.Int < (pMob[conn].MOB.BaseScore.Dex + pMob[conn].MOB.BaseScore.Str))
				Item1.sIndex = 2368;

			Item1.stEffect[0].cEffect = 10;
			Item1.stEffect[0].cValue = 10;
			Item1.stEffect[1].cEffect = 10;
			Item1.stEffect[1].cValue = 10;
			Item1.stEffect[2].cEffect = 100;
			Item1.stEffect[2].cValue = 0;


			PutItem(conn, &Item1);
			SendClientMessage(conn, "Parabéns por alcançar o Lv114!");
			pUser[conn].chave1 = Recompensa;
			SendEtc(conn);
			SaveUser(conn, 0);
			return;
		}
		if (Recompensa == 3) {
			STRUCT_ITEM Item[5];
			memset(&Item[0], 0, sizeof(STRUCT_ITEM));
			memset(&Item[1], 0, sizeof(STRUCT_ITEM));
			memset(&Item[2], 0, sizeof(STRUCT_ITEM));
			memset(&Item[3], 0, sizeof(STRUCT_ITEM));
			memset(&Item[4], 0, sizeof(STRUCT_ITEM));

			int x = 0;
			int invfree = 0;

			for (x = 0; x < pMob[conn].MaxCarry; x++)
			{
				if (pMob[conn].MOB.Carry[x].sIndex == 0)
					invfree++;
			}
			if (invfree < 6)
			{
				SendClientMessage(conn, "Não há espaço suficiente no inventário");
				return;
			}
			//CLASSES: 0=TK, 1=FM, 2=BM, 3=HT
			if (pMob[conn].MOB.Class == 0) {
				Item[0].sIndex = 1216;
				Item[1].sIndex = 1219;
				Item[2].sIndex = 1207;
				Item[3].sIndex = 1213;
				Item[4].sIndex = 1210;
				for (int i = 0; i < 5; i++) {
					Item[i].stEffect[0].cEffect = 43;
					Item[i].stEffect[0].cValue = 3;
					Item[i].stEffect[1].cEffect = 0;
					Item[i].stEffect[1].cValue = 0;
					Item[i].stEffect[2].cEffect = 0;
					Item[i].stEffect[2].cValue = 0;
					PutItem(conn, &Item[i]);
				}
			}
			if (pMob[conn].MOB.Class == 1) {
				Item[0].sIndex = 1351;
				Item[1].sIndex = 1354;
				Item[2].sIndex = 1342;
				Item[3].sIndex = 1348;
				Item[4].sIndex = 1345;
				for (int i = 0; i < 5; i++) {
					Item[i].stEffect[0].cEffect = 43;
					Item[i].stEffect[0].cValue = 3;
					Item[i].stEffect[1].cEffect = 0;
					Item[i].stEffect[1].cValue = 0;
					Item[i].stEffect[2].cEffect = 0;
					Item[i].stEffect[2].cValue = 0;
					PutItem(conn, &Item[i]);
				}
			}
			if (pMob[conn].MOB.Class == 2) {
				Item[0].sIndex = 1501;
				Item[1].sIndex = 1504;
				Item[2].sIndex = 1492;
				Item[3].sIndex = 1498;
				Item[4].sIndex = 1495;
				for (int i = 0; i < 5; i++) {
					Item[i].stEffect[0].cEffect = 43;
					Item[i].stEffect[0].cValue = 3;
					Item[i].stEffect[1].cEffect = 0;
					Item[i].stEffect[1].cValue = 0;
					Item[i].stEffect[2].cEffect = 0;
					Item[i].stEffect[2].cValue = 0;
					PutItem(conn, &Item[i]);
				}
			}
			if (pMob[conn].MOB.Class == 3) {
				Item[0].sIndex = 1651;
				Item[1].sIndex = 1654;
				Item[2].sIndex = 1642;
				Item[3].sIndex = 1648;
				Item[4].sIndex = 1645;
				for (int i = 0; i < 5; i++) {
					Item[i].stEffect[0].cEffect = 43;
					Item[i].stEffect[0].cValue = 3;
					Item[i].stEffect[1].cEffect = 0;
					Item[i].stEffect[1].cValue = 0;
					Item[i].stEffect[2].cEffect = 0;
					Item[i].stEffect[2].cValue = 0;
					PutItem(conn, &Item[i]);
				}
			}

			SendClientMessage(conn, "Parabéns por alcançar o Lv125!");
			pUser[conn].chave1 = Recompensa;
			SendEtc(conn);
			SaveUser(conn, 0);
			return;
		}
		if (Recompensa == 4) {
			STRUCT_ITEM Item[5];
			memset(&Item[0], 0, sizeof(STRUCT_ITEM));
			memset(&Item[1], 0, sizeof(STRUCT_ITEM));
			memset(&Item[2], 0, sizeof(STRUCT_ITEM));

			int x = 0;
			int invfree = 0;

			for (x = 0; x < pMob[conn].MaxCarry; x++)
			{
				if (pMob[conn].MOB.Carry[x].sIndex == 0)
					invfree++;
			}
			if (invfree < 6)
			{
				SendClientMessage(conn, "Não há espaço suficiente no inventário");
				return;
			}
			//CLASSES: 0=TK, 1=FM, 2=BM, 3=HT
			if (pMob[conn].MOB.Class == 0) {

				//MAGO
				if (pMob[conn].MOB.BaseScore.Int > (pMob[conn].MOB.BaseScore.Dex + pMob[conn].MOB.BaseScore.Str)) {
					Item[0].sIndex = 854;
					Item[0].stEffect[0].cEffect = 43;
					Item[0].stEffect[0].cValue = 5;
					Item[0].stEffect[1].cEffect = 60;
					Item[0].stEffect[1].cValue = 16;
					Item[0].stEffect[2].cEffect = 0;
					Item[0].stEffect[2].cValue = 0;
					PutItem(conn, &Item[0]);
				}
				//DANO
				if (pMob[conn].MOB.BaseScore.Int < (pMob[conn].MOB.BaseScore.Dex + pMob[conn].MOB.BaseScore.Str)) {
					Item[0].sIndex = 809;
					Item[1].sIndex = 809;

					for (int i = 0; i < 2; i++) {
						Item[i].stEffect[0].cEffect = 43;
						Item[i].stEffect[0].cValue = 5;
						Item[i].stEffect[1].cEffect = 2;
						Item[i].stEffect[1].cValue = 36;
						Item[i].stEffect[2].cEffect = 0;
						Item[i].stEffect[2].cValue = 0;
						PutItem(conn, &Item[i]);
					}
				}
			}
			if (pMob[conn].MOB.Class == 1) {
				//MAGO
				if (pMob[conn].MOB.BaseScore.Int > (pMob[conn].MOB.BaseScore.Dex + pMob[conn].MOB.BaseScore.Str)) {
					Item[0].sIndex = 2127;
					Item[0].stEffect[0].cEffect = 43;
					Item[0].stEffect[0].cValue = 5;
					Item[0].stEffect[1].cEffect = 60;
					Item[0].stEffect[1].cValue = 16;
					Item[0].stEffect[2].cEffect = 0;
					Item[0].stEffect[2].cValue = 0;
					PutItem(conn, &Item[0]);
				}
				//DANO
				if (pMob[conn].MOB.BaseScore.Int < (pMob[conn].MOB.BaseScore.Dex + pMob[conn].MOB.BaseScore.Str)) {
					Item[0].sIndex = 2122;
					Item[0].stEffect[0].cEffect = 43;
					Item[0].stEffect[0].cValue = 5;
					Item[0].stEffect[1].cEffect = 2;
					Item[0].stEffect[1].cValue = 36;
					Item[0].stEffect[2].cEffect = 0;
					Item[0].stEffect[2].cValue = 0;
					PutItem(conn, &Item[0]);
				}
			}
			if (pMob[conn].MOB.Class == 2) {
				//MAGO
				if (pMob[conn].MOB.BaseScore.Int > (pMob[conn].MOB.BaseScore.Dex + pMob[conn].MOB.BaseScore.Str)) {
					Item[0].sIndex = 854;
					Item[0].stEffect[0].cEffect = 43;
					Item[0].stEffect[0].cValue = 5;
					Item[0].stEffect[1].cEffect = 60;
					Item[0].stEffect[1].cValue = 16;
					Item[0].stEffect[2].cEffect = 0;
					Item[0].stEffect[2].cValue = 0;
					PutItem(conn, &Item[0]);
				}
				//DANO
				if (pMob[conn].MOB.BaseScore.Int < (pMob[conn].MOB.BaseScore.Dex + pMob[conn].MOB.BaseScore.Str)) {
					Item[0].sIndex = 809;
					Item[1].sIndex = 809;

					for (int i = 0; i < 2; i++) {
						Item[i].stEffect[0].cEffect = 43;
						Item[i].stEffect[0].cValue = 5;
						Item[i].stEffect[1].cEffect = 2;
						Item[i].stEffect[1].cValue = 36;
						Item[i].stEffect[2].cEffect = 0;
						Item[i].stEffect[2].cValue = 0;
						PutItem(conn, &Item[i]);
					}
				}
			}
			if (pMob[conn].MOB.Class == 3) {
				Item[0].sIndex = 2122;
				Item[0].stEffect[0].cEffect = 43;
				Item[0].stEffect[0].cValue = 5;
				Item[0].stEffect[1].cEffect = 2;
				Item[0].stEffect[1].cValue = 36;
				Item[0].stEffect[2].cEffect = 0;
				Item[0].stEffect[2].cValue = 0;
				PutItem(conn, &Item[0]);
			}

			SendClientMessage(conn, "Parabéns por alcançar o Lv144!");
			pUser[conn].chave1 = Recompensa;
			SendEtc(conn);
			SaveUser(conn, 0);
			return;
		}
		if (Recompensa == 5) {
			STRUCT_ITEM Item[5];
			memset(&Item[0], 0, sizeof(STRUCT_ITEM));
			memset(&Item[1], 0, sizeof(STRUCT_ITEM));
			memset(&Item[2], 0, sizeof(STRUCT_ITEM));

			int x = 0;
			int invfree = 0;

			for (x = 0; x < pMob[conn].MaxCarry; x++)
			{
				if (pMob[conn].MOB.Carry[x].sIndex == 0)
					invfree++;
			}
			if (invfree < 6)
			{
				SendClientMessage(conn, "Não há espaço suficiente no inventário");
				return;
			}
			//CLASSES: 0=TK, 1=FM, 2=BM, 3=HT
			if (pMob[conn].MOB.Class == 0) {

				//MAGO
				if (pMob[conn].MOB.BaseScore.Int > (pMob[conn].MOB.BaseScore.Dex + pMob[conn].MOB.BaseScore.Str)) {
					Item[0].sIndex = 3566;
					Item[0].stEffect[0].cEffect = 43;
					Item[0].stEffect[0].cValue = 5;
					Item[0].stEffect[1].cEffect = 60;
					Item[0].stEffect[1].cValue = 16;
					Item[0].stEffect[2].cEffect = 0;
					Item[0].stEffect[2].cValue = 0;
					PutItem(conn, &Item[0]);
				}
				//DANO
				if (pMob[conn].MOB.BaseScore.Int < (pMob[conn].MOB.BaseScore.Dex + pMob[conn].MOB.BaseScore.Str)) {
					Item[0].sIndex = 3551;
					Item[1].sIndex = 3551;

					for (int i = 0; i < 2; i++) {
						Item[i].stEffect[0].cEffect = 43;
						Item[i].stEffect[0].cValue = 5;
						Item[i].stEffect[1].cEffect = 2;
						Item[i].stEffect[1].cValue = 36;
						Item[i].stEffect[2].cEffect = 0;
						Item[i].stEffect[2].cValue = 0;
						PutItem(conn, &Item[i]);
					}
				}
			}
			if (pMob[conn].MOB.Class == 1) {
				//MAGO
				if (pMob[conn].MOB.BaseScore.Int > (pMob[conn].MOB.BaseScore.Dex + pMob[conn].MOB.BaseScore.Str)) {
					Item[0].sIndex = 3582;
					Item[0].stEffect[0].cEffect = 43;
					Item[0].stEffect[0].cValue = 5;
					Item[0].stEffect[1].cEffect = 60;
					Item[0].stEffect[1].cValue = 16;
					Item[0].stEffect[2].cEffect = 0;
					Item[0].stEffect[2].cValue = 0;
					PutItem(conn, &Item[0]);
				}
				//DANO
				if (pMob[conn].MOB.BaseScore.Int < (pMob[conn].MOB.BaseScore.Dex + pMob[conn].MOB.BaseScore.Str)) {
					Item[0].sIndex = 3556;
					Item[0].stEffect[0].cEffect = 43;
					Item[0].stEffect[0].cValue = 5;
					Item[0].stEffect[1].cEffect = 2;
					Item[0].stEffect[1].cValue = 36;
					Item[0].stEffect[2].cEffect = 0;
					Item[0].stEffect[2].cValue = 0;
					PutItem(conn, &Item[0]);
				}
			}
			if (pMob[conn].MOB.Class == 2) {
				//MAGO
				if (pMob[conn].MOB.BaseScore.Int > (pMob[conn].MOB.BaseScore.Dex + pMob[conn].MOB.BaseScore.Str)) {
					Item[0].sIndex = 3566;
					Item[0].stEffect[0].cEffect = 43;
					Item[0].stEffect[0].cValue = 5;
					Item[0].stEffect[1].cEffect = 60;
					Item[0].stEffect[1].cValue = 16;
					Item[0].stEffect[2].cEffect = 0;
					Item[0].stEffect[2].cValue = 0;
					PutItem(conn, &Item[0]);
				}
				//DANO
				if (pMob[conn].MOB.BaseScore.Int < (pMob[conn].MOB.BaseScore.Dex + pMob[conn].MOB.BaseScore.Str)) {
					Item[0].sIndex = 3551;
					Item[1].sIndex = 3551;

					for (int i = 0; i < 2; i++) {
						Item[i].stEffect[0].cEffect = 43;
						Item[i].stEffect[0].cValue = 5;
						Item[i].stEffect[1].cEffect = 2;
						Item[i].stEffect[1].cValue = 36;
						Item[i].stEffect[2].cEffect = 0;
						Item[i].stEffect[2].cValue = 0;
						PutItem(conn, &Item[i]);
					}
				}
			}
			if (pMob[conn].MOB.Class == 3) {
				Item[0].sIndex = 3556;
				Item[0].stEffect[0].cEffect = 43;
				Item[0].stEffect[0].cValue = 5;
				Item[0].stEffect[1].cEffect = 2;
				Item[0].stEffect[1].cValue = 36;
				Item[0].stEffect[2].cEffect = 0;
				Item[0].stEffect[2].cValue = 0;
				PutItem(conn, &Item[0]);
			}

			SendClientMessage(conn, "Parabéns por alcançar o Lv256!");
			pUser[conn].chave1 = Recompensa;
			SendEtc(conn);
			SaveUser(conn, 0);
			return;
		}
	}

	/*if (strcmp(m->MobName, "resetall") == 0)
	{
		int special = pMob[conn].MOB.SpecialBonus;

		for (int i = 0; i < 4; i++)
		{
			if (pMob[conn].MOB.BaseScore.Special[i] <= 350) {
				special += pMob[conn].MOB.BaseScore.Special[i];
				pMob[conn].MOB.BaseScore.Special[i] = 0;
			}
			else {
				special += 350;
				pMob[conn].MOB.BaseScore.Special[i] -= 350;
			}
		}
		pMob[conn].MOB.SpecialBonus = special;
		pMob[conn].MOB.Learned
		&= 0xFF000000;
		BASE_GetBonusSkillPoint(&pMob[conn].MOB, &pMob[conn].extra);
		SendClientMessage(conn, g_pMessageStringTable[_NN_Initialize_Skill]);
		SendEtc(conn);
		SendScore(conn);
		SetAffect(conn, 44, 20, 20);
		return;
	}*/

#pragma region >> Info Mac

	else if (strcmp(m->MobName, "infoplay") == 0) //pega as informação do jogador dentro do servidor
	{
		int MacAlvo = 0;
		MacAlvo = GetUserByName(m->String);

		if (pUser[MacAlvo].Mode != USER_PLAY)
			return;

		if (pUser[conn].Admin == 1)
		{
			SendClientMessage(conn, strFmt("!Account do Player %s", pUser[MacAlvo].AccountName));
			SendClientMessage(conn, strFmt("!IP %d", pUser[MacAlvo].IP));
			return;
		}
		else
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Not_Connected]);
			return;
		}
	}

#pragma endregion

#pragma region /criar
	else if (strcmp(m->MobName, "create") == 0 || strcmp(m->MobName, "Create") == 0 || strcmp(m->MobName, "criar") == 0 || strcmp(m->MobName, "Criar") == 0)
	{
		if (m->String[0] == 0)
			return;

		if (sizeof(m->String) > 100 || sizeof(m->String) <= 0)
			return;

		int l = strnlen(m->String, 100);

		if (l > 10)
		{
			SendClientMessage(conn, "Somente 10 caracteres.");
			return;
		}

		if (pMob[conn].MOB.Coin < 100000000)
		{
			SendClientMessage(conn, strFmt(g_pMessageStringTable[_DN_D_Cost], 100000000));
			return;
		}

		if (pMob[conn].MOB.Guild != 0)
			return;

		if (pMob[conn].MOB.Clan != 6 && pMob[conn].MOB.Clan != 7 && pMob[conn].MOB.Clan != 8)
		{
			SendClientMessage(conn, "Você precisa ser Capa Azul ou Red para criar sua guild.");
			return;
		}

		if (GuildCounter >= 4096)
			return;

		if (pMob[conn].extra.Citizen == 0)
		{
			SendClientMessage(conn, g_pMessageStringTable[_DN_NO_TOWNSPEOPLE]);
			return;
		}

		if (ServerIndex == -1)
			return;


		if (GuildCounter == 0)
			return;


		char szName[GUILDNAME_LENGTH];

		memset(szName, 0, GUILDNAME_LENGTH);

		strncpy(szName, m->String, GUILDNAME_LENGTH);

		for (int i = 0; i < 65535; i++)
		{
			int Group = ServerGroup;
			int Server = (i / MAX_GUILD); //& 15;
			int Guild = i - (Server * MAX_GUILD);

			if (!strncmp(m->String, g_pGuildName[Group][Server][Guild], GUILDNAME_LENGTH))
			{
				SendClientMessage(conn, "Este nome já está em uso!");

				return;
			}
		}

		pMob[conn].MOB.Guild = ServerIndex * MAX_GUILD + GuildCounter;
		pMob[conn].MOB.GuildLevel = 9;

		pMob[conn].MOB.Coin -= 100000000;
		SendEtc(conn);

		FILE* fp = fopen("../../Common/Guilds.txt", "a+");

		if (fp == NULL)
			return;


		fprintf(fp, "\n%d %d %d %s   ", ServerGroup, ServerIndex, GuildCounter, szName);

		fclose(fp);

		int Group = ServerGroup;
		int Server = pMob[conn].MOB.Guild / MAX_GUILD;
		int usGuild = pMob[conn].MOB.Guild;

		MSG_GuildInfo sm2;
		memset(&sm2, 0, sizeof(MSG_GuildInfo));

		sm2.Type = _MSG_GuildInfo;
		sm2.Size = sizeof(MSG_GuildInfo);
		sm2.ID = conn;

		sm2.Guild = usGuild;

		GuildInfo[usGuild].Clan = pMob[conn].MOB.Clan;
		GuildInfo[usGuild].Fame = 0;
		GuildInfo[usGuild].Citizen = pMob[conn].extra.Citizen;


		sm2.GuildInfo = GuildInfo[usGuild];

		auto& pc = cSQL::instance();
		sprintf(xQuery, "INSERT INTO guilds (guild, slug, mark, kingdom, name) VALUES ('%d','%d','%d','%d','%s')",
			usGuild, usGuild, usGuild, pMob[conn].MOB.Clan, m->String);
		pc.wQuery(xQuery);

		DBServerSocket.SendOneMessage((char*)&sm2, sizeof(MSG_GuildInfo));

		int GCount = GuildCounter + (ServerIndex << 12);
		/*	
			snprintf(temp, sizeof(temp), "sys,guild medal value:%d count:%d", GCount, GuildCounter);
			SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);*/

		GuildCounter++;

		CReadFiles::WriteGuild();
		doRanking(conn);

		BASE_InitializeGuildName();

		SendClientMessage(conn, strFmt(g_pMessageStringTable[_SN_CREATEGUILD], szName));
		return;
	}
#pragma endregion
#pragma region /subcreate
	else if (strcmp(m->MobName, "createsub") == 0 || strcmp(m->MobName, "subcreate") == 0 || strcmp(m->MobName, "criarsub") == 0 || strcmp(m->MobName, "Criarsub") == 0)
	{
		if (pMob[conn].MOB.Guild == 0)
			return;

		char SubMobName[256];
		char SubName[256];

		sscanf(m->String, "%s %s", SubMobName, SubName);

		char sub[16];

		strncpy(sub, SubMobName, 16);

		int user = GetUserByName(sub);

		if (user == conn)
			return;

		if (user == 0)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Not_Connected]);
			return;
		}

		if (pMob[user].MOB.Guild != pMob[conn].MOB.Guild)
			return;

		if (pMob[conn].MOB.GuildLevel != 9)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Only_Guild_Master_can]);
			return;
		}

		if (pMob[user].MOB.GuildLevel != 0)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Haven_Guild_Medal]);
			return;
		}

		int Guild = pMob[conn].MOB.Guild;

		if (GuildInfo[Guild].Sub1 != 0 && GuildInfo[Guild].Sub2 != 0 && GuildInfo[Guild].Sub3 != 0)
			return;


		if (pMob[conn].MOB.Coin < 50000000)
		{
			SendClientMessage(conn, strFmt(g_pMessageStringTable[_DN_D_Cost], 50000000));
			return;
		}

		pMob[conn].MOB.Coin -= 50000000;

		if (GuildInfo[Guild].Sub1 == 0)
		{
			pMob[user].MOB.GuildLevel = 6;
			GuildInfo[Guild].Sub1 = 1;
		}
		else if (GuildInfo[Guild].Sub2 == 0)
		{
			pMob[user].MOB.GuildLevel = 7;
			GuildInfo[Guild].Sub2 = 1;
		}
		else if (GuildInfo[Guild].Sub3 == 0)
		{
			pMob[user].MOB.GuildLevel = 8;
			GuildInfo[Guild].Sub3 = 1;
		}
		/*
		snprintf(temp, sizeof(temp), "etc,subcreate %s %d ", SubName, Guild);
		SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);*/

		MSG_GuildInfo sm_gi;
		memset(&sm_gi, 0, sizeof(MSG_GuildInfo));

		sm_gi.Type = _MSG_GuildInfo;
		sm_gi.Size = sizeof(MSG_GuildInfo);
		sm_gi.ID = conn;

		sm_gi.Guild = Guild;
		sm_gi.GuildInfo = GuildInfo[Guild];

		DBServerSocket.SendOneMessage((char*)&sm_gi, sizeof(MSG_GuildInfo));

		MSG_CreateMob sm2;
		memset(&sm2, 0, sizeof(MSG_CreateMob));
		GetCreateMob(conn, &sm2);

		GridMulticast(pMob[conn].TargetX, pMob[conn].TargetY, (MSG_STANDARD*)&sm2, 0);
		CharLogOut(conn);
		return;
	}
#pragma endregion
	 
	else if (strcmp(m->MobName, "fecharloja") == 0)
	{
		SendClientSignalParm(conn, 0x7530, pLeilaoStatus, 0);// cliente avisado que a loja foi fechada  
		// Limpar as propriedades da loja no leilao
		goResetLeilao(conn);
		// Enviar mensagem confirmando o fechamento da loja
		SendLeilaoStoreMyInfos(conn);
		SendClientMessage(conn, "Sua lojinha foi fechada com sucesso.");
		return;
	}
	else if (strcmp(m->MobName, "asdf") == 0)
	{
	CharLogOut(conn);	return;
	}
#pragma region /expulsar
	else if (strcmp(m->MobName, "sair") == 0 || strcmp(m->MobName, "expulsar") == 0 || strcmp(m->MobName, "abandonar") == 0)
	{
		if (pMob[conn].MOB.Guild == 0)
			return;


		int gGuild = pMob[conn].MOB.Guild;

		if (pMob[conn].MOB.GuildLevel >= 6 && pMob[conn].MOB.GuildLevel <= 8)
		{
			if (GuildInfo[gGuild].Sub1 != 0)
				GuildInfo[gGuild].Sub1 = 0;
			else if (GuildInfo[gGuild].Sub2 != 0)
				GuildInfo[gGuild].Sub2 = 0;

			else if (GuildInfo[gGuild].Sub3 != 0)
				GuildInfo[gGuild].Sub3 = 0;



			MSG_GuildInfo sm_gi;
			memset(&sm_gi, 0, sizeof(MSG_GuildInfo));

			sm_gi.Type = _MSG_GuildInfo;
			sm_gi.Size = sizeof(MSG_GuildInfo);
			sm_gi.ID = conn;

			sm_gi.Guild = gGuild;
			sm_gi.GuildInfo = GuildInfo[gGuild];

			DBServerSocket.SendOneMessage((char*)&sm_gi, sizeof(MSG_GuildInfo));
		}

		pMob[conn].MOB.Guild = 0;
		pMob[conn].MOB.GuildLevel = 0;

		doRanking(conn);

		MSG_CreateMob sm_eg;
		memset(&sm_eg, 0, sizeof(MSG_CreateMob));
		GetCreateMob(conn, &sm_eg);

		GridMulticast(pMob[conn].TargetX, pMob[conn].TargetY, (MSG_STANDARD*)&sm_eg, 0);
		return;
	}
#pragma endregion 
#pragma region /transferir
	else if (strcmp(m->MobName, "handover") == 0 || strcmp(m->MobName, "transferir") == 0)
	{
		if (pMob[conn].MOB.Guild == 0)
			return;

		if (pMob[conn].MOB.GuildLevel != 9)
			return;

		m->String[NAME_LENGTH - 1] = 0;
		m->String[NAME_LENGTH - 2] = 0;

		int target = GetUserByName(m->String);

		if (target == 0)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Not_Connected]);
			return;
		}

		if (pUser[target].Mode != USER_PLAY)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Not_Connected]);
			return;
		}

		if (pMob[target].MOB.Guild != pMob[conn].MOB.Guild)
			return;

		/*char guildname[256];
		BASE_GetGuildName(ServerGroup, pMob[conn].MOB.Guild, guildname);
		snprintf(temp, sizeof(temp), "etc,handover guild:%d guildname:%s  Lider:%s -> NovoLider:%s ", pMob[conn].MOB.Guild, guildname, pMob[conn].MOB.MobName, pMob[target].MOB.MobName);
		SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);*/


		pMob[target].MOB.GuildLevel = 9;
		pMob[conn].MOB.GuildLevel = 0;

		MSG_CreateMob sm_eg;
		memset(&sm_eg, 0, sizeof(MSG_CreateMob));
		GetCreateMob(conn, &sm_eg);

		GridMulticast(pMob[conn].TargetX, pMob[conn].TargetY, (MSG_STANDARD*)&sm_eg, 0);

		memset(&sm_eg, 0, sizeof(MSG_CreateMob));
		GetCreateMob(target, &sm_eg);

		GridMulticast(pMob[target].TargetX, pMob[target].TargetY, (MSG_STANDARD*)&sm_eg, 0);

		MSG_GuildInfo sm_gi;
		memset(&sm_gi, 0, sizeof(MSG_GuildInfo));

		sm_gi.Type = _MSG_GuildInfo;
		sm_gi.Size = sizeof(MSG_GuildInfo);
		sm_gi.ID = conn;

		sm_gi.Guild = pMob[conn].MOB.Guild;

		sm_gi.GuildInfo = GuildInfo[pMob[conn].MOB.Guild];

		DBServerSocket.SendOneMessage((char*)&sm_gi, sizeof(MSG_GuildInfo));

		return;
	}
#pragma endregion
#pragma region /nt - NT
	else if (strcmp(m->MobName, "nt") == 0)
	{
		SendClientMessage(conn, strFmt(g_pMessageStringTable[_DN_CHANGE_COUNT], pMob[conn].extra.NT));
		return;
	}
#pragma endregion

#pragma region /nt - NT
	else if (strcmp(m->MobName, "honra") == 0)
	{
		SendClientMessage(conn, strFmt("Saldo atual: [ %d ] de Honra", pUser[conn].Honra));
		return;
	}
#pragma endregion

	if (strcmp(m->MobName, "limpar") == 0) {
		if (pUser[conn].Mode != USER_PLAY || conn >= MAX_USER)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Not_Connected]);
			return;
		}

		int isTime = GetTickCount64() - pUser[conn].Atraso; // ATRASO PACOTE

		if (isTime < 2000)
		{
			SendClientMessage(conn, "Aguarde 2 segundos para usar o comando");
			return;
		}

		for (int i = 0; i < 50; i++) {
			pMob[conn].FiltroID[i] = 0;
		}
		SendClientMessage(conn, "Todos os Itens do filtro foram removidos");
		return;
	}
	if (strcmp(m->MobName, "filtro") == 0) {
		if (pUser[conn].Mode != USER_PLAY || conn >= MAX_USER)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Not_Connected]);
			return;
		}

		int isTime = GetTickCount64() - pUser[conn].Atraso; // ATRASO PACOTE

		if (isTime < 1000)
		{
			SendClientMessage(conn, "Aguarde 2 segundos para usar o comando");
			return;
		}
		if (pMob[conn].MOB.Equip[13].sIndex != 3901 && pMob[conn].MOB.Equip[13].sIndex != 3902 && pMob[conn].MOB.Equip[13].sIndex != 3916) {
			SendClientMessage(conn, "Precisa de uma fada azul/vermelha ou do vale para usar essa função!");
			return;
		}
		if (pMob[conn].FiltroState == 0) {
			pMob[conn].FiltroState = 1;
			SendMsgExp(conn, "Filtro de drop ON", TNColor::Speak, false);
			return;
		}
		if (pMob[conn].FiltroState == 1) {
			pMob[conn].FiltroState = 0;
			SendMsgExp(conn, "Filtro de drop OFF", TNColor::DarkOrange, false);
			return;
		}
	}

#pragma region /tab
	if (strcmp(m->MobName, "tab") == 0)
	{
		if (pMob[conn].MOB.CurrentScore.Level < 69 && pMob[conn].extra.ClassMaster == MORTAL)
		{
			SendClientMessage(conn, strFmt(g_pMessageStringTable[_DN_Level_Limit], 70));
			return;
		}

		strncpy(pMob[conn].Tab, m->String, 26);

		if (pUser[conn].TradeMode == 0)
		{
			MSG_CreateMob sm_tb;
			memset(&sm_tb, 0, sizeof(MSG_CreateMob));
			GetCreateMob(conn, &sm_tb);

			GridMulticast(pMob[conn].TargetX, pMob[conn].TargetY, (MSG_STANDARD*)&sm_tb, 0);
		}
		else
		{
			MSG_CreateMobTrade sm_tb;
			memset(&sm_tb, 0, sizeof(MSG_CreateMobTrade));
			GetCreateMobTrade(conn, &sm_tb);

			GridMulticast(pMob[conn].TargetX, pMob[conn].TargetY, (MSG_STANDARD*)&sm_tb, 0);
		}

		MSG_STANDARDPARM sm;
		memset(&sm, 0, sizeof(MSG_STANDARDPARM));

		sm.Size = sizeof(MSG_STANDARDPARM);
		sm.Type = _MSG_PKInfo;
		sm.ID = conn;

		if (NewbieEventServer == 0)
		{
			int guilty = GetGuilty(conn);

			int state = 0;

			if (guilty || pUser[conn].PKMode || RvRState && pMob[conn].TargetX >= 1023 && pMob[conn].TargetY >= 1919 && pMob[conn].TargetX <= 1280 && pMob[conn].TargetY <= 2179 || CastleState && pMob[conn].TargetX >= 1024 && pMob[conn].TargetY >= 1664 && pMob[conn].TargetX <= 1153 && pMob[conn].TargetY <= 1793 || GTorreState && pMob[conn].TargetX >= 2430 && pMob[conn].TargetY >= 1825 && pMob[conn].TargetX <= 2560 && pMob[conn].TargetY <= 1925)
				state = 1;

			sm.Parm = state;
		}
		else
			sm.Parm = 1;

		GridMulticast(pMob[conn].TargetX, pMob[conn].TargetY, (MSG_STANDARD*)&sm, 0);
		return;
	}
#pragma endregion
#pragma region /snd
	if (strcmp(m->MobName, "snd") == 0)
	{
		strncpy(pMob[conn].Snd, m->String, 96);
		SendClientMessage(conn, strFmt("%s %s", g_pMessageStringTable[_NN_SND_MESSAGE], pMob[conn].Snd));
		return;
	}
#pragma endregion

#pragma region /day - Skill
	if (strcmp(m->MobName, "day") == 0)
	{
		SendClientMessage(conn, "!#11  2");

		return;
	}
#pragma endregion  

#pragma region _NN_Kingdom - /kingdom
	if (strcmp(m->MobName, g_pMessageStringTable[_NN_Kingdom]) == 0 || strcmp(m->MobName, "Reino") == 0 || strcmp(m->MobName, "kingdom") == 0)
	{
		if (pUser[conn].Message != 0)
		{
			int isTime = GetTickCount64() - pUser[conn].Message;

			pUser[conn].Message = GetTickCount64();

			if (isTime < 5000)
			{
				SendClientMessage(conn, "Aguarde 5 segundo.");
				return;
			}
		}
		if (Clan == 7)
			DoTeleport(conn, 1690, 1618);
		else if (Clan == 8)
			DoTeleport(conn, 1690, 1842);
		else
			DoTeleport(conn, 1702, 1726);
		return;
	}
#pragma endregion
#pragma region _NN_King  - /king
	else if (strcmp(m->MobName, g_pMessageStringTable[_NN_King]) == 0 || strcmp(m->MobName, "king") == 0 || strcmp(m->MobName, "rei") == 0)
	{
		if (pUser[conn].Message != 0)
		{
			int isTime = GetTickCount64() - pUser[conn].Message;

			pUser[conn].Message = GetTickCount64();

			if (isTime < 5000)
			{
				SendClientMessage(conn, "Aguarde 5 segundo.");
				return;
			}
		}
		if (Clan == 7)
			DoTeleport(conn, 1748, 1574);

		else if (Clan == 8)
			DoTeleport(conn, 1748, 1880);

		return;
	}
#pragma endregion 
#pragma region _NN_Summon_Guild - /summonguild
	else if (strcmp(m->MobName, g_pMessageStringTable[_NN_Summon_Guild]) == 0 || strcmp(m->MobName, "summonguild") == 0)
	{
		int usGuild = pMob[conn].MOB.Guild;
		int usGuildLv = pMob[conn].MOB.GuildLevel;

		int xx = pMob[conn].TargetX;
		int yy = pMob[conn].TargetY;

		int village = BASE_GetVillage(xx, yy);

		unsigned char mapatt = GetAttribute(xx, yy);

		if (usGuildLv <= 0)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Only_Guild_Master_Can]);
			return;
		}

		int sub = BASE_GetSubGuild(pMob[conn].MOB.Equip[12].sIndex);

		if (village < 0 || village >= 5)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Cant_Use_That_Here]);
			return;
		}

		if (usGuildLv == 9)
		{
			SummonGuild2(usGuild, pMob[conn].TargetX, pMob[conn].TargetY, 350, sub);
			return;
		}
		if (mapatt & 4 || mapatt & 0x40)
			SendClientMessage(conn, g_pMessageStringTable[_NN_Cant_Use_That_Here]);
		return;
	}

#pragma endregion 
#pragma region _NN_Summon - /summon
	else if (strcmp(m->MobName, g_pMessageStringTable[_NN_Summon]) == 0 || strcmp(m->MobName, "summon") == 0)
	{
		int admin = 0;

		if (pUser[conn].Admin == 1)
			admin = 1;

		if (pMob[conn].MOB.CurrentScore.Hp <= 0)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Cant_Use_Killed]);
			return;
		}

		if (m->String[0] == 0)
			return;

		m->String[NAME_LENGTH - 1] = 0;
		m->String[NAME_LENGTH - 2] = 0;

		int target = GetUserByName(m->String);

		if (target == 0)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Not_Connected]);
			return;
		}

		if (target == conn)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Cant_Use_To_Yourself]);
			return;
		}

		if (pUser[target].Mode != USER_PLAY)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Not_Connected]);
			return;
		}

		int myguild = pMob[conn].MOB.Guild;
		int targetguild = pMob[target].MOB.Guild;

		int myleader = pMob[conn].Leader;

		if (myleader <= 0)
			myleader = conn;

		int targetleader = pMob[target].Leader;

		if (targetleader <= 0)
			targetleader = target;

		if (pMob[target].MOB.CurrentScore.Hp <= 0 && admin == 0)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Cant_Use_To_Killed]);
			return;
		}

		if ((myguild == 0 && myleader == 0 || myleader != targetleader || myguild != targetguild && myleader == 0) && admin == 0)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Only_To_Party_Or_Guild]);
			return;
		}

		if (pMob[conn].MOB.Class != 1 && admin == 0)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Didnt_Learn_Summon_Skill]);
			return;
		}

		int learn = pMob[conn].MOB.LearnedSkill;

		if ((learn & 0x40000) == 0 && admin == 0)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Didnt_Learn_Summon_Skill]);
			return;
		}

		int special = pMob[conn].MOB.CurrentScore.Special[3];

		unsigned char map_att = GetAttribute(pMob[conn].TargetX, pMob[conn].TargetY);

		if ((map_att & 4) && admin == 0)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Cant_Use_That_Here]);
			return;
		}

		if (pMob[target].TargetX & 0xFF00 || pMob[target].TargetY & 0xFF00)
		{
			DoSummon(target, pMob[conn].TargetX, pMob[conn].TargetY);
			SendClientMessage(target, strFmt("!Sumonado por [%s]", pMob[conn].MOB.MobName));
			return;
		}
		else
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Cant_Use_That_Here]);
			return;
		}
		return;
	}
#pragma endregion
#pragma region /time
	else if (strcmp(m->MobName, "time") == 0)
	{
		char tmptime[256];

		time_t mytime;

		time(&mytime);

		tm* timeinfo = localtime(&mytime);

		strftime(tmptime, 256, "%H:%M:%S | %d-%m-%Y", timeinfo);

		SendClientMessage(conn, tmptime);
		return;
	}
#pragma endregion  
#pragma region _NN_Relocate - /relo
	else if (strcmp(m->MobName, g_pMessageStringTable[_NN_Relocate]) == 0 || strcmp(m->MobName, "relo") == 0)
	{
		int Class = pMob[conn].MOB.Class;
		int admin = 0;

		if (pUser[conn].Admin == 1)
			admin = 1;

		if (pMob[conn].MOB.CurrentScore.Hp <= 0)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Cant_Use_Killed]);
			return;
		}

		if (m->String[0] == 0)
			return;

		m->String[NAME_LENGTH - 1] = 0;
		m->String[NAME_LENGTH - 2] = 0;

		int target = GetUserByName(m->String);

		if (target == 0)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Not_Connected]);
			return;
		}

		if (pUser[target].Mode != USER_PLAY)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Not_Connected]);
			return;
		}

		int myguild = pMob[conn].MOB.Guild;
		int targetguild = pMob[target].MOB.Guild;

		int myleader = pMob[conn].Leader;
		if (myleader <= 0)
			myleader = conn;

		int targetleader = pMob[target].Leader;
		if (targetleader <= 0)
			targetleader = target;

		if ((myguild == 0 && myleader == 0 || myleader != targetleader || myguild != targetguild && myleader == 0) && admin == 0)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Only_To_Party_Or_Guild]);
			return;
		}

		int summonmode = 0;
		int medal = pMob[conn].MOB.Equip[12].sIndex;

		if (medal == 522 || medal == 509 || medal >= 529 && medal <= 531 || medal >= 535 && medal <= 537)
			summonmode = 1;

		if (Class == 1)
		{
			int learn = pMob[conn].MOB.LearnedSkill;

			if (learn & 0x40000)
				summonmode = 2;
		}

		if (summonmode == 0 && admin == 0)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Didnt_Learn_Summon_Skill]);
			return;
		}

		unsigned char map_att = GetAttribute(pMob[target].TargetX, pMob[target].TargetY);

		if ((map_att & 4) && admin == 0)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Cant_Use_That_Here]);
			return;
		}

		int dif = pMob[conn].MOB.CurrentScore.Level;
		int myspecial = pMob[conn].MOB.CurrentScore.Special[3];

		if (summonmode == 1)
			dif += 30;

		if (summonmode == 2)
			dif += myspecial + 30;

		if (pMob[target].MOB.CurrentScore.Level > dif && admin == 0)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Too_High_Level]);
			return;
		}

		DoTeleport(conn, pMob[target].TargetX, pMob[target].TargetY);
		/*
		snprintf(temp, sizeof(temp), "etc,relo %s X:%d Y:%d", pMob[target].MOB.MobName, pMob[target].TargetX, pMob[target].TargetY);
		SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);*/

		if (admin == 0)
		{
			SendClientMessage(target, strFmt(g_pMessageStringTable[_SN_S_Relocate_To_You], pMob[conn].MOB.MobName));
		}

		return;
	}
#pragma endregion
#pragma region _NN_Deprivate - /expulsar
	else if (strcmp(m->MobName, "expulsar") == 0)
	{
		if (m->String[0] == 0)
			return;

		m->String[NAME_LENGTH - 1] = 0;
		m->String[NAME_LENGTH - 2] = 0;

		int target = GetUserByName(m->String);

		if (target)
			DoDeprivate(conn, target);
		else
			SendClientMessage(conn, g_pMessageStringTable[_NN_Not_Connected]);

		return;
	}
#pragma endregion
#pragma region /not
	else if (strcmp(m->MobName, "not") == 0)
	{

		if (pUser[conn].Admin == 1)
		{
			MSG_DBNotice sm_dbn;
			memset(&sm_dbn, 0, sizeof(MSG_DBNotice));

			sm_dbn.Size = sizeof(MSG_DBNotice);
			sm_dbn.ID = 0;
			sm_dbn.Type = _MSG_DBNotice;

			strncpy(sm_dbn.String, m->String, MESSAGE_LENGTH - 1);

			DBServerSocket.SendOneMessage((char*)&sm_dbn, sizeof(MSG_DBNotice));
			return;
		}

		else
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Not_Connected]);
			return;
		}
	}
#pragma endregion
#pragma region /online via IP MAC
	else if (strcmp(m->MobName, "online") == 0) //saber quantos jogadores tem online dentro do game
	{
		if (pUser[conn].Atraso != 0)
		{
			int isTime = GetTickCount64() - pUser[conn].Atraso; // ATRASO

			if (isTime < 10000)
			{
				SendClientMessage(conn, "Aguarde 10 segundos para uma nova Tentativa.");
				return;
			}

		}
		pUser[conn].Atraso = GetTickCount64();
		short num = 0;
		for (int i = 0; i < MAX_USER; i++)
		{
			if (pUser[i].Mode == USER_PLAY)
			{
				num++;
			}
		}

		if (num >= 100)
			num += 50;

		if (num >= 250)
			num += 50;

		if (num >= 400)
			num += 50;

		SendClientMessage(conn, strFmt("Atualmente temos %d jogador(es) online.", num));
		return;
	}
#pragma endregion
#pragma region
	else if (strcmp(m->MobName, "spk") == 0 || strcmp(m->MobName, "gritar") == 0)
	{
		int i = 0;

		if (pUser[conn].MuteChat == 1)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_No_Speak]);
			return;
		}

		for (i = 0; i < pMob[conn].MaxCarry; i++)
		{
			if (pMob[conn].MOB.Carry[i].sIndex != 3330)
				continue;

			int amount = BASE_GetItemAmount(&pMob[conn].MOB.Carry[i]);

			if (amount > 1)
				BASE_SetItemAmount(&pMob[conn].MOB.Carry[i], amount - 1);
			else
				BASE_ClearItem(&pMob[conn].MOB.Carry[i]);

			SendItem(conn, ITEM_PLACE_CARRY, i, &pMob[conn].MOB.Carry[i]);
			break;
		}

		if (i == pMob[conn].MaxCarry)
			return;


		SendSpkMsg(conn, m->String, TNColor::Speak, true);
		return;
	}
#pragma endregion 
#pragma region /ativar
	/*else if (strcmp(m->MobName, "pin") == 0 || strcmp(m->MobName, "PIN") == 0)
	{
		if (m->String[0] == 0)
			return;

		char innerMsg[100] = { 0, }, dir[256];
		int numCash = 0;
		FILE* fp;
		sprintf_s(dir, "../../Common/PinCode/%s.txt", m->String);
		if (!FileExist(dir))
			SendClientMessage(conn, g_pMessageStringTable[_NN_PINCODE_INVALID]);
		else
		{
			fopen_s(&fp, dir, "rt");

			if (fp)
			{
				fscanf_s(fp, "%d", &numCash);
				fclose(fp);
				remove(dir);
				pUser[conn].Donate += numCash;

				char tmg[256];
				SendClientMessage(conn, "Agradecemos a sua contribuição... Digite /saldo");
				SaveUser(conn, 0);
				SendEtc(conn);
				return;
			}
			else
				SendClientMessage(conn, "Um erro ocorreu durante a ativação, favor contatar administração.");
		}
		return;
	}*/
#pragma endregion 
	if (pUser[conn].MuteChat == 1)
	{
		SendClientMessage(conn, g_pMessageStringTable[_NN_No_Speak]);
		return;
	}

#pragma region /r - -- = Cidadao  pm
	if (m->MobName[0] == 0)
	{
#pragma region Chat Guild : -
		if (m->String[0] == '-')
		{
			strncpy(m->MobName, pMob[conn].MOB.MobName, NAME_LENGTH);

			m->String[MESSAGE_LENGTH] = 3;

			int guild = pMob[conn].MOB.Guild;

			if (guild == 0)
			{
				SendClientMessage(conn, g_pMessageStringTable[_NN_Only_Guild_Member_Can]);
				return;
			}

			int guildlevel = pMob[conn].MOB.GuildLevel;

			for (int i = 1; i < MAX_USER; i++)
			{
				if (pUser[i].Mode != USER_PLAY)
					continue;

				if (pMob[i].MOB.Guild != guild && m->String[1] != '-')
					continue;

				if (pMob[i].MOB.Guild != guild && m->String[1] == '-' && (pMob[i].MOB.Guild != g_pGuildAlly[guild] || g_pGuildAlly[guild] == 0))
					continue;

				if (i == conn)
					continue;

				if (pUser[i].Guildchat)
					continue;

				m->ID = conn;
				if (!pUser[i].cSock.AddMessage((char*)m, m->Size))
					CloseUser(conn);
			}

			char guildname[256];
			BASE_GetGuildName(ServerGroup, guild, guildname);
			snprintf(temp, sizeof(temp), "chat_guild, %s : %s guild:%s", m->MobName, m->String, guildname);
			ChatLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);
			return;
		}
#pragma endregion
#pragma region Chat Party : =
		if (m->String[0] == '=')
		{
			strncpy(m->MobName, pMob[conn].MOB.MobName, NAME_LENGTH);

			int myleader = pMob[conn].Leader;

			if (myleader <= 0)
				myleader = conn;

			if (myleader <= 0 || myleader >= MAX_USER)
				return;

			if (pUser[myleader].Mode != USER_PLAY)
				return;

			if (myleader != conn)
				if (!pUser[myleader].cSock.AddMessage((char*)m, sizeof(MSG_MessageWhisper)))
					CloseUser(conn);

			for (int i = 0; i < MAX_PARTY; i++)
			{
				int partyconn = pMob[myleader].PartyList[i];

				if (partyconn <= 0 || partyconn >= MAX_USER)
					continue;

				if (partyconn == conn)
					continue;

				if (pUser[partyconn].Mode != USER_PLAY)
					continue;

				if (pUser[partyconn].PartyChat)
					continue;

				m->ID = conn;
				if (!pUser[partyconn].cSock.AddMessage((char*)m, sizeof(MSG_MessageWhisper)))
					CloseUser(conn);
			}
			snprintf(temp, sizeof(temp), "chat_party, %s : %s", m->MobName, m->String);
			ChatLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);
			return;
		}
#pragma endregion
#pragma region Chat Reino
		if (m->String[0] == '@' && m->String[1] == '@')
		{
			if (pUser[conn].Message != 0)
			{
				int isTime = GetTickCount64() - pUser[conn].Message;

				pUser[conn].Message = GetTickCount64();

				if (isTime < 3000)
				{
					SendClientMessage(conn, "Aguarde 3 segundos.");
					return;
				}
			}
			pUser[conn].Message = GetTickCount64();

			strncpy(m->MobName, pMob[conn].MOB.MobName, NAME_LENGTH);

			SyncKingdomMulticast(conn, pMob[conn].MOB.Clan, (MSG_STANDARD*)m, 0);
			snprintf(temp, sizeof(temp), "chat_kingdom, %s : %s reino:%d", m->MobName, m->String, pMob[conn].MOB.Clan);
			ChatLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);

			return;
		}
#pragma endregion
#pragma region Chat Cidadão
		if (m->String[0] == '@')
		{
			if (pUser[conn].Message != 0)
			{
				int isTime = GetTickCount64() - pUser[conn].Message;

				pUser[conn].Message = GetTickCount64();

				if (isTime < 3000)
				{
					SendClientMessage(conn, "Aguarde 3 segundos.");
					return;
				}
			}
			pUser[conn].Message = GetTickCount64();

			strncpy(m->MobName, pMob[conn].MOB.MobName, NAME_LENGTH);

			SyncMulticast(conn, (MSG_STANDARD*)m, 0);
			snprintf(temp, sizeof(temp), "chat_cidadao, %s : %s", m->MobName, m->String);
			ChatLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);
			return;
		}
#pragma endregion
		return;
	}

#pragma region PM, /r
	if (m->MobName[0] != 0)
	{
		m->MobName[NAME_LENGTH - 1] = 0;
		m->MobName[NAME_LENGTH - 2] = 0;

		int target = 0;

		if (strcmp(m->MobName, g_pMessageStringTable[_NN_Reply]) == 0 || strcmp(m->MobName, "r") == 0)
		{
			if (!pUser[conn].LastChat[0])
			{
				SendClientMessage(conn, g_pMessageStringTable[_NN_No_One_To_Reply]);
				return;
			}
			memmove_s(m->MobName, NAME_LENGTH, pUser[conn].LastChat, NAME_LENGTH);

			m->MobName[NAME_LENGTH - 1] = 0;
			m->MobName[NAME_LENGTH - 2] = 0;
		}

		target = GetUserByName(m->MobName);

		if (target == 0)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Not_Connected]);
			return;
		}

		if (pUser[target].Mode != USER_PLAY)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Not_Connected]);
			return;
		}

		if (pUser[target].Whisper && pMob[conn].MOB.CurrentScore.Level < 1000)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Deny_Whisper]);
			return;
		}
		m->ID = target;

		memmove_s(pUser[conn].LastChat, NAME_LENGTH, m->MobName, NAME_LENGTH);

		if (m->String[0] == 0)
		{
			char temp[1024];
			if (pMob[target].MOB.Guild == 0)
			{
				char tt[256];
				snprintf(tt, sizeof(tt), "Cidadania: %d  Fama: %d", pMob[target].extra.Citizen, pMob[target].extra.Fame);
				snprintf(temp, sizeof(temp), "%s  %s", pMob[target].MOB.MobName, tt);
			}
			else
			{
				char guildname[256];
				char tt[256];
				char guildind[256];
				char guildindex[256];
				int usGuild = pMob[conn].MOB.Guild;
				BASE_GetGuildName(ServerGroup, pMob[target].MOB.Guild, guildname);
				BASE_GetGuildName(ServerGroup, pMob[conn].MOB.Guild, guildind);
				//guildindex = pMob[conn].MOB.GuildLevel;

				if (pMob[conn].MOB.Guild == 0 && pMob[conn].MOB.GuildLevel != 9)
				{
					snprintf(tt, sizeof(tt), "Cidadania: %d  Fama: %d", pMob[target].extra.Citizen, pMob[target].extra.Fame);
					snprintf(temp, sizeof(temp), "%s  %s [ %s ]", pMob[target].MOB.MobName, tt, guildname);

				}
				//GUILDSS
				if (pMob[conn].MOB.Guild != 0 && pMob[conn].MOB.GuildLevel == 9 && pMob[conn].MOB.Clan != pMob[target].MOB.Clan)
				{
					snprintf(tt, sizeof(tt), "[ %s (%d) ] Cidadania: %d  Fama: %d", guildind, pMob[target].MOB.Guild, pMob[target].extra.Citizen, pMob[target].extra.Fame);
					snprintf(temp, sizeof(temp), "%s  %s %s ", pMob[target].MOB.MobName, tt, guildname);
				}
				if (pMob[conn].MOB.Clan != pMob[target].MOB.Clan)
				{
					snprintf(tt, sizeof(tt), "Cidadania %d  Fama %d", pMob[target].extra.Citizen, pMob[target].extra.Fame);
					snprintf(temp, sizeof(temp), "%s  %s [ %s ]", pMob[target].MOB.MobName, tt, guildname);
				}
				if (pMob[conn].MOB.Clan == pMob[target].MOB.Clan && pMob[conn].MOB.GuildLevel != 9)
				{
					snprintf(tt, sizeof(tt), "Cidadania %d  Fama %d", pMob[target].extra.Citizen, pMob[target].extra.Fame);
					snprintf(temp, sizeof(temp), "%s  %s [ %s ]", pMob[target].MOB.MobName, tt, guildname);
				}
				if (pMob[conn].MOB.Clan != pMob[target].MOB.Clan && pMob[conn].MOB.GuildLevel != 0)
				{
					snprintf(tt, sizeof(tt), "Cidadania %d  Fama %d", pMob[target].extra.Citizen, pMob[target].extra.Fame);
					snprintf(temp, sizeof(temp), "%s / %s [ %s ]", pMob[target].MOB.MobName, tt, guildname);
				}
				//GUILDSS
				if (pMob[conn].MOB.GuildLevel == 9 && pMob[conn].MOB.Guild == pMob[target].MOB.Guild)
				{
					snprintf(tt, sizeof(tt), "[ %s (%d) ] Cidadania: %d  Fama: %d", guildname, pMob[target].MOB.Guild, pMob[target].extra.Citizen, pMob[target].extra.Fame);
					snprintf(temp, sizeof(temp), "%s  %s  ", pMob[target].MOB.MobName, tt);
				}
				if (pMob[conn].MOB.GuildLevel == 9 && pMob[conn].MOB.Guild != pMob[target].MOB.Guild)
				{
					snprintf(tt, sizeof(tt), "Cidadania %d  Fama %d", pMob[target].extra.Citizen, pMob[target].extra.Fame);
					snprintf(temp, sizeof(temp), "%s  %s [ %s ]", pMob[target].MOB.MobName, tt, guildname);
				}
			}
			SendClientMessage(conn, temp);

			if (pMob[target].Snd[0] != 0)
			{
				snprintf(temp, sizeof(temp), "%s %s", g_pMessageStringTable[_NN_SND_MESSAGE], pMob[target].Snd);

				SendClientMessage(conn, temp);
			}
			return;
		}

		if (m->String[0] == '-' || m->String[0] == '=')
			m->String[0] = ' ';

		m->String[MESSAGE_LENGTH] = 0;

		memmove_s(m->MobName, NAME_LENGTH, pMob[conn].MOB.MobName, NAME_LENGTH);
		memmove_s(pUser[target].LastChat, NAME_LENGTH, m->MobName, NAME_LENGTH);

		if (!pUser[target].cSock.AddMessage((char*)m, sizeof(MSG_MessageWhisper)))
			CloseUser(conn);

		snprintf(temp, sizeof(temp), "chat_sms,%s %s : %s", pMob[conn].MOB.MobName, m->MobName, m->String);
		ChatLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);
		return;
	}
#pragma endregion
	snprintf(temp, sizeof(temp), "packet, MSG_MessageWhisper user: %s used command: %s", pMob[conn].MOB.MobName, m->MobName);
	SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);

#pragma endregion
}


# -------------------- _MSG_Motion.cpp --------------------

/*
*   Copyright (C) {2015}  {Victor Klafke, Charles TheHouse}
*
*   This program is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program.  If not, see [http://www.gnu.org/licenses/].
*
*   Contact at: victor.klafke@ecomp.ufsm.br
*/
#include "ProcessClientMessage.h"

void Exec_MSG_Motion(int conn, char *pMsg)
{
	MSG_Motion *m = (MSG_Motion*)pMsg;

    int Size = m->Size;

    if (Size > sizeof(MSG_Motion)) //CONTROLE DE SIZE
    {
        SendClientMessage(conn, "Impossível executar ação32, tente mais tarde. ");
        return;
    }
    if (pUser[conn].Atraso != 0)
    {
        int isTime = GetTickCount64() - pUser[conn].Atraso; // ATRASO PACOTE

        if (isTime < 800)
        {
            SendClientMessage(conn, "Aguarde 1 segundo para uma nova Tentativa.");
            return;
        }

    }
    pUser[conn].Atraso = GetTickCount64();

	if (pMob[conn].MOB.CurrentScore.Hp == 0 || pUser[conn].Mode != USER_PLAY)
	{
		SendHpMode(conn);

		AddCrackError(conn, 4, 6);

		return;
	}

	sprintf(temp, "etc,motion motion:%d parm:%d notused:%d", m->Motion, m->Parm, m->NotUsed);
    SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);

	GridMulticast(pMob[conn].TargetX, pMob[conn].TargetY, (MSG_STANDARD*)m, 0);

    // validação de User
    if (m->ID != conn)
        return;

    // validação de Motion
    if (m->Motion < 0 || m->Motion > 27)
    {
        m->Motion = 0;
        return;
    }
    // 14 0 6F 4D 6A 3 91 0 D5 18 61 0 E C1 C4 C1 0 0 0 0   --> pacote enviado pelo wpe crashando client de users próximos
    // etc,motion motion:6926 parm:1267 notused:0

    // valaidação do Parm
    if (m->Parm < 0 || m->Parm > 27)
    {
        m->Parm = 0;
        return;
    }
}

# -------------------- _MSG_NoViewMob.cpp --------------------

/*
*   Copyright (C) {2015}  {Victor Klafke, Charles TheHouse}
*
*   This program is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program.  If not, see [http://www.gnu.org/licenses/].
*
*   Contact at: victor.klafke@ecomp.ufsm.br
*/
#include "ProcessClientMessage.h"

void Exec_MSG_NoViewMob(int conn, char *pMsg)
{
	MSG_STANDARDPARM *m = (MSG_STANDARDPARM*)pMsg;

	int Size = m->Size;

	if (Size > sizeof(MSG_STANDARDPARM)) //CONTROLE DE SIZE
	{
		SendClientMessage(conn, "Impossível executar ação33, tente mais tarde. ");
		return;
	}

	int MobID = m->Parm;

	if (MobID <= 0 || MobID >= MAX_MOB)
	{
		//Log("err,reqmobbyid MobId Out of range", pUser[conn].AccountName, pUser[conn].IP);
		return;
	}

	if (pMob[MobID].Mode == MOB_EMPTY)
	{
		SendRemoveMob(conn, MobID, 0, 0);
		return;
	}

	if (MobID >= MAX_USER || pUser[MobID].Mode == USER_PLAY)
	{
		if (GetInView(conn, MobID))
		{
			SendCreateMob(conn, MobID, 1);
			SendPKInfo(conn, MobID);
		}
		else
			SendRemoveMob(conn, MobID, 0, 0);
	}
	else
		SendRemoveMob(conn, MobID, 0, 0);
}

# -------------------- _MSG_PKMode.cpp --------------------

/*
*   Copyright (C) {2015}  {Victor Klafke, Charles TheHouse}
*
*   This program is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program.  If not, see [http://www.gnu.org/licenses/].
*
*   Contact at: victor.klafke@ecomp.ufsm.br
*/
#include "ProcessClientMessage.h"

void Exec_MSG_PKMode(int conn, char *pMsg)
{
	MSG_STANDARDPARM *m = (MSG_STANDARDPARM*)pMsg;

	int Size = m->Size;

	if (Size > sizeof(MSG_STANDARDPARM)) //CONTROLE DE SIZE
	{
		SendClientMessage(conn, "Impossível executar ação34, tente mais tarde. ");
		return;
	}

	pUser[conn].PKMode = m->Parm != 0 ? 1 : 0;
	
	if (pUser[conn].PKMode == 1) {
		SendClientMessage(conn, "Pk Ativo");
		SendMsgExp(conn, "Pk Ativo", TNColor::Red, false);
	}
	else {
		SendClientMessage(conn, "Pk Desativado");
		SendMsgExp(conn, "Pk Desativado", TNColor::GreenYellow, false);
	}

	if (pUser[conn].Trade.OpponentID)
	{
		if (pUser[pUser[conn].Trade.OpponentID].Mode == USER_PLAY && pUser[pUser[conn].Trade.OpponentID].Trade.OpponentID == conn)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Cant_trade_pkmode]);
			SendClientMessage(pUser[conn].Trade.OpponentID, g_pMessageStringTable[_NN_Cant_trade_pkmode]);

			RemoveTrade(pUser[conn].Trade.OpponentID);
			RemoveTrade(conn);
		}
	}

	MSG_STANDARDPARM sm;
	memset(&sm, 0, sizeof(MSG_STANDARDPARM));

	sm.Size = sizeof(MSG_STANDARDPARM);
	sm.Type = _MSG_PKInfo;
	sm.ID = conn;

	if (NewbieEventServer == 0)
	{
		int guilty = GetGuilty(conn);

		int state = 0;

		if (guilty || pUser[conn].PKMode || RvRState && pMob[conn].TargetX >= 1023 && pMob[conn].TargetY >= 1919 && pMob[conn].TargetX <= 1280 && pMob[conn].TargetY <= 2179 || CastleState && pMob[conn].TargetX >= 1024 && pMob[conn].TargetY >= 1664 && pMob[conn].TargetX <= 1153 && pMob[conn].TargetY <= 1793 || GTorreState && pMob[conn].TargetX >= 2430 && pMob[conn].TargetY >= 1825 && pMob[conn].TargetX <= 2560 && pMob[conn].TargetY <= 1925)
			state = 1;

		sm.Parm = state;
	}
	else
		sm.Parm = 1;


	GridMulticast(pMob[conn].TargetX, pMob[conn].TargetY, (MSG_STANDARD*)&sm, 0);

	//sprintf(temp, "etc,pkmode %d", pUser[conn].PKMode);
	//Log(temp, pUser[conn].AccountName, pUser[conn].IP);
}

# -------------------- _MSG_PutoutSeal.cpp --------------------

/*
*   Copyright (C) {2015}  {Victor Klafke, Charles TheHouse}
*
*   This program is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program.  If not, see [http://www.gnu.org/licenses/].
*
*   Contact at: victor.klafke@ecomp.ufsm.br
*/
#include "ProcessClientMessage.h"

void Exec_MSG_PutoutSeal(int conn, char *pMsg)
{
	MSG_PutoutSeal *m = (MSG_PutoutSeal*)pMsg;

	int Size = m->Size;

	if (Size > sizeof(MSG_PutoutSeal)) //CONTROLE DE SIZE
	{
		SendClientMessage(conn, "Impossível executar ação35, tente mais tarde. ");
		return;
	}

	if (pUser[conn].Mode != USER_PLAY)
	{
		SendHpMode(conn);
		return;
	}

	if (pUser[conn].Trade.OpponentID)
	{
		RemoveTrade(conn);
		return;
	}

	if (pMob[conn].MOB.CurrentScore.Hp == 0)
	{
		SendHpMode(conn);
		AddCrackError(conn, 1, 15);

		if (m->SourType == ITEM_PLACE_CARRY)
			SendItem(conn, m->SourType, m->SourPos, &pMob[conn].MOB.Carry[m->SourPos]);

		else if (m->SourType == ITEM_PLACE_CARGO)
			SendItem(conn, m->SourType, m->SourPos, &pUser[conn].Cargo[m->SourPos]);

		else
			SendItem(conn, m->SourType, m->SourPos, &pMob[conn].MOB.Equip[m->SourPos]);

		return;
	}

	if (m->GridX >= MAX_GRIDX || m->GridY >= MAX_GRIDY)
	{
		CrackLog(conn, " Drop grid, out of range");
		return;
	}

	STRUCT_ITEM *item = GetItemPointer(&pMob[conn].MOB, pUser[conn].Cargo, m->SourType, m->SourPos);

	if (item == NULL)
	{
		//sprintf_s(temp, "err,use item fail source %d %d", m->SourType, m->SourPos);
		//Log(temp, "-system", 0);
		return;
	}

	if(item->sIndex != 3443)
	{
		CrackLog(conn, "outseal no 3443");
		return;
	}

	if(item->stEffect[0].cEffect == 0)
	{
		CrackLog(conn, "outseal no effect");
		return;
	}

	m->MobName[NAME_LENGTH - 1] = 0;
	m->MobName[NAME_LENGTH - 2] = 0;

	if (BASE_CheckValidString(m->MobName) == 0)
	{
		SendItem(conn, m->SourType, m->SourPos, item);
		return;
	}
	CharLogOut(conn);

	MSG_DBOutCapsule sm_outc;
	memset(&sm_outc, 0, sizeof(MSG_DBOutCapsule));

	sm_outc.Size = sizeof(MSG_DBOutCapsule);
	sm_outc.Type = _MSG_DBOutCapsule;
	sm_outc.ID = conn;

	sm_outc.Slot = pUser[conn].Slot;
	sm_outc.SourType = m->SourType;
	sm_outc.SourPos = m->SourPos;
	sm_outc.DestType = m->DestType;
	sm_outc.DestPos = m->DestPos;
	sm_outc.GridX = m->GridX;
	sm_outc.GridY = m->GridY;
	sm_outc.WarpID = m->WarpID;

	strncpy(sm_outc.MobName, m->MobName, 12);

	//sprintf_s(temp, "etc,outcapsule srctype:%d srcslot:%d name:%s", m->SourType, m->SourPos, m->MobName);
	//Log(temp, pMob[conn].MOB.MobName, pUser[conn].IP);

	DBServerSocket.SendOneMessage((char*)&sm_outc, sizeof(MSG_DBOutCapsule));
}

# -------------------- _MSG_Quest.cpp --------------------

#include "ProcessClientMessage.h"   
#include "wMySQL.h"
#include "Functions.h"
//#include "Functions.h"


void Exec_MSG_Quest(int conn, char* pMsg)
{
	MSG_STANDARDPARM2* m = (MSG_STANDARDPARM2*)pMsg;

	int Size = m->Size;

	if (Size > sizeof(MSG_STANDARDPARM2)) //CONTROLE DE SIZE
	{
		SendClientMessage(conn, "Impossível executar ação36, tente mais tarde. ");
		return;
	}
	if (pUser[conn].Atraso != 0)
	{
		int isTime = GetTickCount64() - pUser[conn].Atraso; // ATRASO PACOTE

		if (isTime < 800)
		{
			SendClientMessage(conn, "Aguarde 1 segundo para uma nova Tentativa.");
			return;
		}

	}
	pUser[conn].Atraso = GetTickCount64();

	if (pUser[conn].Mode != USER_PLAY)
		return;

	int npcIndex = m->Parm1;
	int confirm = m->Parm2;

	if (npcIndex < MAX_USER || npcIndex >= MAX_MOB)
		return;

	if (confirm < 0)
		return;

	int npcMode = -1;

	int npcMerc = pMob[npcIndex].MOB.Merchant;
	int npcGrade = pMob[npcIndex].MOB.BaseScore.Level;

	if (pUser[conn].Trade.OpponentID)
	{
		RemoveTrade(pUser[conn].Trade.OpponentID);
		RemoveTrade(conn);
		return;
	}

	if (pUser[conn].TradeMode)
	{
		SendClientMessage(conn, g_pMessageStringTable[_NN_CantWhenAutoTrade]);
		return;
	}


#pragma region Set npcMode Base

	if (npcMerc == 100 && npcGrade == 0)
		npcMode = QUEST_COVEIRO;

	if (npcMerc == 100 && npcGrade == 36)
		npcMode = QUEST_BENCAODEDEUS;

	if (npcMerc == 100 && npcGrade == 39)
		npcMode = AMELIA;

	if (npcMerc == 100 && npcGrade == 40)
		npcMode = QUEST_EQUILIBRIO;

	if (npcMerc == 100 && npcGrade == 1)
		npcMode = QUEST_JARDINEIRO;

	if (npcMerc == 100 && npcGrade == 2)
		npcMode = QUEST_KAIZEN;

	if (npcMerc == 100 && npcGrade == 3)
		npcMode = QUEST_HIDRA;

	if (npcMerc == 100 && npcGrade == 4)
		npcMode = QUEST_ELFOS;

	if (npcMerc == 100 && npcGrade == 5)
		npcMode = LIDER_APRENDIZ;

	if (npcMerc == 100 && npcGrade == 9 || npcMerc == 100 && npcGrade == 8 || npcMerc == 100 && npcGrade == 7)
		npcMode = PERZEN;

	if (npcMerc == 100 && npcGrade == 13)
		npcMode = QUEST_CAPAREAL;

	if (npcMerc == 100 && npcGrade == 14)
		npcMode = CAPAVERDE_TELEPORT;

	if (npcMerc == 100 && npcGrade == 15)
		npcMode = MOLARGARGULA;

	if (npcMerc == 100 && npcGrade == 16)
		npcMode = CHEFE_DE_TREINO;

	if (npcMerc == 100 && npcGrade == 22)
		npcMode = SOBREVIVENTE;

	if (npcMerc == 100 && npcGrade == 30)
		npcMode = GUARDA_REAL_I;

	if (npcMerc == 100 && npcGrade == 31)
		npcMode = GUARDA_REAL_II;

	if (npcMerc == 100 && npcGrade == 32)
		npcMode = GUARDA_REAL_III;

	if (npcMerc == 100 && npcGrade == 33)
		npcMode = GUARDA_REAL_IV;

	if (npcMerc == 100 && npcGrade == 34)
		npcMode = GUARDA_REAL_V;

	if (npcMerc == 100 && npcGrade == 41)
		npcMode = GUARDA_REAL_VI;

	if (npcMerc == 100 && npcGrade == 80)
		npcMode = EVENTO_HIT;

	if (npcMerc == 100 && npcGrade == 37)
		npcMode = KRUNO;

	if (npcMerc == 200)
		npcMode = CURANDEIRA;

	if (npcMerc == 100 && npcGrade == 45)
		npcMode = UXMAL;

	if (npcMerc == 7 && npcGrade == 33) //Bama
		npcMode = MESTREGRIFO;

	if (npcMerc == 36)
		npcMode = TREINADORNEWBIE1;

	if (npcMerc == 40)
		npcMode = TREINADORNEWBIE2;

	if (npcMerc == 41)
		npcMode = TREINADORNEWBIE3;

	if (npcMerc == 8)
		npcMode = CAPAVERDE_TRADE;

	if (npcMerc == 78)
		npcMode = BLACKORACLE;

	if (npcMerc == 120)
		npcMode = CARBUNCLE_WIND;

	if (npcMerc == 4)
		npcMode = GOLD_DRAGON;

	if (npcMerc == 201)
		npcMode = UPADOR;

	if (npcMerc == 10)
		npcMode = AMU_MISTICO;

	if (npcMerc == 11)
		npcMode = EXPLOIT_LEADER;

	if (npcMerc == 12)
		npcMode = JEFFI;

	if (npcMerc == 13)
		npcMode = SHAMA;

	if (npcMerc == 14)
		npcMode = KING;

	if (npcMerc == 15)
		npcMode = KING;

	if (npcMerc == 19)
		npcMode = COMP_SEPHI;

	if (npcMerc == 26)
		npcMode = KINGDOM;

	if (npcMerc == 30)
		npcMode = ZAKUM;

	if (npcMerc == 31)
		npcMode = MESTREHAB;

	if (npcMerc == 100 && npcGrade == 38)
		npcMode = UNICORNIO_PURO;

	if (npcMerc == 15 && npcGrade == 13)
		npcMode = JULIARZAN;

	if (npcMerc == 15 && npcGrade == 12)
		npcMode = JULIGELO;

	if (npcMerc == 68)
		npcMode = GODGOVERNMENT;

	if (npcMerc == 58)
		npcMode = MOUNT_MASTER;

	if (npcMerc == 62)
		npcMode = ARZAN_DRAGON;

	if (npcMerc == 76)
		npcMode = URNAMMU;

	if (npcMerc == 74)
		npcMode = KIBITA;

	if (npcMerc == 75)
		npcMode = EVENTO_DROP;

	if (npcMerc == 75 && npcGrade == 41)
		npcMode = TELEPORTEVENTO1;

	if (npcMerc == 75 && npcGrade == 42)
		npcMode = TELEPORTEVENTO2;

	if (npcMerc == 75 && npcGrade == 43)
		npcMode = TELEPORTEVENTO3;

	if (npcMerc == 75 && npcGrade == 44)
		npcMode = TELEPORTEVENTO4;

	if (npcMerc == 75 && npcGrade == 47)
		npcMode = FRAGMENTODAALMA;

	if (npcMerc == 75 && npcGrade == 48)
		npcMode = TROCADEFADA;

	if (npcMerc == 75 && npcGrade == 45)
		npcMode = LANHOUSEN;
	if (npcMerc == 75 && npcGrade == 46)
		npcMode = LANHOUSEM;

	if (npcMode == -1)
		return;

#pragma endregion

	switch (npcMode)
	{

	case GUARDA_REAL_I:
	{
		EventoClick(conn, GUARDA_REAL_I);
	}return;
	case GUARDA_REAL_II:
	{
		EventoClick(conn, GUARDA_REAL_II);
	}return;
	case GUARDA_REAL_III:
	{
		EventoClick(conn, GUARDA_REAL_III);
	}return;
	case GUARDA_REAL_IV:
	{
		EventoClick(conn, GUARDA_REAL_IV);
	}return;
	case GUARDA_REAL_V:
	{
		EventoClick(conn, GUARDA_REAL_V);
	}return;
	case GUARDA_REAL_VI:
	{
		EventoClick(conn, GUARDA_REAL_VI);
	}return;
	case EVENTO_HIT:
	{
		SendRecaptcha(conn, 4);				
	}return;	
#pragma region MOUNT_MASTER
	case MOUNT_MASTER:
	{
		int mountIndex = pMob[conn].MOB.Equip[14].sIndex;

		if (mountIndex < 2330 || mountIndex >= 2390 || mountIndex < 3091 && mountIndex >= 3139)
		{
			SendSay(npcIndex, g_pMessageStringTable[_NN_Cure_animals]);
			return;
		}

		if (pMob[conn].MOB.Equip[14].stEffect[0].sValue > 0)
		{
			SendSay(npcIndex, g_pMessageStringTable[_NN_Cure_animals]);
			return;
		}

		int price = g_pItemList[mountIndex].Price;

		if (confirm == 0)
		{
			SendSay(npcIndex, strFmt(g_pMessageStringTable[_DS_S_cure_price_D], g_pItemList[mountIndex].Name, price));
			return;
		}

		if (pMob[conn].MOB.Coin < price)
		{

			SendClientMessage(conn, g_pMessageStringTable[_NN_Not_Enough_Money]);
			return;
		}

		if (price < 0 || price > 2000000000)
			return;

		pMob[conn].MOB.Coin -= price;

		int vit = BASE_GetItemAbility(&pMob[conn].MOB.Equip[14], EF_MOUNTLIFE);

		vit -= rand() % 3;

		if (vit > 0)
		{
			SendSay(npcIndex, g_pMessageStringTable[_NN_Cured]);
			pMob[conn].MOB.Equip[14].stEffect[1].cValue = vit;
			pMob[conn].MOB.Equip[14].stEffect[0].sValue = 20;
			pMob[conn].MOB.Equip[14].stEffect[2].cEffect = 5;
		}
		else
		{
			SendSay(npcIndex, g_pMessageStringTable[_NN_Cure_failed]);
			memset(&pMob[conn].MOB.Equip[14], 0, sizeof(STRUCT_ITEM));
		}


		pMob[conn].GetCurrentScore(conn);
		SendItem(conn, ITEM_PLACE_EQUIP, 14, &pMob[conn].MOB.Equip[14]);
		MountProcess(conn, &pMob[conn].MOB.Equip[14]);
		SendScore(conn);
		SendEtc(conn);

	} return;
#pragma endregion
#pragma region ZAKUM
	case ZAKUM:
	{
		char UserNameArea[128];

		int count = GetUserInArea(2180, 1160, 2296, 1270, UserNameArea);

		if (count < 1)
			SendSay(npcIndex, strFmt(g_pMessageStringTable[_NN_Zakum_Quest_empty]));
		else
			SendSay(npcIndex, strFmt(g_pMessageStringTable[_SD_Zakum_Quest_by_S_N], UserNameArea, count - 1));


	} break;
#pragma endregion
#pragma region AMU_MISTICO
	case AMU_MISTICO:
	{
		if (pMob[conn].extra.QuestInfo.Mortal.TerraMistica != 0 || pMob[conn].extra.ClassMaster != MORTAL)
		{
			SendSay(npcIndex, g_pMessageStringTable[_NN_Hurry_Helping_them]);
			break;
		}

		if (confirm == 0)
		{
			SendSay(npcIndex, g_pMessageStringTable[_NN_Monster_Attaking_Us_Help]);
			break;
		}

		/*  if (pMob[conn].Leader)
		{
		SendSay(npcIndex, g_pMessageStringTable[_NN_Party_Only]);
		break;
		}

		int partycont = 0;

		for (int i = 0; i < MAX_PARTY; i++)
		if (pMob[conn].PartyList[i] > 0 && pMob[conn].PartyList[i] < MAX_USER)
		partycont++;

		if (partycont == 0)
		{
		SendSay(npcIndex, g_pMessageStringTable[_NN_Party_Only]);
		break;
		}*/

		pMob[conn].extra.QuestInfo.Mortal.TerraMistica = 1;

		SendClientMessage(conn, g_pMessageStringTable[_NN_Get_Watching_Town_Mission]);
	} break;
#pragma endregion
#pragma region QUEST_COVEIRO
	case QUEST_COVEIRO:
	{
		if (pMob[conn].extra.ClassMaster != MORTAL) //&& pMob[conn].extra.ClassMaster != ARCH)
		{
			SendSay(npcIndex, g_pMessageStringTable[_NN_Level_Limit2]);
			break;
		}

		int minlevel = pMob[conn].extra.ClassMaster == MORTAL ? 39 : 39;
		int maxlevel = pMob[conn].extra.ClassMaster == MORTAL ? 116 : 116;

		if (pMob[conn].MOB.CurrentScore.Level < minlevel || pMob[conn].MOB.CurrentScore.Level >= maxlevel)
		{
			SendSay(npcIndex, g_pMessageStringTable[_NN_Level_limit]);
			break;
		}

		int i = 0;

		for (i = 0; i < pMob[conn].MaxCarry; i++)
		{
			if (pMob[conn].MOB.Carry[i].sIndex != 4038)
				continue;

			BASE_ClearItem(&pMob[conn].MOB.Carry[i]);
			SendItem(conn, ITEM_PLACE_CARRY, i, &pMob[conn].MOB.Carry[i]);
			break;
		}

		if (i == pMob[conn].MaxCarry)
		{
			SendSay(npcIndex, strFmt(g_pMessageStringTable[_SN_BRINGITEM], g_pItemList[4038].Name));
			break;
		}

		pMob[conn].QuestFlag = 1;
		DoTeleport(conn, 2398 + rand() % 5 - 3, 2105 + rand() % 5 - 3);
	} break;
#pragma endregion
#pragma region QUEST_BENCAODEDEUS
	case QUEST_BENCAODEDEUS:
	{
		if (pMob[conn].extra.ClassMaster != MORTAL)
		{
			SendSay(npcIndex, g_pMessageStringTable[_NN_Level_Limit2]);
			break;
		}

		int minlevel = pMob[conn].extra.ClassMaster == MORTAL ? 69 : 69;
		int maxlevel = pMob[conn].extra.ClassMaster == MORTAL ? 74 : 74;

		if (pMob[conn].MOB.CurrentScore.Level < minlevel || pMob[conn].MOB.CurrentScore.Level >= maxlevel)
		{
			SendSay(npcIndex, g_pMessageStringTable[_NN_Level_limit]);
			break;
		}

		DoTeleport(conn, 2651 + rand() % 5 - 3, 1984 + rand() % 5 - 3);

	} break;
#pragma endregion
#pragma region QUEST_JARDINEIRO
	case QUEST_JARDINEIRO:
	{
		if (pMob[conn].extra.ClassMaster != MORTAL) //&& pMob[conn].extra.ClassMaster != ARCH)
		{
			SendSay(npcIndex, g_pMessageStringTable[_NN_Level_Limit2]);
			break;
		}

		int minlevel = pMob[conn].extra.ClassMaster == MORTAL ? 115 : 115;
		int maxlevel = pMob[conn].extra.ClassMaster == MORTAL ? 190 : 190;

		if (pMob[conn].MOB.CurrentScore.Level < minlevel || pMob[conn].MOB.CurrentScore.Level >= maxlevel)
		{
			SendSay(npcIndex, g_pMessageStringTable[_NN_Level_limit]);
			break;
		}

		int i = 0;

		for (i = 0; i < pMob[conn].MaxCarry; i++)
		{
			if (pMob[conn].MOB.Carry[i].sIndex != 4039)
				continue;

			BASE_ClearItem(&pMob[conn].MOB.Carry[i]);
			SendItem(conn, ITEM_PLACE_CARRY, i, &pMob[conn].MOB.Carry[i]);
			break;
		}

		if (i == pMob[conn].MaxCarry)
		{
			SendSay(npcIndex, strFmt(g_pMessageStringTable[_SN_BRINGITEM], g_pItemList[4039].Name));
			break;
		}

		pMob[conn].QuestFlag = 2;
		DoTeleport(conn, 2234 + rand() % 5 - 3, 1714 + rand() % 5 - 3);
	} break;
#pragma region QUEST_KAIZEN
	case QUEST_KAIZEN:
	{
		if (pMob[conn].extra.ClassMaster != MORTAL)
		{
			SendSay(npcIndex, g_pMessageStringTable[_NN_Level_Limit2]);
			break;
		}

		int minlevel = pMob[conn].extra.ClassMaster == MORTAL ? 190 : 190;
		int maxlevel = pMob[conn].extra.ClassMaster == MORTAL ? 265 : 265;

		if (pMob[conn].MOB.CurrentScore.Level < minlevel || pMob[conn].MOB.CurrentScore.Level >= maxlevel)
		{
			SendSay(npcIndex, g_pMessageStringTable[_NN_Level_limit]);
			break;
		}

		int i = 0;

		for (i = 0; i < pMob[conn].MaxCarry; i++)
		{
			if (pMob[conn].MOB.Carry[i].sIndex != 4040)
				continue;

			BASE_ClearItem(&pMob[conn].MOB.Carry[i]);
			SendItem(conn, ITEM_PLACE_CARRY, i, &pMob[conn].MOB.Carry[i]);
			break;
		}

		if (i == pMob[conn].MaxCarry)
		{
			SendSay(npcIndex, strFmt(g_pMessageStringTable[_SN_BRINGITEM], g_pItemList[4040].Name));
			break;
		}

		pMob[conn].QuestFlag = 3;
		DoTeleport(conn, 464 + rand() % 5 - 3, 3902 + rand() % 5 - 3);
	} break;
#pragma endregion
#pragma region QUEST_HIDRA
	case QUEST_HIDRA:
	{
		if (pMob[conn].extra.ClassMaster != MORTAL) //&& pMob[conn].extra.ClassMaster != ARCH)
		{
			SendSay(npcIndex, g_pMessageStringTable[_NN_Level_Limit2]);
			break;
		}

		int minlevel = pMob[conn].extra.ClassMaster == MORTAL ? 265 : 265;
		int maxlevel = pMob[conn].extra.ClassMaster == MORTAL ? 320 : 320;

		if (pMob[conn].MOB.CurrentScore.Level < minlevel || pMob[conn].MOB.CurrentScore.Level >= maxlevel)
		{
			SendSay(npcIndex, g_pMessageStringTable[_NN_Level_limit]);
			break;
		}

		int i = 0;

		for (i = 0; i < pMob[conn].MaxCarry; i++)
		{
			if (pMob[conn].MOB.Carry[i].sIndex != 4041)
				continue;

			BASE_ClearItem(&pMob[conn].MOB.Carry[i]);
			SendItem(conn, ITEM_PLACE_CARRY, i, &pMob[conn].MOB.Carry[i]);
			break;
		}

		if (i == pMob[conn].MaxCarry)
		{
			SendSay(npcIndex, strFmt(g_pMessageStringTable[_SN_BRINGITEM], g_pItemList[4041].Name));
			break;
		}

		pMob[conn].QuestFlag = 4;
		DoTeleport(conn, 668 + rand() % 5 - 3, 3756 + rand() % 5 - 3);
	} break;
#pragma endregion
#pragma region QUEST_ELFOS
	case QUEST_ELFOS:
	{
		if (pMob[conn].extra.ClassMaster != MORTAL) //&& pMob[conn].extra.ClassMaster != ARCH)
		{
			SendSay(npcIndex, g_pMessageStringTable[_NN_Level_Limit2]);
			break;
		}

		int minlevel = pMob[conn].extra.ClassMaster == MORTAL ? 319 : 319;
		int maxlevel = pMob[conn].extra.ClassMaster == MORTAL ? 350 : 350;

		if (pMob[conn].MOB.CurrentScore.Level < minlevel || pMob[conn].MOB.CurrentScore.Level >= maxlevel)
		{
			SendSay(npcIndex, g_pMessageStringTable[_NN_Level_limit]);
			break;
		}

		int i = 0;

		for (i = 0; i < pMob[conn].MaxCarry; i++)
		{
			if (pMob[conn].MOB.Carry[i].sIndex != 4042)
				continue;

			BASE_ClearItem(&pMob[conn].MOB.Carry[i]);
			SendItem(conn, ITEM_PLACE_CARRY, i, &pMob[conn].MOB.Carry[i]);
			break;
		}

		if (i == pMob[conn].MaxCarry)
		{
			SendSay(npcIndex, strFmt(g_pMessageStringTable[_SN_BRINGITEM], g_pItemList[4042].Name));
			break;
		}

		pMob[conn].QuestFlag = 5;
		DoTeleport(conn, 1322 + rand() % 5 - 3, 4041 + rand() % 5 - 3);
	} break;
#pragma endregion
#pragma region JEFFI
	case JEFFI:
	{

		if (pMob[conn].MOB.Equip[13].sIndex == 447 || pMob[conn].MOB.Equip[13].sIndex == 692)
		{
			int price = 0;
			if (pMob[conn].MOB.Equip[13].sIndex == 447)
				price = 1000000;

			else
			{
				if (pMob[conn].MOB.Equip[13].sIndex != 692)
					break;

				price = 5000000;
			}

			if (pMob[conn].MOB.Coin >= price)
			{
				if (price == 1000000)
				{
					pMob[conn].MOB.Coin -= 1000000;
					pMob[conn].MOB.Equip[13].sIndex = rand() % 3 + 448;
				}
				else
				{
					pMob[conn].MOB.Coin -= 5000000;
					pMob[conn].MOB.Equip[13].sIndex = rand() % 3 + 693;
				}

				SendItem(conn, ITEM_PLACE_EQUIP, 13, &pMob[conn].MOB.Equip[13]);
				SendEtc(conn);
				SendSay(npcIndex, g_pMessageStringTable[_NN_Processing_Complete]);
				SetAffect(conn, 44, 20, 20);
				SendScore(conn);
				/*
				snprintf(temp, sizeof(temp), "etc,jeffi make reset50-100 name:%s level:%d", pMob[conn].MOB.MobName, pMob[conn].MOB.BaseScore.Level);
				SystemLog("-system", "-", pUser[conn].IP, temp);*/
			}
			else
			{
				if (price == 1000000)
					SendSay(npcIndex, g_pMessageStringTable[_NN_Need_1000000_Gold]);
				else
					SendSay(npcIndex, g_pMessageStringTable[_NN_Need_5000000_Gold]);
			}
		}
		else
		{
			int ixd = 0;

			for (ixd = 0; ixd < MAX_CARRY - 4; ixd++)
			{
				if (pMob[conn].MOB.Carry[ixd].sIndex != 0)
					continue;

				break;
			}

			if (ixd == MAX_CARRY)
			{
				SendClientMessage(conn, g_pMessageStringTable[_NN_You_Have_No_Space_To_Trade]);
				return;
			}

			int Ori = 0;
			int Lac = 0;

			for (int i = 0; i < pMob[conn].MaxCarry; i++)
			{
				if (pMob[conn].MOB.Carry[i].sIndex == 419)
					Ori += pMob[conn].MOB.Carry[i].stEffect[0].cEffect == 61 ? pMob[conn].MOB.Carry[i].stEffect[0].cValue : 1;

				if (pMob[conn].MOB.Carry[i].sIndex == 420)
					Lac += pMob[conn].MOB.Carry[i].stEffect[0].cEffect == 61 ? pMob[conn].MOB.Carry[i].stEffect[0].cValue : 1;
			}

			if (Ori >= 10 || Lac >= 10)
			{
				if (pMob[conn].MOB.Coin >= 1000000)
				{
					for (; Ori >= 10 || Lac >= 10;)
					{
						if (Ori >= 10)
						{
							Combine(conn, 419, 412);
							Ori -= 10;
						}
						if (Lac >= 10)
						{
							Combine(conn, 420, 413);
							Lac -= 10;
						}
					}
					SendSay(npcIndex, g_pMessageStringTable[_NN_Processing_Complete]);
					pMob[conn].MOB.Coin -= 1000000;
					SetAffect(conn, 44, 20, 20);
					SendScore(conn);
					SendCarry(conn);
					SendEtc(conn);
					/*
					snprintf(temp, sizeof(temp), "etc,jeffi make lac_ori name:%s level:%d", pMob[conn].MOB.MobName, pMob[conn].MOB.BaseScore.Level);
					SystemLog("-system", "-", pUser[conn].IP, temp);*/
				}
				else
					SendSay(npcIndex, g_pMessageStringTable[_NN_Need_1000000_Gold]);

			}
			else
				SendSay(npcIndex, g_pMessageStringTable[_NN_Need_10_Particle]);
		}

	} break;
#pragma endregion
#pragma region SHAMA
	case SHAMA:
	{
		int circle = pMob[conn].MOB.Equip[13].sIndex;

		int ncircle = circle;
		int circlemode = 0;

		if (circle != 448 && circle != 449 && circle != 450)
		{
			if (circle != 693 && circle != 694 && circle != 695)
			{
				SendSay(npcIndex, g_pMessageStringTable[_NN_Need_Pure_Divine]);
				break;
			}
			ncircle -= 693;
			circlemode = 2;
		}
		else
		{
			ncircle -= 448;
			circlemode = 1;
		}

		/*if (circlemode == 1 && pMob[conn].extra.QuestInfo.Circle == 1)
		{
		SendSay(npcIndex, g_pMessageStringTable[_NN_Youve_Done_It_Already]);
		break;
		}*/

		int specialreset = 50;

		if (circlemode == 2)
			specialreset = 100;

		int special = pMob[conn].MOB.SpecialBonus;

		for (int i = 0; i < 4; i++)
		{
			if (pMob[conn].MOB.BaseScore.Special[i] <= specialreset)
			{
				special += pMob[conn].MOB.BaseScore.Special[i];
				pMob[conn].MOB.BaseScore.Special[i] = 0;
			}
			else
			{
				special += specialreset;
				pMob[conn].MOB.BaseScore.Special[i] -= specialreset;
			}
		}

		pMob[conn].MOB.SpecialBonus = special;

		/*if (circlemode == 1)
			pMob[conn].extra.QuestInfo.Circle = 1;*/

		if (ncircle == 0)
			pMob[conn].MOB.LearnedSkill &= 0xFFFFFF00;
		pMob[conn].extra.SecLearnedSkill &= 0xFFFFFF00;

		if (ncircle == 1)
			pMob[conn].MOB.LearnedSkill &= 0xFFFF00FF;
		pMob[conn].extra.SecLearnedSkill &= 0xFFFF00FF;

		if (ncircle == 2)
			pMob[conn].MOB.LearnedSkill &= 0xFF00FFFF;
		pMob[conn].extra.SecLearnedSkill &= 0xFF00FFFF;

		BASE_GetBonusSkillPoint(&pMob[conn].MOB, &pMob[conn].extra);

		memset(&pMob[conn].MOB.Equip[13], 0, sizeof(STRUCT_ITEM));

		SendItem(conn, ITEM_PLACE_EQUIP, 13, &pMob[conn].MOB.Equip[13]);
		SendEtc(conn);
		SendSay(npcIndex, g_pMessageStringTable[_NN_Initialize_Skill]);
		SetAffect(conn, 44, 20, 20);
		/*
		snprintf(temp, sizeof(temp), "etc,device circle quest item:%d mode:%d type:%d", circle, circlemode, ncircle);
		SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);*/

		break;
	} break;
#pragma endregion
#pragma region KING
	case KING:
	{
		int ReiClan = pMob[npcIndex].MOB.Clan;

		int Clan = pMob[conn].MOB.Clan;
		int cLevel = pMob[conn].MOB.CurrentScore.Level;
		int CapeMode = 0;
		int TradingCape = 0;

		STRUCT_ITEM* Capa = &pMob[conn].MOB.Equip[15];

		if (Capa->sIndex == 543 || Capa->sIndex == 545)
			Clan = 7;

		if (Capa->sIndex == 544 || Capa->sIndex == 546)
			Clan = 8;

		if (Capa->sIndex == 734 || Capa->sIndex == 736)
			Clan = 7;

		if (Capa->sIndex == 735 || Capa->sIndex == 737)
			Clan = 8;

		if (Capa->sIndex == 3191 || Capa->sIndex == 3194)
			Clan = 7;

		if (Capa->sIndex == 3192 || Capa->sIndex == 3195)
			Clan = 8;

		if (Capa->sIndex == 3197 || Capa->sIndex == 1767)
			Clan = 7;

		if (Capa->sIndex == 3198 || Capa->sIndex == 1770)
			Clan = 8;

		if (Capa->sIndex == 543 || Capa->sIndex == 544 || Capa->sIndex == 1767 || Capa->sIndex == 1770 || Capa->sIndex == 3191 || Capa->sIndex == 3194 || Capa->sIndex == 3192 || Capa->sIndex == 3195 || Capa->sIndex == 3197 || Capa->sIndex == 3198)
			CapeMode = 2;

		if (Capa->sIndex == 545 || Capa->sIndex == 546 || Capa->sIndex == 549)
			CapeMode = 1;

		if (Capa->sIndex == 3193)
			CapeMode = 1;

		if (Capa->sIndex == 3196)
			CapeMode = 1;

		if (Capa->sIndex == 3196 || Capa->sIndex == 3193 || Capa->sIndex == 549 || Capa->sIndex == 3199)
			TradingCape = TRUE;

		if (Clan != 0 && Clan != ReiClan)
			break;

		int Saphire = 15;

		if (ReiClan == 7)
			Saphire = 4;

	/*	if (TradingCape == TRUE)
			Saphire = 150;*/

		if (TradingCape == TRUE && (pMob[conn].MOB.GuildLevel == 9 || pMob[conn].MOB.GuildLevel == 6))
			Saphire = 2000;

		if (confirm == 0)
		{

			SendMsgExp(conn, g_pMessageStringTable[_DN_Need_D_Sapphire], TNColor::Default, false);
			break;
		}

		if (pMob[conn].MOB.Equip[10].sIndex == 1742 && pMob[conn].MOB.Equip[11].sIndex >= 1760 && pMob[conn].MOB.Equip[11].sIndex <= 1763)
		{
			int sAgua = 0;
			int sTerra = 0;
			int sSol = 0;
			int sVento = 0;


			for (int i = 0; i < pMob[conn].MaxCarry; i++)
			{
				if (pMob[conn].MOB.Carry[i].sIndex == 5334)
					sAgua = 1;

				if (pMob[conn].MOB.Carry[i].sIndex == 5335)
					sTerra = 1;

				if (pMob[conn].MOB.Carry[i].sIndex == 5336)
					sSol = 1;

				if (pMob[conn].MOB.Carry[i].sIndex == 5337)
					sVento = 1;
			}

			if (sAgua == 1 && sTerra == 1 && sSol == 1 && sVento == 1)
			{
				for (int i = 0; i < pMob[conn].MaxCarry; i++)
				{
					if (pMob[conn].MOB.Carry[i].sIndex == 5334 && sAgua == 1)
					{
						memset(&pMob[conn].MOB.Carry[i], 0, sizeof(STRUCT_ITEM));

						pMob[conn].MOB.Carry[i].sIndex = 5338;

						SendItem(conn, ITEM_PLACE_CARRY, i, &pMob[conn].MOB.Carry[i]);
						sAgua = 0;
					}

					if (pMob[conn].MOB.Carry[i].sIndex == 5335 && sTerra == 1)
					{
						memset(&pMob[conn].MOB.Carry[i], 0, sizeof(STRUCT_ITEM));
						SendItem(conn, ITEM_PLACE_CARRY, i, &pMob[conn].MOB.Carry[i]);
						sTerra = 0;
					}

					if (pMob[conn].MOB.Carry[i].sIndex == 5336 && sSol == 1)
					{
						memset(&pMob[conn].MOB.Carry[i], 0, sizeof(STRUCT_ITEM));
						SendItem(conn, ITEM_PLACE_CARRY, i, &pMob[conn].MOB.Carry[i]);
						sSol = 0;
					}

					if (pMob[conn].MOB.Carry[i].sIndex == 5337 && sVento == 1)
					{
						memset(&pMob[conn].MOB.Carry[i], 0, sizeof(STRUCT_ITEM));
						SendItem(conn, ITEM_PLACE_CARRY, i, &pMob[conn].MOB.Carry[i]);
						sVento = 0;
					}
				}

				memset(&pMob[conn].MOB.Equip[10], 0, sizeof(STRUCT_ITEM));
				SendItem(conn, ITEM_PLACE_EQUIP, 10, &pMob[conn].MOB.Equip[10]);

				memset(&pMob[conn].MOB.Equip[11], 0, sizeof(STRUCT_ITEM));
				SendItem(conn, ITEM_PLACE_EQUIP, 11, &pMob[conn].MOB.Equip[11]);

				SendSay(npcIndex, g_pMessageStringTable[_NN_My_King_Bless1]);
				SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, strFmt("etc,king make ideal_stone name:%s level:%d", pMob[conn].MOB.MobName, pMob[conn].MOB.BaseScore.Level));

				break;
			}

			if (pMob[conn].extra.ClassMaster == MORTAL && pMob[conn].MOB.CurrentScore.Level >= 380 && pMob[conn].Mode != MOB_WAITDB)
			{
				if (EvolutionStatus < 1) {
					SendClientMessage(conn, "Criação de Arch Bloqueada");
					return;
				}

				int cls = pMob[conn].MOB.Equip[11].sIndex - 1760;

				MSG_DBCreateArchCharacter sm_ca;
				memset(&sm_ca, 0, sizeof(MSG_DBCreateArchCharacter));

				sm_ca.Size = sizeof(MSG_DBCreateArchCharacter);
				sm_ca.Type = _MSG_DBCreateArchCharacter;
				sm_ca.ID = conn;

				sm_ca.MobClass = cls;
				sm_ca.MortalFace = pMob[conn].extra.MortalFace;
				sm_ca.MortalSlot = pUser[conn].Slot;

				strncpy(sm_ca.MobName, pMob[conn].MOB.MobName, NAME_LENGTH);


				for (int i = 0; i < MAX_AFFECT; i++)
				{
					auto Core = pMob[conn].Affect[i];

					if (Core.Type <= 0) continue;

					if (Core.Type == 34 && Core.Level == TRUE)
					{
						sm_ca.isDivina = true;
						sm_ca.DivinaTimer = Core.Time;
						sm_ca.DivinaEndTimer = pMob[conn].extra.DivineEnd;
						break;
					}
				}		

				strncpy(sm_ca.MobName, pMob[conn].MOB.MobName, NAME_LENGTH);
				memset(&pMob[conn].MOB.Equip[10], 0, sizeof(STRUCT_ITEM));
				SendItem(conn, ITEM_PLACE_EQUIP, 10, &pMob[conn].MOB.Equip[10]);

				memset(&pMob[conn].MOB.Equip[11], 0, sizeof(STRUCT_ITEM));
				SendItem(conn, ITEM_PLACE_EQUIP, 11, &pMob[conn].MOB.Equip[11]);

				pMob[conn].Mode = MOB_WAITDB;
				DBServerSocket.SendOneMessage((char*)&sm_ca, sizeof(MSG_DBCreateArchCharacter));

				SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, strFmt("etc,king_arch name:%s class:%d mortalface:%d mortalslot:%d", pMob[conn].MOB.MobName, cls, pMob[conn].extra.MortalFace, pUser[conn].Slot));

				break;
			}
		}

		if (CapeMode >= 2)
		{
			if (ReiClan == 7)
				SendClientMessage(conn, g_pMessageStringTable[_NN_My_King_Bless1]);
			else
				SendClientMessage(conn, g_pMessageStringTable[_NN_My_King_Bless2]);

			break;
		}

		if ((pMob[conn].extra.ClassMaster == CELESTIAL || pMob[conn].extra.ClassMaster == CELESTIALCS || pMob[conn].extra.ClassMaster == SCELESTIAL || pMob[conn].extra.ClassMaster == HARDCORE) && (pMob[conn].MOB.Equip[15].sIndex == 3199 || pMob[conn].MOB.Equip[15].sIndex == 573))
		{
			int NumSepInv = 0;

			for (int i = 0; i < pMob[conn].MaxCarry; i++)
			{
				if (pMob[conn].MOB.Carry[i].sIndex == 697)
					NumSepInv += pMob[conn].MOB.Carry[i].stEffect[0].cEffect == 61 ? pMob[conn].MOB.Carry[i].stEffect[0].cValue : 1;

				else if (pMob[conn].MOB.Carry[i].sIndex == 4131)
					NumSepInv += 10;
			}

			if (NumSepInv < Saphire)
			{
				SendClientMessage(conn, strFmt(g_pMessageStringTable[_DN_Need_D_Sapphire], Saphire));
				break;
			}

			MSG_STANDARDPARM sm_us;
			memset(&sm_us, 0, sizeof(MSG_STANDARDPARM));

			sm_us.ID = 0;
			sm_us.Type = _MSG_DBUpdateSapphire;

			sm_us.Size = sizeof(MSG_STANDARDPARM);

			sm_us.Parm = ReiClan == 7;

			DBServerSocket.SendOneMessage((char*)&sm_us, sizeof(MSG_STANDARD));

			int slotsInv = 30;
			int SlotId = -1;
			if (pMob[conn].MOB.Carry[60].sIndex == 3467)
				slotsInv += 15;

			if (pMob[conn].MOB.Carry[61].sIndex == 3467)
				slotsInv += 15;

			for (int i = 0; i < slotsInv; i++)
			{
				if (pMob[conn].MOB.Carry[i].sIndex == 0) {
					SlotId = i;
					break;
				}
			}

			if (SlotId == -1) {
				SendClientMessage(conn, "Precisa haver espaço disponivel no inventário");
				return;
			}

			for (int i = 0; i < pMob[conn].MaxCarry && Saphire > 0; i++)
			{
				if (pMob[conn].MOB.Carry[i].sIndex == 697)
				{
					RemoveItem(conn, 697, Saphire);
					Saphire--;
				}

				else if (pMob[conn].MOB.Carry[i].sIndex == 4131)
				{
					memset(&pMob[conn].MOB.Carry[i], 0, sizeof(STRUCT_ITEM));
					SendItem(conn, ITEM_PLACE_CARRY, i, &pMob[conn].MOB.Carry[i]);

					if ((Saphire - 10) < 0)
						Saphire = 0;

					else
						Saphire -= 10;
				}
			}

			if ((pMob[conn].extra.ClassMaster == CELESTIAL || pMob[conn].extra.ClassMaster == CELESTIALCS || pMob[conn].extra.ClassMaster == SCELESTIAL || pMob[conn].extra.ClassMaster == HARDCORE))
			{
				if (ReiClan == 7)
				{
					pMob[conn].MOB.Equip[15].sIndex = 3197;
					SendItem(conn, ITEM_PLACE_EQUIP, 15, &pMob[conn].MOB.Equip[15]);
					SendClientMessage(conn, g_pMessageStringTable[_NN_My_King_Bless1]);
				}
				if (ReiClan == 8)
				{
					pMob[conn].MOB.Equip[15].sIndex = 3198;
					SendItem(conn, ITEM_PLACE_EQUIP, 15, &pMob[conn].MOB.Equip[15]);
					SendClientMessage(conn, g_pMessageStringTable[_NN_My_King_Bless2]);
				}
			}

			/*if ((pMob[conn].extra.ClassMaster == SCELESTIAL))
			{
				if (ReiClan == 7)
				{
					pMob[conn].MOB.Equip[15].sIndex = 1767;
					SendItem(conn, ITEM_PLACE_EQUIP, 15, &pMob[conn].MOB.Equip[15]);
					SendClientMessage(conn, g_pMessageStringTable[_NN_My_King_Bless1]);
				}
				if (ReiClan == 8)
				{
					pMob[conn].MOB.Equip[15].sIndex = 1770;
					SendItem(conn, ITEM_PLACE_EQUIP, 15, &pMob[conn].MOB.Equip[15]);
					SendClientMessage(conn, g_pMessageStringTable[_NN_My_King_Bless2]);
				}
			}*/

			int Guild = pMob[conn].MOB.Guild;
			int Group = ServerGroup;
			int Server = Guild / MAX_GUILD;
			int usGuild = Guild & MAX_GUILD - 1;

			if (Guild && pMob[conn].MOB.GuildLevel == 9)
			{
				MSG_GuildInfo sm_gi;
				memset(&sm_gi, 0, sizeof(MSG_GuildInfo));

				sm_gi.Type = _MSG_GuildInfo;
				sm_gi.Size = sizeof(MSG_GuildInfo);
				sm_gi.ID = conn;

				sm_gi.Guild = Guild;

				GuildInfo[Guild].Clan = ReiClan;
				GuildInfo[Guild].Fame = 0;

				sm_gi.GuildInfo = GuildInfo[Guild];

				auto& pc = cSQL::instance();
				sprintf(xQuery, "UPDATE `guilds` SET fame = '%d' WHERE `guild` = '%d'", 0, Guild);
				pc.wQuery(xQuery);

				DBServerSocket.SendOneMessage((char*)&sm_gi, sizeof(MSG_GuildInfo));
			}
			SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, strFmt("etc,get mantle %d - sapphire:%d", pMob[conn].MOB.Equip[15].sIndex, Saphire));

			break;
		}

		if (cLevel < 219)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Need_Level]);
			break;
		}

		if (CapeMode != 1 || cLevel >= 255)
		{
			int NumSepInv = 0;

			for (int i = 0; i < pMob[conn].MaxCarry; i++)
			{
				if (pMob[conn].MOB.Carry[i].sIndex == 697)
					NumSepInv += pMob[conn].MOB.Carry[i].stEffect[0].cEffect == 61 ? pMob[conn].MOB.Carry[i].stEffect[0].cValue : 1;

				else if (pMob[conn].MOB.Carry[i].sIndex == 4131)
					NumSepInv += 10;
			}

			if (NumSepInv < Saphire && pMob[conn].MOB.Equip[13].sIndex != 4081)
			{
				SendClientMessage(conn, strFmt(g_pMessageStringTable[_DN_Need_D_Sapphire], Saphire));
				break;
			}

			MSG_STANDARDPARM sm_us;
			memset(&sm_us, 0, sizeof(MSG_STANDARDPARM));

			sm_us.ID = 0;
			sm_us.Type = _MSG_DBUpdateSapphire;

			sm_us.Size = sizeof(MSG_STANDARDPARM);

			sm_us.Parm = ReiClan == 7;

			DBServerSocket.SendOneMessage((char*)&sm_us, sizeof(MSG_STANDARD));

			int slotsInv = 30;
			int SlotId = -1;
			if (pMob[conn].MOB.Carry[60].sIndex == 3467)
				slotsInv += 15;

			if (pMob[conn].MOB.Carry[61].sIndex == 3467)
				slotsInv += 15;

			for (int i = 0; i < slotsInv; i++)
			{
				if (pMob[conn].MOB.Carry[i].sIndex == 0) {
					SlotId = i;
					break;
				}
			}

			if (SlotId == -1) {
				SendClientMessage(conn, "Precisa haver espaço disponivel no inventário");
				return;
			}

			for (int i = 0; i < pMob[conn].MaxCarry && Saphire > 0 && pMob[conn].MOB.Equip[13].sIndex != 4081; i++)
			{
				if (pMob[conn].MOB.Carry[i].sIndex == 697)
				{
					RemoveItem(conn, 697, Saphire);
					Saphire--;
				}

				else if (pMob[conn].MOB.Carry[i].sIndex == 4131)
				{
					memset(&pMob[conn].MOB.Carry[i], 0, sizeof(STRUCT_ITEM));
					SendItem(conn, ITEM_PLACE_CARRY, i, &pMob[conn].MOB.Carry[i]);

					if ((Saphire - 10) < 0)
						Saphire = 0;

					else
						Saphire -= 10;
				}
			}

			if (pMob[conn].MOB.Equip[13].sIndex == 4081)
			{
				memset(&pMob[conn].MOB.Equip[13], 0, sizeof(STRUCT_ITEM));
				SendItem(conn, ITEM_PLACE_EQUIP, 13, &pMob[conn].MOB.Equip[13]);
			}

			if (CapeMode == 0)
			{
				if (Capa->sIndex != 548)
					memset(&pMob[conn].MOB.Equip[15], 0, sizeof(STRUCT_ITEM));

				if (ReiClan == 7)
					pMob[conn].MOB.Equip[15].sIndex = 545;
				else
					pMob[conn].MOB.Equip[15].sIndex = 546;
			}

			if (CapeMode == 1)
			{
				if (Capa->sIndex == 3193)
				{
					if (ReiClan == 7)
						pMob[conn].MOB.Equip[15].sIndex = 3191;
					else
						pMob[conn].MOB.Equip[15].sIndex = 3192;
				}

				else if (Capa->sIndex == 3196)
				{
					if (ReiClan == 7)
						pMob[conn].MOB.Equip[15].sIndex = 3194;
					else
						pMob[conn].MOB.Equip[15].sIndex = 3195;
				}

				else
				{
					if (Capa->sIndex != 549)
						memset(&pMob[conn].MOB.Equip[15], 0, sizeof(STRUCT_ITEM));

					if (ReiClan == 7)
						pMob[conn].MOB.Equip[15].sIndex = 543;
					else
						pMob[conn].MOB.Equip[15].sIndex = 544;
				}
			}


			SendItem(conn, ITEM_PLACE_EQUIP, 15, &pMob[conn].MOB.Equip[15]);

			if (ReiClan == 7)
				SendClientMessage(conn, g_pMessageStringTable[_NN_My_King_Bless1]);
			else
				SendClientMessage(conn, g_pMessageStringTable[_NN_My_King_Bless2]);

			int Guild = pMob[conn].MOB.Guild;
			int Group = ServerGroup;
			int Server = Guild / MAX_GUILD;
			int usGuild = Guild & MAX_GUILD - 1;

			if (Guild && pMob[conn].MOB.GuildLevel == 9)
			{
				MSG_GuildInfo sm_gi;
				memset(&sm_gi, 0, sizeof(MSG_GuildInfo));

				sm_gi.Type = _MSG_GuildInfo;
				sm_gi.Size = sizeof(MSG_GuildInfo);
				sm_gi.ID = conn;

				sm_gi.Guild = Guild;

				GuildInfo[Guild].Clan = ReiClan;

				sm_gi.GuildInfo = GuildInfo[Guild];

				DBServerSocket.SendOneMessage((char*)&sm_gi, sizeof(MSG_GuildInfo));
			}
			SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, strFmt("etc,get mantle %d - sapphire:%d", pMob[conn].MOB.Equip[15].sIndex, Saphire));

			break;
		}
		else
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Need_Level]);
			break;
		}
	} break;
#pragma endregion
#pragma region KINGDOM_BROKER
	case KINGDOM:
	{
		int Clan = pMob[conn].MOB.Clan;


		time_t rawtime;
		tm* timeinfo;

		time(&rawtime);
		timeinfo = localtime(&rawtime);
		/*timeinfo->tm_wday == 6 ||*/
		if (timeinfo->tm_wday == 0)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_NotEquip_Saturday]);
			break;
		}

		if (Clan != 7 && Clan != 8)
		{
			if (Clan == 7)
				SendClientMessage(conn, g_pMessageStringTable[_NN_My_King_Bless1]);
			else
				SendClientMessage(conn, g_pMessageStringTable[_NN_My_King_Bless2]);

			break;
		}

		if (confirm == 0)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Leaving_kingdom]);

			break;
		}
		int Saphire = 16;
		int NumSepInv = 0;

		for (int i = 0; i < pMob[conn].MaxCarry; i++)
		{
			if (pMob[conn].MOB.Carry[i].sIndex == 697)
				NumSepInv++;

			else if (pMob[conn].MOB.Carry[i].sIndex == 4131)
				NumSepInv += 10;
		}

		if (NumSepInv < Saphire)
		{
			SendClientMessage(conn, strFmt(g_pMessageStringTable[_DN_Need_D_Sapphire], Saphire));
			break;
		}



		for (int i = 0; i < pMob[conn].MaxCarry && Saphire > 0; i++)
		{
			if (pMob[conn].MOB.Carry[i].sIndex == 697)
			{
				memset(&pMob[conn].MOB.Carry[i], 0, sizeof(STRUCT_ITEM));
				SendItem(conn, ITEM_PLACE_CARRY, i, &pMob[conn].MOB.Carry[i]);
				Saphire--;
			}

			else if (pMob[conn].MOB.Carry[i].sIndex == 4131)
			{
				memset(&pMob[conn].MOB.Carry[i], 0, sizeof(STRUCT_ITEM));
				SendItem(conn, ITEM_PLACE_CARRY, i, &pMob[conn].MOB.Carry[i]);

				if ((Saphire - 10) < 0)
					Saphire = 0;

				else
					Saphire -= 10;
			}
		}


		if (pMob[conn].MOB.Equip[15].sIndex == 543 || pMob[conn].MOB.Equip[15].sIndex == 544)
			pMob[conn].MOB.Equip[15].sIndex = 549;

		if (pMob[conn].MOB.Equip[15].sIndex == 545 || pMob[conn].MOB.Equip[15].sIndex == 546)
			pMob[conn].MOB.Equip[15].sIndex = 548;

		if (pMob[conn].MOB.Equip[15].sIndex == 3191 || pMob[conn].MOB.Equip[15].sIndex == 3192)
			pMob[conn].MOB.Equip[15].sIndex = 3193;

		if (pMob[conn].MOB.Equip[15].sIndex == 3194 || pMob[conn].MOB.Equip[15].sIndex == 3195)
			pMob[conn].MOB.Equip[15].sIndex = 3196;

		if (pMob[conn].MOB.Equip[15].sIndex == 3197 || pMob[conn].MOB.Equip[15].sIndex == 3198)
			pMob[conn].MOB.Equip[15].sIndex = 3199;

		if (pMob[conn].MOB.Equip[15].sIndex == 1767 || pMob[conn].MOB.Equip[15].sIndex == 1770)
			pMob[conn].MOB.Equip[15].sIndex = 3199;

		if (Clan == 7)
			SendClientMessage(conn, g_pMessageStringTable[_NN_My_King_Bless1]);
		else
			SendClientMessage(conn, g_pMessageStringTable[_NN_My_King_Bless2]);

		SendItem(conn, ITEM_PLACE_EQUIP, 15, &pMob[conn].MOB.Equip[15]);

		pMob[conn].GetCurrentScore(conn);

		MSG_STANDARDPARM sm_scl;
		memset(&sm_scl, 0, sizeof(MSG_STANDARDPARM));

		sm_scl.Type = _MSG_SetClan;
		sm_scl.Size = sizeof(MSG_STANDARDPARM);
		sm_scl.ID = conn;
		sm_scl.Parm = pMob[conn].MOB.Clan;
		m->ClientTick = CurrentTime;

		GridMulticast(pMob[conn].TargetX, pMob[conn].TargetY, (MSG_STANDARD*)&sm_scl, 0);

		SendEquip(conn, conn);
		SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, "etc,remove mantle");
		break;

	} break;
#pragma endregion
#pragma region URNAMMU
	case URNAMMU:
	{
		if (pMob[conn].extra.ClassMaster != CELESTIALCS)
		{
			SendClientMessage(conn, strFmt(g_pMessageStringTable[_SN_NEEDCLASS], "Sub Celestial"));
			break;
		}
		if (pMob[conn].MOB.Equip[11].sIndex < 1760 || pMob[conn].MOB.Equip[11].sIndex > 1763)
		{
			SendClientMessage(conn, strFmt(g_pMessageStringTable[_SN_WANTEQUIPITEM], "o Sephirot da classe escolhida e ter 2000 de Fama"));
			break;
		}
		if (pMob[conn].extra.Fame < 2000)
		{
			SendClientMessage(conn, strFmt(g_pMessageStringTable[_DN_NEEDFAME], 2000));
			break;
		}
		SystemLog("-system", "-", 0, strFmt("etc,change SubClass class:%d to %d name:%s level:%d", pMob[conn].MOB.Class, pMob[conn].MOB.Equip[11].sIndex - 1760, pMob[conn].MOB.MobName, pMob[conn].MOB.BaseScore.Level));

		pMob[conn].extra.Fame -= 2000;

		pMob[conn].extra.SaveCelestial[1].Class = pMob[conn].MOB.Equip[11].sIndex - 1760;

		pMob[conn].extra.SaveCelestial[1].BaseScore.Str = BaseSIDCHM[pMob[conn].MOB.Class][0];
		pMob[conn].extra.SaveCelestial[1].BaseScore.Int = BaseSIDCHM[pMob[conn].MOB.Class][1];
		pMob[conn].extra.SaveCelestial[1].BaseScore.Dex = BaseSIDCHM[pMob[conn].MOB.Class][2];
		pMob[conn].extra.SaveCelestial[1].BaseScore.Con = BaseSIDCHM[pMob[conn].MOB.Class][3];

		memset(pMob[conn].extra.SaveCelestial[1].SkillBar1, 0, 4);
		memset(pMob[conn].extra.SaveCelestial[1].SkillBar2, 0, 16);

		int special = pMob[conn].extra.SaveCelestial[1].SpecialBonus;
		int specialreset = 55;

		for (int i = 0; i < 4; i++)
		{
			if (pMob[conn].extra.SaveCelestial[1].BaseScore.Special[i] <= 55)
			{
				special += pMob[conn].extra.SaveCelestial[1].BaseScore.Special[i];
				pMob[conn].extra.SaveCelestial[1].BaseScore.Special[i] = 0;
			}
			else
			{
				special += specialreset;
				pMob[conn].extra.SaveCelestial[1].BaseScore.Special[i] -= specialreset;
			}
		}

		pMob[conn].extra.SaveCelestial[1].SpecialBonus = special;

		pMob[conn].extra.SaveCelestial[1].LearnedSkill &= 0xFF000000;
		pMob[conn].extra.SecLearnedSkill &= 0xFF00FFFF;
		memset(&pMob[conn].MOB.Equip[11], 0, sizeof(STRUCT_ITEM));

		SendItem(conn, ITEM_PLACE_EQUIP, 11, &pMob[conn].MOB.Equip[11]);

		SendClientMessage(conn, g_pMessageStringTable[_NN_My_King_Bless1]);
		break;
	} break;
#pragma endregion
#pragma region UXMAL
	case UXMAL:
	{
		struct tm when;
		time_t now;
		time(&now);
		when = *localtime(&now);

		if (when.tm_min >= 0 && when.tm_min <= 15 || when.tm_min >= 20 && when.tm_min <= 35 || when.tm_min >= 40 && when.tm_min <= 55)
		{
			SendClientMessage(conn, "Quest em progresso. Volte nos minutos (16~19) - (36~39) - (56~59).");
			break;
		}
		if (pMob[conn].Leader != -1 && pMob[conn].Leader)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Party_Leader_Only]);
			break;
		}		

		/*if (pUser[conn].Ingame.CheckPista == TRUE)
		{
			SendClientMessage(conn, "Entrada Já esta registrada");
			break;
		}*/

		for (int k = 0; k < 7; k++) {
			for (int z = 0; z < 3; z++) {
				if (Pista[k].Party[z].LeaderID == conn) {
					SendClientMessage(conn, "Entrada Já esta registrada");
					return;
				}
			}
		}

		int i = 0;

		int sala = -1;

		for (i = 0; i < pMob[conn].MaxCarry; i++)
		{
			if (pMob[conn].MOB.Carry[i].sIndex != 5134)
				continue;

			sala = BASE_GetItemSanc(&pMob[conn].MOB.Carry[i]);

			if (sala > 6)
				sala = 6;

			break;
		}

		if (i == pMob[conn].MaxCarry)
		{
			SendClientMessage(conn, strFmt(g_pMessageStringTable[_SN_BRINGITEM], g_pItemList[5134].Name));
			break;
		}		

		int j = 0;

		for (j = 0; j < (sala == 0 ? 2 : 3); j++)
		{
			if (Pista[sala].Party[j].LeaderID == 0)
				break;
		}

		if (j == (sala == 0 ? 2 : 3))
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Night_Limited]);
			break;
		}

		for (int i = 0; i < MAX_PARTY; i++)
		{
			int partyconn = pMob[conn].PartyList[i];

			if (partyconn > 0 && partyconn < MAX_USER && pUser[partyconn].Mode == USER_PLAY)
			{
				if ((pMob[partyconn].TargetX / 128) == 25 && (pMob[partyconn].TargetY / 128) == 13)
				{
					pUser[partyconn].Ingame.CheckPista = TRUE;
				}
			}
		}
		SystemLog("-system", "-", 0, strFmt("etc,register RuneQuest type:%d conn:%d name:%s level:%d", sala, conn, pMob[conn].MOB.MobName, pMob[conn].MOB.BaseScore.Level));

		Pista[sala].Party[j].LeaderID = conn;
		Pista[sala].Party[j].MobCount = 0;
		Pista[sala].Party[j].Sala = sala;
		strncpy(Pista[sala].Party[j].LeaderName, pMob[conn].MOB.MobName, NAME_LENGTH);

		pUser[conn].Ingame.CheckPista = TRUE;
		BASE_ClearItem(&pMob[conn].MOB.Carry[i]);
		SendItem(conn, ITEM_PLACE_CARRY, i, &pMob[conn].MOB.Carry[i]);

		SendClientMessage(conn, g_pMessageStringTable[_NN_TicketUsed]);

	} break;
#pragma endregion
#pragma region ARZAN_DRAGON
	case ARZAN_DRAGON:
	{
		if (pMob[conn].MOB.Coin < 2000000)
		{
			SendSay(npcIndex, g_pMessageStringTable[_NN_snowimp_need_2MGold]);
			break;
		}

		int Materiais[5] = { 0, 0, 0, 0, 0 };

		for (int i = 0; i < pMob[conn].MaxCarry; i++)
		{
			if (pMob[conn].MOB.Carry[i].sIndex < 1721 || pMob[conn].MOB.Carry[i].sIndex > 1725)
				continue;

			int Id = pMob[conn].MOB.Carry[i].sIndex - 1721;

			Materiais[Id]++;
		}

		if (Materiais[0] < 10 || Materiais[1] < 2 || Materiais[2] < 4 || Materiais[3] < 1 || Materiais[4] < 1)
		{
			SendSay(npcIndex, g_pMessageStringTable[_NN_Need_5_materials]);
			break;
		}

		if (Materiais[0] > 10)
			Materiais[0] = 10;

		if (Materiais[1] > 2)
			Materiais[1] = 2;

		if (Materiais[2] > 4)
			Materiais[2] = 4;

		if (Materiais[3] > 1)
			Materiais[3] = 1;

		if (Materiais[4] > 1)
			Materiais[4] = 1;

		for (int x = 0; x < 5; x++)
		{
			for (int i = 0; i < pMob[conn].MaxCarry && Materiais[x] > 0; i++)
			{
				if (pMob[conn].MOB.Carry[i].sIndex == (1721 + x))
				{
					memset(&pMob[conn].MOB.Carry[i], 0, sizeof(STRUCT_ITEM));
					SendItem(conn, ITEM_PLACE_CARRY, i, &pMob[conn].MOB.Carry[i]);
					Materiais[x]--;
				}
			}
		}

		pMob[conn].MOB.Coin -= 2000000;
		SendEtc(conn);

		STRUCT_ITEM Item;

		memset(&Item, 0, sizeof(STRUCT_ITEM));

		Item.sIndex = 1726;
		Item.stEffect[0].cEffect = 43;
		Item.stEffect[0].cValue = rand() % 4;

		PutItem(conn, &Item);
		SendClientMessage(conn, g_pMessageStringTable[_NN_snowimp_create_success]);
	}break;
#pragma endregion
#pragma region GOLD_DRAGON
	case GOLD_DRAGON:
	{
		int Cristais[7] = { -1, -1, -1, -1, -1, -1, -1 };
		int NumCristal = 0;

		for (int i = 0; i < pMob[conn].MaxCarry; i++)
		{
			int ItemId = pMob[conn].MOB.Carry[i].sIndex;

			if (ItemId >= 421 && ItemId <= 427 && Cristais[ItemId - 421] == -1)
			{
				Cristais[ItemId - 421] = i;
				NumCristal++;
			}
		}

		if (Cristais[0] != -1 && Cristais[1] != -1 && Cristais[2] != -1 && Cristais[3] != -1 && Cristais[4] != -1 && Cristais[5] != -1 && Cristais[6] != -1)
		{
			if (pMob[conn].MOB.Equip[6].sIndex == 0)
			{
				SendSay(npcIndex, "Você precisa equipar a arma desejada");
				break;
			}

			int sanc = BASE_GetItemSanc(&pMob[conn].MOB.Equip[6]);

			if (sanc != 9)
			{
				SendSay(npcIndex, "Apenas armas +9 poderão ser modificadas");
				break;
			}

			if (pMob[conn].MOB.Coin < 50000000) {
				SendClientMessage(conn, "Você precisa pagar 50kk para modificar os atributos");
				return;
			}

			for (int i = 0; i < 7; i++)
				memset(&pMob[conn].MOB.Carry[Cristais[i]], 0, sizeof(STRUCT_ITEM));

			int _rand = rand() % 100;

			pMob[conn].MOB.Equip[6].sIndex;
			pMob[conn].MOB.Equip[6].stEffect[0].cEffect = 0;
			pMob[conn].MOB.Equip[6].stEffect[0].cValue = 0;

			pMob[conn].MOB.Equip[6].stEffect[1].cEffect = 0;
			pMob[conn].MOB.Equip[6].stEffect[1].cValue = 0;

			pMob[conn].MOB.Equip[6].stEffect[2].cEffect = 0;
			pMob[conn].MOB.Equip[6].stEffect[2].cValue = 0;


			STRUCT_ITEM* ItemMob = &pMob[conn].MOB.Equip[6];
			unsigned int Magic = BASE_GetItemAbility(ItemMob, EF_MAGIC);
			unsigned int Damage = BASE_GetItemAbility(ItemMob, EF_DAMAGE);
			unsigned int Level = BASE_GetItemAbility(ItemMob, EF_ITEMLEVEL);

			if (Level >= 6) {
				SendSay(npcIndex, "Apenas armas não Anct podem ser modificadas");
				break;
			}

			if (Damage) {
				pMob[conn].MOB.Equip[6].stEffect[1].cEffect = 2;

				if (_rand >= 0 && _rand <= 60)
					pMob[conn].MOB.Equip[6].stEffect[1].cValue = 63;
				if (_rand >= 61 && _rand <= 90)
					pMob[conn].MOB.Equip[6].stEffect[1].cValue = 63;
				if (_rand >= 91 && _rand <= 100)
					pMob[conn].MOB.Equip[6].stEffect[1].cValue = 72;
			}
			if (Magic) {
				pMob[conn].MOB.Equip[6].stEffect[1].cEffect = 60;

				if (_rand >= 0 && _rand <= 60)
					pMob[conn].MOB.Equip[6].stEffect[1].cValue = 28;
				if (_rand >= 61 && _rand <= 90)
					pMob[conn].MOB.Equip[6].stEffect[1].cValue = 28;
				if (_rand >= 91 && _rand <= 100)
					pMob[conn].MOB.Equip[6].stEffect[1].cValue = 32;
			}

			pMob[conn].MOB.Coin -= 50000000;
			SendClientMessage(conn, strFmt(g_pMessageStringTable[_SN_I_Wwill_Enchant_Your_Weapon], g_pItemList[pMob[conn].MOB.Equip[6].sIndex].Name));
			SendItem(conn, ITEM_PLACE_EQUIP, 6, &pMob[conn].MOB.Equip[6]);
			SendEquip(conn, 6);
			SendCarry(conn);
			SendEtc(conn);

		}
		else {
			SendClientMessage(conn, "Você precisa ter os 7 Cristais + 50kk para melhorar sua arma");
		}


	} break;
#pragma endregion
#pragma region EXPLOIT_LEADER
	case EXPLOIT_LEADER:
	{
		if (pMob[conn].extra.QuestInfo.Mortal.TerraMistica == 0)
		{
			
			BASE_GetLanguage(temp, _NN_Guard_This_Village);
			SendSay(npcIndex, temp);
			break;
		}

		if (pMob[conn].extra.QuestInfo.Mortal.TerraMistica != 2)
		{
			
			BASE_GetLanguage(temp, _SN_All_Villagers_Thanks_Your, pMob[conn].MOB.MobName);
			SendSay(npcIndex, temp);
			break;
		}

		int _Level = pMob[conn].MOB.CurrentScore.Level;
		int _ItemID = 551;
		int _ItemType = 1;

		if (_Level >= 50)
		{
			if (_Level >= 80)
			{
				_ItemID = rand() % 4 + 559;
				_ItemType = 0;
			}
			else
			{
				_ItemID = rand() % 4 + 555;
				_ItemType = 1;
			}
		}
		else
		{
			_ItemID = rand() % 4 + 551;
			_ItemType = 1;
		}

		STRUCT_ITEM Item;
		memset(&Item, 0, sizeof(STRUCT_ITEM));

		Item.sIndex = _ItemID;

		int _rd = rand() % 10;

		int bonustype = g_pBonusType[_rd];

		int bonusvalue1 = g_pBonusValue[_rd][_ItemType][0];
		int bonusvalue2 = g_pBonusValue[_rd][_ItemType][1];
		int fvalue = bonusvalue2 + 1 - bonusvalue1;
		int tvalue = rand() % fvalue + bonusvalue1;

		Item.stEffect[0].cEffect = 43;

		for (int z = 1; z <= 2; ++z)
		{
			int rd_ = rand() % 8;

			if (rd_)
			{
				switch (rd_)
				{
				case 1:
					Item.stEffect[z].cEffect = 2;
					Item.stEffect[z].cValue = rand() % 21 + 5;
					break;

				case 2:
					Item.stEffect[z].cEffect = 26;
					Item.stEffect[z].cValue = rand() % 11 + 5;
					break;

				case 3:
					Item.stEffect[z].cEffect = 5;
					Item.stEffect[z].cValue = rand() % 51 + 20;
					break;

				case 4:
					Item.stEffect[z].cEffect = 60;
					Item.stEffect[z].cValue = rand() % 7 + 2;
					break;

				case 5:
					Item.stEffect[z].cEffect = 7;
					Item.stEffect[z].cValue = rand() % 16 + 5;
					break;

				case 6:
					Item.stEffect[z].cEffect = 8;
					Item.stEffect[z].cValue = rand() % 16 + 5;
					break;

				case 7:
					Item.stEffect[z].cEffect = 9;
					Item.stEffect[z].cValue = rand() % 16 + 5;
					break;
				}
			}
			else
			{
				Item.stEffect[z].cEffect = 4;
				Item.stEffect[z].cValue = rand() % 41 + 20;
			}
		}

		PutItem(conn, &Item);

		pMob[conn].extra.QuestInfo.Mortal.TerraMistica = 3;

		SendClientMessage(conn, g_pMessageStringTable[_NN_Watching_Town_Awarded]);
	} break;
#pragma endregion
#pragma region MESTREHAB
	case MESTREHAB:
	{

		if (confirm == 0)
		{
			SendClientMessage(conn, strFmt(g_pMessageStringTable[_DN_Want_Stat_Init], StatSapphire));

			return;
		}

		for (int i = 1; i < 8; i++)
		{
			if (pMob[conn].MOB.Equip[i].sIndex)
			{
				SendClientMessage(conn, strFmt(g_pMessageStringTable[_NN_Cant_with_armor], StatSapphire));

				return;
			}
		}

		int NumSappInv = 0;

		int RetornoHab = 0;

		for (int i = 0; i < pMob[conn].MaxCarry; i++)
		{
			if (pMob[conn].MOB.Carry[i].sIndex == 697)
				NumSappInv++;

			else if (pMob[conn].MOB.Carry[i].sIndex == 4131)
				NumSappInv += 10;

			else if (pMob[conn].MOB.Carry[i].sIndex == 3336)
				RetornoHab = 1;
		}

		if (NumSappInv < StatSapphire && RetornoHab == 0)
		{
			SendClientMessage(conn, strFmt(g_pMessageStringTable[_DN_Need_D_Sapphire2], StatSapphire));
			return;
		}

		if (RetornoHab == 1)
		{
			for (int i = 0; i < pMob[conn].MaxCarry; i++)
			{
				if (pMob[conn].MOB.Carry[i].sIndex == 3336)
				{
					memset(&pMob[conn].MOB.Carry[i], 0, sizeof(STRUCT_ITEM));
					SendItem(conn, ITEM_PLACE_CARRY, i, &pMob[conn].MOB.Carry[i]);

					break;
				}
			}

			goto DiretoReset;
		}
		if (NumSappInv > StatSapphire)
			NumSappInv = StatSapphire;

		for (int i = 0; i < pMob[conn].MaxCarry && NumSappInv > 0; i++)
		{
			if (pMob[conn].MOB.Carry[i].sIndex == 697)
			{
				memset(&pMob[conn].MOB.Carry[i], 0, sizeof(STRUCT_ITEM));
				SendItem(conn, ITEM_PLACE_CARRY, i, &pMob[conn].MOB.Carry[i]);

				NumSappInv--;
			}

			else if (pMob[conn].MOB.Carry[i].sIndex == 4131 && NumSappInv >= 10)
			{
				memset(&pMob[conn].MOB.Carry[i], 0, sizeof(STRUCT_ITEM));
				SendItem(conn, ITEM_PLACE_CARRY, i, &pMob[conn].MOB.Carry[i]);

				NumSappInv -= 10;
			}
		}
	DiretoReset:

		int cls = pMob[conn].MOB.Class;

		if (cls < 0 || cls > 3)
			return;

		int resetp = 100;
		int score = pMob[conn].MOB.ScoreBonus;
		int str = pMob[conn].MOB.BaseScore.Str - BaseSIDCHM[cls][0];
		int _int = pMob[conn].MOB.BaseScore.Int - BaseSIDCHM[cls][1];
		int dex = pMob[conn].MOB.BaseScore.Dex - BaseSIDCHM[cls][2];
		int con = pMob[conn].MOB.BaseScore.Con - BaseSIDCHM[cls][3];

		if (str <= resetp)
		{
			pMob[conn].MOB.BaseScore.Str -= str;
			score += str;
		}
		else
		{
			pMob[conn].MOB.BaseScore.Str -= resetp;
			score += resetp;
		}

		if (_int <= resetp)
		{
			pMob[conn].MOB.BaseScore.Int -= _int;
			score += _int;
		}
		else
		{
			pMob[conn].MOB.BaseScore.Int -= resetp;
			score += resetp;
		}

		if (dex <= resetp)
		{
			pMob[conn].MOB.BaseScore.Dex -= dex;
			score += dex;
		}

		else
		{
			pMob[conn].MOB.BaseScore.Dex -= resetp;
			score += resetp;
		}

		if (con <= resetp)
		{
			pMob[conn].MOB.BaseScore.Con -= con;
			score += con;
		}
		else
		{
			pMob[conn].MOB.BaseScore.Con -= resetp;
			score += resetp;
		}

		BASE_GetBonusScorePoint(&pMob[conn].MOB, &pMob[conn].extra);
		BASE_GetHpMp(&pMob[conn].MOB, &pMob[conn].extra);

		SetAffect(conn, 44, 20, 20);

		SendScore(conn);
		SendEtc(conn);
		SendClientMessage(conn, "Pontos resetados.");

	} break;
#pragma endregion
#pragma region TREINADORNEWBIE1
	case TREINADORNEWBIE1:
	{
		if (pMob[conn].extra.ClassMaster != MORTAL || pMob[conn].MOB.CurrentScore.Level >= FREEEXP || pMob[conn].extra.QuestInfo.Mortal.Newbie != 0)
		{
			SendSay(npcIndex, g_pMessageStringTable[_NN_NewbieQuest_Already1]);
			break;
		}
		int i = 0;

		for (i = 0; i < pMob[conn].MaxCarry; i++)
		{
			if (pMob[conn].MOB.Carry[i].sIndex == 451)
				break;
		}

		if (i == pMob[conn].MaxCarry)
		{
			SendSay(npcIndex, g_pMessageStringTable[_NN_NewbieQuest_Cheerup1]);
			break;
		}

		pMob[conn].extra.QuestInfo.Mortal.Newbie = 1;

		SendClientMessage(conn, "Sua recompensa chegou!");

		STRUCT_ITEM Item;
		memset(&Item, 0, sizeof(STRUCT_ITEM));

		//Pot com 120 (M)
		Item.sIndex = 401;
		Item.stEffect[0].cEffect = 61;
		Item.stEffect[0].cValue = 60;

		PutItem(conn, &Item);

		SendScore(conn);
		SendCarry(conn);
	} break;
#pragma endregion
#pragma region TREINADORNEWBIE2
	case TREINADORNEWBIE2:
	{
		if (pMob[conn].extra.ClassMaster != MORTAL || pMob[conn].MOB.CurrentScore.Level >= FREEEXP || pMob[conn].extra.QuestInfo.Mortal.Newbie != 1)
		{
			SendSay(npcIndex, g_pMessageStringTable[_NN_NewbieQuest_Already2]);
			break;
		}
		int i = 0;

		for (i = 0; i < pMob[conn].MaxCarry; i++)
		{
			if (pMob[conn].MOB.Carry[i].sIndex == 452)
				break;
		}

		if (i == pMob[conn].MaxCarry)
		{
			SendSay(npcIndex, g_pMessageStringTable[_NN_NewbieQuest_Cheerup2]);
			break;
		}

		pMob[conn].extra.QuestInfo.Mortal.Newbie++;

		SendClientMessage(conn, g_pMessageStringTable[_NN_NewbieQuest_Reward2]);

		int WeaponId = pMob[conn].MOB.Equip[6].sIndex;
		int WeaponId2 = pMob[conn].MOB.Equip[7].sIndex;
		int cls = pMob[conn].MOB.Class;

		if (WeaponId > 0 && WeaponId < MAX_ITEMLIST)
		{
			int _rand = rand() % 100;

			pMob[conn].MOB.Equip[6].stEffect[0].cEffect = 43;
			pMob[conn].MOB.Equip[6].stEffect[0].cValue = 7;

			pMob[conn].MOB.Equip[6].stEffect[1].cEffect = 0;
			pMob[conn].MOB.Equip[6].stEffect[1].cValue = 0;

			pMob[conn].MOB.Equip[6].stEffect[2].cEffect = 0;
			pMob[conn].MOB.Equip[6].stEffect[2].cValue = 0;


			STRUCT_ITEM* ItemMob = &pMob[conn].MOB.Equip[6];
			unsigned int Magic = BASE_GetItemAbility(ItemMob, EF_MAGIC);
			unsigned int Damage = BASE_GetItemAbility(ItemMob, EF_DAMAGE);
			unsigned int Level = BASE_GetItemAbility(ItemMob, EF_ITEMLEVEL);

			if (Level >= 4) {
				SendSay(npcIndex, "Apenas armas Sephira");
				break;
			}

			if (Damage) {
				pMob[conn].MOB.Equip[6].stEffect[1].cEffect = 2;

				if (_rand >= 0 && _rand <= 60)
					pMob[conn].MOB.Equip[6].stEffect[1].cValue = 45;
				if (_rand >= 61 && _rand <= 90)
					pMob[conn].MOB.Equip[6].stEffect[1].cValue = 45;
				if (_rand >= 91 && _rand <= 100)
					pMob[conn].MOB.Equip[6].stEffect[1].cValue = 45;
			}
			if (Magic) {
				pMob[conn].MOB.Equip[6].stEffect[1].cEffect = 60;

				if (_rand >= 0 && _rand <= 60)
					pMob[conn].MOB.Equip[6].stEffect[1].cValue = 20;
				if (_rand >= 61 && _rand <= 90)
					pMob[conn].MOB.Equip[6].stEffect[1].cValue = 20;
				if (_rand >= 91 && _rand <= 100)
					pMob[conn].MOB.Equip[6].stEffect[1].cValue = 20;
			}

			SendClientMessage(conn, strFmt(g_pMessageStringTable[_SN_I_Wwill_Enchant_Your_Weapon], g_pItemList[pMob[conn].MOB.Equip[6].sIndex].Name));
			SendItem(conn, ITEM_PLACE_EQUIP, 6, &pMob[conn].MOB.Equip[6]);
			SendEquip(conn, 6);

		}
		if (WeaponId2 > 0 && WeaponId2 < MAX_ITEMLIST)
		{
			int _rand = rand() % 100;

			pMob[conn].MOB.Equip[7].stEffect[0].cEffect = 43;
			pMob[conn].MOB.Equip[7].stEffect[0].cValue = 7;

			pMob[conn].MOB.Equip[7].stEffect[1].cEffect = 0;
			pMob[conn].MOB.Equip[7].stEffect[1].cValue = 0;

			pMob[conn].MOB.Equip[7].stEffect[2].cEffect = 0;
			pMob[conn].MOB.Equip[7].stEffect[2].cValue = 0;


			STRUCT_ITEM* ItemMob = &pMob[conn].MOB.Equip[7];
			unsigned int Magic = BASE_GetItemAbility(ItemMob, EF_MAGIC);
			unsigned int Damage = BASE_GetItemAbility(ItemMob, EF_DAMAGE);
			unsigned int Level = BASE_GetItemAbility(ItemMob, EF_ITEMLEVEL);

			if (Level >= 4) {
				SendSay(npcIndex, "Apenas armas Sephira");
				break;
			}

			if (Damage) {
				pMob[conn].MOB.Equip[7].stEffect[1].cEffect = 2;

				if (_rand >= 0 && _rand <= 60)
					pMob[conn].MOB.Equip[7].stEffect[1].cValue = 45;
				if (_rand >= 61 && _rand <= 90)
					pMob[conn].MOB.Equip[7].stEffect[1].cValue = 45;
				if (_rand >= 91 && _rand <= 100)
					pMob[conn].MOB.Equip[7].stEffect[1].cValue = 45;
			}
			if (Magic) {
				pMob[conn].MOB.Equip[7].stEffect[1].cEffect = 60;

				if (_rand >= 0 && _rand <= 60)
					pMob[conn].MOB.Equip[7].stEffect[1].cValue = 20;
				if (_rand >= 61 && _rand <= 90)
					pMob[conn].MOB.Equip[7].stEffect[1].cValue = 20;
				if (_rand >= 91 && _rand <= 100)
					pMob[conn].MOB.Equip[7].stEffect[1].cValue = 20;
			}

			SendClientMessage(conn, strFmt(g_pMessageStringTable[_SN_I_Wwill_Enchant_Your_Weapon], g_pItemList[pMob[conn].MOB.Equip[7].sIndex].Name));
			SendItem(conn, ITEM_PLACE_EQUIP, 7, &pMob[conn].MOB.Equip[7]);
			SendEquip(conn, 7);

		}

		SendScore(conn);
		SendCarry(conn);
	} break;
#pragma endregion
#pragma region TREINADORNEWBIE3
	case TREINADORNEWBIE3:
	{
		if (pMob[conn].extra.ClassMaster != MORTAL || pMob[conn].MOB.CurrentScore.Level >= FREEEXP || pMob[conn].extra.QuestInfo.Mortal.Newbie != 2)
		{
			SendSay(npcIndex, g_pMessageStringTable[_NN_NewbieQuest_Already3]);
			break;
		}
		int i = 0;

		for (i = 0; i < pMob[conn].MaxCarry; i++)
		{
			if (pMob[conn].MOB.Carry[i].sIndex == 453)
				break;
		}

		if (i == pMob[conn].MaxCarry)
		{
			SendSay(npcIndex, g_pMessageStringTable[_NN_NewbieQuest_Cheerup3]);
			break;
		}

		pMob[conn].extra.QuestInfo.Mortal.Newbie++;

		SendClientMessage(conn, g_pMessageStringTable[_NN_NewbieQuest_Reward3]);

		for (int j = 1; j < 6; j++)
		{
			int itemId = pMob[conn].MOB.Equip[j].sIndex;

			if (itemId > 0 && itemId < MAX_ITEMLIST)
			{
				int ReqLv = g_pItemList[itemId].ReqLvl;

				pMob[conn].MOB.Equip[j].stEffect[0].cEffect = 43;
				pMob[conn].MOB.Equip[j].stEffect[0].cValue = 6;

				SetItemBonus(&pMob[conn].MOB.Equip[j], 50 + ReqLv, 1, 0);
				SendItem(conn, ITEM_PLACE_EQUIP, j, &pMob[conn].MOB.Equip[j]);
			}
		}
		SendScore(conn);
		SendCarry(conn);

		//Classe A - Roger
		STRUCT_ITEM Item;
		memset(&Item, 0, sizeof(STRUCT_ITEM));

		Item.sIndex = 4016;
		Item.stEffect[0].cEffect = 61;
		Item.stEffect[0].cValue = 100;

		PutItem(conn, &Item);

	} break;
#pragma endregion
#pragma region COMP_SEPHI
	case COMP_SEPHI:
	{
		if (confirm == 0)
		{
			SendSay(npcIndex, g_pMessageStringTable[_NN_Soul_n_8_Sephera]);
			break;
		}
		int Pedras = 0;

		for (int j = 0; j < 8; j++)
		{
			for (int i = 0; i < pMob[conn].MaxCarry; i++)
			{
				if (pMob[conn].MOB.Carry[i].sIndex != (1744 + j))
					continue;

				Pedras++;
				break;
			}
		}

		if (Pedras < 8)
		{
			SendSay(npcIndex, g_pMessageStringTable[_NN_Need_8_Sephera]);
			break;
		}
		if (pMob[conn].MOB.Coin < 30000000)
		{
			SendSay(npcIndex, g_pMessageStringTable[_NN_Need_8_Sephera]);
			break;
		}

		pMob[conn].MOB.Coin -= 30000000;
		SendEtc(conn);

		for (int j = 0; j < 8; j++)
		{
			for (int i = 0; i < pMob[conn].MaxCarry; i++)
			{
				if (pMob[conn].MOB.Carry[i].sIndex != (1744 + j))
					continue;

				BASE_ClearItem(&pMob[conn].MOB.Carry[i]);
				SendItem(conn, ITEM_PLACE_CARRY, i, &pMob[conn].MOB.Carry[i]);

				Pedras--;
				break;
			}
		}

		STRUCT_ITEM Item;

		memset(&Item, 0, sizeof(STRUCT_ITEM));


		if (pMob[npcIndex].MOB.Exp == 994)
			Item.sIndex = 1762;

		else if (pMob[npcIndex].MOB.Exp == 995)
			Item.sIndex = 1761;

		else if (pMob[npcIndex].MOB.Exp == 996)
			Item.sIndex = 1763;

		else if (pMob[npcIndex].MOB.Exp == 997)
			Item.sIndex = 1760;

		PutItem(conn, &Item);
		SendSay(npcIndex, g_pMessageStringTable[_NN_Sepherot_created]);


	} break;
#pragma endregion
#pragma region CAPAVERDE_TELEPORT
	case CAPAVERDE_TELEPORT:
	{
		if (pMob[conn].extra.ClassMaster != MORTAL)
		{
			SendSay(npcIndex, g_pMessageStringTable[_NN_Level_Limit2]);
			break;
		}

		if (pMob[conn].MOB.CurrentScore.Level < 99 || pMob[conn].MOB.CurrentScore.Level >= 150)
		{
			SendSay(npcIndex, g_pMessageStringTable[_NN_Level_limit]);
			break;
		}

		DoTeleport(conn, 2245 + rand() % 5 - 3, 1576 + rand() % 5 - 3);
	} break;
#pragma endregion
#pragma region CAPAVERDE_TRADE
	case CAPAVERDE_TRADE:
	{
		if (pMob[conn].extra.ClassMaster != MORTAL)
		{
			SendSay(npcIndex, g_pMessageStringTable[_NN_Level_Limit2]);
			break;
		}

		if (pMob[conn].MOB.CurrentScore.Level < 99 || pMob[conn].MOB.CurrentScore.Level >= 150)
		{
			SendSay(npcIndex, g_pMessageStringTable[_NN_Level_limit]);
			break;
		}

		if (pMob[conn].MOB.Equip[13].sIndex != 4080)
		{
			SendSay(npcIndex, strFmt(g_pMessageStringTable[_SN_WANTEQUIPITEM], g_pItemList[4080].Name));
			break;
		}

		if (pMob[conn].MOB.Equip[15].sIndex != 0)
		{
			SendSay(npcIndex, g_pMessageStringTable[_NN_Youve_Done_It_Already]);
			break;
		}

		BASE_ClearItem(&pMob[conn].MOB.Equip[13]);
		SendItem(conn, ITEM_PLACE_EQUIP, 13, &pMob[conn].MOB.Equip[13]);

		memset(&pMob[conn].MOB.Equip[15], 0, sizeof(STRUCT_ITEM));
		pMob[conn].MOB.Equip[15].sIndex = 4006;

		SendItem(conn, ITEM_PLACE_EQUIP, 15, &pMob[conn].MOB.Equip[15]);

		pMob[conn].GetCurrentScore(conn);
		SendScore(conn);

		SendEmotion(conn, 14, 3);
	} break;
#pragma endregion
#pragma region MOLARGARGULA
	case MOLARGARGULA:
	{
		if (pMob[conn].extra.ClassMaster != MORTAL)
		{
			SendSay(npcIndex, g_pMessageStringTable[_NN_Level_Limit2]);
			break;
		}

		if (pMob[conn].MOB.CurrentScore.Level < 199 || pMob[conn].MOB.CurrentScore.Level >= 254)
		{
			SendSay(npcIndex, g_pMessageStringTable[_NN_Level_limit]);
			break;
		}


		DoTeleport(conn, 817 + rand() % 5 - 3, 4062 + rand() % 5 - 3);
	} break;
#pragma endregion
#pragma region BLACKORACLE
	case BLACKORACLE:
	{
		int i = 0;

		for (i = 0; i < pMob[conn].MaxCarry; i++)
		{
			if (pMob[conn].MOB.Carry[i].sIndex == 1740)
				break;
		}

		if (i == pMob[conn].MaxCarry)
		{
			SendSay(npcIndex, g_pMessageStringTable[_NN_Set_Soul]);
			break;
		}

		if (pMob[conn].MOB.Carry[i + 1].sIndex != 1741)
		{
			SendSay(npcIndex, g_pMessageStringTable[_NN_Set_Soul]);
			break;
		}


		int NumSepInv = 0;
		int j = 0;

		for (j = 0; j < pMob[conn].MaxCarry; j++)
		{
			if (pMob[conn].MOB.Carry[j].sIndex == 697)
				NumSepInv++;

			else if (pMob[conn].MOB.Carry[j].sIndex == 4131)
				NumSepInv += 10;
		}

		if (NumSepInv < 10)
		{
			SendSay(npcIndex, strFmt(g_pMessageStringTable[_DN_Need_D_Sapphire], 10));
			break;
		}
		int Saphire = 10;

		for (j = 0; j < pMob[conn].MaxCarry && Saphire > 0; j++)
		{
			if (pMob[conn].MOB.Carry[j].sIndex == 697)
			{
				memset(&pMob[conn].MOB.Carry[j], 0, sizeof(STRUCT_ITEM));
				SendItem(conn, ITEM_PLACE_CARRY, j, &pMob[conn].MOB.Carry[j]);
				Saphire--;
			}

			else if (pMob[conn].MOB.Carry[j].sIndex == 4131)
			{
				memset(&pMob[conn].MOB.Carry[j], 0, sizeof(STRUCT_ITEM));
				SendItem(conn, ITEM_PLACE_CARRY, j, &pMob[conn].MOB.Carry[j]);

				if ((Saphire - 10) < 0)
					Saphire = 0;

				else
					Saphire -= 10;
			}
		}

		memset(&pMob[conn].MOB.Carry[i], 0, sizeof(STRUCT_ITEM));
		SendItem(conn, ITEM_PLACE_CARRY, i, &pMob[conn].MOB.Carry[i]);

		memset(&pMob[conn].MOB.Carry[i + 1], 0, sizeof(STRUCT_ITEM));
		SendItem(conn, ITEM_PLACE_CARRY, i + 1, &pMob[conn].MOB.Carry[i + 1]);

		STRUCT_ITEM Item;
		memset(&Item, 0, sizeof(STRUCT_ITEM));

		Item.sIndex = 1742;
		PutItem(conn, &Item);

	} break;
#pragma endregion
#pragma region QUEST_CAPAREAL
	case QUEST_CAPAREAL:
	{
		if (pMob[conn].extra.ClassMaster != MORTAL)
		{
			SendSay(npcIndex, g_pMessageStringTable[_NN_Level_Limit2]);
			break;
		}

		if (pMob[conn].MOB.CurrentScore.Level < 199 || pMob[conn].MOB.CurrentScore.Level >= 254)
		{
			SendSay(npcIndex, g_pMessageStringTable[_NN_Level_limit]);
			break;
		}

		DoTeleport(conn, 1740 + rand() % 5 - 3, 1725 + rand() % 5 - 3);
	} break;
#pragma endregion
#pragma region CARBUNCLE_WIND
	case CARBUNCLE_WIND:
	{
		if (pMob[conn].extra.ClassMaster != MORTAL)
		{
			SendSay(npcIndex, g_pMessageStringTable[_NN_Level_Limit2]);
			break;
		}

		if (pMob[conn].MOB.CurrentScore.Level >= 116)
		{
			SendSay(npcIndex, g_pMessageStringTable[_NN_Level_Limit2]);
			break;
		}
		SetAffect(conn, 41, 600, 1200);
		SetAffect(conn, 43, 600, 1200);
		SetAffect(conn, 44, 600, 1200);
		SetAffect(conn, 45, 600, 1200);


		pMob[conn].GetCurrentScore(conn);
		SendScore(conn);
	} break;
#pragma endregion
#pragma region PERZEN
	case PERZEN:
	{
		int i = 0;

		for (i = 0; i < pMob[conn].MaxCarry; i++)
		{
			if (pMob[conn].MOB.Carry[i].sIndex != pMob[npcIndex].MOB.Carry[0].sIndex)
				continue;

			break;
		}

		if (i == pMob[conn].MaxCarry)
		{
			SendSay(npcIndex, strFmt(g_pMessageStringTable[_SN_BRINGITEM], g_pItemList[pMob[npcIndex].MOB.Carry[0].sIndex].Name));
			break;
		}

		BASE_ClearItem(&pMob[conn].MOB.Carry[i]);

		pMob[conn].MOB.Carry[i].sIndex = pMob[npcIndex].MOB.Carry[1].sIndex;

		BASE_SetItemDate(&pMob[conn].MOB.Carry[i], 30);

		SendItem(conn, ITEM_PLACE_CARRY, i, &pMob[conn].MOB.Carry[i]);
		SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, strFmt("etc,premium mount started type:%d name:%s conn:%d", pMob[npcIndex].MOB.Carry[1].sIndex, pMob[conn].MOB.MobName, conn));
	} break;
#pragma endregion
#pragma region KIBITA
	case KIBITA:
	{
		if (pMob[conn].extra.Citizen == 0 && pMob[conn].MOB.Coin >= 400000)
		{
			pMob[conn].MOB.Coin -= 400000;
			pMob[conn].extra.Citizen = ServerIndex + 1;

			SendClientMessage(conn, g_pMessageStringTable[_DD_JOINTOWNPEP]);
			int Guild = pMob[conn].MOB.Guild;

			if (Guild && pMob[conn].MOB.GuildLevel == 9)
			{
				MSG_GuildInfo sm_gi;
				memset(&sm_gi, 0, sizeof(MSG_GuildInfo));

				sm_gi.Type = _MSG_GuildInfo;
				sm_gi.Size = sizeof(MSG_GuildInfo);
				sm_gi.ID = conn;

				sm_gi.Guild = Guild;

				GuildInfo[Guild].Citizen = ServerIndex + 1;

				sm_gi.GuildInfo = GuildInfo[Guild];

				DBServerSocket.SendOneMessage((char*)&sm_gi, sizeof(MSG_GuildInfo));
			}

			break;
		}
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		struct tm when;
		time_t now;
		time(&now);
		when = *localtime(&now);
		//horário soul kibita buff
		if (when.tm_wday != 0 && when.tm_wday != 6 && when.tm_hour == 23 && pMob[conn].extra.ClassMaster == MORTAL && pMob[conn].MOB.CurrentScore.Level < 1000)
		{
			int i = 0;

			for (i = 0; i < pMob[conn].MaxCarry; i++)
			{
				if (pMob[conn].MOB.Carry[i].sIndex != 414)
					continue;

				break;
			}

			if (i != pMob[conn].MaxCarry)
			{
				BASE_ClearItem(&pMob[conn].MOB.Carry[i]);
				SendItem(conn, ITEM_PLACE_CARRY, i, &pMob[conn].MOB.Carry[i]);

				SendClientMessage(conn, g_pMessageStringTable[_DN_TOWN_SOUL_BUFF]);
				int sAffect = GetEmptyAffect(conn, 29);

				if (sAffect == -1)
					return;


				pMob[conn].Affect[sAffect].Type = 29;
				pMob[conn].Affect[sAffect].Level = 0;
				pMob[conn].Affect[sAffect].Value = 0;
				pMob[conn].Affect[sAffect].Time = AFFECT_1H;

				pMob[conn].GetCurrentScore(conn);
				SendScore(conn);

				DoTeleport(conn, 2454 + rand() % 3, 1843 + rand() % 3);
				break;
			}

			else
			{
				SendClientMessage(conn, g_pMessageStringTable[_DN_TOWN_SOUL_NOBUFF]);
				break;
			}
		}

		if (pMob[conn].extra.ClassMaster == MORTAL && (pMob[conn].MOB.LearnedSkill & (1 << 30)) == 0 && pMob[conn].MOB.CurrentScore.Level >= 369)
		{
			int i = 0;

			int stones[4] = { 5334, 5336, 5335, 5337 };

			for (i = 0; i < pMob[conn].MaxCarry; i++)
			{
				if (pMob[conn].MOB.Carry[i].sIndex != stones[pMob[conn].MOB.Class])
					continue;

				break;
			}

			if (i != pMob[conn].MaxCarry)
			{
				BASE_ClearItem(&pMob[conn].MOB.Carry[i]);
				SendItem(conn, ITEM_PLACE_CARRY, i, &pMob[conn].MOB.Carry[i]);

				pMob[conn].MOB.LearnedSkill |= 1 << 30;

				memset(&pMob[conn].MOB.Equip[15], 0, sizeof(STRUCT_ITEM));

				if (pMob[conn].MOB.Clan == 7)
					pMob[conn].MOB.Equip[15].sIndex = 3194;

				else if (pMob[conn].MOB.Clan == 8)
					pMob[conn].MOB.Equip[15].sIndex = 3195;

				else
					pMob[conn].MOB.Equip[15].sIndex = 3196;

				SendItem(conn, ITEM_PLACE_EQUIP, 15, &pMob[conn].MOB.Equip[15]);

				CharLogOut(conn);

				SendClientSignalParm(conn, ESCENE_FIELD, _MSG_SendArchEffect, pUser[conn].Slot);
				break;
			}
		}
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		SendClientMessage(conn, g_pMessageStringTable[_DN_TOWN_SORRY]);
		SendEtc(conn);
	} break;
#pragma endregion
#pragma region GODGOVERNMENT
	case GODGOVERNMENT:
	{
		int curkill = GetCurKill(conn);
		int PKPoint = GetPKPoint(conn);

		if (curkill >= 100)
		{
			PKPoint += 20;

			if (PKPoint >= 150)
				PKPoint = 150;

			SetCurKill(conn, curkill - 100);
			SetPKPoint(conn, PKPoint);


			MSG_CreateMob sm_rpk;
			memset(&sm_rpk, 0, sizeof(MSG_CreateMob));
			GetCreateMob(conn, &sm_rpk);

			GridMulticast(pMob[conn].TargetX, pMob[conn].TargetY, (MSG_STANDARD*)&sm_rpk, 0);

			SendEmotion(conn, 14, 3);
			break;
		}

		SendSay(npcIndex, g_pMessageStringTable[_NN_MOREKILLPOINT]);
	} break;
#pragma endregion
#pragma region SOBREVIVENTE
	case SOBREVIVENTE:
	{
		int x = 2364 + rand() % 3;
		int y = 3906 + rand() % 3;

		if (pMob[conn].extra.KefraTicket < 1) {

			SendClientMessage(conn, "Você não possui entradas!");

			int i = 0;
			for (i = 0; i < pMob[conn].MaxCarry; i++)
			{
				if (pMob[conn].MOB.Carry[i].sIndex != 4127)
					continue;

				break;
			}

			if (i != pMob[conn].MaxCarry)
			{
				BASE_ClearItem(&pMob[conn].MOB.Carry[i]);
				SendItem(conn, ITEM_PLACE_CARRY, i, &pMob[conn].MOB.Carry[i]);

				pMob[conn].extra.KefraTicket += 100;

				sprintf(temp, "etc,kefraticket ticket:%d name:%s conn:%d", pMob[conn].extra.KefraTicket, pMob[conn].MOB.MobName, conn);
				Log(temp, 0, pUser[conn].IP);

				sprintf(temp, g_pMessageStringTable[_DN_CHANGE_COUNT], pMob[conn].extra.KefraTicket);
				SendMsgExp(conn, temp, TNColor::Default, false);
			}
		}
		if (pMob[conn].extra.KefraTicket >= 1) {
			pMob[conn].extra.KefraTicket--;
			DoTeleport(conn, x, y);
			SendClientMessage(conn, "Bem Vindo ao Kefra!");
		}

	} break;
#pragma endregion
#pragma region LIDER_APRENDIZ
	case LIDER_APRENDIZ:
	{
		if (pMob[conn].extra.ClassMaster != ARCH)
		{
			SendSay(npcIndex, strFmt(g_pMessageStringTable[_SN_NEEDCLASS], "Arch"));
			break;
		}

		if (pMob[conn].MOB.BaseScore.Level < 99 || pMob[conn].MOB.BaseScore.Level > 149)
		{
			SendSay(npcIndex, g_pMessageStringTable[_NN_Level_Limit2]);
			break;
		}

		if (pMob[conn].MOB.Equip[15].sIndex)
		{
			SendSay(npcIndex, g_pMessageStringTable[_NN_Youve_Done_It_Already]);
			break;
		}

		memset(&pMob[conn].MOB.Equip[15], 0, sizeof(STRUCT_ITEM));
		pMob[conn].MOB.Equip[15].sIndex = 4006;

		SendItem(conn, ITEM_PLACE_EQUIP, 15, &pMob[conn].MOB.Equip[15]);

		pMob[conn].GetCurrentScore(conn);
		SendScore(conn);

		SendEmotion(conn, 14, 3);
	} break;
#pragma endregion
	case FRAGMENTODAALMA:
	{
		int ItemReq = 5643; //EMBLEMA DO ORC

		int i = 0;
		for (i = 0; i < pMob[conn].MaxCarry; i++)
		{
			if (pMob[conn].MOB.Carry[i].sIndex != 5643)
				continue;
			int amount = BASE_GetItemAmount(&pMob[conn].MOB.Carry[i]);
			if (amount <= 9)
				continue;
			if (amount > 10)
				BASE_SetItemAmount(&pMob[conn].MOB.Carry[i], amount - 10);
			else
				BASE_ClearItem(&pMob[conn].MOB.Carry[i]);
			SendItem(conn, ITEM_PLACE_CARRY, i, &pMob[conn].MOB.Carry[i]);
			break;

		}

		int x = 0;
		int invfree = 0;

		for (x = 0; x < pMob[conn].MaxCarry; x++)
		{
			if (pMob[conn].MOB.Carry[x].sIndex == 0)
				invfree++;
		}

		if (invfree <= 0) //são 2 itens q recebe (coloca 0 no code), pq 1 é do próprio baú
		{
			SendClientMessage(conn, "Falta espaço no inventário.");
			return;
		}

		if (i != pMob[conn].MaxCarry)
		{


			STRUCT_ITEM Item;
			memset(&Item, 0, sizeof(STRUCT_ITEM));

			int _rd = rand() % 100;
			if (_rd < 50) //25%
			{
				Item.sIndex = 1740; //Anel Iniciante
				Item.stEffect[0].cEffect = 0; //efeito REF
				Item.stEffect[0].cValue = 0; //valor
				Item.stEffect[1].cEffect = 0; //efeito DN
				Item.stEffect[1].cValue = 0; //valor
			}
			else if (_rd < 100) //25%
			{
				Item.sIndex = 1741; //Anel Iniciante
				Item.stEffect[0].cEffect = 0; //efeito REF
				Item.stEffect[0].cValue = 0; //valor
				Item.stEffect[1].cEffect = 0; //efeito MG
				Item.stEffect[1].cValue = 0; //valo
			}
			PutItem(conn, &Item);
			break;
		}
	} break;
	case TROCADEFADA:
	{
		int ItemReq = 3915; //

		int i = 0;
		for (i = 0; i < pMob[conn].MaxCarry; i++)
		{
			if (pMob[conn].MOB.Carry[i].sIndex != ItemReq)
				continue;

			break;
		}

		if (i != pMob[conn].MaxCarry)
		{
			BASE_ClearItem(&pMob[conn].MOB.Carry[i]);
			SendItem(conn, ITEM_PLACE_CARRY, i, &pMob[conn].MOB.Carry[i]);

			STRUCT_ITEM Item;
			memset(&Item, 0, sizeof(STRUCT_ITEM));

			int _rd = rand() % 100;

			if (_rd < 100)
			{
				Item.sIndex = 5611;
				Item.stEffect[0].cEffect = 0;
				Item.stEffect[0].cValue = 0;
			}


			PutItem(conn, &Item);
			break;
		}
	} break;

#pragma region KRUNO
	case KRUNO:
	{
		if (pMob[conn].extra.ClassMaster != MORTAL)
		{
			SendSay(npcIndex, g_pMessageStringTable[_NN_Level_Limit2]);
			break;
		}

		int minlevel = pMob[conn].extra.ClassMaster == MORTAL ? 69 : 69;
		int maxlevel = pMob[conn].extra.ClassMaster == MORTAL ? 74 : 74;

		int ItemReq = 4123; //PEDAÇO DE CHANCE

		int i = 0;
		for (i = 0; i < pMob[conn].MaxCarry; i++)
		{
			if (pMob[conn].MOB.Carry[i].sIndex != ItemReq)
				continue;
			break;
		}
		if (i != pMob[conn].MaxCarry)
		{
			BASE_ClearItem(&pMob[conn].MOB.Carry[i]);
			SendItem(conn, ITEM_PLACE_CARRY, i, &pMob[conn].MOB.Carry[i]);
			STRUCT_ITEM Item;
			memset(&Item, 0, sizeof(STRUCT_ITEM));


			Item.sIndex = 4124; //COMPOSTO DE CHANCE

			PutItem(conn, &Item);
			break;
		}
	} break;
#pragma endregion

#pragma region QUEST_EQUILIBRIO
	case QUEST_EQUILIBRIO:
	{
		if (pMob[conn].extra.ClassMaster != MORTAL || pMob[conn].MOB.CurrentScore.Level < 120 || pMob[conn].MOB.CurrentScore.Level >= 125)
		{
			SendSay(npcIndex, g_pMessageStringTable[_NN_Level_limit]);
			break;
		}

		int minlevel = pMob[conn].extra.ClassMaster == MORTAL ? 119 : 119;
		int maxlevel = pMob[conn].extra.ClassMaster == MORTAL ? 124 : 124;

		SendSay(npcIndex, "Que você consiga sua salvação.");
		DoTeleport(conn, 1961 + rand() % 5 - 3, 1593 + rand() % 5 - 3);
	} break;
#pragma endregion 

#pragma region AMELIA
	case AMELIA:
	{
		if (pMob[conn].extra.ClassMaster != MORTAL)
		{
			SendSay(npcIndex, g_pMessageStringTable[_NN_Level_Limit2]);
			break;
		}

		int minlevel = pMob[conn].extra.ClassMaster == MORTAL ? 119 : 119;
		int maxlevel = pMob[conn].extra.ClassMaster == MORTAL ? 124 : 124;

		if (pMob[conn].MOB.CurrentScore.Level < minlevel || pMob[conn].MOB.CurrentScore.Level >= maxlevel)
		{
			SendSay(npcIndex, g_pMessageStringTable[_NN_Level_limit]);
			break;
		}

		int ItemReq = 4125; //PEDAÇO DE EQUILIBIRO

		int i = 0;
		for (i = 0; i < pMob[conn].MaxCarry; i++)
		{
			if (pMob[conn].MOB.Carry[i].sIndex != ItemReq)
				continue;
			break;
		}
		if (i != pMob[conn].MaxCarry)
		{
			BASE_ClearItem(&pMob[conn].MOB.Carry[i]);
			SendItem(conn, ITEM_PLACE_CARRY, i, &pMob[conn].MOB.Carry[i]);
			STRUCT_ITEM Item;
			memset(&Item, 0, sizeof(STRUCT_ITEM));


			Item.sIndex = 4126; //COMPOSTO DE EQUILIBRIO
			PutItem(conn, &Item);
			break;
		}
	} break;
#pragma endregion
#pragma region JULIARZAN
	case JULIARZAN:
	{

		if (pMob[conn].MOB.Coin < 50000)
		{
			SendSay(npcIndex, "Você precisa de 50,000 mil");
			break;
		}
		SendSay(npcIndex, "Foi teletransportado para Karden!");
		DoTeleport(conn, 3652, 3134);
		pMob[conn].MOB.Coin -= 50000;
		SendEtc(conn);
	} break;
#pragma endregion
#pragma region JULIGELO
	case JULIGELO:
	{

		if (pMob[conn].MOB.Coin < 50000)
		{
			SendSay(npcIndex, "Você precisa de 50,000 mil de gold");
			break;
		}
		SendSay(npcIndex, "Foi teletransportado para Arzan!");
		DoTeleport(conn, 2480, 1649);
		pMob[conn].MOB.Coin -= 50000;
		SendEtc(conn);
	} break;
#pragma endregion

#pragma region UNICORNIO_PURO
	case UNICORNIO_PURO:
	{
		if (pMob[conn].MOB.Equip[6].sIndex == 862)//espada curta
		{
			pMob[conn].MOB.Equip[6].sIndex = 939;//katana
			pMob[conn].MOB.Equip[6].stEffect[1].cEffect = 43;
			pMob[conn].MOB.Equip[6].stEffect[1].cValue = 5;
			pMob[conn].MOB.Equip[6].stEffect[2].cEffect = 2;
			pMob[conn].MOB.Equip[6].stEffect[2].cValue = 45;
			SendSay(npcIndex, "Tome este presente, mas não se acostume a isso...");
			SendItem(conn, ITEM_PLACE_EQUIP, 6, &pMob[conn].MOB.Equip[6]);
			return;
		}
		if (pMob[conn].MOB.Equip[6].sIndex == 923)//arco de cinzas OK
		{
			pMob[conn].MOB.Equip[6].sIndex = 943;//Caveira
			pMob[conn].MOB.Equip[6].stEffect[1].cEffect = 43;
			pMob[conn].MOB.Equip[6].stEffect[1].cValue = 5;
			pMob[conn].MOB.Equip[6].stEffect[2].cEffect = 2;
			pMob[conn].MOB.Equip[6].stEffect[2].cValue = 45;
			SendSay(npcIndex, "Tome este presente, mas não se acostume a isso...");
			SendItem(conn, ITEM_PLACE_EQUIP, 6, &pMob[conn].MOB.Equip[6]);
			return;
		}
		if (pMob[conn].MOB.Equip[6].sIndex == 918)//LANÇA MAGICA OK
		{
			pMob[conn].MOB.Equip[6].sIndex = 940;//ORC
			pMob[conn].MOB.Equip[6].stEffect[1].cEffect = 43;
			pMob[conn].MOB.Equip[6].stEffect[1].cValue = 5;
			pMob[conn].MOB.Equip[6].stEffect[2].cEffect = 60;
			pMob[conn].MOB.Equip[6].stEffect[2].cValue = 20;
			SendSay(npcIndex, "Tome este presente, mas não se acostume a isso...");
			SendItem(conn, ITEM_PLACE_EQUIP, 6, &pMob[conn].MOB.Equip[6]);
			return;
		}
		if (pMob[conn].MOB.Equip[6].sIndex == 917)//Florete
		{
			pMob[conn].MOB.Equip[6].sIndex = 942;//Argos
			pMob[conn].MOB.Equip[6].stEffect[1].cEffect = 43;
			pMob[conn].MOB.Equip[6].stEffect[1].cValue = 5;
			pMob[conn].MOB.Equip[6].stEffect[2].cEffect = 2;
			pMob[conn].MOB.Equip[6].stEffect[2].cValue = 45;
			SendSay(npcIndex, "Tome este presente, mas não se acostume a isso...");
			SendItem(conn, ITEM_PLACE_EQUIP, 6, &pMob[conn].MOB.Equip[6]);
			return;
		}
		SendSay(npcIndex, "Troque sua arma em uma poderosa arma Sephira.");
	}
#pragma endregion
	default:
		break;
	}
}

# -------------------- _MSG_QuitTrade.cpp --------------------

/*
*   Copyright (C) {2015}  {Victor Klafke, Charles TheHouse}
*
*   This program is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program.  If not, see [http://www.gnu.org/licenses/].
*
*   Contact at: victor.klafke@ecomp.ufsm.br
*/
#include "ProcessClientMessage.h"

void Exec_MSG_QuitTrade(int conn, char *pMsg)
{
	if(pMob[conn].MOB.CurrentScore.Hp <= 0 || pUser[conn].Mode != USER_PLAY)
	{
		SendHpMode(conn);
		AddCrackError(conn, 10, 17);
		return; 
	}
						   
	RemoveTrade(pUser[conn].Trade.OpponentID);
	RemoveTrade(conn);

	MSG_STANDARDPARM sm;
	memset(&sm, 0, sizeof(MSG_STANDARDPARM));

	sm.Size = sizeof(MSG_STANDARDPARM);
	sm.Type = _MSG_PKInfo;
	sm.ID = conn;

	if (NewbieEventServer == 0)
	{
		int guilty = GetGuilty(conn);

		int state = 0;

		if (guilty || pUser[conn].PKMode || RvRState && pMob[conn].TargetX >= 1023 && pMob[conn].TargetY >= 1919 && pMob[conn].TargetX <= 1280 && pMob[conn].TargetY <= 2179 || CastleState && pMob[conn].TargetX >= 1024 && pMob[conn].TargetY >= 1664 && pMob[conn].TargetX <= 1153 && pMob[conn].TargetY <= 1793 || GTorreState && pMob[conn].TargetX >= 2430 && pMob[conn].TargetY >= 1825 && pMob[conn].TargetX <= 2560 && pMob[conn].TargetY <= 1925)
			state = 1;

		sm.Parm = state;
	}
	else
		sm.Parm = 1;

	pMob[conn].CheckLojinha = 0;

	GridMulticast(pMob[conn].TargetX, pMob[conn].TargetY, (MSG_STANDARD*)&sm, 0);
}

# -------------------- _MSG_Quiz.cpp --------------------

#include "ProcessClientMessage.h"

void Exec_MSG_Quiz(int conn, char* pMsg)
{
	if (conn <= 0 || conn >= MAX_USER)
		return;

	MSG_STANDARDPARM* m = (MSG_STANDARDPARM*)pMsg;

	int Size = m->Size;

	if (m->Parm < 0 || m->Parm > 3)
		return;

	if (Size > sizeof(MSG_STANDARDPARM)) //CONTROLE DE SIZE
	{
		SendClientMessage(conn, "Impossível executar ação37, tente mais tarde. ");
		return;
	}
	if (pUser[conn].Atraso != 0)
	{
		int isTime = GetTickCount64() - pUser[conn].Atraso; // ATRASO PACOTE

		if (isTime < 800)
		{
			SendClientMessage(conn, "Aguarde 1 segundo para uma nova Tentativa.");
			return;
		}

	}
	pUser[conn].Atraso = GetTickCount64();

	SendClientMessage(conn, "Desativado");

	/*if (SendQuiz[conn].Status)
	{
		if (m->Parm == SendQuiz[conn].RespostaCorreta)
		{
			pMob[conn].MOB.Coin += 500000;
			pMob[conn].MOB.Exp += 700000;
			SendEtc(conn);
			SendClientMessage(conn, "+ + 500.000 EXP / 700.000 GOLD + +");
			SendEmotion(conn, 14, 3);
		}

		else
			SendEmotion(conn, 20, 0);

		SendQuiz[conn].Status = FALSE;
	}

	if (SendQuiz[conn].StatusN)
	{
		if (m->Parm == SendQuiz[conn].RespostaCorretaLanN) {
			DoTeleport(conn, (3639 + rand() % 5 - 3), (3639 + rand() % 5 - 3));
			pMob[conn].LanNFlag = 1;
		}
		else
		{
			SendCarry(conn);
			SendEmotion(conn, 20, 0);
		}
		SendQuiz[conn].StatusN = FALSE;
	}

	if (SendQuiz[conn].StatusM)
	{
		if (m->Parm == SendQuiz[conn].RespostaCorretaLanM) {
			DoTeleport(conn, (3782 + rand() % 5 - 3), (3527 + rand() % 5 - 3));
			pMob[conn].LanMFlag = 1;
		}
		else
		{
			SendCarry(conn);
			SendEmotion(conn, 20, 0);

		}

		SendQuiz[conn].StatusM = FALSE;
	}

	if (SendQuiz[conn].StatusA)
	{
		if (m->Parm == SendQuiz[conn].RespostaCorretaLanA) {
			DoTeleport(conn, (3911 + rand() % 5 - 3), (3655 + rand() % 5 - 3));
			pMob[conn].LanAFlag = 1;
		}
		else
		{
			SendCarry(conn);
			SendEmotion(conn, 20, 0);

		}

		SendQuiz[conn].StatusA = FALSE;
	}*/
	return;
}

# -------------------- _MSG_Rebuy.cpp --------------------

/*
*   Copyright (C) {2015}  {Victor Klafke, Charles TheHouse}
*
*   This program is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program.  If not, see [http://www.gnu.org/licenses/].
*
*   Contact at: victor.klafke@ecomp.ufsm.br
*/
#include "ProcessClientMessage.h"

void Exec_MSG_Rebuy(int conn, char *pMsg)
{
	MSG_Rebuy *m = (MSG_Rebuy*)pMsg;

	int Size = m->Size;

	if (Size > sizeof(MSG_Rebuy)) //CONTROLE DE SIZE
	{
		SendClientMessage(conn, "Impossível executar ação38, tente mais tarde. ");
		return;
	}
	if (pUser[conn].Atraso != 0)
	{
		int isTime = GetTickCount64() - pUser[conn].Atraso; // ATRASO PACOTE

		if (isTime < 800)
		{
			SendClientMessage(conn, "Aguarde 1 segundo para uma nova Tentativa.");
			return;
		}

	}
	pUser[conn].Atraso = GetTickCount64();
	if (m->ID != conn)
	{
		CloseUser(conn);

		return;
	}

	pUser[conn].Ingame.MobDonateStore = !pUser[conn].Ingame.MobDonateStore;


	if (pUser[conn].Mode != USER_PLAY) 
		return;

	for (int i = 0; i < MAX_ITEM_REBUY; i++)
		m->Rebuy[i] = pMob[conn].Rebuy[i];

	if (Size > sizeof(MSG_Rebuy))
	{
		m->Size = 0;
		return;
	}
	if (!pUser[conn].cSock.AddMessage((char*)m, m->Size))
		CloseUser(conn);
}

# -------------------- _MSG_RemoveParty.cpp --------------------

/*
*   Copyright (C) {2015}  {Victor Klafke, Charles TheHouse}
*
*   This program is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program.  If not, see [http://www.gnu.org/licenses/].
*
*   Contact at: victor.klafke@ecomp.ufsm.br
*/
#include "ProcessClientMessage.h"

void Exec_MSG_RemoveParty(int conn, char *pMsg)
{

	MSG_STANDARDPARM *m = (MSG_STANDARDPARM*)pMsg;

	int Size = m->Size;

	if (Size > sizeof(MSG_STANDARDPARM)) //CONTROLE DE SIZE
	{
		SendClientMessage(conn, "Impossível executar ação39, tente mais tarde. ");
		return;
	}

	int target = m->Parm;

	if(target <= 0 || target >= MAX_USER)
		target = conn;

	if(target != conn)
	{
		int i = 0;
		for(i = 0; i < MAX_PARTY; i++)
		{
			if(pMob[conn].PartyList[i] && pMob[conn].PartyList[i] == target)
				break;
		}

		if(i == MAX_PARTY)
			target = conn;
	}

	if (pMob[conn].Leader != -1 && pMob[conn].Leader)
		RemoveParty(conn);
		
	else
		RemoveParty(target);
}

# -------------------- _MSG_ReqBuy.cpp --------------------


#include "ProcessClientMessage.h"

void Exec_MSG_ReqBuy(int conn, char *pMsg)
{
	return;

	//MSG_ReqBuy* m = (MSG_ReqBuy*)pMsg;

	//if (pMob[conn].MOB.CurrentScore.Hp == 0 || pUser[conn].Mode != USER_PLAY)
	//{
	//	SendHpMode(conn);
	//	//AddCrackError(conn, 10, 86);
	//	RemoveTrade(conn);
	//	return;
	//}

	//if (pUser[conn].TradeMode)
	//{
	//	RemoveTrade(conn);
	//	return;
	//}

	//if (pUser[conn].Trade.OpponentID)
	//{
	//	RemoveTrade(conn);
	//	return;
	//}

	//int targetID = m->TargetID;
	//int itemPrice = m->Price;
	//int itemTax = m->Tax;
	//int itemPos = m->Pos;

	//if (itemPrice < 0 || itemPrice > 2000000000)
	//	return;

	//if (itemPos < 0 || itemPos > 60)
	//	return;

	//if (itemTax < 0)
	//	return;

	//if (targetID <= 0 || targetID >= MAX_USER)
	//{
	//	RemoveTrade(conn);
	//	return;
	//}

	//if (pUser[conn].Mode != USER_PLAY)
	//{
	//	RemoveTrade(conn);
	//	return;
	//}

	//if (targetID <= 0 || targetID >= MAX_USER)
	//{
	//	RemoveTrade(conn);
	//	return;
	//}

	//if (pUser[conn].Mode != USER_PLAY)
	//{
	//	RemoveTrade(conn);
	//	return;
	//}

	//if (pMob[conn].TargetX >= pMob[targetID].TargetX - VIEWGRIDX && pMob[conn].TargetX <= pMob[targetID].TargetX + VIEWGRIDX && pMob[conn].TargetY >= pMob[targetID].TargetY - VIEWGRIDY && pMob[conn].TargetY <= pMob[targetID].TargetY + VIEWGRIDY)
	//{
	//	if (itemPos < 0 || itemPos >= MAX_AUTOTRADE)
	//		return;

	//	int StorageSlot = pUser[targetID].AutoTrade.CarryPos[itemPos];

	//	if (StorageSlot < 0 || StorageSlot >= MAX_CARGO)
	//		return;

	//	if (itemTax != pUser[targetID].AutoTrade.Tax)
	//		return;

	//	if (itemPrice != pUser[targetID].AutoTrade.Coin[itemPos])
	//		return;

	//	if (memcmp(&m->item, &pUser[targetID].AutoTrade.Item[itemPos], sizeof(STRUCT_ITEM)))
	//	{
	//		RemoveTrade(conn);
	//		return;
	//	}

	//	if (memcmp(&pUser[targetID].Cargo[StorageSlot], &pUser[targetID].AutoTrade.Item[itemPos], sizeof(STRUCT_ITEM)))
	//	{
	//		RemoveTrade(conn);
	//		return;
	//	}


	//	if (pMob[conn].MOB.Coin < itemPrice)
	//	{
	//		SendClientMessage(conn, g_pMessageStringTable[_NN_Not_Enough_Money]);
	//		return;
	//	}

	//	unsigned int xcoin = pUser[targetID].Coin + itemPrice;

	//	if (xcoin > 2000000000)
	//	{
	//		SendClientMessage(conn, g_pMessageStringTable[_NN_Cant_get_more_than_2G]);
	//		return;
	//	}

	//	int i = 0;

	//	for (i = 0; i < MAX_CARRY - 4; i++)
	//	{
	//		if (pMob[conn].MOB.Carry[i].sIndex != 0)
	//			continue;

	//		break;
	//	}

	//	if (i == MAX_CARRY)
	//	{ 
	//		SendMsgExp(conn, g_pMessageStringTable[_NN_You_Have_No_Space_To_Trade], TNColor::Red, false);
	//		return;
	//	}

	//	int target_village = BASE_GetVillage(pMob[targetID].TargetX, pMob[targetID].TargetY);

	//	if (target_village < 0 || target_village >= 5)
	//	{
	//		SendClientMessage(conn, g_pMessageStringTable[_NN_OnlyVillage]);
	//		return;
	//	}

	//	memcpy(&pMob[conn].MOB.Carry[i], &pUser[targetID].Cargo[StorageSlot], sizeof(STRUCT_ITEM));
	//	SendItem(conn, ITEM_PLACE_CARRY, i, &pMob[conn].MOB.Carry[i]);

	//	char tmplog[2048];
	//	BASE_GetItemCode(&m->item, tmplog);

	//	sprintf_s(temp, "autotrade_buy,target_name:%s price:%d item:%s", pUser[targetID].AccountName, itemPrice, tmplog);
	//	ItemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);

	//	int imposto = 0;
	//	int price_end = itemPrice;

	//	if (itemPrice >= 100000)
	//	{
	//		imposto = (itemPrice / 100) *  itemTax;
	//		price_end = itemPrice - imposto;
	//	}

	//	pUser[targetID].AutoTrade.CarryPos[itemPos] = -1;

	//	memset(&pUser[targetID].AutoTrade.Item[itemPos], 0, sizeof(STRUCT_ITEM));

	//	pUser[targetID].AutoTrade.Coin[itemPos] = 0;

	//	memset(&pUser[targetID].Cargo[StorageSlot], 0, sizeof(STRUCT_ITEM));

	//	SendItem(targetID, ITEM_PLACE_CARGO, StorageSlot, &pUser[targetID].Cargo[StorageSlot]);

	//	pMob[conn].MOB.Coin -= itemPrice;

	//	if (pUser[targetID].Coin < 2000000000)
	//		pUser[targetID].Coin += price_end;

	//	SendEtc(conn);
	//	SendCargoCoin(targetID);
	//	SaveUser(targetID, 1);

	//	// DESCOMENTAR AQUI PARA QUANDO ALGUEM COMPRAR ALGUMA ITEM NA LOJA A LOJA FECHAR PINHEIRO
	//	//if (pUser[targetID].AutoTrade.Item[0].sIndex == 0 && pUser[targetID].AutoTrade.Item[1].sIndex == 0 &&
	//	//	pUser[targetID].AutoTrade.Item[2].sIndex == 0 && pUser[targetID].AutoTrade.Item[3].sIndex == 0 &&
	//	//	pUser[targetID].AutoTrade.Item[4].sIndex == 0 && pUser[targetID].AutoTrade.Item[5].sIndex == 0 &&
	//	//	pUser[targetID].AutoTrade.Item[6].sIndex == 0 && pUser[targetID].AutoTrade.Item[7].sIndex == 0 &&
	//	//	pUser[targetID].AutoTrade.Item[8].sIndex == 0 && pUser[targetID].AutoTrade.Item[9].sIndex == 0 &&
	//	//	pUser[targetID].AutoTrade.Item[10].sIndex == 0) 
	//	//{ 
	//	//	RemoveTrade(targetID);
	//	//	RemoveTrade(conn);
	//	//}

	//	if (target_village >= 0 && target_village < 5)
	//	{
	//		if (GuildImpostoID[target_village] >= MAX_USER && GuildImpostoID[target_village] < MAX_MOB && imposto > 0
	//			&& pMob[GuildImpostoID[target_village]].Mode != MOB_EMPTY && pMob[GuildImpostoID[target_village]].MOB.Guild == g_pGuildZone[target_village].ChargeGuild)
	//		{
	//			if (pMob[GuildImpostoID[target_village]].MOB.Exp < 200000000000)
	//				pMob[GuildImpostoID[target_village]].MOB.Exp += imposto;
	//		}
	//		if (GuildImpostoID[4] >= MAX_USER && GuildImpostoID[4] < MAX_MOB && imposto > 0 && pMob[GuildImpostoID[4]].Mode != MOB_EMPTY
	//			&& pMob[GuildImpostoID[4]].MOB.Guild == g_pGuildZone[4].ChargeGuild)
	//		{
	//			if (pMob[GuildImpostoID[4]].MOB.Exp < 200000000000)
	//				pMob[GuildImpostoID[4]].MOB.Exp += imposto;

	//		}
	//	}

	//	MSG_STANDARDPARM2 sm_is;
	//	memset(&sm_is, 0, sizeof(MSG_STANDARDPARM2));

	//	sm_is.Type = _MSG_ItemSold;
	//	sm_is.ID = ESCENE_FIELD;
	//	sm_is.Parm1 = targetID;
	//	sm_is.Parm2 = itemPos;
	//	sm_is.Size = sizeof(MSG_STANDARDPARM2);

	//	GridMulticast(pMob[targetID].TargetX, pMob[targetID].TargetY, (MSG_STANDARD*)&sm_is, 0);
	//	SendClientMessage(targetID, g_pMessageStringTable[_NN_ItemSold]);
	//}

	//else
	//{
	//	//Log("err,too far from autotrade - _MSG_ReqBuy", pUser[conn].AccountName, pUser[conn].IP);
	//	return;
	//}
}

# -------------------- _MSG_ReqRanking.cpp --------------------

/*
*   Copyright (C) {2015}  {Victor Klafke, Charles TheHouse}
*
*   This program is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program.  If not, see [http://www.gnu.org/licenses/].
*
*   Contact at: victor.klafke@ecomp.ufsm.br
*/
#include "ProcessClientMessage.h"

void Exec_MSG_ReqRanking(int conn, char *pMsg)
{
	MSG_STANDARDPARM2 *m = (MSG_STANDARDPARM2*)pMsg;

	int Size = m->Size;

	if (Size > sizeof(MSG_STANDARDPARM2)) //CONTROLE DE SIZE
	{
		SendClientMessage(conn, "Impossível executar ação41, tente mais tarde. ");
		return;
	}

	int tDuel = m->Parm1;
	int DuelParm = m->Parm2;

	if (DuelParm < 0 || DuelParm > 4 || tDuel <= 0 || tDuel >= MAX_USER)
		return;

	if (pUser[tDuel].Whisper)
	{
		SendClientMessage(conn, g_pMessageStringTable[_NN_Deny_Whisper]);
		return;
	}

	if (DuelParm != 4)
	{
		if (DuelParm != 1 && DuelParm != 2 || pMob[conn].MOB.GuildLevel && pMob[tDuel].MOB.GuildLevel)
		{
			pUser[conn].RankingTarget = tDuel;
			pUser[conn].RankingType = DuelParm;
									
			m->Parm1 = conn;
			m->ID = tDuel;
									
			if (!pUser[tDuel].cSock.AddMessage((char*)m, sizeof(MSG_STANDARDPARM2)))
				CloseUser(conn);

			return;
		}
	}

	else
	{
		if (pUser[tDuel].Mode != USER_PLAY)
			return;

		if (pUser[tDuel].RankingTarget != conn)
			return;

		if (RankingProgress)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Battle_In_Progress]);
			SendClientMessage(tDuel, g_pMessageStringTable[_NN_Battle_In_Progress]);
			return;
		}

		if (pUser[tDuel].RankingType >= 0 && pUser[tDuel].RankingType <= 3)
		{
			SendEtc(conn);
			SendEtc(tDuel);
			DoRanking(pUser[tDuel].RankingType, conn, tDuel);

			sprintf_s(temp, "etc,reqranking %s vs %s type:%d", pMob[conn].MOB.MobName, pMob[tDuel].MOB.MobName, DuelParm);
			SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);
			return;
		}
	}
}

# -------------------- _MSG_REQShopList.cpp --------------------

/*
*   Copyright (C) {2015}  {Victor Klafke, Charles TheHouse}
*
*   This program is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program.  If not, see [http://www.gnu.org/licenses/].
*
*   Contact at: victor.klafke@ecomp.ufsm.br
*/
#include "ProcessClientMessage.h"

void Exec_MSG_OpenDonate(int conn, char* pMsg)
{
	MSG_REQShopList* m = (MSG_REQShopList*)pMsg;
	MSG_DonateStore p;
	auto Packet = (MSG_DonateStore*)pMsg;

	int mobID = 0;
	int mobDropID = 0;

	int Size = m->Size;

	if (Packet->Warp < 0)
		return;

	if (Packet->npcID < 0 && Packet->npcID > MAX_MOB)
		return;

	if (Packet->Face < 0 || Packet->Face > 10000)
		return;

	if (Packet->Effect < 0 || Packet->Effect > 6500)
		return;

	if (pUser[conn].Atraso != 0)
	{
		int isTime = GetTickCount64() - pUser[conn].Atraso; // ATRASO PACOTE

		if (isTime < 200)
		{
			SendClientMessage(conn, "Aguarde um segundo antes de enviar nova solicitação");
			return;
		}

	}
	pUser[conn].Atraso = GetTickCount64();

	if (Packet->npcID == 1010)
	{		
		for (int i = 1000; i < 12800; i++)
		{
			auto Mob = GetMobFromIndex(i);
			int Effect = Packet->Effect;
			int Face = Packet->Face;

			if (Mob->GenerateIndex == Effect) {
				mobID = i;
				break;
			}
		}
		if (mobID != 0)
		{
			memset(&p, 0, sizeof(MSG_DonateStore));
			p.ID = conn;
			p.Type = _MSG_REQShopList;
			p.Size = sizeof(MSG_DonateStore);
			p.npcID = mobID;
			p.Warp = 17669;
			pUser[conn].Ingame.DonateBuyItem = mobID;
			pUser[conn].Ingame.MobDonateStore = TRUE;
			pUser[conn].Ingame.CanBuy = FALSE;
			Exec_MSG_REQShopList(conn, (char*)&p);
		}
	}

	else if (Packet->npcID == 1000)
	{
		for (int i = 1000; i < 12800; i++)
		{
			if (Packet->Warp == 100)
				if (!strcmp(pMob[i].MOB.MobName, "Armas F"))
				{
					mobID = i;
					break;
				}
			if (Packet->Warp == 101)
				if (!strcmp(pMob[i].MOB.MobName, "Sets F"))
				{
					mobID = i;
					break;
				}
			if (Packet->Warp == 102)
				if (!strcmp(pMob[i].MOB.MobName, "Refinaveis F"))
				{
					mobID = i;
					break;
				}
			if (Packet->Warp == 103)
				if (!strcmp(pMob[i].MOB.MobName, "Quests F"))
				{
					mobID = i;
					break;
				}
			
		}
		if (mobID != 0)
		{
			memset(&p, 0, sizeof(MSG_DonateStore));
			p.ID = conn;
			p.Type = _MSG_REQShopList;
			p.Size = sizeof(MSG_DonateStore);
			p.npcID = mobID;
			p.Warp = 17669;
			pUser[conn].Ingame.DonateBuyItem = mobID;
			pUser[conn].Ingame.MobDonateStore = TRUE;
			pUser[conn].Ingame.CanBuy = TRUE;
			Exec_MSG_REQShopList(conn, (char*)&p);
			SendEtc(conn);
			//SendDonateShop(conn, m->Target, 1);
		}
	}
	else
		pUser[conn].Ingame.DonateBuyItem = 0;
	return;
}

/*REQUSHOPLIST*/
void Exec_MSG_REQShopList(int conn, char* pMsg)
{
	MSG_REQShopList* m = (MSG_REQShopList*)pMsg;

	if (conn < 0 || conn >= MAX_USER)
		return;

	if (pMob[conn].MOB.CurrentScore.Hp == 0 || pUser[conn].Mode != USER_PLAY)
	{
		SendHpMode(conn);
		return;
	}

	int target = m->Target;

	if (pUser[conn].Ingame.DonateBuyItem <= 0 && target < MAX_USER || target >= MAX_MOB)
		return;

	int view = GetInView(conn, target);

	if (pUser[conn].Ingame.DonateBuyItem <= 0 && view == 0) {
		pUser[conn].Ingame.CanBuy = 0;
		return;
	}

	if (pMob[target].MOB.Merchant == 0) {
		pUser[conn].Ingame.CanBuy = 0;
		SendItemList(conn, target, 1);
		return;
	}
	else if (pMob[target].MOB.Merchant == 1) {
		pUser[conn].Ingame.CanBuy = 1;
		SendShopList(conn, target, 1);
		return;
	}
	else if ((pMob[target].MOB.Merchant) == 19) {
		pUser[conn].Ingame.CanBuy = 1;
		SendShopList(conn, target, 3);
		return;
	}
	return;
}

# -------------------- _MSG_ReqTeleport.cpp --------------------

/*
*   Copyright (C) {2015}  {Victor Klafke, Charles TheHouse}
*
*   This program is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program.  If not, see [http://www.gnu.org/licenses/].
*
*   Contact at: victor.klafke@ecomp.ufsm.br
*/
#include "ProcessClientMessage.h"

void Exec_MSG_ReqTeleport(int conn, char *pMsg)
{
	int posx = pMob[conn].TargetX;
	int posy = pMob[conn].TargetY;

	if ((posx / 4) == 491 && (posy / 4) == 443)
	{
		SendClientMessage(conn, g_pMessageStringTable[_NN_Only_By_Water_Scroll]);
		return;
	}

	int reqcoin = GetTeleportPosition(conn, &posx, &posy);

	int clan = pMob[conn].MOB.Clan;

	if (g_pGuildZone[4].Clan == clan)
		goto label_tel;
						
	if (reqcoin <= pMob[conn].MOB.Coin)
	{
		if (reqcoin > 0)
		{
			pMob[conn].MOB.Coin -= reqcoin;
			SendEtc(conn);

			int master = GuildImpostoID[4];
			if (GuildImpostoID[4] >= MAX_USER && master < MAX_MOB && pMob[master].Mode != MOB_EMPTY && pMob[master].MOB.Guild == g_pGuildZone[4].ChargeGuild)
			{
					if (pMob[master].MOB.Exp < 2000000000000)
						pMob[master].MOB.Exp += reqcoin / 2;
			}
		}

	label_tel:
		if (posx != pMob[conn].TargetX || posy != pMob[conn].TargetY)
		{
			DoTeleport(conn, posx, posy);
			
		}
	}
	else
		SendClientMessage(conn, g_pMessageStringTable[_NN_Not_Enough_Money]);
}

# -------------------- _MSG_ReqTradeList.cpp --------------------

/*
*   Copyright (C) {2015}  {Victor Klafke, Charles TheHouse}
*
*   This program is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program.  If not, see [http://www.gnu.org/licenses/].
*
*   Contact at: victor.klafke@ecomp.ufsm.br
*/
#include "ProcessClientMessage.h"

void Exec_MSG_ReqTradeList(int conn, char *pMsg)
{
	return;

	MSG_STANDARDPARM* m = (MSG_STANDARDPARM*)pMsg;

	int Size = m->Size;

	if (Size > sizeof(MSG_STANDARDPARM)) //CONTROLE DE SIZE
	{
		SendClientMessage(conn, "Impossível executar ação44, tente mais tarde. ");
		return;
	}

	int autoID = m->Parm;

	if (pMob[conn].MOB.CurrentScore.Hp == 0 || pUser[conn].Mode != USER_PLAY)
	{
		SendHpMode(conn);
		//AddCrackError(conn, 10, 87);
		return;
	}

	if (autoID <= 0 || autoID >= MAX_USER)
		return;

	if (pUser[autoID].TradeMode == 0)
		return;

	if (pMob[conn].TargetX >= pMob[autoID].TargetX - VIEWGRIDX && pMob[conn].TargetX <= pMob[autoID].TargetX + VIEWGRIDX
		&& pMob[conn].TargetY >= pMob[autoID].TargetY - VIEWGRIDY && pMob[conn].TargetY <= pMob[autoID].TargetY + VIEWGRIDY)
		SendAutoTrade(conn, autoID);

	else
		SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, "err,too far from autotrade - _MSG_ReqTradeList");
}

# -------------------- _MSG_Restart.cpp --------------------

/*
*   Copyright (C) {2015}  {Victor Klafke, Charles TheHouse}
*
*   This program is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program.  If not, see [http://www.gnu.org/licenses/].
*
*   Contact at: victor.klafke@ecomp.ufsm.br
*/
#include "ProcessClientMessage.h"

void Exec_MSG_Restart(int conn, char *pMsg)
{
	MSG_STANDARD *m = (MSG_STANDARD*)pMsg;

	int Size = m->Size;

	if (Size > sizeof(MSG_STANDARD)) //CONTROLE DE SIZE
	{
		SendClientMessage(conn, "Impossível executar ação45, tente mais tarde. ");
		return;
	}

	if (pUser[conn].Mode == USER_PLAY)
	{

		if (pUser[conn].Atraso != 0)
		{
			int isTime = GetTickCount64() - pUser[conn].Atraso; // ATRASO PACOTE DE MORTE

			if (isTime < 4000)
			{
				return;
			}
			
		}
		pUser[conn].Atraso = GetTickCount64();

		if (pMob[conn].MOB.CurrentScore.Hp > 0) {
			CloseUser(conn);
			return;
		}

		pMob[conn].MOB.CurrentScore.Hp = 200;

		pUser[conn].NumError = 0;

		SendScore(conn);
		SendSetHpMp(conn);


		if(pMob[conn].TargetX >= 1017 && pMob[conn].TargetX <= 1290 && pMob[conn].TargetY >= 1911 && pMob[conn].TargetY <= 2183 && pMob[conn].MOB.Clan == 7)
			DoTeleport(conn, 1061+ rand()%3, 2129+rand()%3);
			
		else if(pMob[conn].TargetX >= 1017 && pMob[conn].TargetX <= 1290 && pMob[conn].TargetY >= 1911 && pMob[conn].TargetY <= 2183 && pMob[conn].MOB.Clan == 8)
			DoTeleport(conn, 1237+ rand()%3, 1966+rand()%3);
			
		else
			DoRecall(conn);
				
		SendEtc(conn);
	}
	else
		SendHpMode(conn);
}

# -------------------- _MSG_Sell.cpp --------------------

/*
*   Copyright (C) {2015}  {Victor Klafke, Charles TheHouse}
*
*   This program is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program.  If not, see [http://www.gnu.org/licenses/].
*
*   Contact at: victor.klafke@ecomp.ufsm.br
*/
#include "ProcessClientMessage.h"

void Exec_MSG_Sell(int conn, char* pMsg)
{
	MSG_Sell* m = (MSG_Sell*)pMsg;


	if (pMob[conn].MOB.CurrentScore.Hp == 0 || pUser[conn].Mode != USER_PLAY)
	{
		SendHpMode(conn);
		//AddCrackError(conn, 10, 23);
		return;
	}

	if (pUser[conn].Trade.OpponentID)
	{
		RemoveTrade(pUser[conn].Trade.OpponentID);
		RemoveTrade(conn);
		return;
	}

	if (pUser[conn].TradeMode && m->MyType == ITEM_PLACE_CARGO)
	{
		SendClientMessage(conn, g_pMessageStringTable[_NN_CantWhenAutoTrade]);
		return;
	}


	int sTargetID = m->TargetID;
	int sMyType = m->MyType;
	int sMyPos = m->MyPos;
	int isEquip = 0;

	if (sMyType)
	{
		if (sMyType == 1)
		{
			if (sMyPos < 0 || sMyPos >= MAX_CARRY - 4)
			{
				//Log("err,(Wrong dest position)Sell-Carry", pUser[conn].AccountName, pUser[conn].IP);
				return;
			}
		}
		else
		{
			if (sMyType != 2)
			{
				//Log("err,sell mytype", pUser[conn].AccountName, pUser[conn].IP);
				return;
			}
			if (sMyPos < 0 || sMyPos >= MAX_CARGO)
			{
				//Log("err,(Wrong dest position)Sell-Cargo", pUser[conn].AccountName, pUser[conn].IP);
				return;
			}
		}
	}
	else
	{
		if (sMyPos <= 0 || sMyPos >= MAX_EQUIP)
		{
			//Log("err,(Wrong dest position)Sell-Equip", pUser[conn].AccountName, pUser[conn].IP);
			return;
		}
		if (sMyPos < 8)
			isEquip = 1;
	}

	STRUCT_ITEM* Item = GetItemPointer(&pMob[conn].MOB, pUser[conn].Cargo, m->MyType, m->MyPos);

	if (Item == NULL)
	{
		//Log("err,sell target NULL", pUser[conn].AccountName, pUser[conn].IP);
		return;
	}

	if (Item->sIndex == 3193 || Item->sIndex == 3194 || Item->sIndex == 747)
		return;


	if (pMob[conn].MOB.Class == 3 && pMob[conn].MOB.LearnedSkill & 0x1000)
		goto LABEL_S1;

	if (sTargetID < MAX_USER || sTargetID >= MAX_MOB)
	{
		//Log("err,sell target of carrypos outof range", pUser[conn].AccountName, pUser[conn].IP);
		return;
	}
	if (pMob[sTargetID].MOB.Merchant != 1)
	{
		SendClientMessage(conn, g_pMessageStringTable[_NN_Only_Merchant_Buy_Yours]);
		return;
	}
	if (!GetInView(conn, sTargetID))
	{
		SendClientSignal(conn, ESCENE_FIELD, _MSG_CloseShop);
		return;
	}

LABEL_S1:

	char SellName[256];

	strncpy(SellName, pMob[sTargetID].MOB.MobName, NAME_LENGTH);

	if (Item->sIndex <= 0 || Item->sIndex >= MAX_ITEMLIST)
	{
		
		snprintf(temp, sizeof(temp), "err,request sell %d %d %d %d", Item->sIndex, sTargetID, sMyType, sMyPos);

		if (sMyType != 1 || sMyPos < 0 || sMyPos >= MAX_CARRY)
			SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);
		else
			SendItem(conn, ITEM_PLACE_CARRY, sMyPos, &pMob[conn].MOB.Carry[sMyPos]);

		return;
	}

	int Vol = BASE_GetItemAbility(Item, EF_VOLATILE);

	if (Vol == 1)
	{
		SendClientMessage(conn, g_pMessageStringTable[_NN_Cant_Sell_Potion]);
		return;
	}

	int sPrice = g_pItemList[Item->sIndex].Price;
	int sIndex = Item->sIndex;

	int Qnt = 1;

	for (int i = 0; i < 3; i++) {
		if (Item->stEffect[i].cEffect == 61)
			Qnt = Item->stEffect[i].cValue;
	}

	sPrice = sPrice * Qnt;

	sPrice /= 4;

	if (sPrice <= 10000)
	{
		if (sPrice > 5000)
			sPrice = 2 * sPrice / 3;
	}

	else
		sPrice /= 2;

	if (sPrice > 1000 && sIndex != 693 && sIndex != 694 && sIndex != 695 && pMob[conn].MOB.Class == 3 && pMob[conn].MOB.LearnedSkill & 0x200)
	{
		int special = pMob[conn].MOB.CurrentScore.Special[2];
		special /= 10;

		int discount = special + 6;
		if (special + 6 >= 26)
			discount = 26;

		if (discount >= 5 && discount <= 26)
		{
			discount /= 2;
			sPrice = (discount + 50) * sPrice / 50;
		}
	}

	if (sPrice < 0)
	{
		//Log("err,MSG_ReqSell  <><><><><><> MINUS <><><><><><>", pUser[conn].AccountName, pUser[conn].IP);
		return;
	}


	int sVillage = BASE_GetVillage(pMob[sTargetID].TargetX, pMob[sTargetID].TargetY);
	if (sVillage < 0 || sVillage > 5)
		goto LABEL_S2;


	int CityTax = g_pGuildZone[sVillage].CityTax;

	if (CityTax >= 0 && CityTax <= 30)
	{
		int fPrice = sPrice;

		if (sPrice < 100000)
			sPrice = sPrice * (100 - CityTax) / 100;

		else
			sPrice = sPrice / 100 * (100 - CityTax);

		if (sPrice >= 0)
		{
			if (GetRecycleBin(conn, Item, sPrice) == FALSE)
				return;

			int tcoin = (fPrice - sPrice) / 2;
			tcoin /= 2;

			if (GuildImpostoID[sVillage] >= MAX_USER && GuildImpostoID[sVillage] < MAX_MOB && tcoin > 0 && pMob[GuildImpostoID[sVillage]].Mode != MOB_EMPTY)
			{
				if (pMob[GuildImpostoID[sVillage]].MOB.Exp < 200000000000)
					pMob[GuildImpostoID[sVillage]].MOB.Exp += tcoin;


			}

			if (GuildImpostoID[4] >= MAX_USER && GuildImpostoID[4] < MAX_MOB && tcoin > 0 && pMob[GuildImpostoID[4]].Mode != MOB_EMPTY)
			{
				if (pMob[GuildImpostoID[4]].MOB.Exp < 20000000000000)
					pMob[GuildImpostoID[4]].MOB.Exp += tcoin;
			}

		LABEL_S2:

			if ((pMob[conn].MOB.Coin + sPrice) <= 2000000000)
				pMob[conn].MOB.Coin += sPrice;
			else {
				SendClientMessage(conn, "Valor máximo de gold será excedido");
				return;
			}

			char tmplog[2048];
			BASE_GetItemCode(Item, tmplog);


			BASE_ClearItem(Item);

			int Size = m->Size;

			if (Size > sizeof(MSG_Sell))
			{
				m->Size = 0;
				return;
			}

			if (!pUser[conn].cSock.AddMessage((char*)m, sizeof(MSG_Sell)))
				CloseUser(conn);

			if (isEquip)
				SendEquip(conn, conn);

			SendEtc(conn);
		}
	}
}

# -------------------- _MSG_SendAutoTrade.cpp --------------------

/*
*   Copyright (C) {2015}  {Victor Klafke, Charles TheHouse}
*
*   This program is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program.  If not, see [http://www.gnu.org/licenses/].
*
*   Contact at: victor.klafke@ecomp.ufsm.br
*/
#include "ProcessClientMessage.h"

void Exec_MSG_SendAutoTrade(int conn, char *pMsg)
{
	return;

	//MSG_SendAutoTrade* m = (MSG_SendAutoTrade*)pMsg;

	//int Size = m->Size;

	//for (int i = 0; i < MAX_AUTOTRADE; i++) {
	//	if (m->Coin[i] < 0 || m->Coin[i] > 2000000000) {
	//		RemoveTrade(conn);
	//		return;
	//	}
	//}

	//if (m->Tax < 0) {
	//	RemoveTrade(conn);
	//	return;
	//}

	//if (m->Index < 0) {
	//	RemoveTrade(conn);
	//	return;
	//}

	//if (Size > sizeof(MSG_SendAutoTrade)) //CONTROLE DE SIZE
	//{
	//	SendClientMessage(conn, "Impossível executar ação47, tente mais tarde. ");
	//	return;
	//}

	//if (pMob[conn].MOB.CurrentScore.Hp <= 0 || pUser[conn].Mode != USER_PLAY)
	//{
	//	SendHpMode(conn);
	//	AddCrackError(conn, 10, 88);
	//	RemoveTrade(conn);
	//	return;
	//}

	//if (pUser[conn].Trade.OpponentID)
	//{
	//	RemoveTrade(pUser[conn].Trade.OpponentID);
	//	RemoveTrade(conn);
	//	return;
	//}


	///*
	//
	//if (pUser[conn].OnlyTrade)
	//{ 
	//	RemoveTrade(conn);
	//	SendClientMessage(conn, "So é permitido cria uma lojinha na  primeira conta aberta!");
	//	return;
	//}
	//
	//*/

	//if (pUser[conn].TradeMode)
	//{
	//	SendClientMessage(conn, g_pMessageStringTable[_NN_CantWhenAutoTrade]);
	//	return;
	//}

	//if (NewbieEventServer == 0)
	//{
	//	SendClientMessage(conn, g_pMessageStringTable[_NN_NEWBIEEVENTSERVER]);
	//	return;
	//}

	//int targetx = pMob[conn].TargetX;
	//int targety = pMob[conn].TargetY;

	//int Village = BASE_GetVillage(targetx, targety);

	//if (targetx >= 2123 && targetx <= 2148 && targety >= 2139 && targety <= 2157)
	//{
	//	RemoveTrade(conn);
	//	SendClientMessage(conn, g_pMessageStringTable[_NN_OnlyVillage]);
	//	return;
	//}

	//if (Village < 0 || Village >= 5)
	//{
	//	RemoveTrade(conn);
	//	SendClientMessage(conn, g_pMessageStringTable[_NN_OnlyVillage]);
	//	return;
	//}

	//if (conn <= 0 || conn >= MAX_USER)
	//	return;

	//for (int i = 0; i < MAX_AUTOTRADE; i++)
	//{
	//	if (m->Coin[i] < 0 || (m->Coin[i] > 1999999999) || !m->Item[i].sIndex && m->Coin[i])
	//		return;

	//	if (m->Item[i].sIndex)
	//	{
	//		if (!m->Coin[i] || m->Item[i].sIndex == 508 || m->Item[i].sIndex == 3993 || m->Item[i].sIndex == 747 || m->Item[i].sIndex == 509 || m->Item[i].sIndex == 522
	//			|| m->Item[i].sIndex >= 526 && m->Item[i].sIndex <= 531 || m->Item[i].sIndex == 446 || m->CarryPos[i] < 0 || m->CarryPos[i] >= MAX_CARGO)
	//			return;

	//		if (BASE_GetItemAbility(&m->Item[i], EF_NOTRADE) != 0)
	//		{
	//			SendClientMessage(conn, g_pMessageStringTable[_NN_Cant_MoveItem]);									   
	//			return;
	//		}

	//		if (memcmp(&pUser[conn].Cargo[m->CarryPos[i]], &m->Item[i], sizeof(STRUCT_ITEM)))
	//		{
	//			RemoveTrade(conn);
	//			return;
	//		}
	//	}
	//}

	//m->Tax = g_pGuildZone[Village].CityTax;

	//m->Title[MAX_AUTOTRADETITLE - 1] = 0;
	//m->Title[MAX_AUTOTRADETITLE - 2] = 0;

	//strncpy(pUser[conn].AutoTrade.Title, m->Title, MAX_AUTOTRADETITLE);

	//pUser[conn].TradeMode = 1;
	//pMob[conn].CheckLojinha = 600;

	//memcpy(&pUser[conn].AutoTrade, m, sizeof(MSG_SendAutoTrade));

	//m->Size = sizeof(MSG_SendAutoTrade);

	//MSG_CreateMobTrade sm_cmt;
	//memset(&sm_cmt, 0, sizeof(MSG_CreateMobTrade));

	//SendAutoTrade(conn, conn);
	//GetCreateMobTrade(conn, &sm_cmt);

	//sm_cmt.Score.Con = 0;
	//GridMulticast(targetx, targety, (MSG_STANDARD*)&sm_cmt, 0);
}

# -------------------- _MSG_SendReqParty.cpp --------------------

/*
*   Copyright (C) {2015}  {Victor Klafke, Charles TheHouse}
*
*   This program is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program.  If not, see [http://www.gnu.org/licenses/].
*
*   Contact at: victor.klafke@ecomp.ufsm.br
*/
#include "ProcessClientMessage.h"

void Exec_MSG_SendReqParty(int conn, char *pMsg)
{
	if (conn < 0 || conn >= MAX_USER)
		return;

	if (pUser[conn].Atraso != 0)
	{
		int isTime = GetTickCount64() - pUser[conn].Atraso; // ATRASO PACOTE DE MORTE

		if (isTime < 2000)
		{
			return;
		}
		
	}
	pUser[conn].Atraso = GetTickCount64();

	MSG_SendReqParty* m = (MSG_SendReqParty*)pMsg;

	if (m->Level < 0 || m->Level > MAX_LEVEL)
		return;

	if (m->MaxHp < 0 || m->MaxHp > MAX_HP)
		return;

	if (m->Hp < 0 || m->Hp > MAX_HP)
		return;

	if (m->Target < 0 || m->Target > MAX_USER)
		return;

	int Size = m->Size;

	if (Size > sizeof(MSG_SendReqParty)) //CONTROLE DE SIZE
	{
		SendClientMessage(conn, "Impossível executar ação48, tente mais tarde. ");
		return;
	}

	int partyID = m->PartyID;
	int targetID = m->unk;

	m->MobName[NAME_LENGTH - 1] = 0;

	if (partyID <= 0 || partyID >= MAX_USER || partyID != conn)
	{
		//Log("err,REQParty leader out of range", pUser[conn].AccountName, pUser[conn].IP);
		return;
	}
	if (pMob[partyID].Leader)
	{
		SendClientMessage(conn, g_pMessageStringTable[_NN_Dropped_Current_Party_First]);
		return;
	}
	if (targetID <= 0 || targetID >= MAX_USER)
	{
		//Log("err,REQParty target out of range", pUser[conn].AccountName, pUser[conn].IP);
		return;
	}
	
	// anti pulo pista com add grupo
	/*for (int x = 0; x < 3; x++) {
		for (int y = 0; y < 3; y++) {
			if (Pista[x].Party[y].LeaderID == targetID) {
				SendClientMessage(conn, "Não é possível entrar em um grupo que já esteja registrado na pista");
				return;
			}
		}
	}*/

	if (pUser[targetID].Mode != USER_PLAY)
	{
		SendClientMessage(conn, g_pMessageStringTable[_NN_Not_Connected]);
		return;
	}
	if (pMob[targetID].Leader)
	{
		SendClientMessage(conn, g_pMessageStringTable[_NN_Other_Partys_Member]);
		return;
	}

	/*if(pUser[conn].OnlyTrade)
	{
		SendClientMessage(conn, g_pMessageStringTable[_NN_ONLYTRADE]);
		return;
	}*/

	int index = 0;
	
	while (2)
	{
		if (index >= MAX_PARTY)
		{
			int lvl = pMob[targetID].extra.ClassMaster == ARCH || pMob[targetID].extra.ClassMaster == MORTAL ? pMob[targetID].MOB.BaseScore.Level : pMob[targetID].MOB.BaseScore.Level + MAX_CLEVEL;
			int leaderlv = pMob[conn].extra.ClassMaster == ARCH || pMob[conn].extra.ClassMaster == MORTAL ? pMob[conn].MOB.BaseScore.Level : pMob[conn].MOB.BaseScore.Level + MAX_CLEVEL;
			
			//if (lvl >= leaderlv - PARTY_DIF && lvl < leaderlv + PARTY_DIF || lvl >= 1000 || leaderlv >= 1000) //|| pMob[targetID].extra.ClassMaster == pMob[conn].extra.ClassMaster) 
			//{
			if (!BrState || conn >= MAX_USER || BRItem <= 0 || pMob[conn].TargetX < 2604
				|| pMob[conn].TargetY < 1708 || pMob[conn].TargetX > 2648 || pMob[conn].TargetY > 1744)
			{
				pMob[targetID].LastReqParty = conn;
				SendReqParty(targetID, partyID, partyID);
				break;
			}
			//}
			//else
			//{
				//SendClientMessage(conn, g_pMessageStringTable[_NN_Party_Level_Limit]);
				//break;
			//}
		}
		else
		{
			int mindex = pMob[targetID].PartyList[index];
			if (!mindex)
			{
				index++;
				continue;
			}
			SendClientMessage(conn, g_pMessageStringTable[_NN_Have_Own_Party_Already]);
			break;
		}
		break;
	}
}

# -------------------- _MSG_SetShortSkill.cpp --------------------

/*
*   Copyright (C) {2015}  {Victor Klafke, Charles TheHouse}
*
*   This program is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program.  If not, see [http://www.gnu.org/licenses/].
*
*   Contact at: victor.klafke@ecomp.ufsm.br
*/
#include "ProcessClientMessage.h"

void Exec_MSG_SetShortSkill(int conn, char *pMsg)
{
	MSG_SetShortSkill *m = (MSG_SetShortSkill*)pMsg;

	int Size = m->Size;

	if (Size > sizeof(MSG_SetShortSkill)) //CONTROLE DE SIZE
	{
		SendClientMessage(conn, "Impossível executar ação49, tente mais tarde. ");
		return;
	}

	if (pMob[conn].MOB.Class == 1 && (pMob[conn].MOB.Equip[0].sIndex == 7 || pMob[conn].MOB.Equip[0].sIndex == 17 || pMob[conn].MOB.Equip[0].sIndex == 27 || pMob[conn].MOB.Equip[0].sIndex == 37))
	{
		for (int o = 0; o < 4; o++)
		{
			if (m->Skill1[o] == 106 || m->Skill1[o] == 109 || m->Skill1[o] == 114)
			{
				if (m->Skill1[o] == 106) {
					pMob[conn].MOB.SkillBar[o] = 118;
				}

				if (m->Skill1[o] == 109) {
					pMob[conn].MOB.SkillBar[o] = 121;
				}

				if (m->Skill1[o] == 114) {
					pMob[conn].MOB.SkillBar[o] = 126;
				}
			}
			else
				pMob[conn].MOB.SkillBar[o] = m->Skill1[o];
		}
	}
	else
		memcpy(pMob[conn].MOB.SkillBar, m->Skill1, 4);

	if (pMob[conn].MOB.Class == 1 && (pMob[conn].MOB.Equip[0].sIndex == 7 || pMob[conn].MOB.Equip[0].sIndex == 17 || pMob[conn].MOB.Equip[0].sIndex == 27 || pMob[conn].MOB.Equip[0].sIndex == 37))
	{
		for (int i = 0; i < 16; i++)
		{
			if (m->Skill2[i] == 106 || m->Skill2[i] == 109 || m->Skill2[i] == 114)
			{
				if (m->Skill2[i] == 106) {
					pUser[conn].CharShortSkill[i] = 118;
				}

				if (m->Skill2[i] == 109) {
					pUser[conn].CharShortSkill[i] = 121;
				}

				if (m->Skill2[i] == 114) {
					pUser[conn].CharShortSkill[i] = 126;
				}
			}
			else
				pUser[conn].CharShortSkill[i] = m->Skill2[i];
		}
	}
	else
		memcpy(pUser[conn].CharShortSkill, m->Skill2, 16);

	//memcpy(pMob[conn].MOB.SkillBar, m->Skill1, 4);
	//memcpy(pUser[conn].CharShortSkill, m->Skill2, 16);
}

/* // All new skill's Index //
105 106 107 108 TK
109 110 111 112
113 114 115 116

117 118 119 120 FM
121 122 123 124
125 126 127 128

129 130 131 132 BM
133 134 135 136
137 138 139 140

141 142 143 144 HT
145 146 147 148
149 150 151 152
*/

# -------------------- _MSG_SplitItem.cpp --------------------

/*
*   Copyright (C) {2015}  {Victor Klafke, Charles TheHouse}
*
*   This program is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program.  If not, see [http://www.gnu.org/licenses/].
*
*   Contact at: victor.klafke@ecomp.ufsm.br
*/
#include "ProcessClientMessage.h"

void Exec_MSG_SplitItem(int conn, char* pMsg)
{
	MSG_SplitItem* m = (MSG_SplitItem*)pMsg;

	int Size = m->Size;

	if (Size > sizeof(MSG_SplitItem)) //CONTROLE DE SIZE
	{
		SendClientMessage(conn, "Impossível executar ação50, tente mais tarde. ");
		return;
	}
	if (pUser[conn].Atraso != 0)
	{
		int isTime = GetTickCount64() - pUser[conn].Atraso; // ATRASO PACOTE

		if (isTime < 500)
		{
			SendClientMessage(conn, "Separe os itens devagar Meu Filho!");
			return;
		}

	}
	pUser[conn].Atraso = GetTickCount64();

	if (m->Slot < 0 || m->Slot >= MAX_CARRY - 4)
		return;

	if (m->Num <= 0 || m->Num >= 120)
		return;

	if (m->sIndex < 0 || m->sIndex == MAX_ITEMLIST)
		return;

	if (pUser[conn].Mode != USER_PLAY)
	{
		SendHpMode(conn);
		return;
	}

	if (pUser[conn].Trade.OpponentID)
	{
		RemoveTrade(conn);
		return;
	}

	int slot = m->Slot; //DESAGRUPAR ITENS MANUAL

	if (pMob[conn].MOB.Carry[slot].sIndex != 412 && pMob[conn].MOB.Carry[slot].sIndex != 413
		&& pMob[conn].MOB.Carry[slot].sIndex != 3140 && pMob[conn].MOB.Carry[slot].sIndex != 1774
		&& pMob[conn].MOB.Carry[slot].sIndex != 3200 && pMob[conn].MOB.Carry[slot].sIndex != 3201
		&& pMob[conn].MOB.Carry[slot].sIndex != 3202 && pMob[conn].MOB.Carry[slot].sIndex != 3203
		&& pMob[conn].MOB.Carry[slot].sIndex != 3204 && pMob[conn].MOB.Carry[slot].sIndex != 3205
		&& pMob[conn].MOB.Carry[slot].sIndex != 3206 && pMob[conn].MOB.Carry[slot].sIndex != 3207
		&& pMob[conn].MOB.Carry[slot].sIndex != 3208 && pMob[conn].MOB.Carry[slot].sIndex != 3209
		&& pMob[conn].MOB.Carry[slot].sIndex != 4011 && pMob[conn].MOB.Carry[slot].sIndex != 787
		&& pMob[conn].MOB.Carry[slot].sIndex != 4010 && pMob[conn].MOB.Carry[slot].sIndex != 4028
		&& pMob[conn].MOB.Carry[slot].sIndex != 4026 && pMob[conn].MOB.Carry[slot].sIndex != 4027
		&& pMob[conn].MOB.Carry[slot].sIndex != 4029 && pMob[conn].MOB.Carry[slot].sIndex != 3326
		&& pMob[conn].MOB.Carry[slot].sIndex != 3321 && pMob[conn].MOB.Carry[slot].sIndex != 3431
		&& pMob[conn].MOB.Carry[slot].sIndex != 3182 && pMob[conn].MOB.Carry[slot].sIndex != 777 && pMob[conn].MOB.Carry[slot].sIndex != 482 // bau IV
		&& pMob[conn].MOB.Carry[slot].sIndex != 3173 && pMob[conn].MOB.Carry[slot].sIndex != 475 && pMob[conn].MOB.Carry[slot].sIndex != 480 // bau III
		&& pMob[conn].MOB.Carry[slot].sIndex != 4144 && pMob[conn].MOB.Carry[slot].sIndex != 4140 && pMob[conn].MOB.Carry[slot].sIndex != 476 // bau II
		&& pMob[conn].MOB.Carry[slot].sIndex != 3326 && pMob[conn].MOB.Carry[slot].sIndex != 4016 && pMob[conn].MOB.Carry[slot].sIndex != 475 // bau I
		&& pMob[conn].MOB.Carry[slot].sIndex != 4017 && pMob[conn].MOB.Carry[slot].sIndex != 4018 && pMob[conn].MOB.Carry[slot].sIndex != 3140 // pedra da luz
		&& pMob[conn].MOB.Carry[slot].sIndex != 4146 && pMob[conn].MOB.Carry[slot].sIndex != 4019 && pMob[conn].MOB.Carry[slot].sIndex != 484 // bau VI
		&& pMob[conn].MOB.Carry[slot].sIndex != 4020 && pMob[conn].MOB.Carry[slot].sIndex != 4097 && pMob[conn].MOB.Carry[slot].sIndex != 483 // bau V
		&& pMob[conn].MOB.Carry[slot].sIndex != 419 && pMob[conn].MOB.Carry[slot].sIndex != 420 && pMob[conn].MOB.Carry[slot].sIndex != 4051
		&& pMob[conn].MOB.Carry[slot].sIndex != 578 && pMob[conn].MOB.Carry[slot].sIndex != 4051 && pMob[conn].MOB.Carry[slot].sIndex != 415
		&& (pMob[conn].MOB.Carry[slot].sIndex < 4038 || pMob[conn].MOB.Carry[slot].sIndex > 4042)
		&& (pMob[conn].MOB.Carry[slot].sIndex < 4051 || pMob[conn].MOB.Carry[slot].sIndex > 4055)
		&& (pMob[conn].MOB.Carry[slot].sIndex < 4117 || pMob[conn].MOB.Carry[slot].sIndex > 4121)
		&& (pMob[conn].MOB.Carry[slot].sIndex < 2441 || pMob[conn].MOB.Carry[slot].sIndex > 2444)
		&& (pMob[conn].MOB.Carry[slot].sIndex < 1760 || pMob[conn].MOB.Carry[slot].sIndex > 1743))
	{
		//Log("splititem, no validitem", pUser[conn].AccountName, pUser[conn].IP);
		return;
	}

	int amount = BASE_GetItemAmount(&pMob[conn].MOB.Carry[slot]);

	if (m->Num < 0 || m->Num > 120)
	{
		//Log("splititem, invalid num", pUser[conn].AccountName, pUser[conn].IP);
		return;
	}

	int x = 0;
	int invfree = 0;

	for (x = 0; x < pMob[conn].MaxCarry; x++)
	{
		if (pMob[conn].MOB.Carry[x].sIndex == 0)
			invfree++;
	}

	if (invfree < 1)
		return;

	if (amount == 0 || amount == 1 || amount <= m->Num)
		return;

	
	snprintf(temp, sizeof(temp), "splititem, itemindex:%d amount:%d num:%d", pMob[conn].MOB.Carry[slot].sIndex, amount, m->Num);
	ItemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);

	if (amount > 1)
		BASE_SetItemAmount(&pMob[conn].MOB.Carry[slot], amount - m->Num);

	else
		memset(&pMob[conn].MOB.Carry[slot], 0, sizeof(STRUCT_ITEM));

	STRUCT_ITEM nItem;

	memset(&nItem, 0, sizeof(STRUCT_ITEM));

	nItem.sIndex = pMob[conn].MOB.Carry[slot].sIndex;

	BASE_SetItemAmount(&nItem, m->Num);

	PutItem(conn, &nItem);
	SendItem(conn, ITEM_PLACE_CARRY, slot, &pMob[conn].MOB.Carry[slot]);
	return;
}

# -------------------- _MSG_Trade.cpp --------------------


#include "ProcessClientMessage.h"

void Exec_MSG_Trade(int conn, char* pMsg)
{
	MSG_Trade* m = (MSG_Trade*)pMsg;

	int Size = m->Size;

	if (m->TradeMoney < 0 || m->TradeMoney > 2000000000)
		return;

	if (m->MyCheck < 0)
		return;

	if (Size > sizeof(MSG_Trade)) //CONTROLE DE SIZE
	{
		SendClientMessage(conn, "Impossível executar ação51, tente mais tarde. ");
		return;
	}

	if (pUser[conn].Mode != USER_PLAY)
		return;

	if (pMob[conn].MOB.CurrentScore.Hp == 0 || pUser[conn].Mode != USER_PLAY)
	{
		SendHpMode(conn);
		//AddCrackError(conn, 5, 18);
		RemoveTrade(conn);
		return;
	}

	int OpponentID = m->OpponentID;

	if (OpponentID <= 0 || OpponentID >= MAX_USER)
	{
		//Log("err,msg_trade - target out of bound.", pUser[conn].AccountName, pUser[conn].IP);
		SendClientMessage(conn, g_pMessageStringTable[_NN_Wrong_Trade_Packet1]);
		RemoveTrade(conn);
		return;
	}

	if (pUser[OpponentID].Mode != USER_PLAY)
	{
		RemoveTrade(OpponentID);
		RemoveTrade(conn);
		return;
	}

	if (m->TradeMoney < 0 || m->TradeMoney > pMob[conn].MOB.Coin)
	{
		RemoveTrade(conn);
		RemoveTrade(OpponentID);
		return;
	}

	for (int i = 0; i < MAX_TRADE; i++)
	{
		if (m->Item[i].sIndex)
		{
			if (m->InvenPos[i] < 0 || m->InvenPos[i] >= MAX_CARRY - 4)
				return;

			if (memcmp(&pMob[conn].MOB.Carry[m->InvenPos[i]], &m->Item[i], sizeof(STRUCT_ITEM)))
			{
				//Log("err,msg_trade - item remove or changed.", pUser[conn].AccountName, pUser[conn].IP);
				RemoveTrade(conn);
				RemoveTrade(OpponentID);
				return;
			}
		}

		if (pUser[OpponentID].Trade.Item[i].sIndex)
		{
			if (pUser[OpponentID].Trade.InvenPos[i] < 0 || pUser[OpponentID].Trade.InvenPos[i] >= MAX_CARRY - 4)
				return;

			if (memcmp(&pMob[OpponentID].MOB.Carry[pUser[OpponentID].Trade.InvenPos[i]], &pUser[OpponentID].Trade.Item[i], sizeof(STRUCT_ITEM)))
			{
				//Log("err,msg_trade - item remove or changed.", pUser[conn].AccountName, pUser[conn].IP);
				RemoveTrade(conn);
				RemoveTrade(OpponentID);
				return;
			}
		}
	}

	int lastOpponent = pUser[conn].Trade.OpponentID;

	if (lastOpponent == OpponentID)
	{
		for (int i = 0; i < MAX_TRADE; i++)
		{
			int Check = 0;

			if (pUser[conn].Trade.Item[i].sIndex)
				Check = memcmp(&pUser[conn].Trade.Item[i], &m->Item[i], sizeof(STRUCT_ITEM));

			if (pUser[conn].Trade.TradeMoney && m->TradeMoney != pUser[conn].Trade.TradeMoney)
				Check = 1;

			if (Check)
			{
				//Log("err,msg_trade - item remove or changed.", pUser[conn].AccountName, pUser[conn].IP);
				RemoveTrade(conn);
				RemoveTrade(OpponentID);
				return;
			}
		}
	}
	else
	{
		if (lastOpponent)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Already_Trading]);
			RemoveTrade(conn);
			return;
		}
	}

	if (pUser[conn].PKMode || pUser[OpponentID].PKMode)
	{
		SendClientMessage(conn, g_pMessageStringTable[_NN_Cant_trade_pkmode]);
		SendClientMessage(OpponentID, g_pMessageStringTable[_NN_Cant_trade_pkmode]);

		RemoveTrade(conn);
		RemoveTrade(OpponentID);
		return;
	}

	/*if (pUser[conn].Whisper || pUser[OpponentID].Whisper)
	{
		SendClientMessage(conn, g_pMessageStringTable[_NN_Deny_Whisper]);
		SendClientMessage(OpponentID, g_pMessageStringTable[_NN_Deny_Whisper]);

		RemoveTrade(conn);
		RemoveTrade(OpponentID);
		return;
	}
	*/
	int MyGuild = pMob[conn].MOB.Guild;
	int OpponentGuild = pMob[OpponentID].MOB.Guild;
	int MyGuildLevel = pMob[conn].MOB.GuildLevel;
	int OpponentGuildLevel = pMob[OpponentID].MOB.GuildLevel;

	for (int i = 0; i < MAX_TRADE; i++)
	{



		if (m->Item[i].sIndex == 747 || m->Item[i].sIndex == 3993 || m->Item[i].sIndex == 3994)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Only_With_Guild_Master]);
			SendClientMessage(OpponentID, g_pMessageStringTable[_NN_Only_With_Guild_Master]);

			RemoveTrade(conn);

			if (pUser[OpponentID].Trade.OpponentID == conn)
				RemoveTrade(OpponentID);

			return;
		}

		if (m->Item[i].sIndex == 508 || m->Item[i].sIndex == 522 || m->Item[i].sIndex >= 526 && m->Item[i].sIndex <= 537 || m->Item[i].sIndex == 446)
		{
			int getGuild = GetGuild(&m->Item[i]);
			if (getGuild != MyGuild || !MyGuildLevel)
			{
				if (getGuild != OpponentGuild || !OpponentGuildLevel)
				{
					SendClientMessage(conn, g_pMessageStringTable[_NN_Only_With_Guild_Master]);
					SendClientMessage(OpponentID, g_pMessageStringTable[_NN_Only_With_Guild_Master]);
					RemoveTrade(conn);

					if (pUser[OpponentID].Trade.OpponentID == conn)
						RemoveTrade(OpponentID);

					return;
				}
			}
		}

		if (m->Item[i].sIndex && BASE_GetItemAbility(&m->Item[i], EF_NOTRADE) != 0)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Cant_MoveItem]);
			SendClientMessage(OpponentID, g_pMessageStringTable[_NN_Cant_MoveItem]);
			RemoveTrade(conn);

			if (pUser[OpponentID].Trade.OpponentID == conn)
				RemoveTrade(OpponentID);

			return;
		}
	}

	if (pUser[OpponentID].Trade.OpponentID)
	{
		if (pUser[OpponentID].Trade.OpponentID == conn)
		{
			for (int i = 0; i < MAX_TRADE; i++)
			{
				int iPos = m->InvenPos[i];

				if (iPos == -1)
					memset(&m->Item[i], 0, sizeof(STRUCT_ITEM));

				else
				{
					if (iPos < -1 || iPos >= MAX_CARRY - 4)
					{
						SendClientMessage(conn, g_pMessageStringTable[_NN_Wrong_Trade_Packet1]);
						RemoveTrade(conn);
						break;
					}
					for (int j = 0; j < MAX_TRADE; j++)
					{
						if (j != i && iPos == m->InvenPos[j])
						{
							SendClientMessage(conn, g_pMessageStringTable[_NN_Wrong_Trade_Packet1]);
							RemoveTrade(conn);
							return;
						}
					}

					memmove_s(&m->Item[i], sizeof(STRUCT_ITEM), &pMob[conn].MOB.Carry[iPos], sizeof(STRUCT_ITEM));
				}
			}

			if (m->MyCheck == 1)
			{
				pUser[conn].Trade.MyCheck = 1;
				pUser[conn].Trade.KeyWord = m->KeyWord;
				pUser[conn].Trade.CheckSum = m->CheckSum;
				pUser[conn].Trade.ClientTick = m->ClientTick;

				if (memcmp(&pUser[conn].Trade, m, sizeof(MSG_Trade)))
				{
					RemoveTrade(conn);
					RemoveTrade(OpponentID);
					//Log("err,msg_trade - Click check button but diffrent data", pUser[conn].AccountName, pUser[conn].IP);
					return;
				}

				if (pUser[OpponentID].Trade.MyCheck == 0)
				{
					SendClientSignal(conn, conn, _MSG_CNFCheck);

					m->ID = OpponentID;
					m->OpponentID = conn;

					if (!pUser[OpponentID].cSock.AddMessage((char*)m, sizeof(MSG_Trade)))
						CloseUser(conn);

					return;
				}

				if (pUser[conn].Trade.TradeMoney < 0 || pUser[conn].Trade.TradeMoney  > 2000000000)
				{
					RemoveTrade(conn);
					RemoveTrade(OpponentID);

					return;
				}

				if (pUser[OpponentID].Trade.TradeMoney < 0 || pUser[OpponentID].Trade.TradeMoney  > 2000000000)
				{
					RemoveTrade(conn);
					RemoveTrade(OpponentID);

					return;
				}

				unsigned int fGold = pUser[OpponentID].Trade.TradeMoney + pMob[conn].MOB.Coin - pUser[conn].Trade.TradeMoney;

				if (fGold > 2000000000 || fGold < 0)
				{
					SendClientMessage(conn, g_pMessageStringTable[_NN_Cant_get_more_than_2G]);
					RemoveTrade(conn);
					RemoveTrade(OpponentID);
					return;
				}

				unsigned int opfGold = pUser[conn].Trade.TradeMoney + pMob[OpponentID].MOB.Coin - pUser[OpponentID].Trade.TradeMoney;

				if (opfGold > 2000000000 || opfGold < 0)
				{
					SendClientMessage(conn, g_pMessageStringTable[_NN_Cant_get_more_than_2G]);
					RemoveTrade(conn);
					RemoveTrade(OpponentID);
					return;
				}

				if (pUser[conn].Trade.TradeMoney > pMob[conn].MOB.Coin)
				{
					SendClientMessage(conn, g_pMessageStringTable[_NN_Havent_Money_So_Much]);
					SendClientMessage(OpponentID, g_pMessageStringTable[_NN_Opponent_Havent_Money]);
					return;
				}

				if (pUser[OpponentID].Trade.TradeMoney > pMob[OpponentID].MOB.Coin)
				{
					SendClientMessage(OpponentID, g_pMessageStringTable[_NN_Havent_Money_So_Much]);
					SendClientMessage(conn, g_pMessageStringTable[_NN_Opponent_Havent_Money]);
					return;
				}

				STRUCT_ITEM mydest[MAX_CARRY];
				STRUCT_ITEM oppdest[MAX_CARRY];

				int mytrade = BASE_CanTrade(mydest, pMob[conn].MOB.Carry, (unsigned char*)&pUser[conn].Trade.InvenPos, pUser[OpponentID].Trade.Item, pMob[conn].MaxCarry);
				int opptrade = BASE_CanTrade(oppdest, pMob[OpponentID].MOB.Carry, (unsigned char*)&pUser[OpponentID].Trade.InvenPos, pUser[conn].Trade.Item, pMob[OpponentID].MaxCarry);

				if (mytrade == 0 && opptrade == 0)
				{
					SendClientMessage(conn, g_pMessageStringTable[_NN_Each_Of_You_Havent_Space]);
					SendClientMessage(OpponentID, g_pMessageStringTable[_NN_Each_Of_You_Havent_Space]);
					return;
				}

				if (mytrade == 0)
				{
					SendMsgExp(conn, g_pMessageStringTable[_NN_You_Have_No_Space_To_Trade], TNColor::Red, false);
					SendMsgExp(OpponentID, g_pMessageStringTable[_NN_Opponent_Have_No_Space_To], TNColor::Red, false);
					return;
				}

				if (opptrade == 0)
				{
					SendMsgExp(conn, g_pMessageStringTable[_NN_You_Have_No_Space_To_Trade], TNColor::Red, false);
					SendMsgExp(OpponentID, g_pMessageStringTable[_NN_Opponent_Have_No_Space_To], TNColor::Red, false);
					return;
				}

				memmove_s(pMob[conn].MOB.Carry, sizeof(mydest), mydest, sizeof(mydest));
				memmove_s(pMob[OpponentID].MOB.Carry, sizeof(oppdest), oppdest, sizeof(oppdest));

				pMob[conn].MOB.Coin = fGold;
				pMob[OpponentID].MOB.Coin = opfGold;

				SendCarry(conn);
				SendCarry(OpponentID);

				int MyTradeMoney = pUser[conn].Trade.TradeMoney;
				int OppTradeMoney = pUser[OpponentID].Trade.TradeMoney;

				int MyLog = 0;
				int OppLog = 0;
				
				snprintf(temp, sizeof(temp), "Troca entre conta[%s] jogador[%s] e conta[%s] jogador[%s] foi iniciada.", pUser[OpponentID].AccountName, pMob[OpponentID].MOB.MobName, pUser[conn].AccountName, pMob[conn].MOB.MobName);
				Tradelogs(pUser[OpponentID].AccountName, pUser[OpponentID].MacAddress, pUser[OpponentID].IP, temp);

				snprintf(temp, sizeof(temp), "Troca ,conta[%s] jogador[%s] colocou na troca coin[%d] ", pUser[OpponentID].AccountName, pMob[OpponentID].MOB.MobName, OppTradeMoney);
				Tradelogs(pUser[OpponentID].AccountName, pUser[OpponentID].MacAddress, pUser[OpponentID].IP, temp);

				snprintf(temp, sizeof(temp), "Troca ,conta[%s] Jogador[%s] colocou na troca coin[%d] ", pUser[conn].AccountName, pMob[conn].MOB.MobName, MyTradeMoney);
				Tradelogs(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);

				for (int i = 0; i < MAX_TRADE; i++)
				{
					if (pUser[conn].Trade.Item[i].sIndex == 0)
						continue;

					

					BASE_GetItemCode(&pUser[conn].Trade.Item[i], temp);

					Tradelogs(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);
				}

				for (int i = 0; i < MAX_TRADE; i++)
				{
					if (pUser[OpponentID].Trade.Item[i].sIndex == 0)
						continue;

					

					BASE_GetItemCode(&pUser[OpponentID].Trade.Item[i], temp);
					Tradelogs(pUser[OpponentID].AccountName, pUser[OpponentID].MacAddress, pUser[OpponentID].IP, temp);
				}

				snprintf(temp, sizeof(temp), "Troca entre Login[%s] jogador[%s] recebeu coin[%d] e Login[%s] jogador[%s] recebeu coin[%d], foi finalizada.", pUser[OpponentID].AccountName, pMob[OpponentID].MOB.MobName, MyTradeMoney, pUser[conn].AccountName, pMob[conn].MOB.MobName, OppTradeMoney);
				Tradelogs(pUser[OpponentID].AccountName, pUser[OpponentID].MacAddress, pUser[OpponentID].IP, temp);

				SaveUser(conn, 1);
				SaveUser(OpponentID, 1);

				RemoveTrade(conn);
				RemoveTrade(OpponentID);
				return;
			}

			else
			{
				memmove_s(&pUser[conn].Trade, sizeof(MSG_Trade), m, sizeof(MSG_Trade));

				pUser[conn].Trade.MyCheck = 0;
				pUser[OpponentID].Trade.MyCheck = 0;

				m->ID = OpponentID;
				m->OpponentID = conn;

				if (!pUser[OpponentID].cSock.AddMessage((char*)m, sizeof(MSG_Trade)))
					CloseUser(conn);
				return;
			}

		}
		else
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Already_Trading]);
			RemoveTrade(conn);
			return;
		}
	}
	else
	{
		memmove_s(&pUser[conn].Trade, sizeof(MSG_Trade), m, sizeof(MSG_Trade));

		pUser[conn].Trade.MyCheck = 0;
		pUser[conn].Trade.TradeMoney = 0;

		m->ID = OpponentID;

		m->OpponentID = conn;

		if (!pUser[OpponentID].cSock.AddMessage((char*)m, sizeof(MSG_Trade)))
			CloseUser(conn);

		pUser[OpponentID].Trade.MyCheck = 0;
		pUser[OpponentID].Trade.TradeMoney = 0;
	}
}

# -------------------- _MSG_TradingItem.cpp --------------------


#include "ProcessClientMessage.h"
#include "Functions.h"

void Exec_MSG_TradingItem(int conn, char *pMsg)
{
	MSG_TradingItem* m = (MSG_TradingItem*)pMsg;

	int Size = m->Size;

	if (m->WarpID < 0 || m->WarpID >= MAX_MOB)
		return;

	if (m->SrcSlot < 0 || m->SrcSlot >= 120)
		return;

	if (m->SrcPlace < 0)
		return;

	if (m->DestSlot < 0 || m->DestSlot >= 120)
		return;

	if (m->DestPlace < 0)
		return;

	// correção de dup
	if (m->SrcPlace == m->DestPlace && m->SrcSlot == m->DestSlot) {
		CloseUser(conn);
		SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, "Dup bug");
		return;
	}

	if (Size > sizeof(MSG_TradingItem)) //CONTROLE DE SIZE
	{
		SendClientMessage(conn, "Impossível executar ação52, tente mais tarde. ");
		return;
	}

	if (pMob[conn].MOB.CurrentScore.Hp == 0 || pUser[conn].Mode != USER_PLAY)
	{
		SendHpMode(conn);
		AddCrackError(conn, 1, 19);
		return;
	}

	if (pUser[conn].Trade.OpponentID)
	{
		RemoveTrade(pUser[conn].Trade.OpponentID);
		RemoveTrade(conn);
		return;
	}

	if (pUser[conn].TradeMode)
	{
		SendClientMessage(conn, g_pMessageStringTable[_NN_CantWhenAutoTrade]);
		return;
	}

	if(m->SrcPlace == ITEM_PLACE_CARGO && m->DestPlace == ITEM_PLACE_EQUIP)
	{
		SendClientMessage(conn, "Passe o item para o inventário antes de equipá-lo.");
		return;
	}

	if (pUser[conn].MoveItemTime != 0)
	{
		int isTime = GetTickCount64() - pUser[conn].MoveItemTime;

		if (isTime < 800)

		{
			//Log("O jogador [%s] esta tentando dupar IP: %d", pUser[conn].AccountName, pUser[conn].IP);
			return;
		}
	}
	
	pUser[conn].MoveItemTime = GetTickCount64();

	STRUCT_ITEM *item = GetItemPointer(&pMob[conn].MOB, pUser[conn].Cargo, m->SrcPlace, m->SrcSlot);

	if ((m->DestPlace == ITEM_PLACE_CARGO || m->SrcPlace == ITEM_PLACE_CARGO) && (pMob[conn].MOB.Class != 3 && pMob[conn].MOB.Class != 2 && pMob[conn].MOB.Class != 1 && pMob[conn].MOB.Class != 0 || !(pMob[conn].MOB.LearnedSkill & 0x2000)))
	{
		int WarpID = m->WarpID;

		if (WarpID <= MAX_USER && WarpID >= MAX_MOB)
		{
			//SendClientMessage(conn, "Erro 1!");
			SendClientSignal(conn, ESCENE_FIELD, 412);
			return;
		}

		//if (pMob[WarpID].Mode != MOB_PEACE || pMob[WarpID].MOB.Merchant != 2)
		//{
		//	//SendClientMessage(conn, "Erro 2!");
		//	SendClientSignal(conn, ESCENE_FIELD, 412);
		//	return;
		//}

		int PosX = pMob[conn].TargetX;
		int PosY = pMob[conn].TargetY;
		int tx = pMob[WarpID].TargetX;
		int ty = pMob[WarpID].TargetY;

		//if (PosX < tx - VIEWGRIDX || PosX > tx + VIEWGRIDX || PosY < ty - VIEWGRIDY || PosY > ty + VIEWGRIDY)
		//{
		//	//SendClientMessage(conn, "Erro 3!");
		//	SendClientSignal(conn, ESCENE_FIELD, 412);
		//	return;
		//}
	}
	STRUCT_ITEM *Mount = &pMob[conn].MOB.Equip[14];

	int DestPlace = 0;
	int SrcPlace = 0;

	STRUCT_ITEM *DestItem = GetItemPointer(&pMob[conn].MOB, pUser[conn].Cargo, m->DestPlace, m->DestSlot);
	STRUCT_ITEM *SrcItem = GetItemPointer(&pMob[conn].MOB, pUser[conn].Cargo, m->SrcPlace, m->SrcSlot);

	STRUCT_ITEM *dItem = GetItemPointer(&pMob[conn].MOB, pUser[conn].Cargo, m->DestPlace, m->DestSlot);
	STRUCT_ITEM *sItem = GetItemPointer(&pMob[conn].MOB, pUser[conn].Cargo, m->SrcPlace, m->SrcSlot);

	//Cinto > Inventário
	if (m->SrcPlace == 0 && m->SrcSlot == 16) {
		if ((DestItem->sIndex < 4468 || DestItem->sIndex > 4482) && DestItem->sIndex != 0)
			return;

		STRUCT_ITEM Item;
		int Char = pUser[conn].Slot;
		memcpy(&Item, &pUser[conn].Joias[Char][0], sizeof(STRUCT_ITEM));

		memcpy(&pUser[conn].Joias[Char][0], DestItem, sizeof(STRUCT_ITEM));
		memcpy(DestItem, &Item, sizeof(STRUCT_ITEM));
		SendJoias(conn);
		SendCarry(conn);
		pMob[conn].GetCurrentScore(conn);
		SendScore(conn);
		SaveUser(conn, 1);
		return;
	}
	//Colar > Inventário
	if (m->SrcPlace == 0 && m->SrcSlot == 17) {
		if ((DestItem->sIndex < 4483 || DestItem->sIndex > 4497) && DestItem->sIndex != 0)
			return;

		STRUCT_ITEM Item;
		int Char = pUser[conn].Slot;
		memcpy(&Item, &pUser[conn].Joias[Char][1], sizeof(STRUCT_ITEM));

		memcpy(&pUser[conn].Joias[Char][1], DestItem, sizeof(STRUCT_ITEM));
		memcpy(DestItem, &Item, sizeof(STRUCT_ITEM));
		SendJoias(conn);
		SendCarry(conn);
		pMob[conn].GetCurrentScore(conn);
		SendScore(conn);
		SaveUser(conn, 1);
		return;
	}
	//Inventário > Cinto
	if (m->DestPlace == 0 && m->DestSlot == 16) {
		if ((SrcItem->sIndex < 4468 || SrcItem->sIndex > 4482) && SrcItem->sIndex != 0)
			return;

		STRUCT_ITEM Item;
		int Char = pUser[conn].Slot;
		memcpy(&Item, &pUser[conn].Joias[Char][0], sizeof(STRUCT_ITEM));
		memcpy(&pUser[conn].Joias[Char][0], SrcItem, sizeof(STRUCT_ITEM));
		memcpy(SrcItem, &Item, sizeof(STRUCT_ITEM));
		SendJoias(conn);
		SendCarry(conn);
		pMob[conn].GetCurrentScore(conn);
		SendScore(conn);
		SaveUser(conn, 1);
		return;
	}
	//Inventário > Colar
	if (m->DestPlace == 0 && m->DestSlot == 17) {
		if ((SrcItem->sIndex < 4483 || SrcItem->sIndex > 4497) && SrcItem->sIndex != 0)
			return;

		STRUCT_ITEM Item;
		int Char = pUser[conn].Slot;
		memcpy(&Item, &pUser[conn].Joias[Char][1], sizeof(STRUCT_ITEM));
		memcpy(&pUser[conn].Joias[Char][1], SrcItem, sizeof(STRUCT_ITEM));
		memcpy(SrcItem, &Item, sizeof(STRUCT_ITEM));
		SendJoias(conn);
		SendCarry(conn);
		pMob[conn].GetCurrentScore(conn);
		SendScore(conn);
		SaveUser(conn, 1);
		return;
	}

	if (m->DestPlace)
	{
		if (m->DestPlace == ITEM_PLACE_CARRY)
		{
			if (m->DestSlot >= MAX_CARRY - 4)
			{
				//Log("err,trading fails.SwapItem-Carry", pUser[conn].AccountName, pUser[conn].IP);
				return;
			}
		}
		else
		{
			if (m->DestPlace != ITEM_PLACE_CARGO)
			{
				//Log("err,trading fails.SwapItem source type", pUser[conn].AccountName, pUser[conn].IP);
				return;
			}
			if (m->DestSlot > MAX_CARGO)
			{
				//Log("err,trading fails.SwapItem-Cargo", pUser[conn].AccountName, pUser[conn].IP);
				return;
			}
			int PosX = pMob[conn].TargetX;
			int PosY = pMob[conn].TargetY;

			bool NearCargo = false;
			if ((PosX > 1039 && PosX < 1057 && PosY > 1733 && PosY < 1749) || //deserto
				(PosX > 2135 && PosX < 2154 && PosY > 2072 && PosY < 2093) || //armia aki
				(PosX > 2094 && PosX < 2113 && PosY > 2105 && PosY < 2126) || //armia
				(PosX > 2467 && PosX < 2486 && PosY > 1679 && PosY < 1698) || //arzan
				(PosX > 2583 && PosX < 2602 && PosY > 1719 && PosY < 1734) || //arzan coliseu
				(PosX > 2457 && PosX < 2472 && PosY > 1984 && PosY < 1999) || //erion
				(PosX > 3640 && PosX < 3670 && PosY > 3116 && PosY < 3148) || //gelo
				(PosX > 3225 && PosX < 3251 && PosY > 1679 && PosY < 1692)) { //kefra
				NearCargo = true;
			}
			if (NearCargo == false) {
				SendClientMessage(conn, "Você está longe do Bau");
				return;
			}
		}
	}
	else
	{
		if (m->DestSlot < 0 || m->DestSlot >= MAX_EQUIP - 1)
		{
			//Log("err,trading fails.SwapItem-Equip", pUser[conn].AccountName, pUser[conn].IP);
			return;
		}
		DestPlace = 1;
		SrcPlace = 1;
	}
	if (m->SrcPlace)
	{
		if (m->SrcPlace == ITEM_PLACE_CARRY)
		{
			if (m->SrcSlot >= MAX_CARRY - 4)
			{
				//Log("DEBUG:Trading Fails.Swap-Carr", pUser[conn].AccountName, pUser[conn].IP);
				return;
			}
		}
		else
		{
			if (m->SrcPlace != ITEM_PLACE_CARGO)
			{
				//Log("DEBUG:Trading Fails.SwapItem dest type", pUser[conn].AccountName, pUser[conn].IP);
				return;
			}
			if (m->SrcSlot > MAX_CARGO)
			{
				//Log("DEBUG:Trading Fails.Swap-Cargo", pUser[conn].AccountName, pUser[conn].IP);
				return;
			}
			int PosX = pMob[conn].TargetX;
			int PosY = pMob[conn].TargetY;

			bool NearCargo = false;
			if ((PosX > 1039 && PosX < 1057 && PosY > 1733 && PosY < 1749) || //deserto
				(PosX > 2135 && PosX < 2154 && PosY > 2072 && PosY < 2093) || //armia aki
				(PosX > 2094 && PosX < 2113 && PosY > 2105 && PosY < 2126) || //armia
				(PosX > 2467 && PosX < 2486 && PosY > 1679 && PosY < 1698) || //arzan
				(PosX > 2583 && PosX < 2602 && PosY > 1719 && PosY < 1734) || //arzan coliseu
				(PosX > 2457 && PosX < 2472 && PosY > 1984 && PosY < 1999) || //erion
				(PosX > 3640 && PosX < 3670 && PosY > 3116 && PosY < 3148) || //gelo
				(PosX > 3225 && PosX < 3251 && PosY > 1679 && PosY < 1692)) { //kefra
				NearCargo = true;
			}
			if (NearCargo == false) {
				SendClientMessage(conn, "Você está longe do Bau");
				return;
			}
		}
	}
	else
	{
		if (m->SrcSlot <= 0 || m->SrcSlot >= MAX_EQUIP - 1)
		{
			//Log("DEBUG:Trading Fails.Swap-Equip", pUser[conn].AccountName, pUser[conn].IP);
			return;
		}
		DestPlace = 1;
		SrcPlace = 1;
	}

	if (m->DestPlace == ITEM_PLACE_CARRY && m->DestSlot >= pMob[conn].MaxCarry)
		return;

	if (DestItem == NULL || SrcItem == NULL)
	{
		//Log("DEBUG:Trading Fails.Swap-Equip", pUser[conn].AccountName, pUser[conn].IP);
		return;
	}
	/*
	if (m->SrcPlace == m->DestPlace == ITEM_PLACE_CARRY)
	{
		if (pMob[conn].MOB.Carry[m->SrcSlot].sIndex == 4011 && pMob[conn].MOB.Carry[m->DestSlot].sIndex == 4011)
		{
			int numAdd = BASE_GetItemAmount(&pMob[conn].MOB.Carry[m->SrcSlot]);
			pMob[conn].MOB.Carry[m->DestSlot].stEffect[0].cEffect = 61;
			if (pMob[conn].MOB.Carry[m->DestSlot].stEffect[0].cValue + numAdd > 50)
			{
				SendClientMessage(conn, "Limite de agrupamento atingido.");
				return;
			}
			else
			{
				pMob[conn].MOB.Carry[m->DestSlot].stEffect[0].cValue += numAdd;
				memset(&pMob[conn].MOB.Carry[m->SrcSlot], 0x0, sizeof(STRUCT_ITEM));
				SendCarry(conn);
				SendEtc(conn);
				return;
			}
		}
	}
	*/
	//SISTEMA SLOTS NOVOS VIA CLIENTPATCH
	/*if (SrcItem->sIndex == 5774 && (DestItem->sIndex >= 4468 && DestItem->sIndex <= 4482)) {
		if (pUser[conn].Joias[pUser[conn].Slot][0].sIndex != 0) {
			SendItem(conn, m->SrcPlace, m->SrcSlot, SrcItem);
			SendItem(conn, m->DestPlace, m->DestSlot, DestItem);
			return;
		}
		memset(SrcItem, 0, sizeof(STRUCT_ITEM));
		SendItem(conn, m->SrcPlace, m->SrcSlot, SrcItem);

		memcpy(&pUser[conn].Joias[pUser[conn].Slot][0], DestItem, sizeof(STRUCT_ITEM));
		memset(DestItem, 0, sizeof(STRUCT_ITEM));
		SendItem(conn, m->DestPlace, m->DestSlot, DestItem);

		pMob[conn].GetCurrentScore(conn);
		SendScore(conn);
		SendJoias(conn);
		SaveUser(conn, 0);
		SendClientMessage(conn, "Cinto colocado com sucesso");
	}
	if (SrcItem->sIndex == 5775 && (DestItem->sIndex >= 4483 && DestItem->sIndex <= 4497)) {
		if (pUser[conn].Joias[pUser[conn].Slot][1].sIndex != 0) {
			SendItem(conn, m->SrcPlace, m->SrcSlot, SrcItem);
			SendItem(conn, m->DestPlace, m->DestSlot, DestItem);
			return;
		}

		memset(SrcItem, 0, sizeof(STRUCT_ITEM));
		SendItem(conn, m->SrcPlace, m->SrcSlot, SrcItem);

		memcpy(&pUser[conn].Joias[pUser[conn].Slot][1], DestItem, sizeof(STRUCT_ITEM));
		memset(DestItem, 0, sizeof(STRUCT_ITEM));
		SendItem(conn, m->DestPlace, m->DestSlot, DestItem);

		pMob[conn].GetCurrentScore(conn);
		SendScore(conn);
		SendJoias(conn);
		SaveUser(conn, 0);
		SendClientMessage(conn, "Colar colocado com sucesso");
	}*/
	if ((SrcItem->sIndex == 413 || SrcItem->sIndex == 412) && DestItem->sIndex != 0){
		if ((DestItem->sIndex >= 4468 && DestItem->sIndex <= 4497) || (DestItem->sIndex >= 788 && DestItem->sIndex <= 794)) {
			int sanc = BASE_GetItemSanc(DestItem);
			int amount = BASE_GetItemAmount(SrcItem);

			if (sanc >= 9)
			{
				SendClientMessage(conn, g_pMessageStringTable[_NN_Cant_Refine_More]);
				SendItem(conn, m->SrcPlace, m->SrcSlot, SrcItem);
				return;
			}

			if (sanc >= 6 && SrcItem->sIndex == 412)
			{
				SendClientMessage(conn, g_pMessageStringTable[_NN_Cant_Refine_More]);
				SendItem(conn, m->SrcPlace, m->SrcSlot, SrcItem);
				return;
			}

			if (sanc == 0)
			{
				if (DestItem->stEffect[0].cEffect && DestItem->stEffect[0].cEffect != 43 && (DestItem->stEffect[0].cEffect && DestItem->stEffect[0].cEffect < 116 || DestItem->stEffect[0].cEffect && DestItem->stEffect[0].cEffect > 125))
				{
					if (DestItem->stEffect[1].cEffect && DestItem->stEffect[1].cEffect != 43 && (DestItem->stEffect[1].cEffect && DestItem->stEffect[1].cEffect < 116 || DestItem->stEffect[1].cEffect && DestItem->stEffect[1].cEffect > 125))
					{
						if (DestItem->stEffect[2].cEffect && DestItem->stEffect[2].cEffect != 43 && (DestItem->stEffect[2].cEffect && DestItem->stEffect[2].cEffect < 116 || DestItem->stEffect[2].cEffect && DestItem->stEffect[2].cEffect > 125))
						{
							SendClientMessage(conn, g_pMessageStringTable[_NN_Cant_Refine_More]);
							SendItem(conn, m->SrcPlace, m->SrcSlot, SrcItem);
							return;
						}
						DestItem->stEffect[2].cEffect = 43;
						DestItem->stEffect[2].cValue = 0;
					}
					else
					{
						DestItem->stEffect[1].cEffect = 43;
						DestItem->stEffect[1].cValue = 0;
					}
				}
				else
				{
					DestItem->stEffect[0].cEffect = 43;
					DestItem->stEffect[0].cValue = 0;
				}
			}

			int _rd = rand() % 115;

			if (_rd > 100)
				_rd -= 15;

			int ref = sanc;

			int _chance = g_pCelestialRate[ref];

			if (_rd <= _chance)
			{
				BASE_SetItemSanc(DestItem, ref + 1, 0);

				pMob[conn].GetCurrentScore(conn);

				SendScore(conn);

				if (amount > 1)
					BASE_SetItemAmount(item, amount - 1);

				else
					memset(SrcItem, 0, sizeof(STRUCT_ITEM));


				SendItem(conn, m->DestPlace, m->DestSlot, DestItem);
			}

			else
			{
				SendClientMessage(conn, g_pMessageStringTable[_NN_Fail_To_Refine]);

				BASE_SetItemSanc(DestItem, 0, 0);

				pMob[conn].GetCurrentScore(conn);

				SendScore(conn);

				if (amount > 1)
					BASE_SetItemAmount(SrcItem, amount - 1);

				else
					memset(SrcItem, 0, sizeof(STRUCT_ITEM));
			}
			SendCarry(conn);
			SendEtc(conn);
			SendJoias(conn);
			return;
		}
	}
		
	if (DestItem->sIndex != 747 && SrcItem->sIndex != 747 && SrcItem->sIndex != 3505 && SrcItem->sIndex != 3980 || m->DestPlace != ITEM_PLACE_CARGO && m->SrcPlace != ITEM_PLACE_CARGO)
	{
		if (DestItem->sIndex != 3505 && SrcItem->sIndex != 3505 && DestItem->sIndex != 4144 && SrcItem->sIndex != 4144 && DestItem->sIndex != 3980 || m->DestPlace != ITEM_PLACE_CARRY && m->SrcPlace != ITEM_PLACE_CARRY)
		{
			int isGuild = 0;

			if ((DestItem->sIndex == 508 || DestItem->sIndex == 522 || DestItem->sIndex >= 526 && DestItem->sIndex <= 537)
				&& !m->DestPlace && m->SrcPlace)
				isGuild = 1;

			int isGuildAgain = 0;

			if ((SrcItem->sIndex == 508 || SrcItem->sIndex == 522 || SrcItem->sIndex >= 526 && SrcItem->sIndex <= 537)
				&& !m->DestPlace && m->SrcPlace)
				isGuildAgain = 1;

			if ((isGuild == 1 || isGuildAgain == 1) && g_Week && pMob[conn].MOB.BaseScore.Level < 1000)
			{
				SendClientMessage(conn, g_pMessageStringTable[_NN_Only_Sunday]);
				return;
			}

			GetGuild(SrcItem);
			GetGuild(DestItem);

			int Can = 1;
			int YouCan = 1;

			if (dItem->sIndex)
			{
				int error = -2;

				if (m->SrcPlace == ITEM_PLACE_EQUIP)
					Can = BASE_CanEquip(dItem, &pMob[conn].MOB.CurrentScore, m->SrcSlot, pMob[conn].MOB.Class, pMob[conn].MOB.Equip, &pMob[conn].extra);
			
				if (m->SrcPlace == ITEM_PLACE_CARRY)
				{
					if (!Can)
					{
						if (error > 0 && error <= pMob[conn].MaxCarry)
						{
							error--;
							SendItem(conn, ITEM_PLACE_CARRY, error, &pMob[conn].MOB.Carry[error]);
						}
					}
				}
			}

			if (sItem->sIndex)
			{
				int error = -2;

				if (m->DestPlace == ITEM_PLACE_EQUIP)
					YouCan = BASE_CanEquip(sItem, &pMob[conn].MOB.CurrentScore, m->DestSlot, pMob[conn].MOB.Class, pMob[conn].MOB.Equip, &pMob[conn].extra);
				
				if (m->DestPlace == ITEM_PLACE_CARRY)
				{
					if (!YouCan)
					{
						if (error > 0 && error <= pMob[conn].MaxCarry)
						{
							error--;
							SendItem(conn, ITEM_PLACE_CARRY, error, &pMob[conn].MOB.Carry[error]);
						}
					}
				}
			}
			if (Can && YouCan)
			{

				STRUCT_ITEM save1;
				STRUCT_ITEM save2;

				save1.sIndex = SrcItem->sIndex;
				save1.stEffect[0].cEffect = SrcItem->stEffect[0].cEffect;
				save1.stEffect[0].cValue = SrcItem->stEffect[0].cValue;
				save1.stEffect[1].cEffect = SrcItem->stEffect[1].cEffect;
				save1.stEffect[1].cValue = SrcItem->stEffect[1].cValue;
				save1.stEffect[2].cEffect = SrcItem->stEffect[2].cEffect;
				save1.stEffect[2].cValue = SrcItem->stEffect[2].cValue;

				save2.sIndex = DestItem->sIndex;
				save2.stEffect[0].cEffect = DestItem->stEffect[0].cEffect;
				save2.stEffect[0].cValue = DestItem->stEffect[0].cValue;
				save2.stEffect[1].cEffect = DestItem->stEffect[1].cEffect;
				save2.stEffect[1].cValue = DestItem->stEffect[1].cValue;
				save2.stEffect[2].cEffect = DestItem->stEffect[2].cEffect;
				save2.stEffect[2].cValue = DestItem->stEffect[2].cValue;

				//AGRUPAR ITENS MANUALMENTE
				if ((save1.sIndex == save2.sIndex && save1.sIndex == 413
					|| save1.sIndex == save2.sIndex && save1.sIndex == 412
					|| save1.sIndex == save2.sIndex && save1.sIndex == 3140
					|| save1.sIndex == save2.sIndex && save1.sIndex == 419
					|| save1.sIndex == save2.sIndex && save1.sIndex == 420
					|| save1.sIndex == save2.sIndex && save1.sIndex == 697
					|| save1.sIndex == save2.sIndex && save1.sIndex == 3336
					|| save1.sIndex == save2.sIndex && save1.sIndex == 3200
					|| save1.sIndex == save2.sIndex && save1.sIndex == 3201
					|| save1.sIndex == save2.sIndex && save1.sIndex == 3202
					|| save1.sIndex == save2.sIndex && save1.sIndex == 3203
					|| save1.sIndex == save2.sIndex && save1.sIndex == 3204
					|| save1.sIndex == save2.sIndex && save1.sIndex == 3205
					|| save1.sIndex == save2.sIndex && save1.sIndex == 3206
					|| save1.sIndex == save2.sIndex && save1.sIndex == 3207
					|| save1.sIndex == save2.sIndex && save1.sIndex == 3208
					|| save1.sIndex == save2.sIndex && save1.sIndex == 3209
					|| save1.sIndex == save2.sIndex && save1.sIndex == 4011
					|| save1.sIndex == save2.sIndex && save1.sIndex == 4010
					|| save1.sIndex == save2.sIndex && save1.sIndex == 4026
					|| save1.sIndex == save2.sIndex && save1.sIndex == 4027
					|| save1.sIndex == save2.sIndex && save1.sIndex == 4028
					|| save1.sIndex == save2.sIndex && save1.sIndex == 4029
					|| save1.sIndex == save2.sIndex && save1.sIndex == 3326
					|| save1.sIndex == save2.sIndex && save1.sIndex == 4146					
					|| save1.sIndex == save2.sIndex && save1.sIndex == 4016
					|| save1.sIndex == save2.sIndex && save1.sIndex == 4017
					|| save1.sIndex == save2.sIndex && save1.sIndex == 4018
					|| save1.sIndex == save2.sIndex && save1.sIndex == 4019
					|| save1.sIndex == save2.sIndex && save1.sIndex == 4020
					|| save1.sIndex == save2.sIndex && save1.sIndex == 787
					|| save1.sIndex == save2.sIndex && save1.sIndex == 4097
					|| save1.sIndex == save2.sIndex && save1.sIndex == 3182
					|| save1.sIndex == save2.sIndex && save1.sIndex == 777
					|| save1.sIndex == save2.sIndex && save1.sIndex == 4140
					|| save1.sIndex == save2.sIndex && save1.sIndex == 3173
					|| save1.sIndex == save2.sIndex && save1.sIndex == 4046
					|| save1.sIndex == save2.sIndex && save1.sIndex == 1774
					|| save1.sIndex == save2.sIndex && save1.sIndex == 415
					|| save1.sIndex == save2.sIndex && save1.sIndex >= 2441 && save1.sIndex <= 2444
					|| save1.sIndex == save2.sIndex && save1.sIndex >= 4051 && save1.sIndex <= 4055
					|| save1.sIndex == save2.sIndex && save1.sIndex >= 2390 && save1.sIndex <= 2419
					|| save1.sIndex == save2.sIndex && save1.sIndex >= 3027 && save1.sIndex <= 3030)
					&& BASE_GetItemAmount(&save1) < 120 && BASE_GetItemAmount(&save2) < 120)
				{
					int amount1 = BASE_GetItemAmount(&save1);
					int amount2 = BASE_GetItemAmount(&save2);
					int tamount = (amount1 <= 0 ? 1 : amount1) + (amount2 <= 0 ? 1 : amount2);

					if (tamount <= 119)
					{
						save1.stEffect[0].cEffect = 61;
						save1.stEffect[0].cValue = tamount;

						BASE_ClearItem(&save2);

						SendItem(conn, m->SrcPlace, m->SrcSlot, &save1);
						SendItem(conn, m->DestPlace, m->DestSlot, &save2);
					}
					else if (tamount >= 120)
					{
						save1.stEffect[0].cEffect = 61;
						save1.stEffect[0].cValue = 120;

						tamount -= 120;

						if (tamount >= 1)
							BASE_SetItemAmount(&save2, tamount > 120 ? 120 : tamount);

						if (tamount <= 0)
							BASE_ClearItem(&save2);

						SendItem(conn, m->SrcPlace, m->SrcSlot, &save1);
						SendItem(conn, m->DestPlace, m->DestSlot, &save2);
					}
				}
				

				//CONTROLE DE FADAS

				if (save1.sIndex >= 3900 && save1.sIndex <= 3902 && save1.stEffect[0].cEffect == 0 && save1.stEffect[1].cEffect == 0 && save1.stEffect[2].cEffect == 0)
				{
					BASE_FadaDate(&save1, 2); // fadas de 3 dias
					SendItem(conn, m->SrcPlace, m->SrcSlot, &save1);
				}
				if (save1.sIndex >= 3903 && save1.sIndex <= 3905 && save1.stEffect[0].cEffect == 0 && save1.stEffect[1].cEffect == 0 && save1.stEffect[2].cEffect == 0)
				{
					BASE_FadaDate(&save1, 4); // fadas 5 dias
					SendItem(conn, m->SrcPlace, m->SrcSlot, &save1);
				}
				if (save1.sIndex >= 3906 && save1.sIndex <= 3908 && save1.stEffect[0].cEffect == 0 && save1.stEffect[1].cEffect == 0 && save1.stEffect[2].cEffect == 0)
				{
					BASE_FadaDate(&save1, 6); // fadas 7 dias
					SendItem(conn, m->SrcPlace, m->SrcSlot, &save1);
				}
				if (save1.sIndex == 3916 && save1.stEffect[0].cEffect == 0 && save1.stEffect[1].cEffect == 0 && save1.stEffect[2].cEffect == 0)
				{
					BASE_FadaDate(&save1, 6); // fadas 7 dias
					SendItem(conn, m->SrcPlace, m->SrcSlot, &save1);
				}

				//ESFERAS
				if (save1.sIndex == 3980 && save1.stEffect[0].cEffect == 0 && save1.stEffect[1].cEffect == 0 && save1.stEffect[2].cEffect == 0)
				{
					BASE_SetItemDate(&save1, 3); // shire 3 dias
					SendItem(conn, m->SrcPlace, m->SrcSlot, &save1);
				}
				if (save2.sIndex == 3980 && save2.stEffect[0].cEffect == 0 && save2.stEffect[1].cEffect == 0 && save2.stEffect[2].cEffect == 0)
				{
					BASE_SetItemDate(&save2, 3); // shire 3 dias
					SendItem(conn, m->SrcPlace, m->SrcSlot, &save2);
				}

				if (save1.sIndex >= 3981 && save1.sIndex <= 3982 && save1.stEffect[0].cEffect == 0 && save1.stEffect[1].cEffect == 0 && save1.stEffect[2].cEffect == 0)
				{
					BASE_SetItemDate(&save1, 3); // Thoroughbred e Klazedale 3 Dias
					SendItem(conn, m->SrcPlace, m->SrcSlot, &save1);
				}
				if (save2.sIndex >= 3981 && save2.sIndex <= 3982 && save2.stEffect[0].cEffect == 0 && save2.stEffect[1].cEffect == 0 && save2.stEffect[2].cEffect == 0)
				{
					BASE_SetItemDate(&save2, 3); // Thoroughbred e Klazedale 3 Dias
					SendItem(conn, m->SrcPlace, m->SrcSlot, &save2);
				}

				if (save1.sIndex >= 3983 && save1.sIndex <= 3985 && save1.stEffect[0].cEffect == 0 && save1.stEffect[1].cEffect == 0 && save1.stEffect[2].cEffect == 0)
				{
					BASE_SetItemDate(&save1, 15); //Shire, Thoroughbred, Klazedale 15 dias
					SendItem(conn, m->SrcPlace, m->SrcSlot, &save1);
				}
				if (save2.sIndex >= 3983 && save2.sIndex <= 3985 && save2.stEffect[0].cEffect == 0 && save2.stEffect[1].cEffect == 0 && save2.stEffect[2].cEffect == 0)
				{
					BASE_SetItemDate(&save2, 15);//Shire, Thoroughbred, Klazedale 15 dias
					SendItem(conn, m->DestPlace, m->DestSlot, &save2);
				}

				if (save1.sIndex >= 3986 && save1.sIndex <= 3989 && save1.stEffect[0].cEffect == 0 && save1.stEffect[1].cEffect == 0 && save1.stEffect[2].cEffect == 0)
				{
					BASE_SetItemDate(&save1, 30); //Shire, Thoroughbred, Klazedale, Gullfaxi 30 dias
					SendItem(conn, m->SrcPlace, m->SrcSlot, &save1);
				}
				if (save2.sIndex >= 3986 && save2.sIndex <= 3989 && save2.stEffect[0].cEffect == 0 && save2.stEffect[1].cEffect == 0 && save2.stEffect[2].cEffect == 0)
				{
					BASE_SetItemDate(&save2, 30); //Shire, Thoroughbred, Klazedale, Gullfaxi 30 dias
					SendItem(conn, m->DestPlace, m->DestSlot, &save2);
				}

				if (save1.sIndex >= 3995 && save1.sIndex <= 3999 && save1.stEffect[0].cEffect == 0 && save1.stEffect[1].cEffect == 0 && save1.stEffect[2].cEffect == 0)
				{
					BASE_SetItemDate(&save1, 30); //Novas Esferas 30 dias
					SendItem(conn, m->SrcPlace, m->SrcSlot, &save1);
				}
				if (save2.sIndex >= 3995 && save2.sIndex <= 3999 && save2.stEffect[0].cEffect == 0 && save2.stEffect[1].cEffect == 0 && save2.stEffect[2].cEffect == 0)
				{
					BASE_SetItemDate(&save2, 30); //Novas Esferas 30 dias
					SendItem(conn, m->DestPlace, m->DestSlot, &save2);
				}
				if (save1.sIndex >= 3990 && save1.sIndex <= 3992 && save1.stEffect[0].cEffect == 0 && save1.stEffect[1].cEffect == 0 && save1.stEffect[2].cEffect == 0)
				{
					BASE_SetItemDate(&save1, 30); //Novas Esferas 30 dias
					SendItem(conn, m->SrcPlace, m->SrcSlot, &save1);
				}
				if (save2.sIndex >= 3990 && save2.sIndex <= 3992 && save2.stEffect[0].cEffect == 0 && save2.stEffect[1].cEffect == 0 && save2.stEffect[2].cEffect == 0)
				{
					BASE_SetItemDate(&save2, 30); //Novas Esferas 30 dias
					SendItem(conn, m->DestPlace, m->DestSlot, &save2);
				}

				//TRAJES
				if (save1.sIndex >= 4150 && save1.sIndex <= 4188 && save1.stEffect[0].cEffect == 0 && save1.stEffect[1].cEffect == 0 && save1.stEffect[2].cEffect == 0)
				{
					BASE_SetItemDate(&save1, 30);
					SendItem(conn, m->SrcPlace, m->SrcSlot, &save1);
				}
				if (save2.sIndex >= 4150 && save2.sIndex <= 4188 && save2.stEffect[0].cEffect == 0 && save2.stEffect[1].cEffect == 0 && save2.stEffect[2].cEffect == 0)
				{
					BASE_SetItemDate(&save2, 30);
					SendItem(conn, m->DestPlace, m->DestSlot, &save2);
				}
				if (save1.sIndex >= 4200 && save1.sIndex <= 4467 && save1.stEffect[0].cEffect == 0 && save1.stEffect[1].cEffect == 0 && save1.stEffect[2].cEffect == 0)
				{
					BASE_SetItemDate(&save1, 30);
					SendItem(conn, m->SrcPlace, m->SrcSlot, &save1);
				}
				if (save2.sIndex >= 4200 && save2.sIndex <= 4467 && save2.stEffect[0].cEffect == 0 && save2.stEffect[1].cEffect == 0 && save2.stEffect[2].cEffect == 0)
				{
					BASE_SetItemDate(&save2, 30);
					SendItem(conn, m->DestPlace, m->DestSlot, &save2);
				}				

				//VERIFICAÇAO DE DATA
				if (save1.sIndex >= 3980 && save1.sIndex <= 3992 && BASE_CheckItemDate(&save1) || save1.sIndex >= 4150 && save1.sIndex <= 4188 && BASE_CheckItemDate(&save1))
				{
					BASE_ClearItem(&save1);
					SendItem(conn, m->SrcPlace, m->SrcSlot, &save1);
				}
				if (save2.sIndex >= 3980 && save2.sIndex <= 3992 && BASE_CheckItemDate(&save2) || save2.sIndex >= 4150 && save2.sIndex <= 4188 && BASE_CheckItemDate(&save2))
				{
					BASE_ClearItem(&save2);
					SendItem(conn, m->DestPlace, m->DestSlot, &save2);
				}
				if (save1.sIndex >= 4200 && save1.sIndex <= 4467 && BASE_CheckItemDate(&save1))
				{
					BASE_ClearItem(&save1);
					SendItem(conn, m->SrcPlace, m->SrcSlot, &save1);
				}
				if (save2.sIndex >= 4200 && save2.sIndex <= 4467 && BASE_CheckItemDate(&save2))
				{
					BASE_ClearItem(&save2);
					SendItem(conn, m->DestPlace, m->DestSlot, &save2);
				}

				char itemLog[2048];
				char itemLog2[2048];

				BASE_GetItemCode(&save1, itemLog);
				BASE_GetItemCode(&save2, itemLog2);

				//sprintf(temp, "tradingitem, SrcType:%d SrcSlot:%d Item:%s DstType:%d DstSlot:%d Item:%s", m->SrcPlace, m->SrcSlot, itemLog, m->DestPlace, m->DestSlot, itemLog2);
				//ItemLog(temp, pUser[conn].AccountName, pUser[conn].MacAddress);

				memcpy(SrcItem, &save2, sizeof(STRUCT_ITEM));
				memcpy(DestItem, &save1, sizeof(STRUCT_ITEM));


				if (save2.sIndex <= 40)
					GetGuild(SrcItem);

				if (save1.sIndex <= 40)
					GetGuild(DestItem);

				pMob[conn].GetCurrentScore(conn);

				int Size = m->Size;

				if (Size > sizeof(MSG_TradingItem))
				{
					m->Size = 0;
					return;
				}
				if (!pUser[conn].cSock.AddMessage((char*)m, sizeof(MSG_TradingItem)))
					CloseUser(conn);

				if (!pMob[conn].MOB.Equip[6].sIndex)
				{
					if (pMob[conn].MOB.Equip[7].sIndex)
					{
						int hab = BASE_GetItemAbility(&pMob[conn].MOB.Equip[7], EF_POS);

						if (hab != 128)
						{
							m->DestPlace = ITEM_PLACE_EQUIP;
							m->DestSlot = 6;
							m->SrcPlace = ITEM_PLACE_EQUIP;
							m->SrcSlot = 7;

							int Size = m->Size;

							if (Size > sizeof(MSG_TradingItem))
							{
								m->Size = 0;
								return;
							}
							if (!pUser[conn].cSock.AddMessage((char*)m, sizeof(MSG_TradingItem)))
								CloseUser(conn);

							pMob[conn].MOB.Equip[6] = pMob[conn].MOB.Equip[7];

							memset(&pMob[conn].MOB.Equip[7], 0, sizeof(STRUCT_ITEM));
						}
					}
				}

				if (DestPlace == ITEM_PLACE_CARRY)
					SendEquip(conn, conn);

				if (SrcPlace == ITEM_PLACE_CARRY)
				{
					GetGuild(conn);
					SendScore(conn);
				}

				if (DestItem->sIndex >= 2330 && DestItem->sIndex < 2360 || SrcItem->sIndex >= 2330 && SrcItem->sIndex < 2360)
					MountProcess(conn, Mount);

				//Verifica se a montaria tem traje e retira
				if (SrcItem->sIndex >= 2360 && SrcItem->sIndex < 2390) {
					if (m->SrcPlace == ITEM_PLACE_CARGO) {
						if (SrcItem->stEffect[2].cValue != 0) {
							SrcItem->stEffect[2].cValue = 0;
							RemoveMountTraje(conn);
						}
						SendItem(conn, ITEM_PLACE_CARGO, m->SrcSlot, &pUser[conn].Cargo[m->SrcSlot]);
					}
					if (m->SrcPlace == ITEM_PLACE_CARRY) {
						if (SrcItem->stEffect[2].cValue != 0) {
							SrcItem->stEffect[2].cValue = 0;
							RemoveMountTraje(conn);
						}
						SendItem(conn, ITEM_PLACE_CARRY, m->SrcSlot, &pMob[conn].MOB.Carry[m->SrcSlot]);
					}
				}
				if (DestItem->sIndex >= 2360 && DestItem->sIndex < 2390) {
					if (m->DestPlace == ITEM_PLACE_EQUIP) {
						RequestTraje(conn);
					}
					if (m->DestPlace == ITEM_PLACE_CARGO) {
						if (DestItem->stEffect[2].cValue != 0) {
							DestItem->stEffect[2].cValue = 0;
							RemoveMountTraje(conn);
						}
						SendItem(conn, ITEM_PLACE_CARGO, m->DestSlot, &pUser[conn].Cargo[m->DestSlot]);
					}
					if (m->DestPlace == ITEM_PLACE_CARRY) {
						if (DestItem->stEffect[2].cValue != 0) {
							DestItem->stEffect[2].cValue = 0;	
							RemoveMountTraje(conn);
						}
						SendItem(conn, ITEM_PLACE_CARRY, m->DestSlot, &pMob[conn].MOB.Carry[m->DestSlot]);
					}
				}
				STRUCT_ITEM *Storage2 = &pUser[conn].Cargo[MAX_CARGO - 2];
				STRUCT_ITEM *LastStorage = &pUser[conn].Cargo[MAX_CARGO - 1];

				if (m->DestPlace == ITEM_PLACE_CARGO || m->SrcPlace == ITEM_PLACE_CARGO)
				{
					if (Storage2->sIndex || LastStorage->sIndex)
					{
						for (int i = 0; i < 126; ++i)
						{
							if (Storage2->sIndex)
							{
								int cancargo = BASE_CanCargo(Storage2, pUser[conn].Cargo, i % 9, i / 9);
								if (cancargo)
								{
									memcpy(&pUser[conn].Cargo[i], Storage2, sizeof(STRUCT_ITEM));

									memset(Storage2, 0, sizeof(STRUCT_ITEM));
									SendItem(conn, ITEM_PLACE_CARGO, i, &pUser[conn].Cargo[i]);
								}
							}

							else
							{
								if (LastStorage->sIndex)
								{
									int cancargo = BASE_CanCargo(LastStorage, pUser[conn].Cargo, i % 9, i / 9);
									if (cancargo)
									{
										memcpy(&pUser[conn].Cargo[i], LastStorage, sizeof(STRUCT_ITEM));

										memset(LastStorage, 0, sizeof(STRUCT_ITEM));
										SendItem(conn, ITEM_PLACE_CARGO, i, &pUser[conn].Cargo[i]);
									}
								}
							}
						}
					}
				}
			}
			else
			{
				STRUCT_ITEM save1;
				STRUCT_ITEM save2;

				save1.sIndex = SrcItem->sIndex;
				save1.stEffect[0].cEffect = SrcItem->stEffect[0].cEffect;
				save1.stEffect[0].cValue = SrcItem->stEffect[0].cValue;
				save1.stEffect[1].cEffect = SrcItem->stEffect[1].cEffect;
				save1.stEffect[1].cValue = SrcItem->stEffect[1].cValue;
				save1.stEffect[2].cEffect = SrcItem->stEffect[2].cEffect;
				save1.stEffect[2].cValue = SrcItem->stEffect[2].cValue;

				save2.sIndex = DestItem->sIndex;
				save2.stEffect[0].cEffect = DestItem->stEffect[0].cEffect;
				save2.stEffect[0].cValue = DestItem->stEffect[0].cValue;
				save2.stEffect[1].cEffect = DestItem->stEffect[1].cEffect;
				save2.stEffect[1].cValue = DestItem->stEffect[1].cValue;
				save2.stEffect[2].cEffect = DestItem->stEffect[2].cEffect;
				save2.stEffect[2].cValue = DestItem->stEffect[2].cValue;

				memcpy(SrcItem, &save1, sizeof(STRUCT_ITEM));
				memcpy(DestItem, &save2, sizeof(STRUCT_ITEM));
			}
		}
	}

	pMob[conn].GetCurrentScore(conn);
	SendScore(conn);
	SendEtc(conn);
}

# -------------------- _MSG_UpdateItem.cpp --------------------

/*
*   Copyright (C) {2015}  {Victor Klafke, Charles TheHouse}
*
*   This program is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
* 
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program.  If not, see [http://www.gnu.org/licenses/].
*
*   Contact at: victor.klafke@ecomp.ufsm.br
*/
#include "ProcessClientMessage.h"

void Exec_MSG_UpdateItem(int conn, char *pMsg)
{
	MSG_UpdateItem *m = (MSG_UpdateItem*)pMsg;

	int Size = m->Size;

	if (Size > sizeof(MSG_UpdateItem)) //CONTROLE DE SIZE
	{
		SendClientMessage(conn, "Impossível executar ação53, tente mais tarde. ");
		return;
	}

	if (pMob[conn].MOB.CurrentScore.Hp == 0 || pUser[conn].Mode != USER_PLAY)
	{
		SendHpMode(conn);
		AddCrackError(conn, 1, 16);
		return;
	}
	if(m->State < 0 || m->State > 5)
	{
		AddCrackError(conn, 50, 50);
		return;
	}

	if(m->ItemID < 10000 || m->ItemID >= 10000 + MAX_ITEM)
	{
		AddCrackError(conn, 50, 50);
		return;
	}

	int gateid = m->ItemID - 10000;
	int gatestate = m->State;

	if(gateid < 0 || gateid >= MAX_ITEM)
	{
		AddCrackError(conn, 50, 50);
		return;
	}

	if (CCastleZakum::OpenCastleGate(conn, gateid, m) == TRUE)
		return;
		
	int state = pItem[gateid].State;
	int gatestate2 = m->State;

	int gatekey = BASE_GetItemAbility(&pItem[gateid].ITEM, EF_KEYID);

	if (state != 3 && gatestate2 != 3)
		goto NoNeedKey;

	if (gatekey == 0)
		goto NoNeedKey;

	int key = 0;
	int Quest = -1;
	
	int i = 0;
	for (i = 0; i < MAX_CARRY; i++)
	{
		key = BASE_GetItemAbility(&pMob[conn].MOB.Carry[i], EF_KEYID);

		if (key != gatekey)
			continue;

		Quest = BASE_GetItemAbility(&pMob[conn].MOB.Carry[i], EF_QUEST);

		break;
	}

	if (gatekey != key)
	{
		if (pItem[gateid].ITEM.sIndex != 773)
			SendClientMessage(conn, g_pMessageStringTable[_NN_No_Key]);

		return;
	}
	
	memset(&pMob[conn].MOB.Carry[i], 0, sizeof(STRUCT_ITEM));
	SendItem(conn, ITEM_PLACE_CARRY, i, &pMob[conn].MOB.Carry[i]);
NoNeedKey:

	/*if (CEncampment::OpenTreasureBox(conn, gateid) == TRUE)
		return;*/

	int heigth = 0;

	int isUpdate = UpdateItem(gateid, STATE_OPEN, &heigth);

	if (isUpdate)
		GridMulticast(pItem[gateid].PosX, pItem[gateid].PosY, (MSG_STANDARD*)m, 0);

	return;
}

# -------------------- _MSG_UseItem.cpp --------------------

#pragma once
#include "ProcessClientMessage.h"
#include "wMySQL.h"
#include "Functions.h"

int g_pAmunraRate[15] =
{
	100, 100, 100, 100, 100, 100, 90, 80, 70, 60, 50, 40, 25, 20, 10
};
//acho?

int HuntingScrolls[6][10][2] =
{
	//Armia
	{ { 2370, 2106 }, { 2508, 2101 }, { 2526, 2109 }, { 2529, 1882 }, { 2126, 1600 }, { 2005, 1617 }, { 2241, 1474 }, { 1858, 1721 }, { 2250, 1316 }, { 1989, 1755 } },

	//Dungeon
	{ { 290, 3799 }, { 724, 3781 }, { 481, 4062 }, { 876, 4058 }, { 855, 3922 }, { 808, 3876 }, { 959, 3813 }, { 926, 3750 }, { 1096, 3730 }, { 1132, 3800 } },

	//SubMundo
	{ { 1242, 4035 }, { 1264, 4017 }, { 1333, 3994 }, { 1358, 4041 }, { 1462, 4033 }, { 1326, 3788 }, { 1493, 3777 }, { 1437, 3741 }, { 1389, 3740 }, { 1422, 3810 } },

	//Kult
	{ { 1376, 1722 }, { 1426, 1686 }, { 1381, 1861 }, { 1326, 1896 }, { 1510, 1723 }, { 1543, 1726 }, { 1580, 1758 }, { 1182, 1714 }, { 1634, 1727 }, { 1237, 1764 } },

	//Kefra
	{ { 2367, 4024 }, { 2236, 4044 }, { 2236, 3993 }, { 2209, 3989 }, { 2453, 4067 }, { 2485, 4043 }, { 2537, 3897 }, { 2489, 3919 }, { 2269, 3910 }, { 2202, 3866 } },

	//Nipple
	{ { 3664, 3024 }, { 3582, 3007 }, { 3514, 3008 }, { 3819, 2977 }, { 3517, 2889 }, { 3745, 2977 }, { 3639, 2877 }, { 3650, 2727 }, { 3660, 2773 }, { 3746, 2879 } }
};

void Exec_MSG_UseItem(int conn, char* pMsg)
{
	MSG_UseItem* m = (MSG_UseItem*)pMsg;

	int Size = m->Size;

	if (Size > sizeof(MSG_UseItem)) //CONTROLE DE CLIENTE SIZE
	{
		SendClientMessage(conn, "Impossível executar ação54, tente mais tarde. ");
		return;
	}

	if (pUser[conn].Mode != USER_PLAY)
	{
		SendHpMode(conn);
		return;
	}

	if (m->DestType < 0 || m->DestType > 2) {
		CloseUser(conn);
		return;
	}

	if (m->SourType < 0 || m->SourType > 2) {
		CloseUser(conn);
		return;
	}

	if (m->SourPos < 0 || m->SourPos > 60) {
		CloseUser(conn);
		return;
	}

	if (m->DestPos < 0 || m->DestPos > 60) {
		CloseUser(conn);
		return;
	}

	if (m->GridX < 0 || m->GridX > MAX_GRIDX)
		return;

	if (m->GridY < 0 || m->GridY > MAX_GRIDY)
		return;

	if (m->WarpID < 0 || m->WarpID > 10)
		return;

	if (pUser[conn].Trade.OpponentID)
	{
		RemoveTrade(pUser[conn].Trade.OpponentID);
		RemoveTrade(conn);
		return;
	}

	if (pUser[conn].TradeMode)
	{
		RemoveTrade(conn);
		return;
	}

	if (pMob[conn].MOB.CurrentScore.Hp == 0)
	{
		SendHpMode(conn);
		//AddCrackError(conn, 1, 15);

		if (m->SourType == ITEM_PLACE_CARRY)
			SendItem(conn, m->SourType, m->SourPos, &pMob[conn].MOB.Carry[m->SourPos]);

		else if (m->SourType == ITEM_PLACE_CARGO)
			SendItem(conn, m->SourType, m->SourPos, &pUser[conn].Cargo[m->SourPos]);

		else
			SendItem(conn, m->SourType, m->SourPos, &pMob[conn].MOB.Equip[m->SourPos]);

		return;
	}

	if (m->GridX >= MAX_GRIDX || m->GridY >= MAX_GRIDY)
	{
		CrackLog(conn, " Drop grid, out of range");
		return;
	}
	STRUCT_ITEM* item = GetItemPointer(&pMob[conn].MOB, pUser[conn].Cargo, m->SourType, m->SourPos);

	if (item == NULL)
	{
		return;
	}
	int Vol = BASE_GetItemAbility(item, EF_VOLATILE);
	int amount = BASE_GetItemAmount(item);

#pragma region >> Replation Normal
	if (item->sIndex >= 4016 && item->sIndex <= 4020)
	{
		STRUCT_ITEM* dest = GetItemPointer(&pMob[conn].MOB, pUser[conn].Cargo, m->DestType, m->DestPos);

		if (dest == NULL)
			return;

		int nPos = g_pItemList[dest->sIndex].nPos;

		if (!m->DestType || m->DestPos >= 60)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Only_To_Equips]);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (dest->sIndex >= 3500 && dest->sIndex <= 3507)
		{
			SendClientMessage(conn, "Não é possível utilizar em cytheras.");
			SendItem(conn, ITEM_PLACE_CARRY, m->SourPos, item);
			return;
		}

		if (nPos == 64 || nPos == 192 || nPos == 42)
		{
			SendClientMessage(conn, "Possível somente para equipamentos de defesa.");
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		int sanc = BASE_GetItemSanc(dest);
		int ItemId = dest->sIndex;

		if (sanc > 6 || BASE_GetItemAbility(dest, EF_MOBTYPE) != 0 && BASE_GetItemAbility(dest, EF_MOBTYPE) != 2)
		{
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		int replation = item->sIndex >= 4016 && item->sIndex <= 4020 ? item->sIndex - 4015 : item->sIndex - 4020;

		if (BASE_GetItemAbility(dest, EF_ITEMLEVEL) != replation)
		{
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		SetItemBonus2(dest);
		SendItem(conn, m->DestType, m->DestPos, dest);
		SendEmotion(conn, 14, 3);

		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));

		return;
	}
#pragma endregion
#pragma region >> Replation Premium
	if (item->sIndex >= 4021 && item->sIndex <= 4025)
	{
		STRUCT_ITEM* dest = GetItemPointer(&pMob[conn].MOB, pUser[conn].Cargo, m->DestType, m->DestPos);

		if (dest == NULL)
			return;

		int nPos = g_pItemList[dest->sIndex].nPos;

		if (!m->DestType || m->DestPos >= 60)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Only_To_Equips]);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (dest->sIndex >= 3500 && dest->sIndex <= 3507)
		{
			SendClientMessage(conn, "Não é possível utilizar em cytheras.");
			SendItem(conn, ITEM_PLACE_CARRY, m->SourPos, item);
			return;
		}

		if (nPos == 64 || nPos == 192 || nPos == 42)
		{
			SendClientMessage(conn, "Possível somente para equipamentos de defesa.");
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		int sanc = BASE_GetItemSanc(dest);
		int ItemId = dest->sIndex;

		if (sanc > 9 || BASE_GetItemAbility(dest, EF_MOBTYPE) != 0 && BASE_GetItemAbility(dest, EF_MOBTYPE) != 2)
		{
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		int replation = item->sIndex >= 4021 && item->sIndex <= 4025 ? item->sIndex - 4020 : item->sIndex - 4025;

		if (BASE_GetItemAbility(dest, EF_ITEMLEVEL) != replation)
		{
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		SetItemBonus2(dest);
		SendItem(conn, m->DestType, m->DestPos, dest);
		SendEmotion(conn, 14, 3);

		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));

		return;
	}
#pragma endregion

#pragma region POT HP / MP
	if (Vol == 1)
	{
		ULONGLONG Hp = BASE_GetItemAbility(item, EF_HP);

		if (pUser[conn].PotionTime != 0)
		{
			int isTime = GetTickCount64() - pUser[conn].PotionTime;

			if (isTime < 100)
			{
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}
		}
		pUser[conn].PotionTime = GetTickCount64();


		int cancelado = GetEmptyAffect(conn, 32);

		if (cancelado == -1 || pMob[conn].Affect[cancelado].Type == 32)
		{
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (Hp && pMob[conn].MOB.CurrentScore.Hp > 0)
		{
			int ReqHp = pUser[conn].ReqHp;
			ReqHp += Hp;

			if (ReqHp > pMob[conn].MOB.CurrentScore.MaxHp)
				ReqHp = pMob[conn].MOB.CurrentScore.MaxHp;

			pUser[conn].ReqHp = ReqHp;
		}
		int Mp = BASE_GetItemAbility(item, EF_MP);

		if (Mp)
		{
			int ReqMp = pUser[conn].ReqMp;
			ReqMp += Mp;

			if (ReqMp > pMob[conn].MOB.CurrentScore.MaxMp)
				ReqMp = pMob[conn].MOB.CurrentScore.MaxMp;

			pUser[conn].ReqMp = ReqMp;
		}
		pUser[conn].Unk_2688 = 1;
		SendSetHpMp(conn);

		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));

		return;

	}

#pragma endregion
#pragma region PO / PL
	if (Vol == 4 || Vol == 5) // PO - PL
	{
		STRUCT_ITEM* dest = GetItemPointer(&pMob[conn].MOB, pUser[conn].Cargo, m->DestType, m->DestPos);

		if (dest == NULL)
		{
			return;
		}

		if (dest->sIndex == 3197 || dest->sIndex == 3198 || dest->sIndex == 3199 || dest->sIndex == 1767 || dest->sIndex == 1770 || dest->sIndex == 573 || dest->sIndex == 769)
		{
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (dest->sIndex >= 938 && dest->sIndex <= 944)
		{
			SendClientMessage(conn, "Esse item não pode ser refinado");
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		int Egg = 0;

		if (dest->sIndex >= 2300 && dest->sIndex < 2330)
			Egg = 1;

		if (m->DestType == ITEM_PLACE_CARRY && m->DestPos < pMob[conn].MaxCarry)
		{
			if (dest == NULL)
			{
				SendClientMessage(conn, g_pMessageStringTable[_NN_Only_To_Equips]);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			int dstVolatile = BASE_GetItemAbility(dest, EF_VOLATILE);

			if (dstVolatile)
			{
				SendClientMessage(conn, g_pMessageStringTable[_NN_Only_To_Equips]);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			int isSanc = BASE_GetItemAbility(dest, EF_NOSANC);

			if (isSanc)
			{
				SendClientMessage(conn, g_pMessageStringTable[_NN_Cant_Refine_More]);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			int sanc = BASE_GetItemSanc(dest);
			int itemtype = 0;

			if (dest->sIndex >= 1234 && dest->sIndex <= 1237 || dest->sIndex >= 1369 && dest->sIndex <= 1372 || dest->sIndex >= 1519 && dest->sIndex <= 1522 || dest->sIndex >= 1669 && dest->sIndex <= 1672 || dest->sIndex >= 1901 && dest->sIndex <= 1910 || dest->sIndex == 1714)
				itemtype = 5;

			if (sanc >= 6 && Vol == 4)
			{
				SendClientMessage(conn, g_pMessageStringTable[_NN_Cant_Refine_More]);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}



#pragma region Refinar item Selado no inven 
			if (itemtype == 5)
			{
				if (sanc >= 9)
				{
					SendClientMessage(conn, g_pMessageStringTable[_NN_Cant_Refine_More]);
					SendItem(conn, m->SourType, m->SourPos, item);
					return;
				}

				if (sanc >= 6 && Vol == 4)
				{
					SendClientMessage(conn, g_pMessageStringTable[_NN_Cant_Refine_More]);
					SendItem(conn, m->SourType, m->SourPos, item);
					return;
				}

				if (sanc == 0)
				{
					if (dest->stEffect[0].cEffect && dest->stEffect[0].cEffect != 43 && (dest->stEffect[0].cEffect && dest->stEffect[0].cEffect < 116 || dest->stEffect[0].cEffect && dest->stEffect[0].cEffect > 125))
					{
						if (dest->stEffect[1].cEffect && dest->stEffect[1].cEffect != 43 && (dest->stEffect[1].cEffect && dest->stEffect[1].cEffect < 116 || dest->stEffect[1].cEffect && dest->stEffect[1].cEffect > 125))
						{
							if (dest->stEffect[2].cEffect && dest->stEffect[2].cEffect != 43 && (dest->stEffect[2].cEffect && dest->stEffect[2].cEffect < 116 || dest->stEffect[2].cEffect && dest->stEffect[2].cEffect > 125))
							{
								SendClientMessage(conn, g_pMessageStringTable[_NN_Cant_Refine_More]);
								SendItem(conn, m->SourType, m->SourPos, item);
								return;
							}
							dest->stEffect[2].cEffect = 43;
							dest->stEffect[2].cValue = 0;
						}
						else
						{
							dest->stEffect[1].cEffect = 43;
							dest->stEffect[1].cValue = 0;
						}
					}
					else
					{
						dest->stEffect[0].cEffect = 43;
						dest->stEffect[0].cValue = 0;
					}
				}

				int _rd = rand() % 115;

				if (_rd > 100)
					_rd -= 15;

				int ref = sanc;

				int _chance = g_pCelestialRate[ref];

				if (_rd <= _chance)
				{
					BASE_SetItemSanc(dest, ref + 1, 0);

					pMob[conn].GetCurrentScore(conn);

					SendScore(conn);

					if (amount > 1)
						BASE_SetItemAmount(item, amount - 1);

					else
						memset(item, 0, sizeof(STRUCT_ITEM));


					SendItem(conn, m->DestType, m->DestPos, dest);
					SendEmotion(conn, 14, 3);
				}

				else
				{
					SendClientMessage(conn, g_pMessageStringTable[_NN_Fail_To_Refine]);

					if (amount > 1)
						BASE_SetItemAmount(item, amount - 1);

					else
						memset(item, 0, sizeof(STRUCT_ITEM));


					BASE_ClearItem(dest);
					SendItem(conn, m->DestType, m->DestPos, dest);

					int sFace = pMob[conn].MOB.Equip[0].sIndex / 10;

					if (sFace)
						SendEmotion(conn, 15, 0);

					else
						SendEmotion(conn, 20, 0);
				}

				return;
			}
			SendClientMessage(conn, g_pMessageStringTable[_NN_Only_To_Equips]);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
#pragma endregion
		}

		if (m->DestType == ITEM_PLACE_EQUIP && m->DestPos == 0 || m->DestType || m->DestPos > 11 && m->DestPos < 15 && dest->sIndex != 753 && dest->sIndex != 769 && dest->sIndex != 1726 && !Egg)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Only_To_Equips]);
			//char temp[1024];
			//ItemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);

			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (dest == NULL)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Only_To_Equips]);
			
			ItemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		int dstVolatile = BASE_GetItemAbility(dest, EF_VOLATILE);

		if (dstVolatile)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Only_To_Equips]);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		int isSanc = BASE_GetItemAbility(dest, EF_NOSANC);

		if (isSanc)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Cant_Refine_More]);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		int sanc = BASE_GetItemSanc(dest);
		int itemtype = BASE_GetItemAbility(dest, EF_MOBTYPE);

		if (sanc >= 6 && Vol == 4)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Cant_Refine_More]);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

#pragma region Refinar item celestial / HC
		if (itemtype == 3)
		{
			if (sanc >= REF_15)
			{
				SendClientMessage(conn, g_pMessageStringTable[_NN_Cant_Refine_More]);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if (sanc >= 6 && Vol == 4)
			{
				SendClientMessage(conn, g_pMessageStringTable[_NN_Cant_Refine_More]);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if (sanc == 0)
			{
				if (dest->stEffect[0].cEffect && dest->stEffect[0].cEffect != 43 && (dest->stEffect[0].cEffect && dest->stEffect[0].cEffect < 116 || dest->stEffect[0].cEffect && dest->stEffect[0].cEffect > 125))
				{
					if (dest->stEffect[1].cEffect && dest->stEffect[1].cEffect != 43 && (dest->stEffect[1].cEffect && dest->stEffect[1].cEffect < 116 || dest->stEffect[1].cEffect && dest->stEffect[1].cEffect > 125))
					{
						if (dest->stEffect[2].cEffect && dest->stEffect[2].cEffect != 43 && (dest->stEffect[2].cEffect && dest->stEffect[2].cEffect < 116 || dest->stEffect[2].cEffect && dest->stEffect[2].cEffect > 125))
						{
							SendClientMessage(conn, g_pMessageStringTable[_NN_Cant_Refine_More]);
							SendItem(conn, m->SourType, m->SourPos, item);
							return;
						}
						dest->stEffect[2].cEffect = 43;
						dest->stEffect[2].cValue = 0;
					}
					else
					{
						dest->stEffect[1].cEffect = 43;
						dest->stEffect[1].cValue = 0;
					}
				}
				else
				{
					dest->stEffect[0].cEffect = 43;
					dest->stEffect[0].cValue = 0;
				}
			}

			int _rd = rand() % 115;

			if (_rd > 100)
				_rd -= 15;

			int ref = sanc;

			if (ref == REF_10)
				ref = 10;

			else if (ref == REF_11)
				ref = 11;

			else if (ref == REF_12)
				ref = 12;

			else if (ref == REF_13)
				ref = 13;

			else if (ref == REF_14)
				ref = 14;

			else if (ref == REF_15)
				ref = 15;

			int _chance = g_pCelestialRate[ref];

			if (_rd <= _chance)
			{
				SendClientMessage(conn, g_pMessageStringTable[_NN_Refine_Success]);


				BASE_SetItemSanc(dest, ref + 1, 0);

				pMob[conn].GetCurrentScore(conn);

				SendScore(conn);

				snprintf(temp, sizeof(temp), "useitem,refine success %d+%d - (%d,%d,%d)", dest->sIndex, sanc, item->stEffect[0].cEffect, item->stEffect[1].cEffect, item->stEffect[2].cEffect);
				ItemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);

				//SendNotice(g_pMessageStringTable[_SS_Combin_12Succ]);

				if (amount > 1)
					BASE_SetItemAmount(item, amount - 1);

				else
					memset(item, 0, sizeof(STRUCT_ITEM));


				SendItem(conn, m->DestType, m->DestPos, dest);
				SendEmotion(conn, 14, 3);
			}

			else
			{
				snprintf(temp, sizeof(temp), "useitem,refine fail %d+%d - (%d,%d,%d)", dest->sIndex, sanc, item->stEffect[0].cEffect, item->stEffect[1].cEffect, item->stEffect[2].cEffect);
				ItemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);

				if (amount > 1)
					BASE_SetItemAmount(item, amount - 1);

				else
					memset(item, 0, sizeof(STRUCT_ITEM));


				BASE_SetItemSanc(dest, 0, 0);
				SendItem(conn, m->DestType, m->DestPos, dest);

				int sFace = pMob[conn].MOB.Equip[0].sIndex / 10;

				if (sFace)
					SendEmotion(conn, 15, 0);

				else
					SendEmotion(conn, 20, 0);
			}

			return;
		}
#pragma endregion
#pragma region Pedras Arch
		if (dest->sIndex >= 1752 && dest->sIndex <= 1759)
		{
			int _rd = rand() % 115;

			if (_rd > 100)
				_rd -= 15;

			int NextPedra = 1744;
			int RateSucess = 0;

			if (dest->sIndex == 1752)//Orc Tropper
			{
				if (_rd < 56)
					NextPedra = 1744;//Inteligencia

				else if (_rd < 80)
					NextPedra = 1745;//Sabedoria

				else if (_rd < 90)
					NextPedra = 1746;//Misericórdia

				else if (_rd < 93)
					NextPedra = 1747;//Abismo

				RateSucess = 93;
			}

			else if (dest->sIndex == 1753)//Esqueleto
			{
				if (_rd < 21)
					NextPedra = 1744;//Inteligencia

				else if (_rd < 76)
					NextPedra = 1745;//Sabedoria

				else if (_rd < 86)
					NextPedra = 1746;//Misericórdia

				else if (_rd < 90)
					NextPedra = 1747;//Abismo

				RateSucess = 90;
			}

			else if (dest->sIndex == 1754)//Dragão Lich
			{
				if (_rd < 3)
					NextPedra = 1744;//Inteligencia

				else if (_rd < 21)
					NextPedra = 1745;//Sabedoria

				else if (_rd < 76)
					NextPedra = 1746;//Misericórdia

				else if (_rd < 85)
					NextPedra = 1747;//Abismo

				RateSucess = 85;
			}

			else if (dest->sIndex == 1755)//DemonLord
			{
				if (_rd < 3)
					NextPedra = 1744;//Inteligencia

				else if (_rd < 10)
					NextPedra = 1745;//Sabedoria

				else if (_rd < 25)
					NextPedra = 1746;//Misericórdia

				else if (_rd < 80)
					NextPedra = 1747;//Abismo

				RateSucess = 80;
			}

			else if (dest->sIndex == 1756)//Manticora
			{
				if (_rd < 50)
					NextPedra = 1748;//Beleza

				else if (_rd < 62)
					NextPedra = 1749;//Vitória

				else if (_rd < 68)
					NextPedra = 1750;//Originalidade

				else if (_rd < 70)
					NextPedra = 1751;//Reino

				RateSucess = 70;
			}

			else if (dest->sIndex == 1757)//Gargula de fogo
			{
				if (_rd < 9)
					NextPedra = 1748;//Beleza

				else if (_rd < 59)
					NextPedra = 1749;//Vitória

				else if (_rd < 63)
					NextPedra = 1750;//Originalidade

				else if (_rd < 65)
					NextPedra = 1751;//Reino

				RateSucess = 65;
			}

			else if (dest->sIndex == 1758)//Lugefer
			{
				if (_rd < 2)
					NextPedra = 1748;//Beleza

				else if (_rd < 8)
					NextPedra = 1749;//Vitória

				else if (_rd < 58)
					NextPedra = 1750;//Originalidade

				else if (_rd < 62)
					NextPedra = 1751;//Reino

				RateSucess = 62;
			}

			else if (dest->sIndex == 1759)//DemonLord
			{
				if (_rd < 2)
					NextPedra = 1748;//Beleza

				else if (_rd < 5)
					NextPedra = 1749;//Vitória

				else if (_rd < 10)
					NextPedra = 1750;//Originalidade

				else if (_rd < 60)
					NextPedra = 1751;//Reino

				RateSucess = 60;
			}

			if (_rd <= RateSucess || item->sIndex == 4141)
			{
				dest->sIndex = NextPedra;

				pMob[conn].GetCurrentScore(conn);

				SendScore(conn);
				/*snprintf(temp, sizeof(temp), "useitem,refine success %d+%d - (%d,%d,%d)", dest->sIndex, sanc, item->stEffect[0].cEffect, item->stEffect[1].cEffect, item->stEffect[2].cEffect);
				ItemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);*/

				if (amount > 1)
					BASE_SetItemAmount(item, amount - 1);

				else
					memset(item, 0, sizeof(STRUCT_ITEM));


				SendItem(conn, m->DestType, m->DestPos, dest);
				SendEmotion(conn, 14, 3);
			}

			else
			{
				/*SendClientMessage(conn, temp);

				snprintf(temp, sizeof(temp), "useitem,refine fail %d+%d - (%d,%d,%d)", dest->sIndex, sanc, item->stEffect[0].cEffect, item->stEffect[1].cEffect, item->stEffect[2].cEffect);
				ItemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);*/

				if (amount > 1)
					BASE_SetItemAmount(item, amount - 1);

				else
					memset(item, 0, sizeof(STRUCT_ITEM));


				BASE_SetItemSanc(dest, 0, 0);
				SendItem(conn, m->DestType, m->DestPos, dest);

				int sFace = pMob[conn].MOB.Equip[0].sIndex / 10;

				if (sFace)
					SendEmotion(conn, 15, 0);

				else
					SendEmotion(conn, 20, 0);
			}

			return;
		}
#pragma endregion

#pragma region AMULETOS PREMIUM
		if (item->sIndex == 413) {
			if (dest->sIndex >= 762 && dest->sIndex <= 767) {

				int sanc = BASE_GetItemSanc(dest);

				if (sanc >= 9)
				{
					SendMsgExp(conn, g_pMessageStringTable[_NN_Cant_Refine_More], TNColor::Default, false);
					SendItem(conn, m->SourType, m->SourPos, item);
					return;
				}

				if (sanc >= 6 && Vol == 4)
				{
					SendMsgExp(conn, g_pMessageStringTable[_NN_Cant_Refine_More], TNColor::Default, false);
					SendItem(conn, m->SourType, m->SourPos, item);
					return;
				}

				if (sanc == 0)
				{
					if (dest->stEffect[0].cEffect && dest->stEffect[0].cEffect != 43 && (dest->stEffect[0].cEffect && dest->stEffect[0].cEffect < 116 || dest->stEffect[0].cEffect && dest->stEffect[0].cEffect > 126))
					{
						if (dest->stEffect[1].cEffect && dest->stEffect[1].cEffect != 43 && (dest->stEffect[1].cEffect && dest->stEffect[1].cEffect < 116 || dest->stEffect[1].cEffect && dest->stEffect[1].cEffect > 126))
						{
							if (dest->stEffect[2].cEffect && dest->stEffect[2].cEffect != 43 && (dest->stEffect[2].cEffect && dest->stEffect[2].cEffect < 116 || dest->stEffect[2].cEffect && dest->stEffect[2].cEffect > 126))
							{
								SendMsgExp(conn, g_pMessageStringTable[_NN_Cant_Refine_More], TNColor::Default, false);
								SendItem(conn, m->SourType, m->SourPos, item);
								return;
							}
							dest->stEffect[2].cEffect = 43;
							dest->stEffect[2].cValue = 0;
						}
						else
						{
							dest->stEffect[1].cEffect = 43;
							dest->stEffect[1].cValue = 0;
						}
					}
					else
					{
						dest->stEffect[0].cEffect = 43;
						dest->stEffect[0].cValue = 0;
					}
				}

				int _rd = rand() % 115;

				if (_rd > 100)
					_rd -= 15;

				int ref = sanc;

				if (ref == REF_10)
					ref = 10;

				else if (ref == REF_11)
					ref = 11;

				else if (ref == REF_12)
					ref = 12;

				else if (ref == REF_13)
					ref = 13;

				else if (ref == REF_14)
					ref = 14;

				else if (ref == REF_15)
					ref = 15;

				int g_pAmuletoRate[15] =
				{
					100, 95, 90, 85, 80, 75, 70, 65, 60, 50, 40, 30, 0, 0, 0
				};

				int _chance = g_pAmuletoRate[ref];

				if (_rd <= _chance)
				{

					BASE_SetItemSanc(dest, ref + 1, 0);

					pMob[conn].GetCurrentScore(conn);

					SendScore(conn);

					snprintf(temp, sizeof(temp), "useitem,refine amuleto success %d+%d - (%d,%d,%d)", dest->sIndex, sanc, item->stEffect[0].cEffect, item->stEffect[1].cEffect, item->stEffect[2].cEffect);
					ItemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);


					//SendNotice(g_pMessageStringTable[_SS_Combin_12Succ]); //estava desligado n sei pq

					if (amount > 1)
						BASE_SetItemAmount(item, amount - 1);

					else
						memset(item, 0, sizeof(STRUCT_ITEM));


					SendItem(conn, m->DestType, m->DestPos, dest);
					SendEmotion(conn, 14, 3);
				}

				else
				{
					snprintf(temp, sizeof(temp), "useitem,refine amuleto fail %d+%d - (%d,%d,%d)", dest->sIndex, sanc, item->stEffect[0].cEffect, item->stEffect[1].cEffect, item->stEffect[2].cEffect);
					ItemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);

					if (amount > 1)
						BASE_SetItemAmount(item, amount - 1);

					else
						memset(item, 0, sizeof(STRUCT_ITEM));


					BASE_SetItemSanc(dest, 0, 0);
					SendItem(conn, m->DestType, m->DestPos, dest);

					int sFace = pMob[conn].MOB.Equip[0].sIndex / 10;

					if (sFace)
						SendEmotion(conn, 15, 0);

					else
						SendEmotion(conn, 20, 0);
				}
				SaveUser(conn, 0);
				return;

			}
		}
		if (item->sIndex == 412) {
			if (dest->sIndex >= 762 && dest->sIndex <= 767) {
				SendClientMessage(conn, "Este Item não pode ser refinado com Poeira de Ori");
				return;
			}
		}

#pragma endregion
#pragma region Refinar brincos +10+
		if (sanc >= 9 && sanc <= REF_10 && Vol == 5 && m->DestPos == 8 && g_pItemList[dest->sIndex].nPos == 256)
		{
			int RateSucess = 15;
			int _rand = rand() % 100;

			int ref = sanc;

			if (ref == 9)
				ref = 9;

			else if (ref == REF_10)
				ref = 10;

			else if (ref == REF_11)
				ref = 11;

			else if (ref == REF_12)
				ref = 12;

			else if (ref == REF_13)
				ref = 13;

			else if (ref == REF_14)
				ref = 14;

			else if (ref == REF_15)
				ref = 15;

			int _chance = 15;

			if (_rand <= _chance || (item->sIndex == 4141 && ref <= 10))
			{
				BASE_SetItemSanc(dest, ref + 1, 0);

				pMob[conn].GetCurrentScore(conn);

				SendScore(conn);
				snprintf(temp, sizeof(temp), "useitem,refine success %d+%d - (%d,%d,%d)", dest->sIndex, sanc, dest->stEffect[0].cEffect, dest->stEffect[1].cEffect, dest->stEffect[2].cEffect);
				ItemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);

				if (amount > 1)
					BASE_SetItemAmount(item, amount - 1);

				else
					memset(item, 0, sizeof(STRUCT_ITEM));


				SendItem(conn, m->DestType, m->DestPos, dest);
				SendEmotion(conn, 14, 3);
			}

			else
			{
				snprintf(temp, sizeof(temp), "useitem,refine fail %d+%d - (%d,%d,%d)", dest->sIndex, sanc, dest->stEffect[0].cEffect, dest->stEffect[1].cEffect, dest->stEffect[2].cEffect);
				ItemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);

				if (amount > 1)
					BASE_SetItemAmount(item, amount - 1);

				else
					memset(item, 0, sizeof(STRUCT_ITEM));


				
				BASE_ClearItem(dest);				
				SendItem(conn, m->DestType, m->DestPos, dest);

				int sFace = pMob[conn].MOB.Equip[0].sIndex / 10;

				if (sFace)
					SendEmotion(conn, 15, 0);

				else
					SendEmotion(conn, 20, 0);
			}
			return;
		}
#pragma endregion

		if (sanc == 9 || sanc >= REF_11 || sanc < 0 || sanc >= 9 && dest->sIndex == 769)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Cant_Refine_More]);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		int sancsucess = BASE_GetItemSancSuccess(dest);

		if (sanc < 0)
			sanc = 0;

		if (sanc == 0)
		{
			if (dest->stEffect[0].cEffect && dest->stEffect[0].cEffect != 43 && (dest->stEffect[0].cEffect && dest->stEffect[0].cEffect < 116 || dest->stEffect[0].cEffect && dest->stEffect[0].cEffect > 125))
			{
				if (dest->stEffect[1].cEffect && dest->stEffect[1].cEffect != 43 && (dest->stEffect[1].cEffect && dest->stEffect[1].cEffect < 116 || dest->stEffect[1].cEffect && dest->stEffect[1].cEffect > 125))
				{
					if (dest->stEffect[2].cEffect && dest->stEffect[2].cEffect != 43 && (dest->stEffect[2].cEffect && dest->stEffect[2].cEffect < 116 || dest->stEffect[2].cEffect && dest->stEffect[2].cEffect > 125))
					{
						SendClientMessage(conn, g_pMessageStringTable[_NN_Cant_Refine_More]);
						SendItem(conn, m->SourType, m->SourPos, item);
						return;
					}
					dest->stEffect[2].cEffect = 43;
					dest->stEffect[2].cValue = 0;
				}
				else
				{
					dest->stEffect[1].cEffect = 43;
					dest->stEffect[1].cValue = 0;
				}
			}
			else
			{
				dest->stEffect[0].cEffect = 43;
				dest->stEffect[0].cValue = 0;
			}
		}

		if (dest->sIndex >= 2300 && dest->sIndex < 2330 && pMob[conn].MOB.BaseScore.Level < 999 && BASE_GetBonusItemAbility(dest, EF_INCUDELAY) > 0)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Incu_Wait_More]);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		int OriLacto = Vol - 4;
		int RateSucess = item->sIndex != 4141 ? BASE_GetSuccessRate(dest, Vol - 4) : BASE_GetSuccessRate(dest, 2);
		int _rand = rand() % 100;

		int ItemGrade = BASE_GetItemAbility(dest, EF_ITEMLEVEL);

		if (_rand <= RateSucess && RateSucess)
		{
			if (sanc == REF_10)
				BASE_SetItemSanc(dest, 11, BASE_GetItemGem(dest));

			else
			{
				if (ItemGrade >= 1 && ItemGrade <= 5)
				{
					ItemGrade--;
					sanc += g_pSancGrade[OriLacto][ItemGrade];


					if (sanc >= 6 && Vol == 4)
						sanc = 6;

					else if (sanc > 9)
						sanc = 9;
				}
				else
					sanc++;


				sancsucess = 0;

				BASE_SetItemSanc(dest, sanc, 0);
			}
			pMob[conn].GetCurrentScore(conn);

			SendScore(conn);
			snprintf(temp, sizeof(temp), "useitem,refine success %d+%d - (%d,%d,%d)", dest->sIndex, sanc, dest->stEffect[0].cEffect, dest->stEffect[1].cEffect, dest->stEffect[2].cEffect);
			ItemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);

			SendClientMessage(conn, g_pMessageStringTable[_NN_Refine_Success]);

			if (dest->sIndex >= 2300 && dest->sIndex < 2330)
			{
				dest->stEffect[2].cEffect = 84;

				int incurand = rand() & 0x80000003;

				if (incurand < 0)
					incurand = ((incurand - 1) | 0xFC) + 1;

				dest->stEffect[2].cValue = incurand + 6;

				int incubate = BASE_GetBonusItemAbility(dest, EF_INCUBATE);

				if (sanc >= incubate)
				{
					dest->sIndex += 30;

					dest->stEffect[0].sValue = 20000;
					dest->stEffect[1].cEffect = 1;
					dest->stEffect[1].cValue = rand() % 20 + 10;
					dest->stEffect[2].cEffect = 30;
					dest->stEffect[2].cValue = 1;

					SendClientMessage(conn, g_pMessageStringTable[_NN_INCUBATED]);
					MountProcess(conn, 0);

					SendItem(conn, m->DestType, m->DestPos, dest);
				}
			}
			SendItem(conn, m->DestType, m->DestPos, dest);
			SendEmotion(conn, 14, 3);

			if (amount > 1)
				BASE_SetItemAmount(item, amount - 1);

			else
				memset(item, 0, sizeof(STRUCT_ITEM));
		}

		else
		{

			snprintf(temp, sizeof(temp), "useitem,refine fail %d+%d - (%d,%d,%d)", dest->sIndex, sanc, dest->stEffect[0].cEffect, dest->stEffect[1].cEffect, dest->stEffect[2].cEffect);
			ItemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);

			if (amount > 1)
				BASE_SetItemAmount(item, amount - 1);

			else
				memset(item, 0, sizeof(STRUCT_ITEM));

			if (rand() % 4 <= 2)
			{
				if (OriLacto == 1)
					++sancsucess;

				else if (sanc <= 5 && !OriLacto)
					++sancsucess;
			}
			if (dest->sIndex >= 2300 && dest->sIndex < 2330)
			{
				dest->stEffect[2].cEffect = 84;

				int incu = rand() & 0x80000003;
				if (incu < 0)
					incu = ((incu - 1) | 0xFC) + 1;

				dest->stEffect[2].cValue = incu;
			}

			if (sanc != REF_10)
				BASE_SetItemSanc(dest, sanc, sancsucess);

			SendItem(conn, m->DestType, m->DestPos, dest);

			int sFace = pMob[conn].MOB.Equip[0].sIndex / 10;

			if (sFace)
				SendEmotion(conn, 15, 0);

			else
				SendEmotion(conn, 20, 0);
		}

		return;
	}

#pragma endregion
#pragma region Pilula Orc
	if (Vol == 6) // Pilula Orc
	{
		if (pMob[conn].extra.QuestInfo.Mortal.PilulaOrc)
			return;

		pMob[conn].MOB.SkillBonus += 9;
		pMob[conn].extra.QuestInfo.Mortal.PilulaOrc = 1;
		SendEmotion(conn, 14, 3);
		SendEtc(conn);

		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);
		else
			memset(item, 0, sizeof(STRUCT_ITEM));


		return;
	}
#pragma endregion
#pragma region Poeira de Fada
	if (Vol == 7)//Poeira de Fada
	{
		int Level = pMob[conn].MOB.BaseScore.Level;
		int maxlevel = pMob[conn].extra.ClassMaster == MORTAL || pMob[conn].extra.ClassMaster == ARCH ? MAX_LEVEL : MAX_CLEVEL;

		if (pMob[conn].extra.ClassMaster >= CELESTIAL)
		{
			SendClientMessage(conn, "Desculpe. Item disponível apenas para Mortais & Arch's.");
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (Level >= maxlevel || Level < 0)
		{
			int sFace = pMob[conn].MOB.Equip[0].sIndex / 10;

			if (sFace)
				SendEmotion(conn, 15, 0);
			else
				SendEmotion(conn, 20, 0);

			SendMsgExp(conn, g_pMessageStringTable[_NN_Fail_To_Level_Up], TNColor::Default, false);

		}
		else
		{
			pMob[conn].MOB.Exp = pMob[conn].extra.ClassMaster == MORTAL || pMob[conn].extra.ClassMaster == ARCH ? g_pNextLevel[Level + 1] : g_pNextLevel_2[Level + 1];

			if (pMob[conn].CheckGetLevel())
			{

				SendMsgExp(conn, "+++ LEVEL UP +++", TNColor::Yellow, false);
				SendEmotion(conn, 100, rand() % 5);

				SendScore(conn);
				SendEtc(conn);

				/*if (pMob[conn].extra.ClassMaster == MORTAL) {
					DoItemLevel(conn);
					SendEtc(conn);
				}*/
				if (pMob[conn].extra.ClassMaster == SCELESTIAL)
					SetCircletSubGod(conn);
			}
		}

		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));


		return;
	}
#pragma endregion
#pragma region Olho Crescente
	if (Vol == 8)
	{
		if (pMob[conn].extra.ClassMaster != MORTAL)
			return;

		if (pMob[conn].MOB.CurrentScore.Level < 40) {
			pMob[conn].MOB.Exp += 2500;

			SendEmotion(conn, 14, 3);

			if (pMob[conn].CheckGetLevel() == 4)
			{
				SendMsgExp(conn, g_pMessageStringTable[_NN_Level_Up], TNColor::Default, false);
				SendScore(conn);
				SendEtc(conn);

				/*if (pMob[conn].extra.ClassMaster == MORTAL) {
					DoItemLevel(conn);
					
				}*/
			}
			SendEtc(conn);
		}		

		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));


		return;
	}
#pragma endregion
#pragma region Adamantita/beril etc LE
	if (Vol == 9) // Adamantita / Beril etc
	{
		STRUCT_ITEM* dest = GetItemPointer(&pMob[conn].MOB, pUser[conn].Cargo, m->DestType, m->DestPos);

		if (dest == NULL)
		{
			return;
		}

		int sourIndex = item->sIndex;
		int destIndex = dest->sIndex;
		int Type = sourIndex - 575;

		if (sourIndex - 575 >= 0 && Type < 4)
		{
			int UniqueType = -1;
			int nUnique = g_pItemList[destIndex].nUnique;

			if (nUnique == 5 || nUnique == 14 || nUnique == 24 || nUnique == 34)
				UniqueType = 0;

			if (nUnique == 6 || nUnique == 15 || nUnique == 25 || nUnique == 35)
				UniqueType = 1;

			if (nUnique == 7 || nUnique == 16 || nUnique == 26 || nUnique == 36)
				UniqueType = 2;

			if (nUnique == 8 || nUnique == 17 || nUnique == 27 || nUnique == 37)
				UniqueType = 3;

			if (nUnique == 10 || nUnique == 20 || nUnique == 30 || nUnique == 40)
				UniqueType = 3;

			if (nUnique == -1)
			{
				SendItem(conn, m->SourType, m->SourPos, item);
				SendMsgExp(conn, g_pMessageStringTable[Type + _NN_Only_Level1_Armor], TNColor::Default, false);
			}
			else
			{
				if (UniqueType == Type)
				{
					int Grade = g_pItemList[destIndex].Grade;

					if (Grade > 0 && Grade < 4)
					{
						int _rand = rand() % 100;
						int chance = 50;
						if (_rand <= 50)
						{
							int extra = g_pItemList[destIndex].Extra;

							dest->sIndex = extra;

							SendItem(conn, m->DestType, m->DestPos, dest);

							if (amount > 1)
								BASE_SetItemAmount(item, amount - 1);

							else
								memset(item, 0, sizeof(STRUCT_ITEM));

							SendScore(conn);
							SendEmotion(conn, 14, 0);
							/*
							snprintf(temp, sizeof(temp), "useitem,regendary success %d - (%d,%d,%d)", dest->sIndex,
								item->stEffect[0].cEffect, item->stEffect[1].cEffect, item->stEffect[2].cEffect);

							ItemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);
							snprintf(temp, sizeof(temp), "%s(%d/%d)", g_pMessageStringTable[_NN_Refine_Success], _rand, chance);

							SendMsgExp(conn, temp, TNColor::Default, false);*/
						}
						else
						{
							if (pMob[conn].MOB.Equip[0].sIndex / 10)
								SendEmotion(conn, 15, 0);

							else
								SendEmotion(conn, 20, 0);

							/*
							snprintf(temp, sizeof(temp), "useitem,regendary fail %d - (%d,%d,%d)",
								dest->sIndex, item->stEffect[0].cEffect, item->stEffect[1].cEffect, item->stEffect[2].cEffect);

							ItemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);

							snprintf(temp, sizeof(temp), "%s(%d/%d)", g_pMessageStringTable[_NN_Fail_To_Refine], _rand, chance);
							SendMsgExp(conn, temp, TNColor::Default, false);*/

							if (amount > 1)
								BASE_SetItemAmount(item, amount - 1);

							else
								memset(item, 0, sizeof(STRUCT_ITEM));
						}
					}
					else
					{
						SendItem(conn, m->SourType, m->SourPos, item);
						SendMsgExp(conn, g_pMessageStringTable[_NN_Cant_Refine_More], TNColor::Default, false);
					}
				}
				else
				{
					SendItem(conn, m->SourType, m->SourPos, item);
					SendMsgExp(conn, g_pMessageStringTable[Type + _NN_Only_Level1_Armor], TNColor::Default, false);
				}
			}
		}
		else
			SendItem(conn, m->SourType, m->SourPos, item);
		SaveUser(conn, 0);
		return;
	}
#pragma endregion

#pragma endregion
#pragma endregion
#pragma region Poção Kappa
	if (Vol == 10 || Vol == 55 || Vol == 200 || Vol == 201 || Vol == 56 || Vol == 52 || Vol == 53 || Vol == 57 || Vol == 202)
	{
		int value = 0;

		int tempo = 80;

		//Kappa
		if (item->sIndex == 787)
			value = 1;

		//Combatente
		else if (item->sIndex == 1764)
			value = 2;

		//Mental
		else if (item->sIndex == 1765)
			value = 3;

		//Mental 60m
		else if (item->sIndex == 3312)
		{
			tempo = AFFECT_1H;
			value = 3;
		}
		//Combatente 60m
		else if (item->sIndex == 3311)
		{
			tempo = AFFECT_1H;
			value = 2;
		}

		//Kappa 30m
		else if (item->sIndex == 3310)
		{
			tempo = AFFECT_1H / 2;
			value = 1;
		}

		//Mental 20h
		else if (item->sIndex == 3321)
		{
			tempo = AFFECT_1H * 20;
			value = 3;
		}

		//Combatente 20h
		else if (item->sIndex == 3320)
		{
			tempo = AFFECT_1H * 20;
			value = 2;
		}

		//Kappa 20h
		else if (item->sIndex == 3319)
		{
			tempo = AFFECT_1H * 20;
			value = 1;
		}
		//Sephira 30d
		else if (item->sIndex == 3363)
		{
			tempo = AFFECT_1D * 30;
			value = 1;
		}
		//Sephira 15d
		else if (item->sIndex == 3362)
		{
			tempo = AFFECT_1D * 15;
			value = 1;
		}
		//Sephira 7d
		else if (item->sIndex == 3361)
		{
			tempo = AFFECT_1D * 7;
			value = 1;
		}

		int EmptyAffect = -1;

		for (int i = 1; i < MAX_AFFECT; i++)
		{
			if (pMob[conn].Affect[i].Type == 4 && pMob[conn].Affect[i].Value == value)
			{
				EmptyAffect = i;
				break;
			}
		}

		for (int i = 1; i < MAX_AFFECT && EmptyAffect == -1; i++)
		{
			if (pMob[conn].Affect[i].Type == 0)
			{
				EmptyAffect = i;
				break;
			}
		}

		if (item->sIndex == 3361 || item->sIndex == 3362 || item->sIndex == 3363)
		{
			if (pMob[conn].Affect[1].Type != 0)
				memmove_s(&pMob[conn].Affect[EmptyAffect], sizeof(pMob[conn].Affect[EmptyAffect]), &pMob[conn].Affect[1], sizeof(pMob[conn].Affect[1]));

			EmptyAffect = 1;
		}

		if (EmptyAffect != -1)
		{
			pMob[conn].Affect[EmptyAffect].Type = 4;
			pMob[conn].Affect[EmptyAffect].Level = 0;
			pMob[conn].Affect[EmptyAffect].Value = value;
			pMob[conn].Affect[EmptyAffect].Time = tempo;

			pMob[conn].GetCurrentScore(conn);
			SendScore(conn);
		}


		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));

		/*
		snprintf(temp, sizeof(temp), "useitem,poção_kappa affectslot:%d value:%d time:%d", EmptyAffect, value, tempo);
		ItemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);*/
		return;
	}
#pragma endregion
#pragma region Retorno
	if (Vol == 11)
	{
		DoRecall(conn);

		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));

		/*
		snprintf(temp, sizeof(temp), "useitem,recall");
		ItemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);*/
		return;
	}
#pragma endregion
#pragma region Gema Estelar
	if (Vol == 12)
	{
		unsigned char map_att = GetAttribute(pMob[conn].TargetX, pMob[conn].TargetY);

		if ((pMob[conn].TargetX / 128) == 9 && (pMob[conn].TargetY / 128) == 1)
			goto CanSave;

		if ((pMob[conn].TargetX / 128) == 8 && (pMob[conn].TargetY / 128) == 2)
			goto CanSave;

		if (map_att & 4 && pMob[conn].MOB.CurrentScore.Level < 1000)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Cant_Use_That_Here]);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		int Arena = BASE_GetArena(pMob[conn].TargetX, pMob[conn].TargetY);
		int Village = BASE_GetVillage(pMob[conn].TargetX, pMob[conn].TargetY);

		if (Arena < MAX_GUILDZONE || Village < MAX_GUILDZONE)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Cant_Use_That_Here]);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (pMob[conn].TargetX >= 1302 && pMob[conn].TargetY >= 1391 && pMob[conn].TargetX <= 1483 && pMob[conn].TargetY <= 1523)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Cant_Use_That_Here]);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

	CanSave:
		int sFace = pMob[conn].MOB.Equip[0].sIndex / 10;

		if (sFace == 0)
			SendEmotion(conn, 23, 0);

		else if (sFace == 1)
			SendEmotion(conn, 15, 0);

		else if (sFace == 2)
			SendEmotion(conn, 15, 0);

		else if (sFace == 3)
			SendEmotion(conn, 15, 0);


		pMob[conn].MOB.SPX = pMob[conn].TargetX;
		pMob[conn].MOB.SPY = pMob[conn].TargetY;

		/*
		snprintf(temp, sizeof(temp), "useitem,gema salva %d %d", pMob[conn].TargetX, pMob[conn].TargetY);
		ItemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);*/

		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));

		SendClientMessage(conn, g_pMessageStringTable[_NN_Set_Warp]);

		return;
	}
#pragma endregion
#pragma region Portal
	if (Vol == 13)
	{
		if ((pMob[conn].MOB.SPX / 128) == 9 && (pMob[conn].MOB.SPY / 128) == 1 || (pMob[conn].MOB.SPX / 128) == 8 && (pMob[conn].MOB.SPY / 128) == 2)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Cant_Use_That_Here]);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		unsigned char map_att = GetAttribute(pMob[conn].TargetX, pMob[conn].TargetY);
		unsigned char map_att2 = GetAttribute(pMob[conn].MOB.SPX, pMob[conn].MOB.SPY);

		if (map_att & 4 && pMob[conn].MOB.CurrentScore.Level < 1000)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Cant_Use_That_Here]);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (map_att2 & 4 && pMob[conn].MOB.CurrentScore.Level < 1000)
		{
			SendClientMessage(conn, "Área de Destino Inválida");
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		DoTeleport(conn, pMob[conn].MOB.SPX, pMob[conn].MOB.SPY);

		/*
		snprintf(temp, sizeof(temp), "useitem,teleport portal scrool %d %d", pMob[conn].TargetX, pMob[conn].TargetY);
		ItemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);*/

		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));

		return;
	}
#pragma endregion
#pragma region DBRecord
	if (Vol == 14)
	{
		MSG_MessageDBRecord sm_dbrec;
		memset(&sm_dbrec, 0, sizeof(MSG_MessageDBRecord));

		sm_dbrec.Type = _MSG_MessageDBRecord;
		sm_dbrec.ID = 0;
		sm_dbrec.Size = sizeof(MSG_MessageDBRecord);

		snprintf(sm_dbrec.Record, sizeof(sm_dbrec.Record), "TCK %d %s %d %d %d %d", ServerIndex, pUser[conn].AccountName, item->stEffect[0].cEffect, item->stEffect[1].cEffect, item->stEffect[2].cEffect, item->sIndex);

		DBServerSocket.SendOneMessage((char*)&sm_dbrec, sizeof(MSG_MessageDBRecord));

		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));

		return;
	}
#pragma endregion
#pragma region Rações
	if (Vol == 15)
	{
		if (m->DestType || m->DestPos != 14)
		{
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		STRUCT_ITEM* dest = &pMob[conn].MOB.Equip[14];

		if (dest->sIndex < 2330 || dest->sIndex >= 2390 || dest->sIndex < 3091 && dest->sIndex >= 3139)
		{
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		int mount = (dest->sIndex - 2330) % 30;

		if (mount >= 6 && mount <= 15 || mount == 27)
			mount = 6;

		if (mount == 19)
			mount = 7;

		if (mount == 20)
			mount = 8;

		if (mount == 21 || mount == 22 || mount == 23 || mount == 28)
			mount = 9;

		if (mount == 24 || mount == 25 || mount == 26)
			mount = 10;

		if (mount == 29)
			mount = 19;

		int racid = item->sIndex >= 3367 ? item->sIndex - 3367 : item->sIndex - 2420;

		int racao = racid % 30;

		if (mount == racao)
		{
			if (dest->stEffect[0].sValue > 0)
			{
				if ((pMob[conn].MOB.Equip[14].stEffect[0].sValue + 5000) > 30000)
					pMob[conn].MOB.Equip[14].stEffect[0].sValue = 30000;
				else
					pMob[conn].MOB.Equip[14].stEffect[0].sValue += 5000;

				int _racao = dest->stEffect[2].cEffect + 2;

				if (_racao > 100)
					_racao = 100;

				dest->stEffect[2].cEffect = _racao;

				if (dest->sIndex >= 2330 && dest->sIndex < 2360)
					MountProcess(conn, &pMob[conn].MOB.Equip[14]);

				if (dest->sIndex >= 2360 && dest->sIndex < 2390 || dest->sIndex < 3091 && dest->sIndex >= 3139)
					ProcessAdultMount(conn, 0);

				if (amount > 1)
					BASE_SetItemAmount(item, amount - 1);

				else
					memset(item, 0, sizeof(STRUCT_ITEM));

				SendClientSignalParm(conn, ESCENE_FIELD, _MSG_SoundEffect, 270);
				SendItem(conn, m->DestType, m->DestPos, dest);
			}
			else
				SendItem(conn, m->SourType, m->SourPos, item);
		}
		else
		{
			SendMsgExp(conn, g_pMessageStringTable[_NN_Mount_Not_Match], TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
		}

		/*
		snprintf(temp, sizeof(temp), "useitem,ração mount:%d", mount);
		ItemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);*/
		return;
	}
#pragma endregion
#pragma region >> Âmagos
	if (Vol == 16)
	{
		if (m->DestType || m->DestPos != 14)
		{
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		STRUCT_ITEM* dest = &pMob[conn].MOB.Equip[14];

		if (dest->sIndex < 2330 || dest->sIndex >= 2390 || dest->sIndex < 3091 && dest->sIndex >= 3139 || dest->stEffect[0].sValue <= 0)
		{
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		int mountIndex = (dest->sIndex - 2330) % 30;
		int amgIndex = (item->sIndex - 2390) % 30;

		if (mountIndex == 28)//Sleipnir
			mountIndex = 28;

		if (mountIndex == 27)//Svadilfire
			mountIndex = 27;

		if (mountIndex != amgIndex)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Mount_Not_Match]);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		dest->stEffect[0].sValue = 20000;		
		int level = dest->stEffect[1].cEffect;

		if (level >= 120 && dest->sIndex >= 2360 && dest->sIndex < 2390 || dest->sIndex < 3091 && dest->sIndex >= 3139)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Cant_Upgrade_More]);
			SendItem(conn, m->SourType, m->SourPos, item);
			ProcessAdultMount(conn, 0);
			return;
		}

		if (dest->sIndex >= 2360 && dest->sIndex < 2390 || dest->sIndex < 3091 && dest->sIndex >= 3139)
		{
			int rate = BASE_GetGrowthRate(dest);
			int _rand = rand() % 100;

			if (_rand > rate) // Refinação falhou
			{
				int rand2 = rand() % 100;

				if (dest->stEffect[1].cEffect < 50 && dest->stEffect[1].cEffect % 2 == 0)
				{
					if (rand2 < 20)
					{
						dest->stEffect[1].cEffect--;
						SendClientMessage(conn, "Reduziu level da montaria."); //bama adicionou
					}
				}

				if (dest->stEffect[1].cEffect > 50 && dest->stEffect[1].cEffect < 100 && dest->stEffect[1].cEffect % 2 == 0)
				{
					if (rand2 < 40)
					{
						dest->stEffect[1].cEffect--;
						SendClientMessage(conn, "Reduziu level da montaria."); //bama adicionou
					}
				}

				else if (dest->stEffect[1].cEffect >= 100 && dest->stEffect[1].cEffect % 2 == 0)
				{
					if (rand2 < 70)
					{
						dest->stEffect[1].cEffect--;
						SendClientMessage(conn, "Reduziu level da montaria."); //bama adicionou
					}
				}


				if (amount > 1)
					BASE_SetItemAmount(item, amount - 1);

				else
					memset(item, 0, 8);

				/*
				snprintf(temp, sizeof(temp), "%s", g_pMessageStringTable[_NN_Fail_To_Refine]);
				SendClientMessage(conn, temp);*/

				SendItem(conn, m->DestType, m->DestPos, dest);

				ProcessAdultMount(conn, 0);
				return;
			}
			else

			{   //bama adicionou
				if (pMob[conn].MOB.Equip[0].sIndex / 10)
					SendEmotion(conn, 14, 0); //Zuada do PET (funfando)
				SendEmotion(conn, 14, 3); //Lac 100 (funfando)
				SendClientMessage(conn, "Obteve sucesso na refinação.");
			}

			{
				/*
				snprintf(temp, sizeof(temp), "useitem,mount refine success %d+%d (%d,%d,%d)", dest->sIndex, dest->stEffect[1].cValue,
					item->stEffect[0].cEffect, item->stEffect[1].cEffect, item->stEffect[2].cEffect);
				ItemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);*/
			}
		}
		int levelUP = 1;

		if (LOCALSERVER)
			levelUP = 10;

		level = levelUP + level;
		dest->stEffect[1].cEffect = level;
		//dest->stEffect[2].cValue = 1;

		STRUCT_ITEM* Mount = &pMob[conn].MOB.Equip[14];

		if (level >= 25 && dest->sIndex == 2330
			|| level >= 35 && dest->sIndex == 2331
			|| level >= 45 && dest->sIndex == 2332
			|| level >= 55 && dest->sIndex == 2333
			|| level >= 65 && dest->sIndex == 2334
			|| level >= 75 && dest->sIndex == 2335
			|| level >= 100 && dest->sIndex >= 2336 && dest->sIndex < 2360)
		{
			dest->sIndex += 30;

			dest->stEffect[1].cValue += rand() % 14 + 1; // Variar entre quantas vitalidades pode subir 1 ~ 14
			dest->stEffect[1].cEffect = 0;
			dest->stEffect[2].cValue = 0;
			dest->stEffect[2].cEffect = 100;

			if (dest->stEffect[1].cValue >= 60) // Verificação para saber se a vitalidade é maior que 60
				dest->stEffect[1].cValue = 60; // iguala a vitalidade a 60 para não bugar

			SendClientMessage(conn, g_pMessageStringTable[_NN_Mount_Growth]);
			ProcessAdultMount(conn, 0);
			RemoveParty(conn);
			SendEquip(conn, conn);
		}

		if (dest->sIndex >= 2330 && dest->sIndex < 2360)
			MountProcess(conn, 0);

		if (dest->sIndex >= 2360 && dest->sIndex < 2390 || dest->sIndex < 3091 && dest->sIndex >= 3139)
			ProcessAdultMount(conn, 0);

		SendItem(conn, m->DestType, m->DestPos, dest);

		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));

		return;
	}
#pragma endregion
#pragma region GUILDBOARD
	if (Vol == 17)
	{
		int Guild = BASE_GetGuild(item);

		if (Guild > 0)
		{
			MSG_STANDARDPARM2 sm_gbo;
			memset(&sm_gbo, 0, sizeof(MSG_STANDARDPARM2));

			sm_gbo.Type = _MSG_GuildBoard;
			sm_gbo.ID = ESCENE_FIELD;
			sm_gbo.Parm1 = Guild;
			sm_gbo.Parm2 = GUILDBOARD;
			sm_gbo.Size = sizeof(MSG_STANDARDPARM2);

			int Size = sm_gbo.Size;

			if (Size > sizeof(MSG_STANDARDPARM2))
			{
				sm_gbo.Size = 0;
				return;
			}
			if (!pUser[conn].cSock.AddMessage((char*)&sm_gbo, sizeof(MSG_STANDARDPARM2)))
				CloseUser(conn);
		}

		return;
	}
#pragma endregion
#pragma region Fogos de Artificio
	if (Vol == 19)
	{
		SendEmotion(conn, 100, rand() % 5);

		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));

		/*
		snprintf(temp, sizeof(temp), "useitem,fogos_de_artificio");
		ItemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);*/
		return;
	}
#pragma endregion
#pragma region Livros Nona e Decima
#pragma region Livros TRANSKNIGHT
	if (item->sIndex == 5500) // Proteção Divina
	{
		if (pMob[conn].MOB.BaseScore.Level <= 199)
		{
			SendMsgExp(conn, "Level insuficiente.", TNColor::Default, false);

			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (pMob[conn].extra.ClassMaster == MORTAL || pMob[conn].extra.ClassMaster == ARCH)
		{
			SendMsgExp(conn, "É necessário ser Celestial/SubCelestial.", TNColor::Default, false);

			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		int ItemID = item->sIndex;

		if (pMob[conn].MOB.Class == 0)
		{
			if ((1 << 4) & pMob[conn].extra.SecLearnedSkill)
			{
				SendMsgExp(conn, "Apenas uma 9ª Skill por personagem.", TNColor::Default, false);

				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if ((1 << 8) & pMob[conn].extra.SecLearnedSkill)
			{
				SendMsgExp(conn, "Apenas uma 9ª Skill por personagem.", TNColor::Default, false);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if ((1 << 7) & pMob[conn].MOB.LearnedSkill)
			{
				if ((1 << 0) & pMob[conn].extra.SecLearnedSkill)
				{
					SendMsgExp(conn, g_pMessageStringTable[_NN_Already_Learned_It], TNColor::Default, false);

					SendItem(conn, m->SourType, m->SourPos, item);
					return;
				}
				else
				{
					pMob[conn].extra.SecLearnedSkill |= 0x1;
					/*
					snprintf(temp, sizeof(temp), g_pMessageStringTable[_SN_Learn_Sephera], g_pItemList[ItemID].Name);

					SendMsgExp(conn, temp, TNColor::Default, false);*/
					SendEtc(conn);

					if (amount > 1)
						BASE_SetItemAmount(item, amount - 1);

					else
						memset(item, 0, sizeof(STRUCT_ITEM));

					return;
				}
			}
			else
			{
				SendMsgExp(conn, "Necessário ter aprendido a 8ª Skill.", TNColor::Default, false);

				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

		}
		else
		{
			SendMsgExp(conn, "Esse livro não pertence a sua Classe.", TNColor::Default, false);

			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}
	}
	if (item->sIndex == 5501) // Bênção Divina
	{
		int ItemID = item->sIndex;

		if (pMob[conn].MOB.BaseScore.Level <= 240)
		{
			SendMsgExp(conn, "Level insuficiente.", TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (pMob[conn].extra.ClassMaster == MORTAL || pMob[conn].extra.ClassMaster == ARCH)
		{
			SendMsgExp(conn, "É necessário ser Celestial/SubCelestial.", TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (pMob[conn].MOB.Class == 0)
		{
			if ((1 << 5) & pMob[conn].extra.SecLearnedSkill)
			{
				SendMsgExp(conn, "Apenas uma 10ª Skill por personagem.", TNColor::Default, false);

				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if ((1 << 9) & pMob[conn].extra.SecLearnedSkill)
			{
				SendMsgExp(conn, "Apenas uma 10ª Skill por personagem.", TNColor::Default, false);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if ((1 << 0) & pMob[conn].extra.SecLearnedSkill)
			{
				if ((1 << 1) & pMob[conn].extra.SecLearnedSkill)
				{
					SendMsgExp(conn, g_pMessageStringTable[_NN_Already_Learned_It], TNColor::Default, false);
					SendItem(conn, m->SourType, m->SourPos, item);
					return;
				}
				else
				{
					pMob[conn].extra.SecLearnedSkill |= 0x2;
					/*
					snprintf(temp, sizeof(temp), g_pMessageStringTable[_SN_Learn_Sephera], g_pItemList[ItemID].Name);

					SendMsgExp(conn, temp, TNColor::Default, false);*/
					SendEtc(conn);

					if (amount > 1)
						BASE_SetItemAmount(item, amount - 1);

					else
						memset(item, 0, sizeof(STRUCT_ITEM));

					return;
				}
			}
			else
			{
				SendMsgExp(conn, "Necessário ter aprendido a 9ª Skill.", TNColor::Default, false);

				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}
		}
		else
		{
			SendMsgExp(conn, "Esse livro não pertence a sua Classe.", TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}
	}
	if (item->sIndex == 5504) // Mãos Sangrentas
	{
		if (pMob[conn].MOB.BaseScore.Level <= 199)
		{
			SendMsgExp(conn, "Level insuficiente.", TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (pMob[conn].extra.ClassMaster == MORTAL || pMob[conn].extra.ClassMaster == ARCH)
		{
			SendMsgExp(conn, "É necessário ser Celestial/SubCelestial.", TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		int ItemID = item->sIndex;

		if (pMob[conn].MOB.Class == 0)
		{
			if ((1 << 0) & pMob[conn].extra.SecLearnedSkill)
			{
				SendMsgExp(conn, "Apenas uma 9ª Skill por personagem.", TNColor::Default, false);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if ((1 << 8) & pMob[conn].extra.SecLearnedSkill)
			{
				SendMsgExp(conn, "Apenas uma 9ª Skill por personagem.", TNColor::Default, false);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if ((1 << 15) & pMob[conn].MOB.LearnedSkill)
			{
				if ((1 << 4) & pMob[conn].extra.SecLearnedSkill)
				{
					SendMsgExp(conn, g_pMessageStringTable[_NN_Already_Learned_It], TNColor::Default, false);
					SendItem(conn, m->SourType, m->SourPos, item);
					return;
				}
				else
				{
					pMob[conn].extra.SecLearnedSkill |= 0x10;
					/*
					snprintf(temp, sizeof(temp), g_pMessageStringTable[_SN_Learn_Sephera], g_pItemList[ItemID].Name);

					SendMsgExp(conn, temp, TNColor::Default, false);*/
					SendEtc(conn);

					if (amount > 1)
						BASE_SetItemAmount(item, amount - 1);

					else
						memset(item, 0, sizeof(STRUCT_ITEM));

					return;
				}
			}
			else
			{
				SendMsgExp(conn, "Necessário ter aprendido a 8ª Skill.", TNColor::Default, false);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}
		}
		else
		{
			SendMsgExp(conn, "Esse livro não pertence a sua Classe.", TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}
	}

	if (item->sIndex == 5505) // Mestres das Armas
	{
		int ItemID = item->sIndex;

		if (pMob[conn].MOB.BaseScore.Level <= 240)
		{
			SendMsgExp(conn, "Level insuficiente.", TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (pMob[conn].extra.ClassMaster == MORTAL || pMob[conn].extra.ClassMaster == ARCH)
		{
			SendMsgExp(conn, "É necessário ser Celestial/SubCelestial.", TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (pMob[conn].MOB.Class == 0)
		{
			if ((1 << 1) & pMob[conn].extra.SecLearnedSkill)
			{
				SendMsgExp(conn, "Apenas uma 10ª Skill por personagem.", TNColor::Default, false);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if ((1 << 9) & pMob[conn].extra.SecLearnedSkill)
			{
				SendMsgExp(conn, "Apenas uma 10ª Skill por personagem.", TNColor::Default, false);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if ((1 << 4) & pMob[conn].extra.SecLearnedSkill)
			{
				if ((1 << 5) & pMob[conn].extra.SecLearnedSkill)
				{
					SendMsgExp(conn, g_pMessageStringTable[_NN_Already_Learned_It], TNColor::Default, false);
					SendItem(conn, m->SourType, m->SourPos, item);
					return;
				}
				else
				{
					pMob[conn].extra.SecLearnedSkill |= 0x20;
					/*
					snprintf(temp, sizeof(temp), g_pMessageStringTable[_SN_Learn_Sephera], g_pItemList[ItemID].Name);

					SendMsgExp(conn, temp, TNColor::Default, false);*/
					SendEtc(conn);

					if (amount > 1)
						BASE_SetItemAmount(item, amount - 1);

					else
						memset(item, 0, sizeof(STRUCT_ITEM));

					return;
				}
			}
			else
			{
				SendMsgExp(conn, "Necessário ter aprendido a 9ª Skill.", TNColor::Default, false);
				return;
			}
		}
		else
		{
			SendMsgExp(conn, "Esse livro não pertence a sua Classe.", TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}
	}
	if (item->sIndex == 5508) // Espelho Mágico
	{

		if (pMob[conn].MOB.BaseScore.Level <= 199)
		{
			SendMsgExp(conn, "Level insuficiente.", TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (pMob[conn].extra.ClassMaster == MORTAL || pMob[conn].extra.ClassMaster == ARCH)
		{
			SendMsgExp(conn, "É necessário ser Celestial/SubCelestial.", TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		int ItemID = item->sIndex;

		if (pMob[conn].MOB.Class == 0)
		{
			if ((1 << 0) & pMob[conn].extra.SecLearnedSkill)
			{
				SendMsgExp(conn, "Apenas uma 9ª Skill por personagem.", TNColor::Default, false);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if ((1 << 4) & pMob[conn].extra.SecLearnedSkill)
			{
				SendMsgExp(conn, "Apenas uma 9ª Skill por personagem.", TNColor::Default, false);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if ((1 << 23) & pMob[conn].MOB.LearnedSkill)
			{
				if ((1 << 8) & pMob[conn].extra.SecLearnedSkill)
				{
					SendMsgExp(conn, g_pMessageStringTable[_NN_Already_Learned_It], TNColor::Default, false);
					SendItem(conn, m->SourType, m->SourPos, item);
					return;
				}
				else
				{
					pMob[conn].extra.SecLearnedSkill |= 0x100;
					/*
					snprintf(temp, sizeof(temp), g_pMessageStringTable[_SN_Learn_Sephera], g_pItemList[ItemID].Name);

					SendMsgExp(conn, temp, TNColor::Default, false);*/
					SendEtc(conn);

					if (amount > 1)
						BASE_SetItemAmount(item, amount - 1);

					else
						memset(item, 0, sizeof(STRUCT_ITEM));

					return;
				}
			}
			else
			{
				SendMsgExp(conn, "Necessário ter aprendido a 8ª Skill.", TNColor::Default, false);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}
		}
		else
		{
			SendMsgExp(conn, "Esse livro não pertence a sua Classe.", TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}
	}
	if (item->sIndex == 5509) // Conexão de Gelo
	{
		int ItemID = item->sIndex;

		if (pMob[conn].MOB.BaseScore.Level <= 240)
		{
			SendMsgExp(conn, "Level insuficiente.", TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (pMob[conn].extra.ClassMaster == MORTAL || pMob[conn].extra.ClassMaster == ARCH)
		{
			SendMsgExp(conn, "É necessário ser Celestial/SubCelestial.", TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (pMob[conn].MOB.Class == 0)
		{
			if ((1 << 1) & pMob[conn].extra.SecLearnedSkill)
			{
				SendMsgExp(conn, "Apenas uma 10ª Skill por personagem.", TNColor::Default, false);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if ((1 << 5) & pMob[conn].extra.SecLearnedSkill)
			{
				SendMsgExp(conn, "Apenas uma 10ª Skill por personagem.", TNColor::Default, false);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if ((1 << 8) & pMob[conn].extra.SecLearnedSkill)
			{
				if ((1 << 9) & pMob[conn].extra.SecLearnedSkill)
				{
					SendMsgExp(conn, g_pMessageStringTable[_NN_Already_Learned_It], TNColor::Default, false);
					SendItem(conn, m->SourType, m->SourPos, item);
					return;
				}
				else
				{
					pMob[conn].extra.SecLearnedSkill |= 0x200;
					/*
					snprintf(temp, sizeof(temp), g_pMessageStringTable[_SN_Learn_Sephera], g_pItemList[ItemID].Name);

					SendMsgExp(conn, temp, TNColor::Default, false);*/
					SendEtc(conn);

					if (amount > 1)
						BASE_SetItemAmount(item, amount - 1);

					else
						memset(item, 0, sizeof(STRUCT_ITEM));

					return;
				}
			}
			else
			{
				SendMsgExp(conn, "Necessário ter aprendido a 9ª Skill.", TNColor::Default, false);
				return;
			}
		}
		else
		{
			SendMsgExp(conn, "Esse livro não pertence a sua Classe.", TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}
	}
#pragma endregion
#pragma region Livros FOEMA
	if (item->sIndex == 5512) // Cenote
	{

		if (pMob[conn].MOB.BaseScore.Level <= 199)
		{
			SendMsgExp(conn, "Level insuficiente.", TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (pMob[conn].extra.ClassMaster == MORTAL || pMob[conn].extra.ClassMaster == ARCH)
		{
			SendMsgExp(conn, "É necessário ser Celestial/SubCelestial.", TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		int ItemID = item->sIndex;

		if (pMob[conn].MOB.Class == 1)
		{
			if ((1 << 4) & pMob[conn].extra.SecLearnedSkill)
			{
				SendMsgExp(conn, "Apenas uma 9ª Skill por personagem.", TNColor::Default, false);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if ((1 << 8) & pMob[conn].extra.SecLearnedSkill)
			{
				SendMsgExp(conn, "Apenas uma 9ª Skill por personagem.", TNColor::Default, false);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if ((1 << 7) & pMob[conn].MOB.LearnedSkill)
			{
				if ((1 << 0) & pMob[conn].extra.SecLearnedSkill)
				{
					SendMsgExp(conn, g_pMessageStringTable[_NN_Already_Learned_It], TNColor::Default, false);
					SendItem(conn, m->SourType, m->SourPos, item);
					return;
				}
				else
				{
					pMob[conn].extra.SecLearnedSkill |= 0x1;
					/*
					snprintf(temp, sizeof(temp), g_pMessageStringTable[_SN_Learn_Sephera], g_pItemList[ItemID].Name);

					SendMsgExp(conn, temp, TNColor::Default, false);*/
					SendEtc(conn);

					if (amount > 1)
						BASE_SetItemAmount(item, amount - 1);

					else
						memset(item, 0, sizeof(STRUCT_ITEM));

					return;
				}
			}
			else
			{
				SendMsgExp(conn, "Necessário ter aprendido a 8ª Skill.", TNColor::Default, false);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

		}
		else
		{
			SendMsgExp(conn, "Esse livro não pertence a sua Classe.", TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}
	}
	if (item->sIndex == 5513) // Proteção Absoluta
	{
		int ItemID = item->sIndex;

		if (pMob[conn].MOB.BaseScore.Level <= 240)
		{
			SendMsgExp(conn, "Level insuficiente.", TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (pMob[conn].extra.ClassMaster == MORTAL || pMob[conn].extra.ClassMaster == ARCH)
		{
			SendMsgExp(conn, "É necessário ser Celestial/SubCelestial.", TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (pMob[conn].MOB.Class == 1)
		{
			if ((1 << 5) & pMob[conn].extra.SecLearnedSkill)
			{
				SendMsgExp(conn, "Apenas uma 10ª Skill por personagem.", TNColor::Default, false);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if ((1 << 9) & pMob[conn].extra.SecLearnedSkill)
			{
				SendMsgExp(conn, "Apenas uma 10ª Skill por personagem.", TNColor::Default, false);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if ((1 << 0) & pMob[conn].extra.SecLearnedSkill)
			{
				if ((1 << 1) & pMob[conn].extra.SecLearnedSkill)
				{
					SendMsgExp(conn, g_pMessageStringTable[_NN_Already_Learned_It], TNColor::Default, false);
					SendItem(conn, m->SourType, m->SourPos, item);
					return;
				}
				else
				{
					pMob[conn].extra.SecLearnedSkill |= 0x2;
					/*
					snprintf(temp, sizeof(temp), g_pMessageStringTable[_SN_Learn_Sephera], g_pItemList[ItemID].Name);

					SendMsgExp(conn, temp, TNColor::Default, false);*/
					SendEtc(conn);

					if (amount > 1)
						BASE_SetItemAmount(item, amount - 1);

					else
						memset(item, 0, sizeof(STRUCT_ITEM));

					return;
				}
			}
			else
			{
				SendMsgExp(conn, "Necessário ter aprendido a 9ª Skill.", TNColor::Default, false);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}
		}
		else
		{
			SendMsgExp(conn, "Esse livro não pertence a sua Classe.", TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}
	}
	if (item->sIndex == 5516) // Magia Misteriosa
	{

		if (pMob[conn].MOB.BaseScore.Level <= 199)
		{
			SendMsgExp(conn, "Level insuficiente.", TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (pMob[conn].extra.ClassMaster == MORTAL || pMob[conn].extra.ClassMaster == ARCH)
		{
			SendMsgExp(conn, "É necessário ser Celestial/SubCelestial.", TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		int ItemID = item->sIndex;

		if (pMob[conn].MOB.Class == 1)
		{
			if ((1 << 0) & pMob[conn].extra.SecLearnedSkill)
			{
				SendMsgExp(conn, "Apenas uma 9ª Skill por personagem.", TNColor::Default, false);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if ((1 << 8) & pMob[conn].extra.SecLearnedSkill)
			{
				SendMsgExp(conn, "Apenas uma 9ª Skill por personagem.", TNColor::Default, false);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if ((1 << 15) & pMob[conn].MOB.LearnedSkill)
			{
				if ((1 << 4) & pMob[conn].extra.SecLearnedSkill)
				{
					SendMsgExp(conn, g_pMessageStringTable[_NN_Already_Learned_It], TNColor::Default, false);
					SendItem(conn, m->SourType, m->SourPos, item);
					return;
				}
				else
				{
					pMob[conn].extra.SecLearnedSkill |= 0x10;
					/*snprintf(temp, sizeof(temp), g_pMessageStringTable[_SN_Learn_Sephera], g_pItemList[ItemID].Name);

					SendMsgExp(conn, temp, TNColor::Default, false);*/
					SendEtc(conn);

					if (amount > 1)
						BASE_SetItemAmount(item, amount - 1);

					else
						memset(item, 0, sizeof(STRUCT_ITEM));

					return;
				}
			}
			else
			{
				SendMsgExp(conn, "Necessário ter aprendido a 8ª Skill.", TNColor::Default, false);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}
		}
		else
		{
			SendMsgExp(conn, "Esse livro não pertence a sua Classe.", TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}
	}

	if (item->sIndex == 5517) // Congelamento Proficiente
	{
		int ItemID = item->sIndex;

		if (pMob[conn].MOB.BaseScore.Level <= 240)
		{
			SendMsgExp(conn, "Level insuficiente.", TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (pMob[conn].extra.ClassMaster == MORTAL || pMob[conn].extra.ClassMaster == ARCH)
		{
			SendMsgExp(conn, "É necessário ser Celestial/SubCelestial.", TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (pMob[conn].MOB.Class == 1)
		{
			if ((1 << 1) & pMob[conn].extra.SecLearnedSkill)
			{
				SendMsgExp(conn, "Apenas uma 10ª Skill por personagem.", TNColor::Default, false);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if ((1 << 9) & pMob[conn].extra.SecLearnedSkill)
			{
				SendMsgExp(conn, "Apenas uma 10ª Skill por personagem.", TNColor::Default, false);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if ((1 << 4) & pMob[conn].extra.SecLearnedSkill)
			{
				if ((1 << 5) & pMob[conn].extra.SecLearnedSkill)
				{
					SendMsgExp(conn, g_pMessageStringTable[_NN_Already_Learned_It], TNColor::Default, false);
					SendItem(conn, m->SourType, m->SourPos, item);
					return;
				}
				else
				{
					pMob[conn].extra.SecLearnedSkill |= 0x20;
					/*
					snprintf(temp, sizeof(temp), g_pMessageStringTable[_SN_Learn_Sephera], g_pItemList[ItemID].Name);

					SendMsgExp(conn, temp, TNColor::Default, false);*/
					SendEtc(conn);

					if (amount > 1)
						BASE_SetItemAmount(item, amount - 1);

					else
						memset(item, 0, sizeof(STRUCT_ITEM));

					return;
				}
			}
			else
			{
				SendMsgExp(conn, "Necessário ter aprendido a 9ª Skill.", TNColor::Default, false);
				return;
			}
		}
		else
		{
			SendMsgExp(conn, "Esse livro não pertence a sua Classe.", TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}
	}
	if (item->sIndex == 5520) // Remover Memoria
	{

		if (pMob[conn].MOB.BaseScore.Level <= 199)
		{
			SendMsgExp(conn, "Level insuficiente.", TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (pMob[conn].extra.ClassMaster == MORTAL || pMob[conn].extra.ClassMaster == ARCH)
		{
			SendMsgExp(conn, "É necessário ser Celestial/SubCelestial.", TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		int ItemID = item->sIndex;

		if (pMob[conn].MOB.Class == 1)
		{
			if ((1 << 0) & pMob[conn].extra.SecLearnedSkill)
			{
				SendMsgExp(conn, "Apenas uma 9ª Skill por personagem.", TNColor::Default, false);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if ((1 << 4) & pMob[conn].extra.SecLearnedSkill)
			{
				SendMsgExp(conn, "Apenas uma 9ª Skill por personagem.", TNColor::Default, false);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if ((1 << 23) & pMob[conn].MOB.LearnedSkill)
			{
				if ((1 << 8) & pMob[conn].extra.SecLearnedSkill)
				{
					SendMsgExp(conn, g_pMessageStringTable[_NN_Already_Learned_It], TNColor::Default, false);
					SendItem(conn, m->SourType, m->SourPos, item);
					return;
				}
				else
				{
					pMob[conn].extra.SecLearnedSkill |= 0x100;
					/*
					snprintf(temp, sizeof(temp), g_pMessageStringTable[_SN_Learn_Sephera], g_pItemList[ItemID].Name);

					SendMsgExp(conn, temp, TNColor::Default, false);*/
					SendEtc(conn);

					if (amount > 1)
						BASE_SetItemAmount(item, amount - 1);

					else
						memset(item, 0, sizeof(STRUCT_ITEM));

					return;
				}
			}
			else
			{
				SendMsgExp(conn, "Necessário ter aprendido a 8ª Skill.", TNColor::Default, false);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}
		}
		else
		{
			SendMsgExp(conn, "Esse livro não pertence a sua Classe.", TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}
	}
	if (item->sIndex == 5521) // Incapacitador
	{
		int ItemID = item->sIndex;

		if (pMob[conn].MOB.BaseScore.Level <= 240)
		{
			SendMsgExp(conn, "Level insuficiente.", TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (pMob[conn].extra.ClassMaster == MORTAL || pMob[conn].extra.ClassMaster == ARCH)
		{
			SendMsgExp(conn, "É necessário ser Celestial/SubCelestial.", TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (pMob[conn].MOB.Class == 1)
		{
			if ((1 << 1) & pMob[conn].extra.SecLearnedSkill)
			{
				SendMsgExp(conn, "Apenas uma 10ª Skill por personagem.", TNColor::Default, false);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if ((1 << 5) & pMob[conn].extra.SecLearnedSkill)
			{
				SendMsgExp(conn, "Apenas uma 10ª Skill por personagem.", TNColor::Default, false);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if ((1 << 8) & pMob[conn].extra.SecLearnedSkill)
			{
				if ((1 << 9) & pMob[conn].extra.SecLearnedSkill)
				{
					SendMsgExp(conn, g_pMessageStringTable[_NN_Already_Learned_It], TNColor::Default, false);
					SendItem(conn, m->SourType, m->SourPos, item);
					return;
				}
				else
				{
					pMob[conn].extra.SecLearnedSkill |= 0x200;
					/*
					snprintf(temp, sizeof(temp), g_pMessageStringTable[_SN_Learn_Sephera], g_pItemList[ItemID].Name);

					SendMsgExp(conn, temp, TNColor::Default, false);*/
					SendEtc(conn);

					if (amount > 1)
						BASE_SetItemAmount(item, amount - 1);

					else
						memset(item, 0, sizeof(STRUCT_ITEM));

					return;
				}
			}
			else
			{
				SendMsgExp(conn, "Necessário ter aprendido a 9ª Skill.", TNColor::Default, false);
				return;
			}
		}
		else
		{
			SendMsgExp(conn, "Esse livro não pertence a sua Classe.", TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}
	}
#pragma endregion
#pragma region Livros BEASTMASTER
	if (item->sIndex == 5524) // Anti Magia
	{

		if (pMob[conn].MOB.BaseScore.Level <= 199)
		{
			SendMsgExp(conn, "Level insuficiente.", TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (pMob[conn].extra.ClassMaster == MORTAL || pMob[conn].extra.ClassMaster == ARCH)
		{
			SendMsgExp(conn, "É necessário ser Celestial/SubCelestial.", TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		int ItemID = item->sIndex;

		if (pMob[conn].MOB.Class == 2)
		{
			if ((1 << 4) & pMob[conn].extra.SecLearnedSkill)
			{
				SendMsgExp(conn, "Apenas uma 9ª Skill por personagem.", TNColor::Default, false);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if ((1 << 8) & pMob[conn].extra.SecLearnedSkill)
			{
				SendMsgExp(conn, "Apenas uma 9ª Skill por personagem.", TNColor::Default, false);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if ((1 << 7) & pMob[conn].MOB.LearnedSkill)
			{
				if ((1 << 0) & pMob[conn].extra.SecLearnedSkill)
				{
					SendMsgExp(conn, g_pMessageStringTable[_NN_Already_Learned_It], TNColor::Default, false);
					SendItem(conn, m->SourType, m->SourPos, item);
					return;
				}
				else
				{
					pMob[conn].extra.SecLearnedSkill |= 0x1;
					/*
					snprintf(temp, sizeof(temp), g_pMessageStringTable[_SN_Learn_Sephera], g_pItemList[ItemID].Name);

					SendMsgExp(conn, temp, TNColor::Default, false);*/
					SendEtc(conn);

					if (amount > 1)
						BASE_SetItemAmount(item, amount - 1);

					else
						memset(item, 0, sizeof(STRUCT_ITEM));

					return;
				}
			}
			else
			{
				SendMsgExp(conn, "Necessário ter aprendido a 8ª Skill.", TNColor::Default, false);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

		}
		else
		{
			SendMsgExp(conn, "Esse livro não pertence a sua Classe.", TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}
	}
	if (item->sIndex == 5525) // Chama Resistente
	{
		int ItemID = item->sIndex;

		if (pMob[conn].MOB.BaseScore.Level <= 240)
		{
			SendMsgExp(conn, "Level insuficiente.", TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (pMob[conn].extra.ClassMaster == MORTAL || pMob[conn].extra.ClassMaster == ARCH)
		{
			SendMsgExp(conn, "É necessário ser Celestial/SubCelestial.", TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (pMob[conn].MOB.Class == 2)
		{
			if ((1 << 5) & pMob[conn].extra.SecLearnedSkill)
			{
				SendMsgExp(conn, "Apenas uma 10ª Skill por personagem.", TNColor::Default, false);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if ((1 << 9) & pMob[conn].extra.SecLearnedSkill)
			{
				SendMsgExp(conn, "Apenas uma 10ª Skill por personagem.", TNColor::Default, false);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if ((1 << 0) & pMob[conn].extra.SecLearnedSkill)
			{
				if ((1 << 1) & pMob[conn].extra.SecLearnedSkill)
				{
					SendMsgExp(conn, g_pMessageStringTable[_NN_Already_Learned_It], TNColor::Default, false);
					SendItem(conn, m->SourType, m->SourPos, item);
					return;
				}
				else
				{
					pMob[conn].extra.SecLearnedSkill |= 0x2;
					/*
					snprintf(temp, sizeof(temp), g_pMessageStringTable[_SN_Learn_Sephera], g_pItemList[ItemID].Name);

					SendMsgExp(conn, temp, TNColor::Default, false);*/
					SendEtc(conn);

					if (amount > 1)
						BASE_SetItemAmount(item, amount - 1);

					else
						memset(item, 0, sizeof(STRUCT_ITEM));

					return;
				}
			}
			else
			{
				SendMsgExp(conn, "Necessário ter aprendido a 9ª Skill.", TNColor::Default, false);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}
		}
		else
		{
			SendMsgExp(conn, "Esse livro não pertence a sua Classe.", TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}
	}
	if (item->sIndex == 5528) // Unidade Mental
	{

		if (pMob[conn].MOB.BaseScore.Level <= 199)
		{
			SendMsgExp(conn, "Level insuficiente.", TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (pMob[conn].extra.ClassMaster == MORTAL || pMob[conn].extra.ClassMaster == ARCH)
		{
			SendMsgExp(conn, "É necessário ser Celestial/SubCelestial.", TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		int ItemID = item->sIndex;

		if (pMob[conn].MOB.Class == 2)
		{
			if ((1 << 0) & pMob[conn].extra.SecLearnedSkill)
			{
				SendMsgExp(conn, "Apenas uma 9ª Skill por personagem.", TNColor::Default, false);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if ((1 << 8) & pMob[conn].extra.SecLearnedSkill)
			{
				SendMsgExp(conn, "Apenas uma 9ª Skill por personagem.", TNColor::Default, false);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if ((1 << 15) & pMob[conn].MOB.LearnedSkill)
			{
				if ((1 << 4) & pMob[conn].extra.SecLearnedSkill)
				{
					SendMsgExp(conn, g_pMessageStringTable[_NN_Already_Learned_It], TNColor::Default, false);
					SendItem(conn, m->SourType, m->SourPos, item);
					return;
				}
				else
				{
					pMob[conn].extra.SecLearnedSkill |= 0x10;
					/*
					snprintf(temp, sizeof(temp), g_pMessageStringTable[_SN_Learn_Sephera], g_pItemList[ItemID].Name);

					SendMsgExp(conn, temp, TNColor::Default, false);*/
					SendEtc(conn);

					if (amount > 1)
						BASE_SetItemAmount(item, amount - 1);

					else
						memset(item, 0, sizeof(STRUCT_ITEM));

					return;
				}
			}
			else
			{
				SendMsgExp(conn, "Necessário ter aprendido a 8ª Skill.", TNColor::Default, false);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}
		}
		else
		{
			SendMsgExp(conn, "Esse livro não pertence a sua Classe.", TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}
	}

	if (item->sIndex == 5529) // Invocação Final
	{
		int ItemID = item->sIndex;

		if (pMob[conn].MOB.BaseScore.Level <= 240)
		{
			SendMsgExp(conn, "Level insuficiente.", TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (pMob[conn].extra.ClassMaster == MORTAL || pMob[conn].extra.ClassMaster == ARCH)
		{
			SendMsgExp(conn, "É necessário ser Celestial/SubCelestial.", TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}


		if (pMob[conn].MOB.Class == 2)
		{
			if ((1 << 1) & pMob[conn].extra.SecLearnedSkill)
			{
				SendMsgExp(conn, "Apenas uma 10ª Skill por personagem.", TNColor::Default, false);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if ((1 << 9) & pMob[conn].extra.SecLearnedSkill)
			{
				SendMsgExp(conn, "Apenas uma 10ª Skill por personagem.", TNColor::Default, false);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if ((1 << 4) & pMob[conn].extra.SecLearnedSkill)
			{
				if ((1 << 5) & pMob[conn].extra.SecLearnedSkill)
				{
					SendMsgExp(conn, g_pMessageStringTable[_NN_Already_Learned_It], TNColor::Default, false);
					SendItem(conn, m->SourType, m->SourPos, item);
					return;
				}
				else
				{
					pMob[conn].extra.SecLearnedSkill |= 0x20;
					/*har temp[1024];
					snprintf(temp, sizeof(temp), g_pMessageStringTable[_SN_Learn_Sephera], g_pItemList[ItemID].Name);

					SendMsgExp(conn, temp, TNColor::Default, false);*/
					SendEtc(conn);

					if (amount > 1)
						BASE_SetItemAmount(item, amount - 1);

					else
						memset(item, 0, sizeof(STRUCT_ITEM));

					return;
				}
			}
			else
			{
				SendMsgExp(conn, "Necessário ter aprendido a 9ª Skill.", TNColor::Default, false);
				return;
			}
		}
		else
		{
			SendMsgExp(conn, "Esse livro não pertence a sua Classe.", TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}
	}
	if (item->sIndex == 5532) // Concha Resistente
	{
		if (pMob[conn].MOB.BaseScore.Level <= 199)
		{
			SendMsgExp(conn, "Level insuficiente.", TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (pMob[conn].extra.ClassMaster == MORTAL || pMob[conn].extra.ClassMaster == ARCH)
		{
			SendMsgExp(conn, "É necessário ser Celestial/SubCelestial.", TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		int ItemID = item->sIndex;

		if (pMob[conn].MOB.Class == 2)
		{
			if ((1 << 0) & pMob[conn].extra.SecLearnedSkill)
			{
				SendMsgExp(conn, "Apenas uma 9ª Skill por personagem.", TNColor::Default, false);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if ((1 << 4) & pMob[conn].extra.SecLearnedSkill)
			{
				SendMsgExp(conn, "Apenas uma 9ª Skill por personagem.", TNColor::Default, false);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if ((1 << 23) & pMob[conn].MOB.LearnedSkill)
			{
				if ((1 << 8) & pMob[conn].extra.SecLearnedSkill)
				{
					SendMsgExp(conn, g_pMessageStringTable[_NN_Already_Learned_It], TNColor::Default, false);
					SendItem(conn, m->SourType, m->SourPos, item);
					return;
				}
				else
				{
					pMob[conn].extra.SecLearnedSkill |= 0x100;
					/*
					snprintf(temp, sizeof(temp), g_pMessageStringTable[_SN_Learn_Sephera], g_pItemList[ItemID].Name);

					SendMsgExp(conn, temp, TNColor::Default, false);*/
					SendEtc(conn);

					if (amount > 1)
						BASE_SetItemAmount(item, amount - 1);

					else
						memset(item, 0, sizeof(STRUCT_ITEM));

					return;
				}
			}
			else
			{
				SendMsgExp(conn, "Necessário ter aprendido a 8ª Skill.", TNColor::Default, false);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}
		}
		else
		{
			SendMsgExp(conn, "Esse livro não pertence a sua Classe.", TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}
	}
	if (item->sIndex == 5533) // Espinhos Fortalecidos
	{
		int ItemID = item->sIndex;

		if (pMob[conn].MOB.BaseScore.Level <= 240)
		{
			SendMsgExp(conn, "Level insuficiente.", TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (pMob[conn].extra.ClassMaster == MORTAL || pMob[conn].extra.ClassMaster == ARCH)
		{
			SendMsgExp(conn, "É necessário ser Celestial/SubCelestial.", TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (pMob[conn].MOB.Class == 2)
		{
			if ((1 << 1) & pMob[conn].extra.SecLearnedSkill)
			{
				SendMsgExp(conn, "Apenas uma 10ª Skill por personagem.", TNColor::Default, false);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if ((1 << 5) & pMob[conn].extra.SecLearnedSkill)
			{
				SendMsgExp(conn, "Apenas uma 10ª Skill por personagem.", TNColor::Default, false);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if ((1 << 8) & pMob[conn].extra.SecLearnedSkill)
			{
				if ((1 << 9) & pMob[conn].extra.SecLearnedSkill)
				{
					SendMsgExp(conn, g_pMessageStringTable[_NN_Already_Learned_It], TNColor::Default, false);
					SendItem(conn, m->SourType, m->SourPos, item);
					return;
				}
				else
				{
					pMob[conn].extra.SecLearnedSkill |= 0x200;
					/*
					snprintf(temp, sizeof(temp), g_pMessageStringTable[_SN_Learn_Sephera], g_pItemList[ItemID].Name);

					SendMsgExp(conn, temp, TNColor::Default, false);*/
					SendEtc(conn);

					if (amount > 1)
						BASE_SetItemAmount(item, amount - 1);

					else
						memset(item, 0, sizeof(STRUCT_ITEM));

					return;
				}
			}
			else
			{
				SendMsgExp(conn, "Necessário ter aprendido a 9ª Skill.", TNColor::Default, false);
				return;
			}
		}
		else
		{
			SendMsgExp(conn, "Esse livro não pertence a sua Classe.", TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}
	}
#pragma endregion
#pragma region Livros HUNTRESS
	if (item->sIndex == 5536) // Contra Ataque
	{
		if (pMob[conn].MOB.BaseScore.Level <= 199)
		{
			SendMsgExp(conn, "Level insuficiente.", TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (pMob[conn].extra.ClassMaster == MORTAL || pMob[conn].extra.ClassMaster == ARCH)
		{
			SendMsgExp(conn, "É necessário ser Celestial/SubCelestial.", TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		int ItemID = item->sIndex;

		if (pMob[conn].MOB.Class == 3)
		{
			if ((1 << 4) & pMob[conn].extra.SecLearnedSkill)
			{
				SendMsgExp(conn, "Apenas uma 9ª Skill por personagem.", TNColor::Default, false);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if ((1 << 8) & pMob[conn].extra.SecLearnedSkill)
			{
				SendMsgExp(conn, "Apenas uma 9ª Skill por personagem.", TNColor::Default, false);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if ((1 << 7) & pMob[conn].MOB.LearnedSkill)
			{
				if ((1 << 0) & pMob[conn].extra.SecLearnedSkill)
				{
					SendMsgExp(conn, g_pMessageStringTable[_NN_Already_Learned_It], TNColor::Default, false);
					SendItem(conn, m->SourType, m->SourPos, item);
					return;
				}
				else
				{
					pMob[conn].extra.SecLearnedSkill |= 0x1;
					/*
					snprintf(temp, sizeof(temp), g_pMessageStringTable[_SN_Learn_Sephera], g_pItemList[ItemID].Name);

					SendMsgExp(conn, temp, TNColor::Default, false);*/
					SendEtc(conn);

					if (amount > 1)
						BASE_SetItemAmount(item, amount - 1);

					else
						memset(item, 0, sizeof(STRUCT_ITEM));

					return;
				}
			}
			else
			{
				SendMsgExp(conn, "Necessário ter aprendido a 8ª Skill.", TNColor::Default, false);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

		}
		else
		{
			SendMsgExp(conn, "Esse livro não pertence a sua Classe.", TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}
	}
	if (item->sIndex == 5537) // Ataque Rápido Proficiente
	{
		int ItemID = item->sIndex;

		if (pMob[conn].MOB.BaseScore.Level <= 240)
		{
			SendMsgExp(conn, "Level insuficiente.", TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (pMob[conn].extra.ClassMaster == MORTAL || pMob[conn].extra.ClassMaster == ARCH)
		{
			SendMsgExp(conn, "É necessário ser Celestial/SubCelestial.", TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (pMob[conn].MOB.Class == 3)
		{
			if ((1 << 5) & pMob[conn].extra.SecLearnedSkill)
			{
				SendMsgExp(conn, "Apenas uma 10ª Skill por personagem.", TNColor::Default, false);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if ((1 << 9) & pMob[conn].extra.SecLearnedSkill)
			{
				SendMsgExp(conn, "Apenas uma 10ª Skill por personagem.", TNColor::Default, false);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if ((1 << 0) & pMob[conn].extra.SecLearnedSkill)
			{
				if ((1 << 1) & pMob[conn].extra.SecLearnedSkill)
				{
					SendMsgExp(conn, g_pMessageStringTable[_NN_Already_Learned_It], TNColor::Default, false);
					SendItem(conn, m->SourType, m->SourPos, item);
					return;
				}
				else
				{
					pMob[conn].extra.SecLearnedSkill |= 0x2;
					/*
					snprintf(temp, sizeof(temp), g_pMessageStringTable[_SN_Learn_Sephera], g_pItemList[ItemID].Name);

					SendMsgExp(conn, temp, TNColor::Default, false);*/
					SendEtc(conn);

					if (amount > 1)
						BASE_SetItemAmount(item, amount - 1);

					else
						memset(item, 0, sizeof(STRUCT_ITEM));

					return;
				}
			}
			else
			{
				SendMsgExp(conn, "Necessário ter aprendido a 9ª Skill.", TNColor::Default, false);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}
		}
		else
		{
			SendMsgExp(conn, "Esse livro não pertence a sua Classe.", TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}
	}
	if (item->sIndex == 5540) // Ponto de Mestre
	{
		if (pMob[conn].MOB.BaseScore.Level <= 199)
		{
			SendMsgExp(conn, "Level insuficiente.", TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (pMob[conn].extra.ClassMaster == MORTAL || pMob[conn].extra.ClassMaster == ARCH)
		{
			SendMsgExp(conn, "É necessário ser Celestial/SubCelestial.", TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		int ItemID = item->sIndex;

		if (pMob[conn].MOB.Class == 3)
		{
			if ((1 << 0) & pMob[conn].extra.SecLearnedSkill)
			{
				SendMsgExp(conn, "Apenas uma 9ª Skill por personagem.", TNColor::Default, false);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if ((1 << 8) & pMob[conn].extra.SecLearnedSkill)
			{
				SendMsgExp(conn, "Apenas uma 9ª Skill por personagem.", TNColor::Default, false);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if ((1 << 15) & pMob[conn].MOB.LearnedSkill)
			{
				if ((1 << 4) & pMob[conn].extra.SecLearnedSkill)
				{
					SendMsgExp(conn, g_pMessageStringTable[_NN_Already_Learned_It], TNColor::Default, false);
					SendItem(conn, m->SourType, m->SourPos, item);
					return;
				}
				else
				{
					pMob[conn].extra.SecLearnedSkill |= 0x10;
					/*
					snprintf(temp, sizeof(temp), g_pMessageStringTable[_SN_Learn_Sephera], g_pItemList[ItemID].Name);

					SendMsgExp(conn, temp, TNColor::Default, false);*/
					SendEtc(conn);

					if (amount > 1)
						BASE_SetItemAmount(item, amount - 1);

					else
						memset(item, 0, sizeof(STRUCT_ITEM));

					return;
				}
			}
			else
			{
				SendMsgExp(conn, "Necessário ter aprendido a 8ª Skill.", TNColor::Default, false);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}
		}
		else
		{
			SendMsgExp(conn, "Esse livro não pertence a sua Classe.", TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}
	}

	if (item->sIndex == 5541) // Absorção de Alma
	{
		int ItemID = item->sIndex;

		if (pMob[conn].MOB.BaseScore.Level <= 240)
		{
			SendMsgExp(conn, "Level insuficiente.", TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (pMob[conn].extra.ClassMaster == MORTAL || pMob[conn].extra.ClassMaster == ARCH)
		{
			SendMsgExp(conn, "É necessário ser Celestial/SubCelestial.", TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (pMob[conn].MOB.Class == 3)
		{
			if ((1 << 1) & pMob[conn].extra.SecLearnedSkill)
			{
				SendMsgExp(conn, "Apenas uma 10ª Skill por personagem.", TNColor::Default, false);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if ((1 << 9) & pMob[conn].extra.SecLearnedSkill)
			{
				SendMsgExp(conn, "Apenas uma 10ª Skill por personagem.", TNColor::Default, false);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if ((1 << 4) & pMob[conn].extra.SecLearnedSkill)
			{
				if ((1 << 5) & pMob[conn].extra.SecLearnedSkill)
				{
					SendMsgExp(conn, g_pMessageStringTable[_NN_Already_Learned_It], TNColor::Default, false);
					SendItem(conn, m->SourType, m->SourPos, item);
					return;
				}
				else
				{
					pMob[conn].extra.SecLearnedSkill |= 0x20;
					/*
					snprintf(temp, sizeof(temp), g_pMessageStringTable[_SN_Learn_Sephera], g_pItemList[ItemID].Name);

					SendMsgExp(conn, temp, TNColor::Default, false);*/
					SendEtc(conn);

					if (amount > 1)
						BASE_SetItemAmount(item, amount - 1);

					else
						memset(item, 0, sizeof(STRUCT_ITEM));

					return;
				}
			}
			else
			{
				SendMsgExp(conn, "Necessário ter aprendido a 9ª Skill.", TNColor::Default, false);
				return;
			}
		}
		else
		{
			SendMsgExp(conn, "Esse livro não pertence a sua Classe.", TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}
	}
	if (item->sIndex == 5544) // Tiro Direto
	{
		if (pMob[conn].MOB.BaseScore.Level <= 199)
		{
			SendMsgExp(conn, "Level insuficiente.", TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (pMob[conn].extra.ClassMaster == MORTAL || pMob[conn].extra.ClassMaster == ARCH)
		{
			SendMsgExp(conn, "É necessário ser Celestial/SubCelestial.", TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		int ItemID = item->sIndex;

		if (pMob[conn].MOB.Class == 3)
		{
			if ((1 << 0) & pMob[conn].extra.SecLearnedSkill)
			{
				SendMsgExp(conn, "Apenas uma 9ª Skill por personagem.", TNColor::Default, false);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if ((1 << 4) & pMob[conn].extra.SecLearnedSkill)
			{
				SendMsgExp(conn, "Apenas uma 9ª Skill por personagem.", TNColor::Default, false);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if ((1 << 23) & pMob[conn].MOB.LearnedSkill)
			{
				if ((1 << 8) & pMob[conn].extra.SecLearnedSkill)
				{
					SendMsgExp(conn, g_pMessageStringTable[_NN_Already_Learned_It], TNColor::Default, false);
					SendItem(conn, m->SourType, m->SourPos, item);
					return;
				}
				else
				{
					pMob[conn].extra.SecLearnedSkill |= 0x100;
					/*
					snprintf(temp, sizeof(temp), g_pMessageStringTable[_SN_Learn_Sephera], g_pItemList[ItemID].Name);

					SendMsgExp(conn, temp, TNColor::Default, false);*/
					SendEtc(conn);

					if (amount > 1)
						BASE_SetItemAmount(item, amount - 1);

					else
						memset(item, 0, sizeof(STRUCT_ITEM));

					return;
				}
			}
			else
			{
				SendMsgExp(conn, "Necessário ter aprendido a 8ª Skill.", TNColor::Default, false);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}
		}
		else
		{
			SendMsgExp(conn, "Esse livro não pertence a sua Classe.", TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}
	}
	if (item->sIndex == 5545) // Garra Habilidosa
	{
		int ItemID = item->sIndex;

		if (pMob[conn].MOB.BaseScore.Level <= 240)
		{
			SendMsgExp(conn, "Level insuficiente.", TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (pMob[conn].extra.ClassMaster == MORTAL || pMob[conn].extra.ClassMaster == ARCH)
		{
			SendMsgExp(conn, "É necessário ser Celestial/SubCelestial.", TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (pMob[conn].MOB.Class == 3)
		{
			if ((1 << 1) & pMob[conn].extra.SecLearnedSkill)
			{
				SendMsgExp(conn, "Apenas uma 10ª Skill por personagem.", TNColor::Default, false);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if ((1 << 5) & pMob[conn].extra.SecLearnedSkill)
			{
				SendMsgExp(conn, "Apenas uma 10ª Skill por personagem.", TNColor::Default, false);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if ((1 << 8) & pMob[conn].extra.SecLearnedSkill)
			{
				if ((1 << 9) & pMob[conn].extra.SecLearnedSkill)
				{
					SendMsgExp(conn, g_pMessageStringTable[_NN_Already_Learned_It], TNColor::Default, false);
					SendItem(conn, m->SourType, m->SourPos, item);
					return;
				}
				else
				{
					pMob[conn].extra.SecLearnedSkill |= 0x200;
					/*
					snprintf(temp, sizeof(temp), g_pMessageStringTable[_SN_Learn_Sephera], g_pItemList[ItemID].Name);

					SendMsgExp(conn, temp, TNColor::Default, false);*/
					SendEtc(conn);

					if (amount > 1)
						BASE_SetItemAmount(item, amount - 1);

					else
						memset(item, 0, sizeof(STRUCT_ITEM));

					return;
				}
			}
			else
			{
				SendMsgExp(conn, "Necessário ter aprendido a 9ª Skill.", TNColor::Default, false);
				return;
			}
		}
		else
		{
			SendMsgExp(conn, "Esse livro não pertence a sua Classe.", TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}
	}
#pragma endregion
#pragma endregion
#pragma region Livros Sephira
	if (Vol >= 31 && Vol <= 38)
	{
		int ItemID = item->sIndex;
		if (ItemID <= 0 || ItemID > MAX_ITEMLIST)
		{

			//MyLog(LogType::Itens, pMob[conn].MOB.MobName, "err, wrong skill book index", 0, pUser[conn].IP);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}
		int SkillLearn = 1 << (Vol - 7);

		if ((pMob[conn].MOB.LearnedSkill & SkillLearn) != 0)
		{
			SendItem(conn, m->SourType, m->SourPos, item);
			SendMsgExp(conn, g_pMessageStringTable[_NN_Already_Learned_It], TNColor::Default, false);
			return;
		}

		pMob[conn].MOB.LearnedSkill = pMob[conn].MOB.LearnedSkill | SkillLearn;

		/*
		snprintf(temp, sizeof(temp), g_pMessageStringTable[_SN_Learn_Sephera], g_pItemList[ItemID].Name);

		SendMsgExp(conn, temp, TNColor::Default, false);*/
		SendEtc(conn);
		SaveUser(conn, 0);
		SetAffect(conn, 44, 20, 20);

		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));

		return;
	}
#pragma endregion
#pragma region Contratos do reino
	if (Vol >= 41 && Vol < 50)
	{
		int Evock = Vol - 41;

		if (pMob[conn].MOB.Clan != 7 && pMob[conn].MOB.Clan != 8)
		{
			SendMsgExp(conn, g_pMessageStringTable[_NN_Only_same_kingdom], TNColor::Default, false);

			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (Evock < 5 && pMob[conn].MOB.Clan == 8)
		{
			SendMsgExp(conn, g_pMessageStringTable[_NN_Only_same_kingdom], TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (Evock >= 5 && pMob[conn].MOB.Clan == 7)
		{
			SendMsgExp(conn, g_pMessageStringTable[_NN_Only_same_kingdom], TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}


		if (CastleState == 0)
		{
			SendMsgExp(conn, g_pMessageStringTable[_NN_Only_when_castle_war], TNColor::Default, false);

			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}


		GenerateSummon(conn, Evock + 28, 0, 1);

		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));

		return;
	}
#pragma endregion 
#pragma region Pergaminho da agua N
	if (Vol >= 131 && Vol <= 140)
	{
		int TargetX = pMob[conn].TargetX;
		int TargetY = pMob[conn].TargetY;

		int inside = 0;

		for (int i = 0; i < 10; i++)
		{
			if (TargetX >= WaterScrollPosition[0][i][0] - 12 && TargetY >= WaterScrollPosition[0][i][1] - 12
				&& TargetX <= WaterScrollPosition[0][i][0] + 12 && TargetY <= WaterScrollPosition[0][i][1] + 12 && i >= 9)
			{
				inside = 1;
				break;
			}

			if (TargetX >= WaterScrollPosition[0][i][0] - 8 && TargetY >= WaterScrollPosition[0][i][1] - 8
				&& TargetX <= WaterScrollPosition[0][i][0] + 8 && TargetY <= WaterScrollPosition[0][i][1] + 8)
			{
				inside = 1;
				break;
			}
		}
		if ((pMob[conn].extra.ClassMaster == CELESTIAL || pMob[conn].extra.ClassMaster == CELESTIALCS || pMob[conn].extra.ClassMaster == SCELESTIAL) && pMob[conn].MOB.CurrentScore.Level > -1)
		{
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}
		if (((TargetX / 4) != 491 || (TargetY / 4) != 443 || Vol == 139) && inside == 0)
		{
			SendMsgExp(conn, g_pMessageStringTable[_NN_Cant_Use_That_Here], TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (pMob[conn].Leader != -1 && pMob[conn].Leader)
		{
			SendMsgExp(conn, g_pMessageStringTable[_NN_Party_Leader_Only], TNColor::Default, false);

			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}


		char UserName[128];

		int Sala = Vol - 131;
		int UserArea = Sala <= 7 ? GetUserInArea(WaterScrollPosition[0][Vol - 131][0] - 8, WaterScrollPosition[0][Vol - 131][1] - 8, WaterScrollPosition[0][Vol - 131][0] + 8, WaterScrollPosition[0][Vol - 131][1] + 8, UserName) : GetUserInArea(WaterScrollPosition[0][Vol - 131][0] - 12, WaterScrollPosition[0][Vol - 131][1] - 12, WaterScrollPosition[0][Vol - 131][0] + 12, WaterScrollPosition[0][Vol - 131][1] + 12, UserName);

		if (UserArea >= 1)
		{
			SendMsgExp(conn, temp, TNColor::Default, strFmt(g_pMessageStringTable[_NN_Someone_is_on_quest], UserName, UserArea - 1));
			SendItem(conn, m->SourType, m->SourPos, item);

			return;
		}

		WaterClear1[0][Vol - 131] = 30;

		DoTeleport(conn, WaterScrollPosition[0][Vol - 131][0], WaterScrollPosition[0][Vol - 131][1]);
		SendClientSignalParm(conn, ESCENE_FIELD, _MSG_StartTime, WaterClear1[0][Vol - 131] * 2);

		//MACRO PERGA
		pUser[conn].Ingame.MacroSala = Vol - 131;
		pUser[conn].Ingame.MacroType = 1;
		////////////

		for (int i = 0; i < MAX_PARTY; i++)
		{
			int partyconn = pMob[conn].PartyList[i];

			if ((pMob[partyconn].extra.ClassMaster == CELESTIAL || pMob[partyconn].extra.ClassMaster == CELESTIALCS || pMob[partyconn].extra.ClassMaster == SCELESTIAL) && pMob[partyconn].MOB.CurrentScore.Level >= -1)
				continue;
			if (partyconn > 0 && partyconn < MAX_USER && partyconn != conn && pUser[partyconn].Mode == USER_PLAY)
			{
				DoTeleport(partyconn, WaterScrollPosition[0][Vol - 131][0], WaterScrollPosition[0][Vol - 131][1]);
				SendClientSignalParm(partyconn, ESCENE_FIELD, _MSG_StartTime, WaterClear1[0][Vol - 131] * 2);
			}
		}

		if (Sala <= 7)
		{
			GenerateMob(Sala + WATER_N_INITIAL, 0, 0);
			GenerateMob(Sala + WATER_N_INITIAL, 0, 0);
			//RebuildGenerator();
		}
		else if (Sala == 9)
		{
			int _rand = rand() % 10;

			if (_rand < 4)
				GenerateMob(WATER_N_INITIAL + 8, 0, 0);

			else if (_rand < 5)
				GenerateMob(WATER_N_INITIAL + 9, 0, 0);

			else if (_rand < 6)
				GenerateMob(WATER_N_INITIAL + 10, 0, 0);

			else
				GenerateMob(WATER_N_INITIAL + 11, 0, 0);
		}

		/*
		 snprintf(temp, sizeof(temp), "useitem,water scroll N %d", Sala);
		 ItemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);*/

		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));

		return;
	}
#pragma endregion
#pragma region Pergaminho da agua M
	if (Vol >= 21 && Vol <= 30)
	{
		int TargetX = pMob[conn].TargetX;
		int TargetY = pMob[conn].TargetY;

		int inside = 0;

		for (int i = 0; i < 10; i++)
		{
			if (TargetX >= WaterScrollPosition[1][i][0] - 12 && TargetY >= WaterScrollPosition[1][i][1] - 12
				&& TargetX <= WaterScrollPosition[1][i][0] + 12 && TargetY <= WaterScrollPosition[1][i][1] + 12 && i >= 9)
			{
				inside = 1;
				break;
			}

			if (TargetX >= WaterScrollPosition[1][i][0] - 8 && TargetY >= WaterScrollPosition[1][i][1] - 8
				&& TargetX <= WaterScrollPosition[1][i][0] + 8 && TargetY <= WaterScrollPosition[1][i][1] + 8)
			{
				inside = 1;
				break;
			}
		}

		if ((pMob[conn].extra.ClassMaster == CELESTIAL || pMob[conn].extra.ClassMaster == CELESTIALCS || pMob[conn].extra.ClassMaster == SCELESTIAL) && pMob[conn].MOB.CurrentScore.Level > -1)
		{
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}
		if (((TargetX / 4) != 491 || (TargetY / 4) != 443 || Vol == 29) && inside == 0)
		{
			SendMsgExp(conn, g_pMessageStringTable[_NN_Cant_Use_That_Here], TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (pMob[conn].Leader != -1 && pMob[conn].Leader)
		{
			SendMsgExp(conn, g_pMessageStringTable[_NN_Party_Leader_Only], TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		char UserName[128];

		int Sala = Vol - 21;
		int UserArea = Sala <= 7 ? GetUserInArea(WaterScrollPosition[1][Vol - 21][0] - 8, WaterScrollPosition[1][Vol - 21][1] - 8, WaterScrollPosition[1][Vol - 21][0] + 8, WaterScrollPosition[1][Vol - 21][1] + 8, UserName) : GetUserInArea(WaterScrollPosition[1][Vol - 21][0] - 12, WaterScrollPosition[1][Vol - 21][1] - 12, WaterScrollPosition[1][Vol - 21][0] + 12, WaterScrollPosition[1][Vol - 21][1] + 12, UserName);

		if (UserArea >= 1)
		{
			SendMsgExp(conn, strFmt("O jogador [%s] Já se encontra na sala", UserName), TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		WaterClear1[1][Vol - 21] = 30;

		//MACRO PERGA
		pUser[conn].Ingame.MacroSala = Sala;
		pUser[conn].Ingame.MacroType = 2;
		/////////////

		DoTeleport(conn, WaterScrollPosition[1][Vol - 21][0], WaterScrollPosition[1][Vol - 21][1]);
		SendClientSignalParm(conn, ESCENE_FIELD, _MSG_StartTime, WaterClear1[1][Vol - 21] * 2);

		for (int i = 0; i < MAX_PARTY; i++)
		{
			int partyconn = pMob[conn].PartyList[i];

			if ((pMob[partyconn].extra.ClassMaster == CELESTIAL || pMob[partyconn].extra.ClassMaster == CELESTIALCS || pMob[partyconn].extra.ClassMaster == SCELESTIAL) && pMob[partyconn].MOB.CurrentScore.Level >= -1)
				continue;

			if (partyconn > 0 && partyconn < MAX_USER && partyconn != conn && pUser[partyconn].Mode == USER_PLAY)
			{
				DoTeleport(partyconn, WaterScrollPosition[1][Vol - 21][0], WaterScrollPosition[1][Vol - 21][1]);
				SendClientSignalParm(partyconn, ESCENE_FIELD, _MSG_StartTime, WaterClear1[1][Vol - 21] * 2);
			}
		}

		if (Sala <= 7)
		{
			GenerateMob(Sala + WATER_M_INITIAL, 0, 0);
			GenerateMob(Sala + WATER_M_INITIAL, 0, 0);
			RebuildGenerator();
		}
		else if (Sala == 9)
		{
			int _rand = rand() % 10;

			if (_rand < 4)
				GenerateMob(WATER_M_INITIAL + 8, 0, 0);

			else if (_rand < 5)
				GenerateMob(WATER_M_INITIAL + 9, 0, 0);

			else if (_rand < 6)
				GenerateMob(WATER_M_INITIAL + 10, 0, 0);

			else
				GenerateMob(WATER_M_INITIAL + 11, 0, 0);
		}

		/*
		snprintf(temp, sizeof(temp), "useitem,water scroll M %d", Sala);
		ItemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);*/

		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));

		return;
	}
#pragma endregion

#pragma region Pergaminho da agua A
	if (Vol >= 161 && Vol <= 170)
	{
		int TargetX = pMob[conn].TargetX;
		int TargetY = pMob[conn].TargetY;

		int inside = 0;

		for (int i = 0; i < 10; i++)
		{
			if (TargetX >= WaterScrollPosition[2][i][0] - 12 && TargetY >= WaterScrollPosition[2][i][1] - 12
				&& TargetX <= WaterScrollPosition[2][i][0] + 12 && TargetY <= WaterScrollPosition[2][i][1] + 12 && i >= 9)
			{
				inside = 1;
				break;
			}

			if (TargetX >= WaterScrollPosition[2][i][0] - 8 && TargetY >= WaterScrollPosition[2][i][1] - 8
				&& TargetX <= WaterScrollPosition[2][i][0] + 8 && TargetY <= WaterScrollPosition[2][i][1] + 8)
			{
				inside = 1;
				break;
			}
		}

		if (((TargetX / 4) != 491 || (TargetY / 4) != 443 || Vol == 169) && inside == 0)
		{
			SendMsgExp(conn, g_pMessageStringTable[_NN_Cant_Use_That_Here], TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (pMob[conn].Leader != -1 && pMob[conn].Leader)
		{
			SendMsgExp(conn, g_pMessageStringTable[_NN_Party_Leader_Only], TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		char UserName[128];

		int Sala = Vol - 161;
		int UserArea = Sala <= 7 ? GetUserInArea(WaterScrollPosition[2][Vol - 161][0] - 8, WaterScrollPosition[2][Vol - 161][1] - 8, WaterScrollPosition[2][Vol - 161][0] + 8, WaterScrollPosition[2][Vol - 161][1] + 8, UserName) : GetUserInArea(WaterScrollPosition[2][Vol - 161][0] - 12, WaterScrollPosition[2][Vol - 161][1] - 12, WaterScrollPosition[2][Vol - 161][0] + 12, WaterScrollPosition[2][Vol - 161][1] + 12, UserName);

		if (UserArea >= 1)
		{
			SendMsgExp(conn, strFmt(g_pMessageStringTable[_NN_Someone_is_on_quest], UserName, UserArea - 1), TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);

			return;
		}

		WaterClear1[2][Vol - 161] = Sala <= 7 ? 30 : 15;

		//MACRO PERGA
		pUser[conn].Ingame.MacroSala = Vol - 161;
		pUser[conn].Ingame.MacroType = 3;
		/////////////

		DoTeleport(conn, WaterScrollPosition[2][Vol - 161][0], WaterScrollPosition[2][Vol - 161][1]);
		SendClientSignalParm(conn, ESCENE_FIELD, _MSG_StartTime, WaterClear1[2][Vol - 161] * 2);

		for (int i = 0; i < MAX_PARTY; i++)
		{
			int partyconn = pMob[conn].PartyList[i];

			if (partyconn > 0 && partyconn < MAX_USER && partyconn != conn && pUser[partyconn].Mode == USER_PLAY)
			{
				DoTeleport(partyconn, WaterScrollPosition[2][Vol - 161][0], WaterScrollPosition[2][Vol - 161][1]);
				SendClientSignalParm(partyconn, ESCENE_FIELD, _MSG_StartTime, WaterClear1[2][Vol - 161] * 2);
			}
		}

		if (Sala <= 7)
		{
			GenerateMob(Sala + WATER_A_INITIAL, 0, 0);
			GenerateMob(Sala + WATER_A_INITIAL, 0, 0);
			//RebuildGenerator();
		}
		else if (Sala == 9)
		{
			int _rand = rand() % 10;

			if (_rand < 4)
				GenerateMob(WATER_A_INITIAL + 8, 0, 0);

			else if (_rand < 5)
				GenerateMob(WATER_A_INITIAL + 9, 0, 0);

			else if (_rand < 6)
				GenerateMob(WATER_A_INITIAL + 10, 0, 0);

			else
				GenerateMob(WATER_A_INITIAL + 11, 0, 0);
		}


		snprintf(temp, sizeof(temp), "useitem,water scroll A %d", Sala);
		ItemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);

		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));

		return;
	}
#pragma endregion


#pragma region ITENS QUEST
	if (item->sIndex == 4038) {
		if (pMob[conn].extra.ClassMaster != MORTAL)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Level_Limit2]);
			SendEtc(conn);
			SendCarry(conn);
			return;
		}

		int minlevel = pMob[conn].extra.ClassMaster == MORTAL ? 39 : 39;
		int maxlevel = pMob[conn].extra.ClassMaster == MORTAL ? 115 : 115;

		if (pMob[conn].MOB.CurrentScore.Level < minlevel || pMob[conn].MOB.CurrentScore.Level >= maxlevel)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Level_limit]);
			SendEtc(conn);
			SendCarry(conn);
			return;
		}

		/*if (amount > 1) {
			BASE_SetItemAmount(item, amount = 1);
			SendEtc(conn);
			SendCarry(conn);
		}
		else {
			memset(item, 0, sizeof(STRUCT_ITEM));
			SendCarry(conn);
		}

		pMob[conn].QuestFlag = 1;*/
				
		SendEtc(conn);
		SendCarry(conn);
		DoTeleport(conn, 2366 + rand() % 5 - 3, 2105 + rand() % 5 - 3);
	}
	if (item->sIndex == 4039) {
		if (pMob[conn].extra.ClassMaster != MORTAL)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Level_Limit2]);
			SendEtc(conn);
			SendCarry(conn);
			return;
		}

		int minlevel = pMob[conn].extra.ClassMaster == MORTAL ? 115 : 115;
		int maxlevel = pMob[conn].extra.ClassMaster == MORTAL ? 190 : 190;

		if (pMob[conn].MOB.CurrentScore.Level < minlevel || pMob[conn].MOB.CurrentScore.Level >= maxlevel)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Level_limit]);
			SendEtc(conn);
			SendCarry(conn);
			return;
		}

		/*if (amount > 1) {
			BASE_SetItemAmount(item, amount - 1);
			SendEtc(conn);
			SendCarry(conn);
		}
		else {
			memset(item, 0, sizeof(STRUCT_ITEM));
			SendCarry(conn);
		}

		pMob[conn].QuestFlag = 2;*/
		SendEtc(conn);
		SendCarry(conn);
		DoTeleport(conn, 2220 + rand() % 5 - 3, 1714 + rand() % 5 - 3);
	}
	if (item->sIndex == 4040) {
		if (pMob[conn].extra.ClassMaster != MORTAL)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Level_Limit2]);
			SendCarry(conn);
			return;
		}

		int minlevel = pMob[conn].extra.ClassMaster == MORTAL ? 190 : 190;
		int maxlevel = pMob[conn].extra.ClassMaster == MORTAL ? 265 : 265;

		if (pMob[conn].MOB.CurrentScore.Level < minlevel || pMob[conn].MOB.CurrentScore.Level >= maxlevel)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Level_limit]);
			SendCarry(conn);
			return;
		}
		/*
		if (amount > 1) {
			BASE_SetItemAmount(item, amount - 1);
			SendEtc(conn);
			SendCarry(conn);
		}
		else {
			memset(item, 0, sizeof(STRUCT_ITEM));
			SendCarry(conn);
		}
		
		pMob[conn].QuestFlag = 3; */
		
		SendEtc(conn);
		SendCarry(conn);
		DoTeleport(conn, 444 + rand() % 5 - 3, 3916 + rand() % 5 - 3);
	}
	if (item->sIndex == 4041) {
		if (pMob[conn].extra.ClassMaster != MORTAL)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Level_Limit2]);
			SendCarry(conn);
			return;
		}

		int minlevel = pMob[conn].extra.ClassMaster == MORTAL ? 265 : 265;
		int maxlevel = pMob[conn].extra.ClassMaster == MORTAL ? 320 : 320;

		if (pMob[conn].MOB.CurrentScore.Level < minlevel || pMob[conn].MOB.CurrentScore.Level >= maxlevel)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Level_limit]);
			SendCarry(conn);
			return;
		}

		/*if (amount > 1) {
			BASE_SetItemAmount(item, amount - 1);
			SendEtc(conn);
			SendCarry(conn);
		}
		else {
			memset(item, 0, sizeof(STRUCT_ITEM));
			SendCarry(conn);
		}

		pMob[conn].QuestFlag = 4;*/
	
		SendEtc(conn);
		SendCarry(conn);
		DoTeleport(conn, 668 + rand() % 5 - 3, 3768 + rand() % 5 - 3);
	}
	if (item->sIndex == 4042) {
		if (pMob[conn].extra.ClassMaster != MORTAL)
		{
			SendSay(conn, g_pMessageStringTable[_NN_Level_Limit2]);
			SendCarry(conn);
			return;
		}

		int minlevel = pMob[conn].extra.ClassMaster == MORTAL ? 320 : 320;
		int maxlevel = pMob[conn].extra.ClassMaster == MORTAL ? 350 : 350;

		if (pMob[conn].MOB.CurrentScore.Level < minlevel || pMob[conn].MOB.CurrentScore.Level >= maxlevel)
		{
			SendSay(conn, g_pMessageStringTable[_NN_Level_limit]);
			SendCarry(conn);
			return;
		}

		/*if (amount > 1) {
			BASE_SetItemAmount(item, amount - 1);
			SendEtc(conn);
			SendCarry(conn);
		}
		else {
			memset(item, 0, sizeof(STRUCT_ITEM));
			SendCarry(conn);
		}

		pMob[conn].QuestFlag = 5;*/
		
		SendEtc(conn);
		SendCarry(conn);
		DoTeleport(conn, 1286 + rand() % 5 - 3, 4036 + rand() % 5 - 3);
	}
#pragma endregion

#pragma region >> Poção Divina 7 15 30 Dias 
	if ((item->sIndex >= 3379 && item->sIndex <= 3381) || item->sIndex == 5709)
	{
		int divina = GetEmptyAffect(conn, 34);

		int div = 0;
		for (int i = 0; i < MAX_AFFECT; i++)
		{
			if (pMob[conn].Affect[i].Type == 34)
			{
				SendClientMessage(conn, g_pMessageStringTable[_NN_CantEatMore]);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}
		}

		if (divina == -1 || pMob[conn].Affect[divina].Type == 34)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_CantEatMore]);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}
		//time(&pMob[conn].extra.DivineEnd);
		time_t now;
		time(&now);

		int val = 0;

		if (item->sIndex == 3379)//7DD
		{
			val = 60 * 60 * 24 * 8;
			pMob[conn].extra.DivineEnd = val + now;
		}
		else  if (item->sIndex == 3380)//15D
		{
			val = 60 * 60 * 24 * 16;
			pMob[conn].extra.DivineEnd = val + now;
		}
		else if (item->sIndex == 3381)//30D
		{
			val = 60 * 60 * 24 * 31;
			pMob[conn].extra.DivineEnd = val + now;
		}
		else if (item->sIndex == 5709)//1d
		{
			val = 86400;
			pMob[conn].extra.DivineEnd = val + now;
		}


		int AffectIndex = 34;
		int Level = 1;

		pMob[conn].Affect[divina].Type = AffectIndex;
		pMob[conn].Affect[divina].Level = Level;
		pMob[conn].Affect[divina].Value = 2;
		pMob[conn].Affect[divina].Time = 2000000000;

		BASE_GetHpMp(&pMob[conn].MOB, &pMob[conn].extra);
		pMob[conn].GetCurrentScore(conn);
		SendScore(conn);
		SaveUser(conn, 0);

		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);
		else
		{
			memset(item, 0, sizeof(STRUCT_ITEM));
		}
		return;
	}
#pragma endregion
#pragma region Trans Javali 
	if (item->sIndex == 3418) // 316
	{
		int sAffect = GetEmptyAffect(conn, 33);

		if (sAffect == -1 || pMob[conn].Affect[sAffect].Type == 33)
		{
			SendMsgExp(conn, g_pMessageStringTable[_NN_CantEatMore], TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		pMob[conn].Affect[sAffect].Type = 33;
		pMob[conn].Affect[sAffect].Level = 1;
		pMob[conn].Affect[sAffect].Value = 1;
		pMob[conn].Affect[sAffect].Time = AFFECT_1H;

		pMob[conn].GetCurrentScore(conn);
		SendItem(conn, ITEM_PLACE_EQUIP, 0, &pMob[conn].MOB.Equip[0]);
		SendEquip(conn, 0);
		SendScore(conn);


		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));

		return;
	}
#pragma endregion
#pragma region Trans Lobo
	if (item->sIndex == 3419) // 317
	{
		int sAffect = GetEmptyAffect(conn, 33);

		if (sAffect == -1 || pMob[conn].Affect[sAffect].Type == 33)
		{
			SendMsgExp(conn, g_pMessageStringTable[_NN_CantEatMore], TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		pMob[conn].Affect[sAffect].Type = 33;
		pMob[conn].Affect[sAffect].Level = 1;
		pMob[conn].Affect[sAffect].Value = 2;
		pMob[conn].Affect[sAffect].Time = AFFECT_1H;

		pMob[conn].GetCurrentScore(conn);
		SendItem(conn, ITEM_PLACE_EQUIP, 0, &pMob[conn].MOB.Equip[0]);
		SendEquip(conn, 0);
		SendScore(conn);


		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));

		return;
	}
#pragma endregion
#pragma region Trans Golem
	if (item->sIndex == 3420) // 297
	{
		int sAffect = GetEmptyAffect(conn, 33);

		if (sAffect == -1 || pMob[conn].Affect[sAffect].Type == 33)
		{
			SendMsgExp(conn, g_pMessageStringTable[_NN_CantEatMore], TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		pMob[conn].Affect[sAffect].Type = 33;
		pMob[conn].Affect[sAffect].Level = 1;
		pMob[conn].Affect[sAffect].Value = 3;
		pMob[conn].Affect[sAffect].Time = AFFECT_1H;

		pMob[conn].GetCurrentScore(conn);
		SendItem(conn, ITEM_PLACE_EQUIP, 0, &pMob[conn].MOB.Equip[0]);
		SendEquip(conn, 0);
		SendScore(conn);


		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));

		return;
	}
#pragma endregion
#pragma region Trans Grem
	if (item->sIndex == 3421) // 202
	{
		int sAffect = GetEmptyAffect(conn, 33);

		if (sAffect == -1 || pMob[conn].Affect[sAffect].Type == 33)
		{
			SendMsgExp(conn, g_pMessageStringTable[_NN_CantEatMore], TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		pMob[conn].Affect[sAffect].Type = 33;
		pMob[conn].Affect[sAffect].Level = 1;
		pMob[conn].Affect[sAffect].Value = 4;
		pMob[conn].Affect[sAffect].Time = AFFECT_1H;

		pMob[conn].GetCurrentScore(conn);
		SendItem(conn, ITEM_PLACE_EQUIP, 0, &pMob[conn].MOB.Equip[0]);
		SendEquip(conn, 0);
		SendScore(conn);


		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));

		return;
	}
#pragma endregion
#pragma region Trans OrcA
	if (item->sIndex == 3422) // 209
	{
		int sAffect = GetEmptyAffect(conn, 33);

		if (sAffect == -1 || pMob[conn].Affect[sAffect].Type == 33)
		{
			SendMsgExp(conn, g_pMessageStringTable[_NN_CantEatMore], TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		pMob[conn].Affect[sAffect].Type = 33;
		pMob[conn].Affect[sAffect].Level = 1;
		pMob[conn].Affect[sAffect].Value = 5;
		pMob[conn].Affect[sAffect].Time = AFFECT_1H;

		pMob[conn].GetCurrentScore(conn);
		SendItem(conn, ITEM_PLACE_EQUIP, 0, &pMob[conn].MOB.Equip[0]);
		SendEquip(conn, 0);
		SendScore(conn);


		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));

		return;
	}
#pragma endregion
#pragma region Trans Troll
	if (item->sIndex == 3423) // 212
	{
		int sAffect = GetEmptyAffect(conn, 33);

		if (sAffect == -1 || pMob[conn].Affect[sAffect].Type == 33)
		{
			SendMsgExp(conn, g_pMessageStringTable[_NN_CantEatMore], TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		pMob[conn].Affect[sAffect].Type = 33;
		pMob[conn].Affect[sAffect].Level = 1;
		pMob[conn].Affect[sAffect].Value = 6;
		pMob[conn].Affect[sAffect].Time = AFFECT_1H;

		pMob[conn].GetCurrentScore(conn);
		SendItem(conn, ITEM_PLACE_EQUIP, 0, &pMob[conn].MOB.Equip[0]);
		SendEquip(conn, 0);
		SendScore(conn);


		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));

		return;
	}
#pragma endregion
#pragma region Trans Carbun
	if (item->sIndex == 3424) // 230
	{
		int sAffect = GetEmptyAffect(conn, 33);

		if (sAffect == -1 || pMob[conn].Affect[sAffect].Type == 33)
		{
			SendMsgExp(conn, g_pMessageStringTable[_NN_CantEatMore], TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		pMob[conn].Affect[sAffect].Type = 33;
		pMob[conn].Affect[sAffect].Level = 1;
		pMob[conn].Affect[sAffect].Value = 7;
		pMob[conn].Affect[sAffect].Time = AFFECT_1H;

		pMob[conn].GetCurrentScore(conn);
		SendItem(conn, ITEM_PLACE_EQUIP, 0, &pMob[conn].MOB.Equip[0]);
		SendEquip(conn, 0);
		SendScore(conn);


		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));

		return;
	}
#pragma endregion
#pragma region Trans Zumbi
	if (item->sIndex == 3425) // 228
	{
		int sAffect = GetEmptyAffect(conn, 33);

		if (sAffect == -1 || pMob[conn].Affect[sAffect].Type == 33)
		{
			SendMsgExp(conn, g_pMessageStringTable[_NN_CantEatMore], TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		pMob[conn].Affect[sAffect].Type = 33;
		pMob[conn].Affect[sAffect].Level = 1;
		pMob[conn].Affect[sAffect].Value = 8;
		pMob[conn].Affect[sAffect].Time = 4;

		pMob[conn].GetCurrentScore(conn);
		SendItem(conn, ITEM_PLACE_EQUIP, 0, &pMob[conn].MOB.Equip[0]);
		SendEquip(conn, 0);
		SendScore(conn);


		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));

		return;
	}
#pragma endregion
#pragma region Poção Saúde
	if (Vol == 58)
	{
		int sAffect = GetEmptyAffect(conn, 35);

		if (sAffect == -1)
		{
			SendMsgExp(conn, g_pMessageStringTable[_NN_CantEatMore], TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (item->sIndex == 3364) // 7 Dias
		{
			pMob[conn].Affect[sAffect].Type = 35;
			pMob[conn].Affect[sAffect].Level = 1;
			pMob[conn].Affect[sAffect].Value = 0;
			pMob[conn].Affect[sAffect].Time = AFFECT_1D * 7;

			BASE_GetHpMp(&pMob[conn].MOB, &pMob[conn].extra);
			pMob[conn].GetCurrentScore(conn);

			SendScore(conn);


			if (amount > 1)
				BASE_SetItemAmount(item, amount - 1);

			else
				memset(item, 0, sizeof(STRUCT_ITEM));

			return;
		}
		else if (item->sIndex == 3365) // 15 Dias
		{
			pMob[conn].Affect[sAffect].Type = 35;
			pMob[conn].Affect[sAffect].Level = 1;
			pMob[conn].Affect[sAffect].Value = 0;
			pMob[conn].Affect[sAffect].Time = AFFECT_1D * 15;

			BASE_GetHpMp(&pMob[conn].MOB, &pMob[conn].extra);
			pMob[conn].GetCurrentScore(conn);

			SendScore(conn);


			if (amount > 1)
				BASE_SetItemAmount(item, amount - 1);

			else
				memset(item, 0, sizeof(STRUCT_ITEM));

			return;
		}
		else if (item->sIndex == 3366) // 30 Dias
		{
			pMob[conn].Affect[sAffect].Type = 35;
			pMob[conn].Affect[sAffect].Level = 1;
			pMob[conn].Affect[sAffect].Value = 0;
			pMob[conn].Affect[sAffect].Time = AFFECT_1D * 30;

			BASE_GetHpMp(&pMob[conn].MOB, &pMob[conn].extra);
			pMob[conn].GetCurrentScore(conn);

			SendScore(conn);


			if (amount > 1)
				BASE_SetItemAmount(item, amount - 1);

			else
				memset(item, 0, sizeof(STRUCT_ITEM));

			return;
		}
	}
#pragma endregion
#pragma region Baú de XP
	if (Vol == 198)
	{
		int sAffect = GetEmptyAffect(conn, 39);

		if (sAffect == -1)
		{
			SendMsgExp(conn, g_pMessageStringTable[_NN_CantEatMore], TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		pMob[conn].Affect[sAffect].Type = 39;
		pMob[conn].Affect[sAffect].Level = 0;
		pMob[conn].Affect[sAffect].Value = 0;
		pMob[conn].Affect[sAffect].Time += AFFECT_1H * 2;

		if (pMob[conn].Affect[sAffect].Time >= 324000)
			pMob[conn].Affect[sAffect].Time = 324000;

		pMob[conn].GetCurrentScore(conn);
		SendScore(conn);
		SaveUser(conn, 0);

		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));

		return;
	}
#pragma endregion
#pragma region Removedor de Pergaminho da Transformação
	if (item->sIndex == 3335)
	{
		int trans = pMob[conn].MOB.Equip[0].sIndex == 316 || pMob[conn].MOB.Equip[0].sIndex == 317 || pMob[conn].MOB.Equip[0].sIndex == 297 ||
			pMob[conn].MOB.Equip[0].sIndex == 202 || pMob[conn].MOB.Equip[0].sIndex == 297 || pMob[conn].MOB.Equip[0].sIndex == 209 ||
			pMob[conn].MOB.Equip[0].sIndex == 212 || pMob[conn].MOB.Equip[0].sIndex == 230 || pMob[conn].MOB.Equip[0].sIndex == 228 ? 1 : 0;

		if (trans)
		{
			for (int i = 0; i < MAX_AFFECT; i++)
			{
				if (pMob[conn].Affect[i].Type != 33)
					continue;

				pMob[conn].Affect[i].Type = 0;
				pMob[conn].Affect[i].Value = 0;
				pMob[conn].Affect[i].Level = 0;
				pMob[conn].Affect[i].Time = 0;

				break;
			}

			if ((pMob[conn].MOB.Equip[0].sIndex == 316 || pMob[conn].MOB.Equip[0].sIndex == 317 || pMob[conn].MOB.Equip[0].sIndex == 297 ||
				pMob[conn].MOB.Equip[0].sIndex == 202 || pMob[conn].MOB.Equip[0].sIndex == 297 || pMob[conn].MOB.Equip[0].sIndex == 209 ||
				pMob[conn].MOB.Equip[0].sIndex == 212 || pMob[conn].MOB.Equip[0].sIndex == 230 || pMob[conn].MOB.Equip[0].sIndex == 228))
				pMob[conn].MOB.Equip[0].sIndex = pMob[conn].extra.ClassMaster == MORTAL ? pMob[conn].extra.MortalFace : pMob[conn].extra.MortalFace + 5 + pMob[conn].MOB.Class;

			SendEquip(conn, 0);
			SendScore(conn);
			SendEtc(conn);

			if (amount > 1)
				BASE_SetItemAmount(item, amount - 1);

			else
				memset(item, 0, sizeof(STRUCT_ITEM));



			return;
		}
		else
		{
			SendMsgExp(conn, "Você não está transformado!", TNColor::Default, false);

			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		return;
	}
#pragma endregion

#pragma region >>Poção revigorante
	if (item->sIndex == 5548)
	{
		int sAffect = GetEmptyAffect(conn, 51);

		if (sAffect == -1 || pMob[conn].Affect[sAffect].Type == 51)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_CantEatMore]);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		pMob[conn].Affect[sAffect].Type = 51;
		pMob[conn].Affect[sAffect].Level = 2;
		pMob[conn].Affect[sAffect].Value = 0;
		pMob[conn].Affect[sAffect].Time = AFFECT_1D * 7;

		pMob[conn].GetCurrentScore(conn);
		SendScore(conn);
		SaveUser(conn, 0);

		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));

		return;
	}
#pragma endregion
#pragma region Frango Assado
	if (Vol == 63)
	{
		int sAffect = GetEmptyAffect(conn, 30);

		if (sAffect == -1 || (pMob[conn].Affect[sAffect].Value != 2000 && pMob[conn].Affect[sAffect].Time == 30))
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_CantEatMore]);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (pMob[conn].Affect[sAffect].Time >= AFFECT_1H * 23) {
			SendClientMessage(conn, g_pMessageStringTable[_NN_CantEatMore]);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		pMob[conn].Affect[sAffect].Type = 30;
		pMob[conn].Affect[sAffect].Level = 2000;
		pMob[conn].Affect[sAffect].Value = 0;
		pMob[conn].Affect[sAffect].Time += AFFECT_1H * 4;		

		pMob[conn].GetCurrentScore(conn);
		SendScore(conn);

		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));

		return;
	}
#pragma endregion

#pragma region Entrada Cassino // Passe Evento
	if (Vol == 178)
	{
		if (pUser[conn].Keys[49] == 1) {
			SendClientMessage(conn, "Passe do Evento já está ativo");
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		SendEmotion(conn, 100, rand() % 5);
		SendEmotion(conn, 100, rand() % 5);
		SendEmotion(conn, 100, rand() % 5);

		pUser[conn].Keys[49] = 1;
		SaveUser(conn, 0);

		STRUCT_ITEM Item;
		memset(&Item, 0, sizeof(STRUCT_ITEM));
				
		Item.sIndex = 4104;

		PutItem(conn, &Item);
		SendClientMessage(conn, "Passe do Evento Ativado!");
		ItemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, "useitem,passe evento used");


		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));


		return;
	}
#pragma endregion
#pragma region Chocolate do Amor
	if (Vol == 204)
	{
		SetAffect(conn, 43, 320, 320);
		SetAffect(conn, 44, 320, 320);
		SetAffect(conn, 45, 320, 320);
		SetAffect(conn, 41, 320, 320);
		pMob[conn].GetCurrentScore(conn);
		SendScore(conn);

		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));

		return;
	}
#pragma endregion
#pragma region Itens de quests
	if (Vol == 191)
	{
		if (pMob[conn].extra.ClassMaster != MORTAL)
		{
			SendMsgExp(conn, g_pMessageStringTable[_NN_Level_Limit2], TNColor::Red, false);

			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}
		int thisQuest = item->sIndex - 4117;

		int minlevel = pMob[conn].extra.ClassMaster == MORTAL ? CReadFiles::QuestLevel[thisQuest][0] : CReadFiles::QuestLevel[thisQuest][2];
		int maxlevel = pMob[conn].extra.ClassMaster == MORTAL ? CReadFiles::QuestLevel[thisQuest][1] : CReadFiles::QuestLevel[thisQuest][3];

		if (pMob[conn].MOB.CurrentScore.Level < minlevel || pMob[conn].MOB.CurrentScore.Level >= maxlevel)
		{
			SendMsgExp(conn, g_pMessageStringTable[_NN_Level_limit], TNColor::Red, false);

			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		struct tm when;
		time_t now;
		time(&now);
		when = *localtime(&now);

		int QuestExp = pMob[conn].extra.ClassMaster == MORTAL ? CReadFiles::QuestExp[thisQuest][0] : CReadFiles::QuestExp[thisQuest][1];
		int QuestExpParty = QuestExp / 10;

		pMob[conn].MOB.Coin += CReadFiles::QuestCoin[thisQuest];
		pMob[conn].MOB.Exp += QuestExp;

#pragma region Log de Experiência diário
		if (when.tm_yday != pMob[conn].extra.DayLog.YearDay)
			pMob[conn].extra.DayLog.Exp = 0;

		pMob[conn].extra.DayLog.YearDay = when.tm_yday;
		pMob[conn].extra.DayLog.Exp += QuestExp;
#pragma endregion

		if (pMob[conn].MOB.Coin > 2000000000)
			pMob[conn].MOB.Coin = 2000000000;

		
		snprintf(temp, sizeof(temp), g_pMessageStringTable[_NS_GETEXP], pMob[conn].extra.ClassMaster == MORTAL ? CReadFiles::QuestExp[thisQuest][0] : CReadFiles::QuestExp[thisQuest][1]);
		SendMsgExp(conn, temp, TNColor::Speak, false);

		//SendEmotion(conn, 14, 3);

		if (pMob[conn].CheckGetLevel() == 4)
		{
			SendMsgExp(conn, g_pMessageStringTable[_NN_Level_Up], TNColor::Speak, false);

			/*if (pMob[conn].extra.ClassMaster == MORTAL) {
				DoItemLevel(conn);
				
			}*/

			int PKPoint = GetPKPoint(conn) + 5;
			SetPKPoint(conn, PKPoint);
			SendScore(conn);
			SendEtc(conn);
			doRanking(conn);
			MSG_CreateMob sCreateMob;
			GetCreateMob(conn, &sCreateMob);
			GridMulticast(pMob[conn].TargetX, pMob[conn].TargetY, (MSG_STANDARD*)&sCreateMob, 0);
		}

		SendEtc(conn);

		int partyleader = pMob[conn].Leader;

		if (partyleader <= 0)
			partyleader = conn;

		if (partyleader >= MAX_USER)
			partyleader = conn;

		if (partyleader != conn && (pMob[partyleader].extra.ClassMaster == MORTAL)
			&& pMob[partyleader].MOB.CurrentScore.Level < 350)
		{
			pMob[partyleader].MOB.Exp += QuestExpParty;

			//SendMsgExp(partyleader, temp, TNColor::Default, strFmt(g_pMessageStringTable[_NS_GETEXP], false));

#pragma region Log de Experiência diário
			if (when.tm_yday != pMob[partyleader].extra.DayLog.YearDay)
				pMob[partyleader].extra.DayLog.Exp = 0;

			pMob[partyleader].extra.DayLog.YearDay = when.tm_yday;
			pMob[partyleader].extra.DayLog.Exp += QuestExpParty;
#pragma endregion

			//SendEmotion(partyleader, 14, 3);

			if (pMob[partyleader].CheckGetLevel() == 4)
			{
				/*if (pMob[partyleader].extra.ClassMaster == MORTAL) {
					DoItemLevel(partyleader);
					
				}*/

				SendMsgExp(conn, g_pMessageStringTable[_NN_Level_Up], TNColor::Default, false);

				int PKPoint = GetPKPoint(partyleader) + 5;
				SetPKPoint(partyleader, PKPoint);
				SendScore(partyleader);
				doRanking(partyleader);
				SendEtc(partyleader);
				MSG_CreateMob sCreateMob;
				GetCreateMob(partyleader, &sCreateMob);
				GridMulticast(pMob[partyleader].TargetX, pMob[partyleader].TargetY, (MSG_STANDARD*)&sCreateMob, 0);

			}
			SendEtc(partyleader);
		}

		for (int i = 0; i < MAX_PARTY; i++)
		{
			int partymember = pMob[partyleader].PartyList[i];

			if (partymember <= 0 || partymember >= MAX_USER)
				continue;

			if (pUser[partymember].Mode != USER_PLAY || partymember == conn)
				continue;

			if (partymember != conn && (pMob[partymember].extra.ClassMaster == MORTAL)
				&& pMob[partymember].MOB.CurrentScore.Level < 350)
			{
				pMob[partymember].MOB.Exp += QuestExpParty;

#pragma region Log de Experiência diário
				if (when.tm_yday != pMob[partymember].extra.DayLog.YearDay)
					pMob[partymember].extra.DayLog.Exp = 0;

				pMob[partymember].extra.DayLog.YearDay = when.tm_yday;
				pMob[partymember].extra.DayLog.Exp += QuestExpParty;
#pragma endregion
				SendMsgExp(partymember, strFmt(g_pMessageStringTable[_NS_GETEXP], QuestExpParty), TNColor::Default, false);

				//SendEmotion(partymember, 14, 3);

				if (pMob[partymember].CheckGetLevel() == 4)
				{
					/*if (pMob[partymember].extra.ClassMaster == MORTAL) {
						DoItemLevel(partymember);
						
					}*/

					SendMsgExp(conn, g_pMessageStringTable[_NN_Level_Up], TNColor::Default, false);

					int PKPoint = GetPKPoint(partyleader) + 5;
					SetPKPoint(partymember, PKPoint);
					SendScore(partymember);
					SendEtc(partymember);
					doRanking(partymember);
					MSG_CreateMob sCreateMob;
					GetCreateMob(partymember, &sCreateMob);
					GridMulticast(pMob[partymember].TargetX, pMob[partymember].TargetY, (MSG_STANDARD*)&sCreateMob, 0);

				}

				SendEtc(partymember);
			}
		}
		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));
		return;
	}
#pragma endregion
#pragma region Molar do Gargula
	if (Vol == 194)
	{
		if (pMob[conn].extra.ClassMaster != MORTAL)
		{
			SendMsgExp(conn, g_pMessageStringTable[_NN_Level_Limit2], TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (pMob[conn].MOB.CurrentScore.Level < 200 || pMob[conn].MOB.CurrentScore.Level >= 256)
		{
			SendMsgExp(conn, g_pMessageStringTable[_NN_Level_limit], TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (pMob[conn].extra.QuestInfo.Mortal.MolarGargula)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Youve_Done_It_Already]);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		for (int i = 1; i < 6; i++)
		{
			if (pMob[conn].MOB.Equip[i].sIndex == 0)
				continue;

			int sanc = BASE_GetItemSanc(&pMob[conn].MOB.Equip[i]);

			if (sanc < 6)
			{
				BASE_SetItemSanc(&pMob[conn].MOB.Equip[i], 6, 0);
				SendItem(conn, ITEM_PLACE_EQUIP, i, &pMob[conn].MOB.Equip[i]);
			}
		}
		pMob[conn].extra.QuestInfo.Mortal.MolarGargula = 1;
		pMob[conn].GetCurrentScore(conn);
		SaveUser(conn, 0);


		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));

		return;
	}
#pragma endregion
#pragma region Pesadelo N
	if (Vol == 173)
	{
		int TargetX = pMob[conn].TargetX;
		int TargetY = pMob[conn].TargetY;

		if ((TargetX / 128) != 19 || (TargetY / 128) != 15)
		{
			SendMsgExp(conn, g_pMessageStringTable[_NN_Cant_Use_That_Here], TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (pMob[conn].Leader != -1 && pMob[conn].Leader)
		{
			SendMsgExp(conn, g_pMessageStringTable[_NN_Party_Leader_Only], TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}
		if ((pMob[conn].extra.ClassMaster == CELESTIAL || pMob[conn].extra.ClassMaster == CELESTIALCS || pMob[conn].extra.ClassMaster == SCELESTIAL) && pMob[conn].MOB.CurrentScore.Level >= 180)
		{
			SendItem(conn, m->SourType, m->SourPos, item);

			return;
		}

		struct tm when;
		time_t now;
		time(&now);
		when = *localtime(&now);

		if (when.tm_min >= 4 && when.tm_min <= 19 || when.tm_min >= 24 && when.tm_min <= 39
			|| when.tm_min >= 44 && when.tm_min <= 59)
		{
			SendItem(conn, m->SourType, m->SourPos, item);
			SendClientMessage(conn, "Espere o tempo correto.");
			return;
		}

		int isParty = item->sIndex == 3324 ? 1 : 0;

		if (isParty == 0)
			goto lbl_n_noparty;

		if (PartyPesa[0] >= maxNightmare)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Night_Limited]);
			SendItem(conn, m->SourType, m->SourPos, item);

			return;
		}
		PartyPesa[0]++;

	lbl_n_noparty:
		int NigthTime = 240;

		if (when.tm_min >= 20 && when.tm_min <= 23)
			NigthTime -= ((when.tm_min - 20) * 60) + when.tm_sec;

		else if (when.tm_min >= 40 && when.tm_min <= 43)
			NigthTime -= ((when.tm_min - 40) * 60) + when.tm_sec;

		else if (when.tm_min >= 0 && when.tm_min <= 3)
			NigthTime -= (when.tm_min * 60) + when.tm_sec;


		DoTeleport(conn, PesaNPosStandard[0][0], PesaNPosStandard[0][1]);
		SendClientSignalParm(conn, ESCENE_FIELD, _MSG_StartTime, NigthTime);

		//Pesa N NPC
		for (int w = PESANPC_N_INITIAL; w <= PESANPC_N_END; w++)
			GenerateMob(w, 0, 0);

		for (int i = 0; i < MAX_PARTY && isParty == 1; i++)
		{
			int partyconn = pMob[conn].PartyList[i];

			if ((pMob[partyconn].extra.ClassMaster == CELESTIAL
				|| pMob[partyconn].extra.ClassMaster == CELESTIALCS
				|| pMob[partyconn].extra.ClassMaster == SCELESTIAL)
				&& pMob[partyconn].MOB.CurrentScore.Level >= 180)
				continue;

			if (partyconn > 0 && partyconn < MAX_USER && partyconn != conn && pUser[partyconn].Mode == USER_PLAY)
			{
				DoTeleport(partyconn, PesaNPosStandard[i][0], PesaNPosStandard[i][1]);
				SendClientSignalParm(partyconn, ESCENE_FIELD, _MSG_StartTime, NigthTime);
			}
		}

		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));

		return;
	}
#pragma endregion
#pragma region Pesadelo M
	if (Vol == 174)
	{
		int TargetX = pMob[conn].TargetX;
		int TargetY = pMob[conn].TargetY;

		if ((TargetX / 128) != 16 || (TargetY / 128) != 16)
		{
			SendMsgExp(conn, g_pMessageStringTable[_NN_Cant_Use_That_Here], TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (pMob[conn].Leader != -1 && pMob[conn].Leader)
		{
			SendMsgExp(conn, g_pMessageStringTable[_NN_Party_Leader_Only], TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}
		if ((pMob[conn].extra.ClassMaster == CELESTIAL || pMob[conn].extra.ClassMaster == CELESTIALCS || pMob[conn].extra.ClassMaster == SCELESTIAL) && pMob[conn].MOB.CurrentScore.Level >= 180)
		{
			SendItem(conn, m->SourType, m->SourPos, item);

			return;
		}

		struct tm when;
		time_t now;
		time(&now);
		when = *localtime(&now);

		if (when.tm_min >= 0 && when.tm_min <= 4 || when.tm_min >= 9 && when.tm_min <= 24
			|| when.tm_min >= 29 && when.tm_min <= 44 || when.tm_min >= 49 && when.tm_min <= 59)
		{
			SendItem(conn, m->SourType, m->SourPos, item);
			SendClientMessage(conn, "Espere o tempo correto.");
			return;
		}

		int isParty = item->sIndex == 3325 ? 1 : 0;

		if (isParty == 0)
			goto lbl_m_noparty;

		if (PartyPesa[1] >= maxNightmare)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Night_Limited]);
			SendItem(conn, m->SourType, m->SourPos, item);

			return;
		}
		PartyPesa[1]++;

	lbl_m_noparty:
		int NigthTime = 240;

		if (when.tm_min >= 5 && when.tm_min <= 8)
			NigthTime -= ((when.tm_min - 5) * 60) + when.tm_sec;

		else if (when.tm_min >= 25 && when.tm_min <= 28)
			NigthTime -= ((when.tm_min - 25) * 60) + when.tm_sec;

		else if (when.tm_min >= 45 && when.tm_min <= 48)
			NigthTime -= ((when.tm_min - 45) * 60) + when.tm_sec;

		if ((pMob[conn].MOB.SPX / 128) == 8 && (pMob[conn].MOB.SPY / 128) == 2)
			DoTeleport(conn, pMob[conn].MOB.SPX, pMob[conn].MOB.SPY);
		else
			DoTeleport(conn, PesaMPosStandard[0][0], PesaMPosStandard[0][1]);

		SendClientSignalParm(conn, ESCENE_FIELD, _MSG_StartTime, NigthTime);

		//Pesa M NPC
		for (int w = PESANPC_M_INITIAL; w <= PESANPC_M_END; w++)
			GenerateMob(w, 0, 0);

		for (int i = 0; i < MAX_PARTY && isParty == 1; i++)
		{
			int partyconn = pMob[conn].PartyList[i];

			if ((pMob[partyconn].extra.ClassMaster == CELESTIAL || pMob[partyconn].extra.ClassMaster == CELESTIALCS || pMob[partyconn].extra.ClassMaster == SCELESTIAL) && pMob[partyconn].MOB.CurrentScore.Level >= 180)
				continue;

			if (partyconn > 0 && partyconn < MAX_USER && partyconn != conn && pUser[partyconn].Mode == USER_PLAY)
			{
				if ((pMob[partyconn].MOB.SPX / 128) == 8 && (pMob[partyconn].MOB.SPY / 128) == 2)
					DoTeleport(partyconn, pMob[partyconn].MOB.SPX, pMob[partyconn].MOB.SPY);
				else
					DoTeleport(partyconn, PesaMPosStandard[i][0], PesaMPosStandard[i][1]);

				SendClientSignalParm(partyconn, ESCENE_FIELD, _MSG_StartTime, NigthTime);
			}
		}

		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));

		return;
	}
#pragma endregion
#pragma region Pesadelo A
	if (Vol == 175)
	{
		int TargetX = pMob[conn].TargetX;
		int TargetY = pMob[conn].TargetY;

		struct tm when;
		time_t now;
		time(&now);
		when = *localtime(&now);

		if (when.tm_min >= 0 && when.tm_min <= 9 || when.tm_min >= 14 && when.tm_min <= 29
			|| when.tm_min >= 34 && when.tm_min <= 49 || when.tm_min >= 54 && when.tm_min <= 60)
		{
			SendItem(conn, m->SourType, m->SourPos, item);
			SendClientMessage(conn, "Espere o tempo correto.");
			return;
		}

		if ((TargetX / 128) != 19 || (TargetY / 128) != 13)
		{
			SendMsgExp(conn, g_pMessageStringTable[_NN_Cant_Use_That_Here], TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (pMob[conn].Leader != -1 && pMob[conn].Leader)
		{
			SendMsgExp(conn, g_pMessageStringTable[_NN_Party_Leader_Only], TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		int isParty = item->sIndex == 3326 ? 1 : 0;

		if (isParty == 0)
			goto lbl_a_noparty;

		if ((pMob[conn].extra.ClassMaster == CELESTIAL || pMob[conn].extra.ClassMaster == CELESTIALCS || pMob[conn].extra.ClassMaster == SCELESTIAL) && pMob[conn].MOB.CurrentScore.Level >= 239)
		{
			SendItem(conn, m->SourType, m->SourPos, item);

			return;
		}

		if ((pMob[conn].extra.ClassMaster == CELESTIAL || pMob[conn].extra.ClassMaster == SCELESTIAL || pMob[conn].extra.ClassMaster == CELESTIALCS) && pMob[conn].extra.NT <= 0)
		{
			SendItem(conn, m->SourType, m->SourPos, item);

			return;
		}

		if (PartyPesa[2] >= maxNightmare)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Night_Limited]);
			SendItem(conn, m->SourType, m->SourPos, item);

			return;
		}
		PartyPesa[2]++;

	lbl_a_noparty:
		int NigthTime = 240;

		if (when.tm_min >= 10 && when.tm_min <= 13)
			NigthTime -= ((when.tm_min - 10) * 60) + when.tm_sec;

		else if (when.tm_min >= 30 && when.tm_min <= 33)
			NigthTime -= ((when.tm_min - 30) * 60) + when.tm_sec;

		else if (when.tm_min >= 50 && when.tm_min <= 53)
			NigthTime -= ((when.tm_min - 50) * 60) + when.tm_sec;


		if ((pMob[conn].extra.ClassMaster == CELESTIAL || pMob[conn].extra.ClassMaster == SCELESTIAL || pMob[conn].extra.ClassMaster == CELESTIALCS))
			pMob[conn].extra.NT--;

		if ((pMob[conn].MOB.SPX / 128) == 9 && (pMob[conn].MOB.SPY / 128) == 1)
			DoTeleport(conn, pMob[conn].MOB.SPX + rand() % 1, pMob[conn].MOB.SPY + rand() % 1);

		else
			DoTeleport(conn, PesaAPosStandard[0][0] + rand() % 1, PesaAPosStandard[0][1] + rand() % 1);

		SendClientSignalParm(conn, ESCENE_FIELD, _MSG_StartTime, NigthTime);

		//Pesa A NPC
		for (int w = PESANPC_A_INITIAL; w <= PESANPC_A_END; w++)
			GenerateMob(w, 0, 0);

		for (int i = 0; i < MAX_PARTY && isParty == 1; i++)
		{
			int partyconn = pMob[conn].PartyList[i];

			if ((pMob[partyconn].extra.ClassMaster == CELESTIAL || pMob[partyconn].extra.ClassMaster == CELESTIALCS || pMob[partyconn].extra.ClassMaster == SCELESTIAL) && pMob[partyconn].MOB.CurrentScore.Level >= 239)
				continue;

			if (partyconn > 0 && partyconn < MAX_USER && partyconn != conn && pUser[partyconn].Mode == USER_PLAY)
			{
				if ((pMob[partyconn].extra.ClassMaster == CELESTIAL || pMob[partyconn].extra.ClassMaster == SCELESTIAL || pMob[partyconn].extra.ClassMaster == CELESTIALCS))
				{
					if (pMob[partyconn].extra.NT <= 0)
						continue;

					pMob[partyconn].extra.NT--;
				}

				if ((pMob[partyconn].MOB.SPX / 128) == 9 && (pMob[partyconn].MOB.SPY / 128) == 1)
					DoTeleport(partyconn, pMob[partyconn].MOB.SPX + rand() % 1, pMob[partyconn].MOB.SPY + rand() % 1);
				else
					DoTeleport(partyconn, PesaAPosStandard[i][0] + rand() % 1, PesaAPosStandard[i][1] + rand() % 1);

				SendClientSignalParm(partyconn, ESCENE_FIELD, _MSG_StartTime, NigthTime);
			}
		}

		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));

		return;
	}
#pragma endregion
#pragma region Portão Infernal N/M (Ind/Grupo)
	if (Vol == 176)
	{
		int TargetX = pMob[conn].TargetX;
		int TargetY = pMob[conn].TargetY;

		struct tm when;
		time_t now;
		time(&now);
		when = *localtime(&now);

		if (when.tm_min >= 4 && when.tm_min <= 29 || when.tm_min >= 34 && when.tm_min <= 59)
		{
			SendItem(conn, m->SourType, m->SourPos, item);
			SendClientMessage(conn, "Espere o tempo correto.");
			return;
		}

		if (pMob[conn].Leader != -1 && pMob[conn].Leader)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Party_Leader_Only]);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		int isParty = item->sIndex == 3329 ? 1 : 0;

		if (isParty == 0)
			goto lbl_pt_noparty;

		/*if (PartyPortao[0] >= 1000)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Night_Limited]);
			SendItem(conn, m->SourType, m->SourPos, item);

			return;
		}
		PartyPortao[0]++;*/

	lbl_pt_noparty:
		int PortaoTime = 240;

		if (when.tm_min >= 0 && when.tm_min <= 3)
			PortaoTime -= ((when.tm_min - 0) * 60) + when.tm_sec;

		else if (when.tm_min >= 30 && when.tm_min <= 33)
			PortaoTime -= ((when.tm_min - 30) * 60) + when.tm_sec;

		if ((pMob[conn].MOB.SPX / 128) == 13 && (pMob[conn].MOB.SPY / 128) == 28)
			DoTeleport(conn, pMob[conn].MOB.SPX + rand() % 1, pMob[conn].MOB.SPY + rand() % 1);
		else
			DoTeleport(conn, 1684, 3676);

		SendClientSignalParm(conn, ESCENE_FIELD, _MSG_StartTime, PortaoTime);

		for (int i = 0; i < MAX_PARTY && isParty == 1; i++)
		{
			int partyconn = pMob[conn].PartyList[i];

			if (partyconn > 0 && partyconn < MAX_USER && partyconn != conn && pUser[partyconn].Mode == USER_PLAY)
			{
				if ((pMob[partyconn].MOB.SPX / 128) == 13 && (pMob[partyconn].MOB.SPY / 128) == 28)
					DoTeleport(partyconn, pMob[partyconn].MOB.SPX + rand() % 1, pMob[partyconn].MOB.SPY + rand() % 1);
				else
					DoTeleport(partyconn, 1684, 3676);

				SendClientSignalParm(partyconn, ESCENE_FIELD, _MSG_StartTime, PortaoTime);
			}
		}

		//Portão Infernal
		for (int i = PI_INITIAL1; i <= PI_END1; i++)
			GenerateMob(i, 0, 0);


		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));

		return;
	}
#pragma endregion
#pragma region Carta de Duelo N.M.A
	if (Vol == 20)
	{

		int TargetX = pMob[conn].TargetX;
		int TargetY = pMob[conn].TargetY;


		if ((TargetX / 4) != 261 || (TargetY / 4) != 422)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Only_at_tor_alter]);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (pMob[conn].Leader != -1 && pMob[conn].Leader)
		{
			SendMsgExp(conn, g_pMessageStringTable[_NN_Party_Leader_Only], TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (pMob[conn].MOB.Coin < 15000000) {
			SendClientMessage(conn, "Você precisa pagar 15kk para entrar nessa quest");
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		char UserName[128];

		int UserArea = GetUserInArea(774, 3593, 892, 3702, UserName);

		if (UserArea >= 1)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Someone_is_on_quest]);
			SendItem(conn, m->SourType, m->SourPos, item);

			return;
		}

		CartaTime = 60;
		CartaSala = 1;

		DoTeleport(conn, CartaPos[0][0], CartaPos[0][1]);
		pMob[conn].MOB.Coin -= 15000000;
		SendClientSignalParm(conn, ESCENE_FIELD, _MSG_StartTime, CartaTime * 2);

		for (int i = 0; i < MAX_PARTY; i++)
		{
			int partyconn = pMob[conn].PartyList[i];

			if (partyconn > 0 && partyconn < MAX_USER && partyconn != conn && pUser[partyconn].Mode == USER_PLAY)
			{
				DoTeleport(partyconn, CartaPos[0][0], CartaPos[0][1]);
				SendClientSignalParm(partyconn, ESCENE_FIELD, _MSG_StartTime, CartaTime * 2);
			}
		}

		for (int xx = 767; xx < 897; xx++)
		{
			for (int yy = 3582; yy < 3712; yy++)
			{
				int tmob = pMobGrid[yy][xx];

				if (tmob < MAX_USER)
					continue;

				DeleteMob(tmob, 3);
			}
		}

		int cartaindex = item->sIndex - 3171;

		if (cartaindex == 1)
		{//Carta N
			for (int i = SECRET_ROOM_N_INITIAL; i <= SECRET_ROOM_N_END; i++)
			{
				GenerateMob(i, 0, 0);
				GenerateMob(i, 0, 0);
			}

			GenerateMob(SECRET_ROOM_N_BOSS_INITIAL + rand() % 1, 0, 0);
		}

		else if (cartaindex == 0)
		{//Carta M
			for (int i = SECRET_ROOM_M_INITIAL; i <= SECRET_ROOM_M_END; i++)
			{
				GenerateMob(i, 0, 0);
				GenerateMob(i, 0, 0);
			}

			GenerateMob(SECRET_ROOM_M_BOSS_INITIAL + rand() % 1, 0, 0);
		}
		else
		{//Carta A
			for (int i = SECRET_ROOM_A_INITIAL; i <= SECRET_ROOM_A_END; i++)
			{
				GenerateMob(i, 0, 0);
				GenerateMob(i, 0, 0);
			}

			GenerateMob(SECRET_ROOM_A_BOSS_INITIAL + rand() % 1, 0, 0);
		}
		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));


		return;
	}
#pragma endregion
#pragma region Pedidos de caça
	if (Vol == 195)
	{
		if (item->sIndex < 3432 || item->sIndex > 3437)
			return;

		if (m->WarpID <= 0 || m->WarpID > 10)
			return;

		DoTeleport(conn, HuntingScrolls[item->sIndex - 3432][m->WarpID - 1][0], HuntingScrolls[item->sIndex - 3432][m->WarpID - 1][1]);

		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));

		return;
	}
#pragma endregion
#pragma region >> Retornar Cavalo
	if (item->sIndex == 3453)
	{
		int mountIndex = pMob[conn].MOB.Equip[14].sIndex;

		if (mountIndex < 2330 || mountIndex >= 2390 || mountIndex < 3091 && mountIndex >= 3139)
		{
			SendClientMessage(conn, "?Sua montaria não está ferida.?");
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (pMob[conn].MOB.Equip[14].stEffect[0].sValue > 0)
		{
			SendClientMessage(conn, "?Sua montaria não está ferida.?");
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		int price = g_pItemList[mountIndex].Price;

		if (pMob[conn].MOB.Coin < price)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Not_Enough_Money]);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (price < 0 || price > 2000000000)
			return;

		pMob[conn].MOB.Coin -= price;

		int vit = BASE_GetItemAbility(&pMob[conn].MOB.Equip[14], 79);

		vit -= rand() % 3;

		if (vit > 0)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Cured]);
			pMob[conn].MOB.Equip[14].stEffect[1].cValue = vit;
			pMob[conn].MOB.Equip[14].stEffect[0].sValue = 18000;
			pMob[conn].MOB.Equip[14].stEffect[2].cEffect = 50;
		}
		else
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Cure_failed]);
			memset(&pMob[conn].MOB.Equip[14], 0, sizeof(STRUCT_ITEM));
		}

		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, 8);

		pMob[conn].GetCurrentScore(conn);
		SendItem(conn, ITEM_PLACE_EQUIP, 14, &pMob[conn].MOB.Equip[14]);
		MountProcess(conn, &pMob[conn].MOB.Equip[14]);
		SendEtc(conn);


		return;
	}
#pragma endregion
#pragma region Pedra Ideal
	if (Vol == 211)
	{
		if (EvolutionStatus < 2)
		{
			SendClientMessage(conn, "Criação de Celestial Bloqueada");
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}


#pragma region HardCore Desligado
		if (isHardCore == 0)
		{
			if (pMob[conn].extra.ClassMaster != ARCH && pMob[conn].extra.ClassMaster != CELESTIAL)
			{
				SendClientMessage(conn, "Não há quest's disponíveis para sua classe.");
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if (pMob[conn].extra.ClassMaster == ARCH && pMob[conn].MOB.CurrentScore.Level < 399)
			{
				SendClientMessage(conn, "Somente personagem nível 400.");
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if (pMob[conn].extra.ClassMaster == ARCH && (pMob[conn].MOB.Equip[1].sIndex != 0 || pMob[conn].extra.QuestInfo.Arch.MortalLevel < 99))
			{
				if (pMob[conn].MOB.Equip[1].sIndex)
					SendClientMessage(conn, g_pMessageStringTable[_NN_Cant_with_armor]);

				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if (pMob[conn].extra.ClassMaster == CELESTIAL && (pMob[conn].MOB.Equip[11].sIndex < 1760 || pMob[conn].MOB.Equip[11].sIndex > 1763))
			{
				SendClientMessage(conn, "Equipe a o item (Sephirot[Classe]) para concluír esta Quest.");
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if (pMob[conn].extra.ClassMaster == CELESTIAL && pMob[conn].MOB.CurrentScore.Level < 120)
			{
				SendClientMessage(conn, "Seu Persogaem deve possuir nivel 121 + !"); //"Somente personagem nível 120.");
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if (pMob[conn].extra.ClassMaster == CELESTIAL && pMob[conn].extra.Fame < 100)
			{
				SendClientMessage(conn, "Seu personagem não possui [100] de Fame.");
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if (pMob[conn].extra.ClassMaster == CELESTIAL)
			{
				pMob[conn].extra.Fame -= 100;

				pMob[conn].extra.ClassMaster = CELESTIALCS;
				pMob[conn].extra.SaveCelestial[1].Class = pMob[conn].MOB.Equip[11].sIndex - 1760;

				pMob[conn].extra.SaveCelestial[1].BaseScore = pMob[conn].MOB.BaseScore;

				pMob[conn].extra.SaveCelestial[1].LearnedSkill = pMob[conn].MOB.LearnedSkill;
				pMob[conn].extra.SaveCelestial[1].SecLearnedSkill = pMob[conn].extra.SecLearnedSkill;
				pMob[conn].extra.SaveCelestial[1].BaseScore.Level = 0;

				pMob[conn].extra.SaveCelestial[1].BaseScore.Str = BaseSIDCHM[pMob[conn].MOB.Class][0];
				pMob[conn].extra.SaveCelestial[1].BaseScore.Int = BaseSIDCHM[pMob[conn].MOB.Class][1];
				pMob[conn].extra.SaveCelestial[1].BaseScore.Dex = BaseSIDCHM[pMob[conn].MOB.Class][2];
				pMob[conn].extra.SaveCelestial[1].BaseScore.Con = BaseSIDCHM[pMob[conn].MOB.Class][3];

				pMob[conn].extra.SaveCelestial[1].BaseScore.Special[0] = 0;
				pMob[conn].extra.SaveCelestial[1].BaseScore.Special[1] = 0;
				pMob[conn].extra.SaveCelestial[1].BaseScore.Special[2] = 0;
				pMob[conn].extra.SaveCelestial[1].BaseScore.Special[3] = 0;

				if (pMob[conn].extra.QuestInfo.Arch.Cristal == 1)
					pMob[conn].extra.SaveCelestial[1].BaseScore.Ac = 954;
				else if (pMob[conn].extra.QuestInfo.Arch.Cristal == 2)
					pMob[conn].extra.SaveCelestial[1].BaseScore.Ac = 984;
				else if (pMob[conn].extra.QuestInfo.Arch.Cristal == 3)
					pMob[conn].extra.SaveCelestial[1].BaseScore.Ac = 984;
				else if (pMob[conn].extra.QuestInfo.Arch.Cristal == 4)
					pMob[conn].extra.SaveCelestial[1].BaseScore.Ac = 1004;
				else
					pMob[conn].extra.SaveCelestial[1].BaseScore.Ac = 954;

				pMob[conn].extra.SaveCelestial[1].BaseScore.Damage = 488;
				pMob[conn].extra.SaveCelestial[1].BaseScore.Hp = BaseSIDCHM[pMob[conn].MOB.Equip[11].sIndex - 1760][4];
				pMob[conn].extra.SaveCelestial[1].BaseScore.MaxHp = BaseSIDCHM[pMob[conn].MOB.Equip[11].sIndex - 1760][4];
				pMob[conn].extra.SaveCelestial[1].BaseScore.Mp = BaseSIDCHM[pMob[conn].MOB.Equip[11].sIndex - 1760][5];
				pMob[conn].extra.SaveCelestial[1].BaseScore.MaxMp = BaseSIDCHM[pMob[conn].MOB.Equip[11].sIndex - 1760][5];

				pMob[conn].extra.SaveCelestial[1].SpecialBonus = 855;
				pMob[conn].extra.SaveCelestial[1].LearnedSkill &= 0xFF000000;
				pMob[conn].extra.SaveCelestial[1].SecLearnedSkill = 0;

				pMob[conn].extra.SaveCelestial[1].Exp = 0;

				pMob[conn].extra.SaveCelestial[1].Soul = pMob[conn].extra.Soul;

				if (pMob[conn].MOB.Clan == 7)
					pMob[conn].MOB.Equip[15].sIndex = 3197;

				else if (pMob[conn].MOB.Clan == 8)
					pMob[conn].MOB.Equip[15].sIndex = 3198;

				else
					SendItem(conn, m->SourType, m->SourPos, item);

				memset(&pMob[conn].MOB.Equip[11], 0, sizeof(STRUCT_ITEM));
				SendItem(conn, ITEM_PLACE_EQUIP, 11, &pMob[conn].MOB.Equip[11]);
				SendItem(conn, ITEM_PLACE_EQUIP, 15, &pMob[conn].MOB.Equip[15]);

				if (amount > 1)
					BASE_SetItemAmount(item, amount - 1);

				else
					memset(item, 0, sizeof(STRUCT_ITEM));

				SendItem(conn, m->SourType, m->SourPos, item);

				ItemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, "useitem,ideal stone used to make god2");

				SendClientMessage(conn, g_pMessageStringTable[_NN_My_King_Bless1]);
				return;
			}

			if (pMob[conn].extra.ClassMaster == ARCH)
			{
				int ptlevel = 0;

				if (pMob[conn].MOB.CurrentScore.Level < 370)
					ptlevel = 1;

				else if (pMob[conn].MOB.CurrentScore.Level < 380)
					ptlevel = 2;

				else if (pMob[conn].MOB.CurrentScore.Level < 398)
					ptlevel = 3;

				else if (pMob[conn].MOB.CurrentScore.Level == 398)
					ptlevel = 4;
				else
					ptlevel = 5;

				memset(&pMob[conn].MOB.Equip[1], 0, sizeof(STRUCT_ITEM));

				if (pMob[conn].MOB.CurrentScore.Level < 380)
					pMob[conn].MOB.Equip[1].sIndex = 3500;

				else if (pMob[conn].MOB.CurrentScore.Level < 399)
					pMob[conn].MOB.Equip[1].sIndex = 3501;

				else if (pMob[conn].MOB.CurrentScore.Level < 400)
					pMob[conn].MOB.Equip[1].sIndex = 3502;

				pMob[conn].extra.QuestInfo.Celestial.ArchLevel = ptlevel;
				pMob[conn].extra.ClassMaster = CELESTIAL;

				pMob[conn].MOB.BaseScore.Level = 0;
				pMob[conn].MOB.CurrentScore.Level = 0;

				pMob[conn].MOB.BaseScore.Str = BaseSIDCHM[pMob[conn].MOB.Class][0];
				pMob[conn].MOB.BaseScore.Int = BaseSIDCHM[pMob[conn].MOB.Class][1];
				pMob[conn].MOB.BaseScore.Dex = BaseSIDCHM[pMob[conn].MOB.Class][2];
				pMob[conn].MOB.BaseScore.Con = BaseSIDCHM[pMob[conn].MOB.Class][3];

				pMob[conn].MOB.BaseScore.Special[0] = 0;
				pMob[conn].MOB.BaseScore.Special[1] = 0;
				pMob[conn].MOB.BaseScore.Special[2] = 0;
				pMob[conn].MOB.BaseScore.Special[3] = 0;

				if (pMob[conn].extra.QuestInfo.Arch.Cristal == 1)
					pMob[conn].MOB.BaseScore.Ac = 954;
				else if (pMob[conn].extra.QuestInfo.Arch.Cristal == 2)
					pMob[conn].MOB.BaseScore.Ac = 984;
				else if (pMob[conn].extra.QuestInfo.Arch.Cristal == 3)
					pMob[conn].MOB.BaseScore.Ac = 984;
				else if (pMob[conn].extra.QuestInfo.Arch.Cristal == 4)
					pMob[conn].MOB.BaseScore.Ac = 1004;
				else
					pMob[conn].MOB.BaseScore.Ac = 954;

				pMob[conn].MOB.BaseScore.Damage = 488;
				pMob[conn].MOB.BaseScore.Hp = BaseSIDCHM[pMob[conn].MOB.Class][4];
				pMob[conn].MOB.BaseScore.MaxHp = BaseSIDCHM[pMob[conn].MOB.Class][4];
				pMob[conn].MOB.BaseScore.Mp = BaseSIDCHM[pMob[conn].MOB.Class][5];
				pMob[conn].MOB.BaseScore.MaxMp = BaseSIDCHM[pMob[conn].MOB.Class][5];

				pMob[conn].MOB.SpecialBonus = 855;

				pMob[conn].MOB.LearnedSkill = 1073741824;
				pMob[conn].extra.SecLearnedSkill = 0;

				pMob[conn].MOB.Exp = 0;

				memset(&pMob[conn].MOB.Equip[15], 0, sizeof(STRUCT_ITEM));

				if (pMob[conn].MOB.Clan == 7)
					pMob[conn].MOB.Equip[15].sIndex = 3197;

				else if (pMob[conn].MOB.Clan == 8)
					pMob[conn].MOB.Equip[15].sIndex = 3198;

				else
					pMob[conn].MOB.Equip[15].sIndex = 3199;

				pMob[conn].MOB.Equip[0].stEffect[1].cEffect = 98;
				pMob[conn].MOB.Equip[0].stEffect[1].cValue = 3;
				pMob[conn].MOB.Equip[0].stEffect[2].cEffect = 106;
				pMob[conn].MOB.Equip[0].stEffect[2].cValue = (unsigned char)pMob[conn].MOB.Equip[0].sIndex;

				SendClientMessage(conn, g_pMessageStringTable[_NN_My_King_Bless1]);

				if (amount > 1)
					BASE_SetItemAmount(item, amount - 1);

				else
					memset(item, 0, sizeof(STRUCT_ITEM));


				BASE_GetHpMp(&pMob[conn].MOB, &pMob[conn].extra);

				SendScore(conn);
				SendEtc(conn);

				CharLogOut(conn);

				SendClientSignalParm(conn, ESCENE_FIELD, _MSG_SendArchEffect, pUser[conn].Slot);

				return;
			}


			if (amount > 1)
				BASE_SetItemAmount(item, amount - 1);

			else
				memset(item, 0, sizeof(STRUCT_ITEM));

			ItemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, strFmt("useitem,ideal stone used to make god %d %d", pMob[conn].extra.QuestInfo.Celestial.ArchLevel, pMob[conn].extra.QuestInfo.Arch.Cristal));

			return;
		}
#pragma endregion
#pragma region HardCore Ligado
		else if (isHardCore == 1)
		{
			if (pMob[conn].extra.ClassMaster != ARCH && pMob[conn].extra.ClassMaster != CELESTIAL && pMob[conn].extra.ClassMaster != CELESTIALCS && pMob[conn].extra.ClassMaster != HARDCORE && pMob[conn].extra.ClassMaster != HARDCOREA)
			{
				SendClientMessage(conn, "Não há quest's disponíveis para sua classe.");
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if (pMob[conn].extra.ClassMaster == ARCH && (pMob[conn].MOB.Equip[1].sIndex != 0 || pMob[conn].extra.QuestInfo.Arch.MortalLevel < 99))
			{
				if (pMob[conn].MOB.Equip[1].sIndex)
					SendClientMessage(conn, g_pMessageStringTable[_NN_Cant_with_armor]);

				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if ((pMob[conn].extra.ClassMaster == CELESTIAL || pMob[conn].extra.ClassMaster == CELESTIALCS) && pMob[conn].extra.Fame < 100)
			{
				SendClientMessage(conn, "Seu personagem não possui [100] de Fame.");
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if (pMob[conn].extra.ClassMaster == CELESTIAL && (pMob[conn].MOB.Equip[10].sIndex != 1742 &&
				pMob[conn].MOB.Equip[11].sIndex != 1760 && pMob[conn].MOB.Equip[11].sIndex != 1761 && pMob[conn].MOB.Equip[11].sIndex != 1762
				&& pMob[conn].MOB.Equip[11].sIndex != 1763))
			{
				SendClientMessage(conn, "Equipe a o item (Sephirot[Classe]) para concluír esta Quest.");
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if (pMob[conn].extra.ClassMaster == CELESTIAL && (pMob[conn].MOB.Equip[10].sIndex == 1742 && pMob[conn].MOB.Equip[11].sIndex >= 1760 && pMob[conn].MOB.Equip[11].sIndex <= 1763))
			{
				SendClientMessage(conn, "Escolha entre [HardCore(Imortalidade)] ou [SubCelestial(Sephirot)].");
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if (pMob[conn].extra.ClassMaster == CELESTIALCS && (pMob[conn].MOB.Equip[11].sIndex >= 1760 && pMob[conn].MOB.Equip[11].sIndex <= 1763))
			{
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if (pMob[conn].extra.ClassMaster == CELESTIALCS && (pMob[conn].MOB.Equip[10].sIndex != 1742))
			{
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if ((pMob[conn].extra.ClassMaster == HARDCORE || pMob[conn].extra.ClassMaster == HARDCOREA) && pMob[conn].extra.Fame < 100)
			{
				SendClientMessage(conn, "Seu personagem não possui [100] de Fame.");
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if (pMob[conn].extra.ClassMaster == HARDCORE && (pMob[conn].MOB.Equip[10].sIndex != 1742 &&
				pMob[conn].MOB.Equip[11].sIndex != 1760 && pMob[conn].MOB.Equip[11].sIndex != 1761 && pMob[conn].MOB.Equip[11].sIndex != 1762
				&& pMob[conn].MOB.Equip[11].sIndex != 1763))
			{
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if (pMob[conn].extra.ClassMaster == HARDCOREA && (pMob[conn].MOB.Equip[10].sIndex != 1742 &&
				pMob[conn].MOB.Equip[11].sIndex != 1760 && pMob[conn].MOB.Equip[11].sIndex != 1761 && pMob[conn].MOB.Equip[11].sIndex != 1762
				&& pMob[conn].MOB.Equip[11].sIndex != 1763))
			{
				SendClientMessage(conn, "Equipe a o item (Sephirot[Classe]) para concluír esta Quest.");
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if (pMob[conn].extra.ClassMaster == HARDCORE && (pMob[conn].MOB.Equip[10].sIndex == 1742 && pMob[conn].MOB.Equip[11].sIndex >= 1760 && pMob[conn].MOB.Equip[11].sIndex <= 1763))
			{
				SendClientMessage(conn, "Para se tornar um Sub HardCore: Retire a [Pedra da Imortalidade].");
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if (pMob[conn].extra.ClassMaster == HARDCOREA && (pMob[conn].MOB.Equip[10].sIndex == 1742 && pMob[conn].MOB.Equip[11].sIndex >= 1760 && pMob[conn].MOB.Equip[11].sIndex <= 1763))
			{
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if (pMob[conn].extra.ClassMaster == HARDCORECS && (pMob[conn].MOB.Equip[11].sIndex >= 1760 && pMob[conn].MOB.Equip[11].sIndex <= 1763))
			{
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if (pMob[conn].extra.ClassMaster == HARDCORE && (pMob[conn].MOB.Equip[10].sIndex == 1742))
			{
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if (pMob[conn].extra.ClassMaster == HARDCOREA && (pMob[conn].MOB.Equip[10].sIndex == 1742))
			{
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if (pMob[conn].extra.ClassMaster == ARCH)
			{
				if (pMob[conn].MOB.BaseScore.Level >= 355)
				{
					int ptlevel = 0;

					if (pMob[conn].MOB.CurrentScore.Level < 370)
						ptlevel = 1;

					else if (pMob[conn].MOB.CurrentScore.Level < 380)
						ptlevel = 2;

					else if (pMob[conn].MOB.CurrentScore.Level < 398)
						ptlevel = 3;

					else if (pMob[conn].MOB.CurrentScore.Level == 398)
						ptlevel = 4;
					else
						ptlevel = 5;

					memset(&pMob[conn].MOB.Equip[1], 0, sizeof(STRUCT_ITEM));

					if (pMob[conn].MOB.CurrentScore.Level < 380)
						pMob[conn].MOB.Equip[1].sIndex = 3500;

					else if (pMob[conn].MOB.CurrentScore.Level < 399)
						pMob[conn].MOB.Equip[1].sIndex = 3501;

					else if (pMob[conn].MOB.CurrentScore.Level < 400)
						pMob[conn].MOB.Equip[1].sIndex = 3502;

					pMob[conn].extra.QuestInfo.Celestial.ArchLevel = ptlevel;
					pMob[conn].extra.ClassMaster = CELESTIAL;

					pMob[conn].MOB.BaseScore.Level = 0;

					pMob[conn].MOB.BaseScore.Str = BaseSIDCHM[pMob[conn].MOB.Class][0];
					pMob[conn].MOB.BaseScore.Int = BaseSIDCHM[pMob[conn].MOB.Class][1];
					pMob[conn].MOB.BaseScore.Dex = BaseSIDCHM[pMob[conn].MOB.Class][2];
					pMob[conn].MOB.BaseScore.Con = BaseSIDCHM[pMob[conn].MOB.Class][3];

					pMob[conn].MOB.BaseScore.Special[0] = 0;
					pMob[conn].MOB.BaseScore.Special[1] = 0;
					pMob[conn].MOB.BaseScore.Special[2] = 0;
					pMob[conn].MOB.BaseScore.Special[3] = 0;

					pMob[conn].MOB.BaseScore.Ac = 1004;
					pMob[conn].MOB.BaseScore.Damage = 400;
					pMob[conn].MOB.BaseScore.Hp = BaseSIDCHM[pMob[conn].MOB.Class][4];
					pMob[conn].MOB.BaseScore.MaxHp = BaseSIDCHM[pMob[conn].MOB.Class][4];
					pMob[conn].MOB.BaseScore.Mp = BaseSIDCHM[pMob[conn].MOB.Class][5];
					pMob[conn].MOB.BaseScore.MaxMp = BaseSIDCHM[pMob[conn].MOB.Class][5];

					pMob[conn].MOB.SpecialBonus = 855;

					pMob[conn].MOB.LearnedSkill = 1073741824;
					pMob[conn].extra.SecLearnedSkill = 0;

					pMob[conn].MOB.Exp = 0;

					memset(&pMob[conn].MOB.Equip[15], 0, sizeof(STRUCT_ITEM));

					if (pMob[conn].MOB.Clan == 7)
						pMob[conn].MOB.Equip[15].sIndex = 3197;

					else if (pMob[conn].MOB.Clan == 8)
						pMob[conn].MOB.Equip[15].sIndex = 3198;

					else
						pMob[conn].MOB.Equip[15].sIndex = 3199;

					pMob[conn].MOB.Equip[0].stEffect[1].cEffect = 98;
					pMob[conn].MOB.Equip[0].stEffect[1].cValue = 3;
					pMob[conn].MOB.Equip[0].stEffect[2].cEffect = 106;
					pMob[conn].MOB.Equip[0].stEffect[2].cValue = (unsigned char)pMob[conn].MOB.Equip[0].sIndex;

					SendClientMessage(conn, g_pMessageStringTable[_NN_My_King_Bless1]);

					if (amount > 1)
						BASE_SetItemAmount(item, amount - 1);

					else
						memset(item, 0, sizeof(STRUCT_ITEM));

					BASE_GetHpMp(&pMob[conn].MOB, &pMob[conn].extra);

					SendScore(conn);
					SendEtc(conn);

					CharLogOut(conn);

					SendClientSignalParm(conn, ESCENE_FIELD, _MSG_SendArchEffect, pUser[conn].Slot);

					return;
				}

				if (pMob[conn].MOB.BaseScore.Level <= 354)
				{
					if (pMob[conn].MOB.Equip[1].sIndex != 0)
					{
						SendClientMessage(conn, "Desequipe sua Cythera e tente novamente.");
						SendItem(conn, m->SourType, m->SourPos, item);
						return;
					}
					else
					{
						memset(&pMob[conn].MOB.Equip[1], 0, sizeof(STRUCT_ITEM));

						pMob[conn].extra.QuestInfo.Celestial.ArchLevel = 5;
						pMob[conn].extra.ClassMaster = HARDCOREA;

						pMob[conn].MOB.Equip[1].sIndex = 3505;

						pMob[conn].MOB.BaseScore.Level = 0;

						pMob[conn].MOB.BaseScore.Str = BaseSIDCHM[pMob[conn].MOB.Class][0];
						pMob[conn].MOB.BaseScore.Int = BaseSIDCHM[pMob[conn].MOB.Class][1];
						pMob[conn].MOB.BaseScore.Dex = BaseSIDCHM[pMob[conn].MOB.Class][2];
						pMob[conn].MOB.BaseScore.Con = BaseSIDCHM[pMob[conn].MOB.Class][3];

						pMob[conn].MOB.BaseScore.Special[0] = 0;
						pMob[conn].MOB.BaseScore.Special[1] = 0;
						pMob[conn].MOB.BaseScore.Special[2] = 0;
						pMob[conn].MOB.BaseScore.Special[3] = 0;

						pMob[conn].MOB.BaseScore.Ac = 954;
						pMob[conn].MOB.BaseScore.Damage = 800;
						pMob[conn].MOB.BaseScore.Hp = BaseSIDCHM[pMob[conn].MOB.Class][4];
						pMob[conn].MOB.BaseScore.MaxHp = BaseSIDCHM[pMob[conn].MOB.Class][4];
						pMob[conn].MOB.BaseScore.Mp = BaseSIDCHM[pMob[conn].MOB.Class][5];
						pMob[conn].MOB.BaseScore.MaxMp = BaseSIDCHM[pMob[conn].MOB.Class][5];

						pMob[conn].MOB.SpecialBonus = 855;

						pMob[conn].MOB.LearnedSkill = 1073741824;
						pMob[conn].extra.SecLearnedSkill = 0;

						pMob[conn].MOB.Exp = 0;

						memset(&pMob[conn].MOB.Equip[15], 0, sizeof(STRUCT_ITEM));

						if (pMob[conn].MOB.Clan == 7)
							pMob[conn].MOB.Equip[15].sIndex = 3197;

						else if (pMob[conn].MOB.Clan == 8)
							pMob[conn].MOB.Equip[15].sIndex = 3198;

						else
							pMob[conn].MOB.Equip[15].sIndex = 3199;

						pMob[conn].MOB.Equip[0].stEffect[1].cEffect = 98;
						pMob[conn].MOB.Equip[0].stEffect[1].cValue = 3;
						pMob[conn].MOB.Equip[0].stEffect[2].cEffect = 106;
						pMob[conn].MOB.Equip[0].stEffect[2].cValue = (unsigned char)pMob[conn].MOB.Equip[0].sIndex;

						SendClientMessage(conn, g_pMessageStringTable[_NN_My_King_Bless1]);

						if (amount > 1)
							BASE_SetItemAmount(item, amount - 1);

						else
							memset(item, 0, sizeof(STRUCT_ITEM));

						BASE_GetHpMp(&pMob[conn].MOB, &pMob[conn].extra);

						SendScore(conn);
						SendEtc(conn);

						CharLogOut(conn);

						SendClientSignalParm(conn, ESCENE_FIELD, _MSG_SendArchEffect, pUser[conn].Slot);

						return;
					}
				}
			}

			if (pMob[conn].extra.ClassMaster == CELESTIAL)
			{
				if (pMob[conn].MOB.Equip[11].sIndex >= 1760 && pMob[conn].MOB.Equip[11].sIndex <= 1763 && pMob[conn].MOB.Equip[10].sIndex != 1742)
				{
					if (pMob[conn].MOB.BaseScore.Level >= 120)
					{
						pMob[conn].extra.Fame -= 100;

						pMob[conn].extra.ClassMaster = CELESTIALCS;
						pMob[conn].extra.SaveCelestial[1].Class = pMob[conn].MOB.Equip[11].sIndex - 1760;

						pMob[conn].extra.SaveCelestial[1].BaseScore = pMob[conn].MOB.BaseScore;

						pMob[conn].extra.SaveCelestial[1].LearnedSkill = pMob[conn].MOB.LearnedSkill;
						pMob[conn].extra.SaveCelestial[1].SecLearnedSkill = pMob[conn].extra.SecLearnedSkill;
						pMob[conn].extra.SaveCelestial[1].BaseScore.Level = 0;

						pMob[conn].extra.SaveCelestial[1].BaseScore.Str = BaseSIDCHM[pMob[conn].MOB.Class][0];
						pMob[conn].extra.SaveCelestial[1].BaseScore.Int = BaseSIDCHM[pMob[conn].MOB.Class][1];
						pMob[conn].extra.SaveCelestial[1].BaseScore.Dex = BaseSIDCHM[pMob[conn].MOB.Class][2];
						pMob[conn].extra.SaveCelestial[1].BaseScore.Con = BaseSIDCHM[pMob[conn].MOB.Class][3];

						pMob[conn].extra.SaveCelestial[1].BaseScore.Special[0] = 0;
						pMob[conn].extra.SaveCelestial[1].BaseScore.Special[1] = 0;
						pMob[conn].extra.SaveCelestial[1].BaseScore.Special[2] = 0;
						pMob[conn].extra.SaveCelestial[1].BaseScore.Special[3] = 0;

						pMob[conn].extra.SaveCelestial[1].BaseScore.Ac = 1004;
						pMob[conn].extra.SaveCelestial[1].BaseScore.Damage = 400;
						pMob[conn].extra.SaveCelestial[1].BaseScore.Hp = BaseSIDCHM[pMob[conn].MOB.Equip[11].sIndex - 1760][4];
						pMob[conn].extra.SaveCelestial[1].BaseScore.MaxHp = BaseSIDCHM[pMob[conn].MOB.Equip[11].sIndex - 1760][4];
						pMob[conn].extra.SaveCelestial[1].BaseScore.Mp = BaseSIDCHM[pMob[conn].MOB.Equip[11].sIndex - 1760][5];
						pMob[conn].extra.SaveCelestial[1].BaseScore.MaxMp = BaseSIDCHM[pMob[conn].MOB.Equip[11].sIndex - 1760][5];

						pMob[conn].extra.SaveCelestial[1].SpecialBonus = 855;
						pMob[conn].extra.SaveCelestial[1].LearnedSkill &= 0xFF000000;
						pMob[conn].extra.SaveCelestial[1].SecLearnedSkill = 0;
						pMob[conn].extra.SaveCelestial[1].Exp = 0;

						pMob[conn].extra.SaveCelestial[1].Soul = pMob[conn].extra.Soul;

						if (pMob[conn].MOB.Clan == 7)
							pMob[conn].MOB.Equip[15].sIndex = 3197;

						else if (pMob[conn].MOB.Clan == 8)
							pMob[conn].MOB.Equip[15].sIndex = 3198;

						else
							SendItem(conn, m->SourType, m->SourPos, item);

						memset(&pMob[conn].MOB.Equip[11], 0, sizeof(STRUCT_ITEM));
						SendItem(conn, ITEM_PLACE_EQUIP, 11, &pMob[conn].MOB.Equip[11]);
						SendItem(conn, ITEM_PLACE_EQUIP, 15, &pMob[conn].MOB.Equip[15]);

						if (amount > 1)
							BASE_SetItemAmount(item, amount - 1);
						else
							memset(item, 0, sizeof(STRUCT_ITEM));


						ItemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, "useitem,ideal stone used to make god2");

						SendClientMessage(conn, g_pMessageStringTable[_NN_My_King_Bless1]);
						return;
					}
					else
					{
						SendItem(conn, m->SourType, m->SourPos, item);
						return;
					}
				}
				else if (pMob[conn].MOB.Equip[10].sIndex == 1742 && (pMob[conn].MOB.Equip[11].sIndex != 1760 && pMob[conn].MOB.Equip[11].sIndex != 1761 && pMob[conn].MOB.Equip[11].sIndex != 1762 && pMob[conn].MOB.Equip[11].sIndex != 1763))
				{

					SendClientMessage(conn, "Divino não pode ser criado por Celestial a partir da versão 7.55");
					return;
				}
			}

			if (pMob[conn].extra.ClassMaster == CELESTIALCS)
			{

				SendClientMessage(conn, "Divino não pode ser criado por Celestial a partir da versão 7.55");
				return;
			}

			if (pMob[conn].extra.ClassMaster == HARDCORE || pMob[conn].extra.ClassMaster == HARDCOREA)
			{
				if (pMob[conn].extra.ClassMaster == HARDCORE)
				{
					if (pMob[conn].MOB.BaseScore.Level >= 120)
					{
						pMob[conn].extra.Fame -= 100;

						pMob[conn].extra.ClassMaster = HARDCORECS;
						pMob[conn].extra.SaveCelestial[2].Class = pMob[conn].MOB.Equip[11].sIndex - 1760;

						pMob[conn].extra.SaveCelestial[2].BaseScore = pMob[conn].MOB.BaseScore;

						pMob[conn].extra.SaveCelestial[2].LearnedSkill = pMob[conn].MOB.LearnedSkill;
						pMob[conn].extra.SaveCelestial[2].SecLearnedSkill = pMob[conn].extra.SecLearnedSkill;
						pMob[conn].extra.SaveCelestial[2].BaseScore.Level = 0;

						pMob[conn].extra.SaveCelestial[2].BaseScore.Str = BaseSIDCHM[pMob[conn].MOB.Class][0];
						pMob[conn].extra.SaveCelestial[2].BaseScore.Int = BaseSIDCHM[pMob[conn].MOB.Class][1];
						pMob[conn].extra.SaveCelestial[2].BaseScore.Dex = BaseSIDCHM[pMob[conn].MOB.Class][2];
						pMob[conn].extra.SaveCelestial[2].BaseScore.Con = BaseSIDCHM[pMob[conn].MOB.Class][3];

						pMob[conn].extra.SaveCelestial[2].BaseScore.Special[0] = 0;
						pMob[conn].extra.SaveCelestial[2].BaseScore.Special[1] = 0;
						pMob[conn].extra.SaveCelestial[2].BaseScore.Special[2] = 0;
						pMob[conn].extra.SaveCelestial[2].BaseScore.Special[3] = 0;

						pMob[conn].extra.SaveCelestial[2].BaseScore.Ac = 954;
						pMob[conn].extra.SaveCelestial[2].BaseScore.Damage = 800;
						pMob[conn].extra.SaveCelestial[2].BaseScore.Hp = BaseSIDCHM[pMob[conn].MOB.Equip[11].sIndex - 1760][4];
						pMob[conn].extra.SaveCelestial[2].BaseScore.MaxHp = BaseSIDCHM[pMob[conn].MOB.Equip[11].sIndex - 1760][4];
						pMob[conn].extra.SaveCelestial[2].BaseScore.Mp = BaseSIDCHM[pMob[conn].MOB.Equip[11].sIndex - 1760][5];
						pMob[conn].extra.SaveCelestial[2].BaseScore.MaxMp = BaseSIDCHM[pMob[conn].MOB.Equip[11].sIndex - 1760][5];

						pMob[conn].extra.SaveCelestial[2].SpecialBonus = 855;
						pMob[conn].extra.SaveCelestial[2].LearnedSkill &= 0xFF000000;
						pMob[conn].extra.SaveCelestial[2].SecLearnedSkill = 0;

						pMob[conn].extra.SaveCelestial[2].Exp = 0;

						pMob[conn].extra.SaveCelestial[2].Soul = pMob[conn].extra.Soul;

						memset(&pMob[conn].MOB.Equip[11], 0, sizeof(STRUCT_ITEM));
						SendItem(conn, ITEM_PLACE_EQUIP, 11, &pMob[conn].MOB.Equip[11]);

						if (amount > 1)
							BASE_SetItemAmount(item, amount - 1);
						else
							memset(item, 0, sizeof(STRUCT_ITEM));

						ItemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, "useitem,ideal stone used to make god2");

						SendClientMessage(conn, g_pMessageStringTable[_NN_My_King_Bless1]);
						return;
					}
					else
					{
						SendItem(conn, m->SourType, m->SourPos, item);
						return;
					}
				}
				if (pMob[conn].extra.ClassMaster == HARDCOREA)
				{
					if (pMob[conn].MOB.BaseScore.Level >= 120)
					{
						pMob[conn].extra.Fame -= 100;

						pMob[conn].extra.ClassMaster = HARDCORECS;
						pMob[conn].extra.SaveCelestial[2].Class = pMob[conn].MOB.Equip[11].sIndex - 1760;

						pMob[conn].extra.SaveCelestial[2].BaseScore = pMob[conn].MOB.BaseScore;

						pMob[conn].extra.SaveCelestial[2].LearnedSkill = pMob[conn].MOB.LearnedSkill;
						pMob[conn].extra.SaveCelestial[2].SecLearnedSkill = pMob[conn].extra.SecLearnedSkill;
						pMob[conn].extra.SaveCelestial[2].BaseScore.Level = 0;

						pMob[conn].extra.SaveCelestial[2].BaseScore.Str = BaseSIDCHM[pMob[conn].MOB.Class][0];
						pMob[conn].extra.SaveCelestial[2].BaseScore.Int = BaseSIDCHM[pMob[conn].MOB.Class][1];
						pMob[conn].extra.SaveCelestial[2].BaseScore.Dex = BaseSIDCHM[pMob[conn].MOB.Class][2];
						pMob[conn].extra.SaveCelestial[2].BaseScore.Con = BaseSIDCHM[pMob[conn].MOB.Class][3];

						pMob[conn].extra.SaveCelestial[2].BaseScore.Special[0] = 0;
						pMob[conn].extra.SaveCelestial[2].BaseScore.Special[1] = 0;
						pMob[conn].extra.SaveCelestial[2].BaseScore.Special[2] = 0;
						pMob[conn].extra.SaveCelestial[2].BaseScore.Special[3] = 0;

						pMob[conn].extra.SaveCelestial[2].BaseScore.Ac = 954;
						pMob[conn].extra.SaveCelestial[2].BaseScore.Damage = 800;
						pMob[conn].extra.SaveCelestial[2].BaseScore.Hp = BaseSIDCHM[pMob[conn].MOB.Equip[11].sIndex - 1760][4];
						pMob[conn].extra.SaveCelestial[2].BaseScore.MaxHp = BaseSIDCHM[pMob[conn].MOB.Equip[11].sIndex - 1760][4];
						pMob[conn].extra.SaveCelestial[2].BaseScore.Mp = BaseSIDCHM[pMob[conn].MOB.Equip[11].sIndex - 1760][5];
						pMob[conn].extra.SaveCelestial[2].BaseScore.MaxMp = BaseSIDCHM[pMob[conn].MOB.Equip[11].sIndex - 1760][5];

						pMob[conn].extra.SaveCelestial[2].SpecialBonus = 855;
						pMob[conn].extra.SaveCelestial[2].LearnedSkill &= 0xFF000000;
						pMob[conn].extra.SaveCelestial[2].SecLearnedSkill = 0;

						pMob[conn].extra.SaveCelestial[2].Exp = 0;

						pMob[conn].extra.SaveCelestial[2].Soul = pMob[conn].extra.Soul;

						memset(&pMob[conn].MOB.Equip[11], 0, sizeof(STRUCT_ITEM));
						SendItem(conn, ITEM_PLACE_EQUIP, 11, &pMob[conn].MOB.Equip[11]);

						if (amount > 1)
							BASE_SetItemAmount(item, amount - 1);
						else
							memset(item, 0, sizeof(STRUCT_ITEM));

						ItemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, "useitem,ideal stone used to make god2");

						SendClientMessage(conn, g_pMessageStringTable[_NN_My_King_Bless1]);
						return;
					}
					else
					{
						SendItem(conn, m->SourType, m->SourPos, item);
						return;
					}
				}
			}
#pragma endregion

			if (amount > 1)
				BASE_SetItemAmount(item, amount - 1);

			else
				memset(item, 0, sizeof(STRUCT_ITEM));

			ItemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, strFmt("useitem,ideal stone used to make god %d %d", pMob[conn].extra.QuestInfo.Celestial.ArchLevel, pMob[conn].extra.QuestInfo.Arch.Cristal));

			SendScore(conn);
			SendEtc(conn);

			CharLogOut(conn);

			SendClientSignalParm(conn, ESCENE_FIELD, _MSG_SendArchEffect, pUser[conn].Slot);

			return;
		}
	}
#pragma endregion
#pragma region Pedra Misteriosa
	if (item->sIndex == 4148)
	{
		if (isHardCore == 0)
		{
			if (pMob[conn].extra.ClassMaster != CELESTIALCS && pMob[conn].extra.ClassMaster != SCELESTIAL)
			{
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			int Village = BASE_GetVillage(pMob[conn].TargetX, pMob[conn].TargetY);

			if ((pMob[conn].TargetX / 128) != 25 && (pMob[conn].TargetY / 128) != 13)
			{
				if (Village < 0 || Village >= 5)
				{
					SendClientMessage(conn, g_pMessageStringTable[_NN_OnlyVillage]);
					SendItem(conn, m->SourType, m->SourPos, item);
					return;
				}
			}

			int cl = pMob[conn].extra.ClassMaster == CELESTIALCS ? 0 : 1;
			int ncl = pMob[conn].extra.ClassMaster == CELESTIALCS ? 1 : 0;

			if (pMob[conn].extra.ClassMaster == CELESTIALCS)
			{
				pMob[conn].extra.ClassMaster = SCELESTIAL;
				SendClientMessage(conn, "Alternado [Sub Celestial]");
				pMob[conn].extra.QuestInfo.Celestial.CelestialLevel = pMob[conn].MOB.BaseScore.Level;
			}
			else
			{
				pMob[conn].extra.ClassMaster = CELESTIALCS;
				SendClientMessage(conn, "Alternado [Celestial]");
				pMob[conn].extra.QuestInfo.Celestial.SubCelestialLevel = pMob[conn].MOB.BaseScore.Level;
			}
			pMob[conn].extra.SaveCelestial[cl].BaseScore = pMob[conn].MOB.BaseScore;
			//pMob[conn].extra.SaveCelestial[cl].CurrentScore = pMob[conn].MOB.CurrentScore;
			pMob[conn].extra.SaveCelestial[cl].Class = pMob[conn].MOB.Class;
			pMob[conn].extra.SaveCelestial[cl].Exp = pMob[conn].MOB.Exp;
			pMob[conn].extra.SaveCelestial[cl].LearnedSkill = pMob[conn].MOB.LearnedSkill;
			pMob[conn].extra.SaveCelestial[cl].SecLearnedSkill = pMob[conn].extra.SecLearnedSkill;
			pMob[conn].extra.SaveCelestial[cl].ScoreBonus = pMob[conn].MOB.ScoreBonus;
			pMob[conn].extra.SaveCelestial[cl].SkillBonus = pMob[conn].MOB.SkillBonus;
			pMob[conn].extra.SaveCelestial[cl].SpecialBonus = pMob[conn].MOB.SpecialBonus;
			pMob[conn].extra.SaveCelestial[cl].SPX = pMob[conn].MOB.SPX;
			pMob[conn].extra.SaveCelestial[cl].SPY = pMob[conn].MOB.SPY;

			pMob[conn].extra.SaveCelestial[cl].Soul = pMob[conn].extra.Soul;

			memmove_s(pMob[conn].extra.SaveCelestial[cl].SkillBar1, 4, pMob[conn].MOB.SkillBar, 4);
			memmove_s(pMob[conn].extra.SaveCelestial[cl].SkillBar2, 16, pUser[conn].CharShortSkill, 16);

			pMob[conn].MOB.BaseScore = pMob[conn].extra.SaveCelestial[ncl].BaseScore;
			//pMob[conn].MOB.CurrentScore = pMob[conn].extra.SaveCelestial[ncl].CurrentScore;
			pMob[conn].MOB.Class = pMob[conn].extra.SaveCelestial[ncl].Class;
			pMob[conn].MOB.Exp = pMob[conn].extra.SaveCelestial[ncl].Exp;
			pMob[conn].MOB.LearnedSkill = pMob[conn].extra.SaveCelestial[ncl].LearnedSkill;
			pMob[conn].extra.SecLearnedSkill = pMob[conn].extra.SaveCelestial[ncl].SecLearnedSkill;
			pMob[conn].MOB.ScoreBonus = pMob[conn].extra.SaveCelestial[ncl].ScoreBonus;
			pMob[conn].MOB.SkillBonus = pMob[conn].extra.SaveCelestial[ncl].SkillBonus;
			pMob[conn].MOB.SpecialBonus = pMob[conn].extra.SaveCelestial[ncl].SpecialBonus;
			pMob[conn].MOB.SPX = pMob[conn].extra.SaveCelestial[ncl].SPX;
			pMob[conn].MOB.SPY = pMob[conn].extra.SaveCelestial[ncl].SPY;
			pMob[conn].extra.Soul = pMob[conn].extra.SaveCelestial[ncl].Soul;

			memmove_s(pMob[conn].MOB.SkillBar, 4, pMob[conn].extra.SaveCelestial[ncl].SkillBar1, 4);
			memmove_s(pUser[conn].CharShortSkill, 16, pMob[conn].extra.SaveCelestial[ncl].SkillBar2, 16);

			for (int i = 0; i < MAX_AFFECT; i++)
			{
				if (pMob[conn].Affect[i].Type == 4 || pMob[conn].Affect[i].Type == 8 || pMob[conn].Affect[i].Type == 29 || pMob[conn].Affect[i].Type == 30 || pMob[conn].Affect[i].Type == 34 || pMob[conn].Affect[i].Type == 35 || pMob[conn].Affect[i].Type == 39 || pMob[conn].Affect[i].Type == 51)
					continue;

				memset(&pMob[conn].Affect[i], 0, sizeof(STRUCT_AFFECT));
			}

			pMob[conn].MOB.Equip[0].sIndex = pMob[conn].extra.MortalFace + 5 + pMob[conn].MOB.Class;
			SendItem(conn, ITEM_PLACE_EQUIP, 0, &pMob[conn].MOB.Equip[0]);

			MSG_SetShortSkill sm_sss;
			memset(&sm_sss, 0, sizeof(MSG_SetShortSkill));

			sm_sss.Size = sizeof(MSG_SetShortSkill);
			sm_sss.ID = ESCENE_FIELD;
			sm_sss.Type = _MSG_SetShortSkill;

			memmove_s(sm_sss.Skill1, 4, pMob[conn].extra.SaveCelestial[ncl].SkillBar1, 4);
			memmove_s(sm_sss.Skill2, 16, pMob[conn].extra.SaveCelestial[ncl].SkillBar2, 16);

			int Size = sm_sss.Size;

			if (Size > sizeof(MSG_SetShortSkill))
			{
				sm_sss.Size = 0;
				return;
			}

			if (!pUser[conn].cSock.AddMessage((char*)&sm_sss, sizeof(MSG_SetShortSkill)))
				CloseUser(conn);

			BASE_GetBonusSkillPoint(&pMob[conn].MOB, &pMob[conn].extra);
			BASE_GetBonusScorePoint(&pMob[conn].MOB, &pMob[conn].extra);

			BASE_GetHpMp(&pMob[conn].MOB, &pMob[conn].extra);

			pMob[conn].GetCurrentScore(conn);

			GetGuild(conn);

			SendScore(conn);
			SendEtc(conn);

			ItemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, "useitem,mistery stone change god2god");

			if (amount > 1)
				BASE_SetItemAmount(item, amount - 1);

			else
				memset(item, 0, sizeof(STRUCT_ITEM));

			return;
		}
		else if (isHardCore == 1)
		{
			if (pMob[conn].extra.ClassMaster != CELESTIALCS && pMob[conn].extra.ClassMaster != SCELESTIAL && pMob[conn].extra.ClassMaster != HARDCORECS && pMob[conn].extra.ClassMaster != SHARDCORE)
			{
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			int Village = BASE_GetVillage(pMob[conn].TargetX, pMob[conn].TargetY);

			if (Village < 0 || Village >= 5)
			{
				SendClientMessage(conn, g_pMessageStringTable[_NN_OnlyVillage]);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			int cl = pMob[conn].extra.ClassMaster == CELESTIALCS ? 0 : 1;
			int ncl = pMob[conn].extra.ClassMaster == CELESTIALCS ? 1 : 0;

			int hc = pMob[conn].extra.ClassMaster == HARDCORECS ? 0 : 2;
			int nhc = pMob[conn].extra.ClassMaster == HARDCORECS ? 2 : 0;

			if (pMob[conn].extra.ClassMaster == CELESTIALCS || pMob[conn].extra.ClassMaster == SCELESTIAL)
			{
				if (pMob[conn].extra.ClassMaster == CELESTIALCS)
				{
					pMob[conn].extra.ClassMaster = SCELESTIAL;
					SendClientMessage(conn, "Alternado [Sub Celestial]");
					BASE_GetHpMp(&pMob[conn].MOB, &pMob[conn].extra);
					pMob[conn].extra.QuestInfo.Celestial.CelestialLevel = pMob[conn].MOB.BaseScore.Level;
				}
				else
				{
					pMob[conn].extra.ClassMaster = CELESTIALCS;
					SendClientMessage(conn, "Alternado [Celestial]");
					BASE_GetHpMp(&pMob[conn].MOB, &pMob[conn].extra);
					pMob[conn].extra.QuestInfo.Celestial.SubCelestialLevel = pMob[conn].MOB.BaseScore.Level;
				}
				pMob[conn].extra.SaveCelestial[cl].BaseScore = pMob[conn].MOB.BaseScore;
				pMob[conn].extra.SaveCelestial[cl].Class = pMob[conn].MOB.Class;
				pMob[conn].extra.SaveCelestial[cl].Exp = pMob[conn].MOB.Exp;
				pMob[conn].extra.SaveCelestial[cl].LearnedSkill = pMob[conn].MOB.LearnedSkill;
				pMob[conn].extra.SaveCelestial[cl].SecLearnedSkill = pMob[conn].extra.SecLearnedSkill;
				pMob[conn].extra.SaveCelestial[cl].ScoreBonus = pMob[conn].MOB.ScoreBonus;
				pMob[conn].extra.SaveCelestial[cl].SkillBonus = pMob[conn].MOB.SkillBonus;
				pMob[conn].extra.SaveCelestial[cl].SpecialBonus = pMob[conn].MOB.SpecialBonus;
				pMob[conn].extra.SaveCelestial[cl].SPX = pMob[conn].MOB.SPX;
				pMob[conn].extra.SaveCelestial[cl].SPY = pMob[conn].MOB.SPY;

				pMob[conn].extra.SaveCelestial[cl].Soul = pMob[conn].extra.Soul;

				memmove_s(pMob[conn].extra.SaveCelestial[cl].SkillBar1, 4, pMob[conn].MOB.SkillBar, 4);
				memmove_s(pMob[conn].extra.SaveCelestial[cl].SkillBar2, 16, pUser[conn].CharShortSkill, 16);

				pMob[conn].MOB.BaseScore = pMob[conn].extra.SaveCelestial[ncl].BaseScore;
				pMob[conn].MOB.Class = pMob[conn].extra.SaveCelestial[ncl].Class;
				pMob[conn].MOB.Exp = pMob[conn].extra.SaveCelestial[ncl].Exp;
				pMob[conn].MOB.LearnedSkill = pMob[conn].extra.SaveCelestial[ncl].LearnedSkill;
				pMob[conn].extra.SecLearnedSkill = pMob[conn].extra.SaveCelestial[ncl].SecLearnedSkill;
				pMob[conn].MOB.ScoreBonus = pMob[conn].extra.SaveCelestial[ncl].ScoreBonus;
				pMob[conn].MOB.SkillBonus = pMob[conn].extra.SaveCelestial[ncl].SkillBonus;
				pMob[conn].MOB.SpecialBonus = pMob[conn].extra.SaveCelestial[ncl].SpecialBonus;
				pMob[conn].MOB.SPX = pMob[conn].extra.SaveCelestial[ncl].SPX;
				pMob[conn].MOB.SPY = pMob[conn].extra.SaveCelestial[ncl].SPY;
				pMob[conn].extra.Soul = pMob[conn].extra.SaveCelestial[ncl].Soul;

				memmove_s(pMob[conn].MOB.SkillBar, 4, pMob[conn].extra.SaveCelestial[ncl].SkillBar1, 4);
				memmove_s(pUser[conn].CharShortSkill, 16, pMob[conn].extra.SaveCelestial[ncl].SkillBar2, 16);

				for (int i = 0; i < MAX_AFFECT; i++)
				{
					if (pMob[conn].Affect[i].Type == 4 || pMob[conn].Affect[i].Type == 8 || pMob[conn].Affect[i].Type == 29 || pMob[conn].Affect[i].Type == 30 || pMob[conn].Affect[i].Type == 34 || pMob[conn].Affect[i].Type == 35 || pMob[conn].Affect[i].Type == 39)
						continue;

					memset(&pMob[conn].Affect[i], 0, sizeof(STRUCT_AFFECT));
				}

				pMob[conn].MOB.Equip[0].sIndex = pMob[conn].extra.MortalFace + 5 + pMob[conn].MOB.Class;
				SendItem(conn, ITEM_PLACE_EQUIP, 0, &pMob[conn].MOB.Equip[0]);

				MSG_SetShortSkill sm_sss;
				memset(&sm_sss, 0, sizeof(MSG_SetShortSkill));

				sm_sss.Size = sizeof(MSG_SetShortSkill);
				sm_sss.ID = ESCENE_FIELD;
				sm_sss.Type = _MSG_SetShortSkill;

				memmove_s(sm_sss.Skill1, 4, pMob[conn].extra.SaveCelestial[ncl].SkillBar1, 4);
				memmove_s(sm_sss.Skill2, 16, pMob[conn].extra.SaveCelestial[ncl].SkillBar2, 16);

				int Size = sm_sss.Size;

				if (Size > sizeof(MSG_SetShortSkill))
				{
					sm_sss.Size = 0;
					return;
				}

				if (!pUser[conn].cSock.AddMessage((char*)&sm_sss, sizeof(MSG_SetShortSkill)))
					CloseUser(conn);

				BASE_GetBonusSkillPoint(&pMob[conn].MOB, &pMob[conn].extra);
				BASE_GetBonusScorePoint(&pMob[conn].MOB, &pMob[conn].extra);

				BASE_GetHpMp(&pMob[conn].MOB, &pMob[conn].extra);
				pMob[conn].GetCurrentScore(conn);

				GetGuild(conn);

				SendScore(conn);
				SendEtc(conn);

				ItemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, "useitem,mistery stone change god2god");

				if (amount > 1)
					BASE_SetItemAmount(item, amount - 1);

				else
					memset(item, 0, sizeof(STRUCT_ITEM));

				return;
			}

			if (pMob[conn].extra.ClassMaster == HARDCORECS || pMob[conn].extra.ClassMaster == SHARDCORE)
			{
				if (pMob[conn].extra.ClassMaster == HARDCORECS)
				{
					pMob[conn].extra.ClassMaster = SHARDCORE;
					SendClientMessage(conn, "Alternado [Sub HardCore]");
					pMob[conn].extra.QuestInfo.Celestial.CelestialLevel = pMob[conn].MOB.BaseScore.Level;
				}
				else
				{
					pMob[conn].extra.ClassMaster = HARDCORECS;
					SendClientMessage(conn, "Alternado [HardCore]");
					pMob[conn].extra.QuestInfo.Celestial.SubCelestialLevel = pMob[conn].MOB.BaseScore.Level;
				}
				pMob[conn].extra.SaveCelestial[hc].BaseScore = pMob[conn].MOB.BaseScore;
				pMob[conn].extra.SaveCelestial[hc].Class = pMob[conn].MOB.Class;
				pMob[conn].extra.SaveCelestial[hc].Exp = pMob[conn].MOB.Exp;
				pMob[conn].extra.SaveCelestial[hc].LearnedSkill = pMob[conn].MOB.LearnedSkill;
				pMob[conn].extra.SaveCelestial[hc].SecLearnedSkill = pMob[conn].extra.SecLearnedSkill;
				pMob[conn].extra.SaveCelestial[hc].ScoreBonus = pMob[conn].MOB.ScoreBonus;
				pMob[conn].extra.SaveCelestial[hc].SkillBonus = pMob[conn].MOB.SkillBonus;
				pMob[conn].extra.SaveCelestial[hc].SpecialBonus = pMob[conn].MOB.SpecialBonus;
				pMob[conn].extra.SaveCelestial[hc].SPX = pMob[conn].MOB.SPX;
				pMob[conn].extra.SaveCelestial[hc].SPY = pMob[conn].MOB.SPY;

				pMob[conn].extra.SaveCelestial[hc].Soul = pMob[conn].extra.Soul;

				memmove_s(pMob[conn].extra.SaveCelestial[hc].SkillBar1, 4, pMob[conn].MOB.SkillBar, 4);
				memmove_s(pMob[conn].extra.SaveCelestial[hc].SkillBar2, 16, pUser[conn].CharShortSkill, 16);

				pMob[conn].MOB.BaseScore = pMob[conn].extra.SaveCelestial[nhc].BaseScore;
				pMob[conn].MOB.Class = pMob[conn].extra.SaveCelestial[nhc].Class;
				pMob[conn].MOB.Exp = pMob[conn].extra.SaveCelestial[nhc].Exp;
				pMob[conn].MOB.LearnedSkill = pMob[conn].extra.SaveCelestial[nhc].LearnedSkill;
				pMob[conn].extra.SecLearnedSkill = pMob[conn].extra.SaveCelestial[nhc].SecLearnedSkill;
				pMob[conn].MOB.ScoreBonus = pMob[conn].extra.SaveCelestial[nhc].ScoreBonus;
				pMob[conn].MOB.SkillBonus = pMob[conn].extra.SaveCelestial[nhc].SkillBonus;
				pMob[conn].MOB.SpecialBonus = pMob[conn].extra.SaveCelestial[nhc].SpecialBonus;
				pMob[conn].MOB.SPX = pMob[conn].extra.SaveCelestial[nhc].SPX;
				pMob[conn].MOB.SPY = pMob[conn].extra.SaveCelestial[nhc].SPY;
				pMob[conn].extra.Soul = pMob[conn].extra.SaveCelestial[nhc].Soul;

				memmove_s(pMob[conn].MOB.SkillBar, 4, pMob[conn].extra.SaveCelestial[nhc].SkillBar1, 4);
				memmove_s(pUser[conn].CharShortSkill, 16, pMob[conn].extra.SaveCelestial[nhc].SkillBar2, 16);

				for (int i = 0; i < MAX_AFFECT; i++)
				{
					if (pMob[conn].Affect[i].Type == 4 || pMob[conn].Affect[i].Type == 8 || pMob[conn].Affect[i].Type == 29 || pMob[conn].Affect[i].Type == 30 || pMob[conn].Affect[i].Type == 34 || pMob[conn].Affect[i].Type == 35 || pMob[conn].Affect[i].Type == 39)
						continue;

					memset(&pMob[conn].Affect[i], 0, sizeof(STRUCT_AFFECT));
				}

				pMob[conn].MOB.Equip[0].sIndex = pMob[conn].extra.MortalFace + 5 + pMob[conn].MOB.Class;
				SendItem(conn, ITEM_PLACE_EQUIP, 0, &pMob[conn].MOB.Equip[0]);

				MSG_SetShortSkill sm_sss;
				memset(&sm_sss, 0, sizeof(MSG_SetShortSkill));

				sm_sss.Size = sizeof(MSG_SetShortSkill);
				sm_sss.ID = ESCENE_FIELD;
				sm_sss.Type = _MSG_SetShortSkill;

				memmove_s(sm_sss.Skill1, 4, pMob[conn].extra.SaveCelestial[nhc].SkillBar1, 4);
				memmove_s(sm_sss.Skill2, 16, pMob[conn].extra.SaveCelestial[nhc].SkillBar2, 16);

				int Size = sm_sss.Size;

				if (Size > sizeof(MSG_SetShortSkill))
				{
					sm_sss.Size = 0;
					return;
				}

				if (!pUser[conn].cSock.AddMessage((char*)&sm_sss, sizeof(MSG_SetShortSkill)))
					CloseUser(conn);

				BASE_GetBonusSkillPoint(&pMob[conn].MOB, &pMob[conn].extra);
				BASE_GetBonusScorePoint(&pMob[conn].MOB, &pMob[conn].extra);

				BASE_GetHpMp(&pMob[conn].MOB, &pMob[conn].extra);
				pMob[conn].GetCurrentScore(conn);

				GetGuild(conn);

				SendScore(conn);
				SendEtc(conn);

				ItemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, "useitem,mistery stone change god2god");

				if (amount > 1)
					BASE_SetItemAmount(item, amount - 1);

				else
					memset(item, 0, sizeof(STRUCT_ITEM));

				return;
			}
		}
	}
#pragma endregion
#pragma region Escritura do Pesadelo
	if (Vol == 212)
	{
		time_t mtime;

		time(&mtime);

		if (mtime < (pMob[conn].extra.LastNT + 43200))
		{
			int rtime = (int)((43200 - (mtime - pMob[conn].extra.LastNT)) / 60 / 60);
			int rmin = (int)((43200 - (mtime - pMob[conn].extra.LastNT)) / 60 - (rtime * 60));

			SendMsgExp(conn, strFmt(g_pMessageStringTable[_DD_NightmareTime], rtime, rmin), TNColor::Default, false);

			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		pMob[conn].extra.LastNT = mtime;
		pMob[conn].extra.NT += 13;


		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));

		return;
	}
#pragma endregion
#pragma region Selo do Guerreiro
	if (item->sIndex == 4146)
	{
		pUser[conn].UseItemTime = GetTickCount64();

		if (pMob[conn].extra.Fame >= 2000000000)
			pMob[conn].extra.Fame = 2000000000;

		pMob[conn].extra.Fame += 10;

		SendEmotion(conn, 14, 3);

		if (pMob[conn].extra.ClassMaster == MORTAL && pMob[conn].MOB.CurrentScore.Level >= 354 && pMob[conn].MOB.Equip[15].sIndex != 3191 && pMob[conn].MOB.Equip[15].sIndex != 3192 && pMob[conn].MOB.Equip[15].sIndex != 3193 && pMob[conn].MOB.Equip[15].sIndex != 3194 && pMob[conn].MOB.Equip[15].sIndex != 3195 && pMob[conn].MOB.Equip[15].sIndex != 3196)
		{
			memset(&pMob[conn].MOB.Equip[15], 0, sizeof(STRUCT_ITEM));

			if (pMob[conn].MOB.Clan == 7)
				pMob[conn].MOB.Equip[15].sIndex = 3191;

			else if (pMob[conn].MOB.Clan == 8)
				pMob[conn].MOB.Equip[15].sIndex = 3192;

			else
				pMob[conn].MOB.Equip[15].sIndex = 3193;

			SendItem(conn, ITEM_PLACE_EQUIP, 15, &pMob[conn].MOB.Equip[15]);
		}

		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));

		return;
	}
#pragma endregion
#pragma region Cristal - Elime - Sylphed - Thelion - Noas
	if (Vol == 187)
	{
		if (pMob[conn].extra.ClassMaster == CELESTIAL || pMob[conn].extra.ClassMaster == CELESTIALCS || pMob[conn].extra.ClassMaster == SCELESTIAL) {
			int quest = item->sIndex - 4106 + 1;

			if (pMob[conn].extra.QuestInfo.Arch.Cristal == quest)
			{
				SendClientMessage(conn, g_pMessageStringTable[_NN_Youve_Done_It_Already]);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if (pMob[conn].extra.QuestInfo.Arch.Cristal >= quest)
			{
				SendClientMessage(conn, g_pMessageStringTable[_NN_Youve_Done_It_Already]);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if (pMob[conn].extra.QuestInfo.Arch.Cristal != quest - 1)
			{
				SendClientMessage(conn, g_pMessageStringTable[_NN_Need_BeforeQuest]);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			pMob[conn].extra.QuestInfo.Arch.Cristal = quest;

			pMob[conn].MOB.Exp -= 100000000;

			int newlevel = 0;

			for (int i = 0; i < MAX_LEVEL; i++)
			{
				if (pMob[conn].MOB.Exp >= g_pNextLevel[i] && pMob[conn].MOB.Exp <= g_pNextLevel[i + 1])
					newlevel = i;
			}

			pMob[conn].MOB.BaseScore.Level = newlevel;
			int check = pMob[conn].CheckGetLevel();

			if (check == 4)
				SetCircletSubGod(conn);

			BASE_GetBonusScorePoint(&pMob[conn].MOB, &pMob[conn].extra);

			pMob[conn].GetCurrentScore(conn);
			SendEtc(conn);
			SendScore(conn);
			SaveUser(conn, 0);
			SendEmotion(conn, 14, 3);

			SendMsgExp(conn, strFmt(g_pMessageStringTable[_DN_Play_Quest], g_pItemList[item->sIndex].Name), TNColor::Default, false);


			if (amount > 1)
				BASE_SetItemAmount(item, amount - 1);
			else
				memset(item, 0, sizeof(STRUCT_ITEM));

			return;
		}
		if (pMob[conn].extra.ClassMaster == ARCH || pMob[conn].extra.ClassMaster == HARDCOREA)
		{
			if (pMob[conn].extra.ClassMaster == ARCH)
			{
				if (pMob[conn].MOB.CurrentScore.Level == 369)
				{
					SendClientMessage(conn, "Quest não pode ser concluída no nível 370.");
					SendItem(conn, m->SourType, m->SourPos, item);
					return;
				}

				if (pMob[conn].MOB.CurrentScore.Level < 355)
				{
					SendMsgExp(conn, strFmt(g_pMessageStringTable[_DN_Level_Limit], 356), TNColor::Default, false);
					SendItem(conn, m->SourType, m->SourPos, item);
					return;
				}
				else
				{
					int quest = item->sIndex - 4106 + 1;

					if (pMob[conn].extra.QuestInfo.Arch.Cristal == quest)
					{
						SendClientMessage(conn, g_pMessageStringTable[_NN_Youve_Done_It_Already]);
						SendItem(conn, m->SourType, m->SourPos, item);
						return;
					}

					if (pMob[conn].extra.QuestInfo.Arch.Cristal >= quest)
					{
						SendClientMessage(conn, g_pMessageStringTable[_NN_Youve_Done_It_Already]);
						SendItem(conn, m->SourType, m->SourPos, item);
						return;
					}

					if (pMob[conn].extra.QuestInfo.Arch.Cristal != quest - 1)
					{
						SendClientMessage(conn, g_pMessageStringTable[_NN_Need_BeforeQuest]);
						SendItem(conn, m->SourType, m->SourPos, item);
						return;
					}

					pMob[conn].extra.QuestInfo.Arch.Cristal = quest;

					if (quest == 1)
						pMob[conn].MOB.BaseScore.MaxMp += 80;

					else if (quest == 2)
						pMob[conn].MOB.BaseScore.Ac += 30;

					else if (quest == 3)
						pMob[conn].MOB.BaseScore.MaxHp += 80;

					else if (quest == 4)
					{
						pMob[conn].MOB.BaseScore.MaxHp += 60;
						pMob[conn].MOB.BaseScore.MaxMp += 60;
						pMob[conn].MOB.BaseScore.Ac += 20;
					}

					pMob[conn].MOB.Exp -= 100000000;

					int newlevel = 0;

					for (int i = 0; i < MAX_LEVEL; i++)
					{
						if (pMob[conn].MOB.Exp >= g_pNextLevel[i] && pMob[conn].MOB.Exp <= g_pNextLevel[i + 1])
							newlevel = i;
					}

					pMob[conn].MOB.BaseScore.Level = newlevel;
					int check = pMob[conn].CheckGetLevel();

					if (check == 4)
						SetCircletSubGod(conn);

					BASE_GetBonusScorePoint(&pMob[conn].MOB, &pMob[conn].extra);

					pMob[conn].GetCurrentScore(conn);
					SendEtc(conn);
					SendScore(conn);
					SaveUser(conn, 0);
					SendEmotion(conn, 14, 3);

					SendMsgExp(conn, strFmt(g_pMessageStringTable[_DN_Play_Quest], g_pItemList[item->sIndex].Name), TNColor::Default, false);


					if (amount > 1)
						BASE_SetItemAmount(item, amount - 1);
					else
						memset(item, 0, sizeof(STRUCT_ITEM));

					return;
				}
			}
			if (pMob[conn].extra.ClassMaster == HARDCOREA)
			{
				if (pMob[conn].MOB.Exp > 2000000000)
				{
					if (pMob[conn].extra.Fame > 499)
					{
						int quest = item->sIndex - 4106 + 1;
						int score = pMob[conn].MOB.ScoreBonus;

						if (pMob[conn].extra.QuestInfo.Hardcore.Cristal == quest)
						{
							SendClientMessage(conn, g_pMessageStringTable[_NN_Youve_Done_It_Already]);
							SendItem(conn, m->SourType, m->SourPos, item);
							return;
						}

						if (pMob[conn].extra.QuestInfo.Hardcore.Cristal >= quest)
						{
							SendClientMessage(conn, g_pMessageStringTable[_NN_Youve_Done_It_Already]);
							SendItem(conn, m->SourType, m->SourPos, item);
							return;
						}

						if (pMob[conn].extra.QuestInfo.Hardcore.Cristal != quest - 1)
						{
							SendClientMessage(conn, g_pMessageStringTable[_NN_Need_BeforeQuest]);
							SendItem(conn, m->SourType, m->SourPos, item);
							return;
						}

						pMob[conn].extra.QuestInfo.Hardcore.Cristal = quest;

						if (quest == 1) {
							pMob[conn].extra.Fame -= 500;
						}
						else if (quest == 2) {
							pMob[conn].extra.Fame -= 500;
						}
						else if (quest == 3) {
							pMob[conn].extra.Fame -= 500;
						}
						else
						{
							pMob[conn].extra.Fame -= 500;
						}

						pMob[conn].MOB.Exp -= 100000000;

						int newlevel = 0;

						for (int i = 0; i < MAX_CLEVEL; i++)
						{
							if (pMob[conn].MOB.Exp >= g_pNextLevel_2[i] && pMob[conn].MOB.Exp <= g_pNextLevel_2[i + 1])
								newlevel = i;
						}

						pMob[conn].MOB.BaseScore.Level = newlevel;
						int check = pMob[conn].CheckGetLevel();

						if (check == 4)
							SetCircletSubGod(conn);

						BASE_GetBonusScorePoint(&pMob[conn].MOB, &pMob[conn].extra);

						pMob[conn].GetCurrentScore(conn);
						SendEtc(conn);
						SendScore(conn);

						SendEmotion(conn, 14, 3);

						SendMsgExp(conn, strFmt(g_pMessageStringTable[_DN_Play_Quest], g_pItemList[item->sIndex].Name), TNColor::Default, false);


						if (amount > 1)
							BASE_SetItemAmount(item, amount - 1);
						else
							memset(item, 0, sizeof(STRUCT_ITEM));

						return;
					}
					else
					{
						SendItem(conn, m->SourType, m->SourPos, item);
						return;
					}
				}
				else
				{
					SendItem(conn, m->SourType, m->SourPos, item);
					return;
				}
			}
		}
		else
		{
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}
	}
#pragma endregion
#pragma region Pedra da Fúria
	if (item->sIndex == 3020)
	{
		if ((pMob[conn].extra.ClassMaster == CELESTIAL || pMob[conn].extra.ClassMaster == CELESTIALCS || pMob[conn].extra.ClassMaster == SCELESTIAL) && pMob[conn].MOB.CurrentScore.Level >= 199)
		{
			if (!pMob[conn].MOB.Equip[1].sIndex) {
				SendClientMessage(conn, "É Preciso estar com a Cythera equipada");
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if (pMob[conn].extra.Fame < 500)
			{
				SendClientMessage(conn, "Precisa ter mais de 500 pontos de fama");
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if (pMob[conn].extra.QuestInfo.Circle == 0)
			{
				int sAgua = 0;
				int sTerra = 0;
				int sSol = 0;
				int sVento = 0;

				for (int i = 0; i < pMob[conn].MaxCarry; i++)
				{
					if (pMob[conn].MOB.Carry[i].sIndex == 5334)
						sAgua = 1;

					if (pMob[conn].MOB.Carry[i].sIndex == 5335)
						sTerra = 1;

					if (pMob[conn].MOB.Carry[i].sIndex == 5336)
						sSol = 1;

					if (pMob[conn].MOB.Carry[i].sIndex == 5337)
						sVento = 1;
				}

				if (sAgua == 1 && sTerra == 1 && sSol == 1 && sVento == 1)
				{
					for (int i = 0; i < pMob[conn].MaxCarry; i++)
					{
						if (pMob[conn].MOB.Carry[i].sIndex == 5334 && sAgua == 1)
						{
							memset(&pMob[conn].MOB.Carry[i], 0, sizeof(STRUCT_ITEM));
							SendItem(conn, ITEM_PLACE_CARRY, i, &pMob[conn].MOB.Carry[i]);
							sAgua = 0;
						}

						if (pMob[conn].MOB.Carry[i].sIndex == 5335 && sTerra == 1)
						{
							memset(&pMob[conn].MOB.Carry[i], 0, sizeof(STRUCT_ITEM));
							SendItem(conn, ITEM_PLACE_CARRY, i, &pMob[conn].MOB.Carry[i]);
							sTerra = 0;
						}

						if (pMob[conn].MOB.Carry[i].sIndex == 5336 && sSol == 1)
						{
							memset(&pMob[conn].MOB.Carry[i], 0, sizeof(STRUCT_ITEM));
							SendItem(conn, ITEM_PLACE_CARRY, i, &pMob[conn].MOB.Carry[i]);
							sSol = 0;
						}

						if (pMob[conn].MOB.Carry[i].sIndex == 5337 && sVento == 1)
						{
							memset(&pMob[conn].MOB.Carry[i], 0, sizeof(STRUCT_ITEM));
							SendItem(conn, ITEM_PLACE_CARRY, i, &pMob[conn].MOB.Carry[i]);
							sVento = 0;
						}
					}

					pMob[conn].extra.Fame -= 500;

					int _rand = rand() % 115;

					if (_rand > 100)
						_rand -= 15;

					if (_rand < 50)
					{
						if (!pMob[conn].MOB.Equip[1].sIndex)
							memset(&pMob[conn].MOB.Equip[1], 0, sizeof(STRUCT_ITEM));

						pMob[conn].MOB.Equip[1].sIndex = 3507;

						SendItem(conn, ITEM_PLACE_EQUIP, 1, &pMob[conn].MOB.Equip[1]);


						SendEmotion(conn, 14, 3);
						pMob[conn].extra.QuestInfo.Circle = 1;

					}

					else
					{
						SendClientMessage(conn, g_pMessageStringTable[_NN_FAILURE]);
					}
					if (amount > 1)
						BASE_SetItemAmount(item, amount - 1);

					else
						memset(item, 0, sizeof(STRUCT_ITEM));

					return;
				}
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			else if (pMob[conn].extra.QuestInfo.Circle && pMob[conn].extra.QuestInfo.Celestial.Reset < 3)
			{
				pMob[conn].extra.QuestInfo.Celestial.Reset++;
				pMob[conn].extra.Fame -= 500;

				pMob[conn].MOB.Exp -= 20000000;

				int newlevel = pMob[conn].MOB.CurrentScore.Level;

				for (int i = 0; i < MAX_CLEVEL; i++)
				{
					if (pMob[conn].MOB.Exp >= g_pNextLevel_2[i] && pMob[conn].MOB.Exp <= g_pNextLevel_2[i + 1])
						newlevel = i;
				}

				pMob[conn].MOB.BaseScore.Level = newlevel;
				int check = pMob[conn].CheckGetLevel();

				if (check == 4)
					SetCircletSubGod(conn);

				BASE_GetBonusScorePoint(&pMob[conn].MOB, &pMob[conn].extra);

				pMob[conn].GetCurrentScore(conn);
				SendEtc(conn);
				SendScore(conn);

				SendEmotion(conn, 14, 3);


				if (amount > 1)
					BASE_SetItemAmount(item, amount - 1);

				else
					memset(item, 0, sizeof(STRUCT_ITEM));

				return;
			}
		}

		if (pMob[conn].extra.ClassMaster != CELESTIAL)
		{
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (pMob[conn].MOB.CurrentScore.Level < 89)
		{
			SendMsgExp(conn, g_pMessageStringTable[_NN_Level_Limit2], TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (pMob[conn].extra.QuestInfo.Celestial.Lv90 == 1)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Youve_Done_It_Already]);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (pMob[conn].extra.Fame < 500)
		{
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		int _rand = rand() % 115;

		if (_rand > 100)
			_rand -= 15;

		pMob[conn].extra.Fame -= 500;

		if (_rand < 60)
		{
			pMob[conn].extra.QuestInfo.Celestial.Lv90 = 1;

			SendEmotion(conn, 14, 3);

			if (amount > 1)
				BASE_SetItemAmount(item, amount - 1);

			else
				memset(item, 0, sizeof(STRUCT_ITEM));

			STRUCT_ITEM Prize;
			memset(&Prize, 0, sizeof(STRUCT_ITEM));

			Prize.sIndex = 3502;

			PutItem(conn, &Prize);


		}
		else
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_FAILURE]);

			if (amount > 1)
				BASE_SetItemAmount(item, amount - 1);

			else
				memset(item, 0, sizeof(STRUCT_ITEM));

		}

		return;
	}
#pragma endregion
#pragma region Proteção Divina
	if (item->sIndex == 679)
	{
		int _rand = rand() % 115;

		if (_rand > 100)
			_rand -= 15;

		if (pMob[conn].extra.ClassMaster < CELESTIAL)// || pMob[conn].extra.ClassMaster > CELESTIALCS)
		{
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}
		else
		{
			if (pMob[conn].MOB.CurrentScore.Level == 239 || pMob[conn].MOB.CurrentScore.Level == 279 ||
				pMob[conn].MOB.CurrentScore.Level == 319 || pMob[conn].MOB.CurrentScore.Level == 359)
			{
				if (pMob[conn].MOB.CurrentScore.Level == 239)
				{
					if (pMob[conn].extra.QuestInfo.Celestial.Lv240 == 1)
					{
						SendClientMessage(conn, g_pMessageStringTable[_NN_Youve_Done_It_Already]);
						SendItem(conn, m->SourType, m->SourPos, item);
						return;
					}
					else if (_rand < 70)
					{
						pMob[conn].extra.QuestInfo.Celestial.Lv240 = 1;

						SendEmotion(conn, 14, 3);


						if (amount > 1)
							BASE_SetItemAmount(item, amount - 1);

						else
							memset(item, 0, sizeof(STRUCT_ITEM));

						return;
					}
					else
					{
						SendClientMessage(conn, "Falha no destrave de nível.");
						if (amount > 1)
							BASE_SetItemAmount(item, amount - 1);

						else
							memset(item, 0, sizeof(STRUCT_ITEM));

						return;
					}
				}
				if (pMob[conn].MOB.CurrentScore.Level == 279)
				{
					if (pMob[conn].extra.QuestInfo.Celestial.Lv280 == 1)
					{
						SendClientMessage(conn, g_pMessageStringTable[_NN_Youve_Done_It_Already]);
						SendItem(conn, m->SourType, m->SourPos, item);
						return;
					}
					else if (_rand < 70)
					{
						pMob[conn].extra.QuestInfo.Celestial.Lv280 = 1;

						SendEmotion(conn, 14, 3);

						if (amount > 1)
							BASE_SetItemAmount(item, amount - 1);

						else
							memset(item, 0, sizeof(STRUCT_ITEM));


						return;
					}
					else
					{
						SendClientMessage(conn, "Falha no destrave de nível.");
						if (amount > 1)
							BASE_SetItemAmount(item, amount - 1);

						else
							memset(item, 0, sizeof(STRUCT_ITEM));

						return;
					}
				}
				if (pMob[conn].MOB.CurrentScore.Level == 319)
				{
					if (pMob[conn].extra.QuestInfo.Celestial.Lv320 == 1)
					{
						SendClientMessage(conn, g_pMessageStringTable[_NN_Youve_Done_It_Already]);
						SendItem(conn, m->SourType, m->SourPos, item);
						return;
					}
					else if (_rand < 70)
					{
						pMob[conn].extra.QuestInfo.Celestial.Lv320 = 1;

						SendEmotion(conn, 14, 3);


						if (amount > 1)
							BASE_SetItemAmount(item, amount - 1);

						else
							memset(item, 0, sizeof(STRUCT_ITEM));


						return;
					}
					else
					{
						SendClientMessage(conn, "Falha no destrave de nível.");
						if (amount > 1)
							BASE_SetItemAmount(item, amount - 1);

						else
							memset(item, 0, sizeof(STRUCT_ITEM));

						return;
					}
				}
				if (pMob[conn].MOB.CurrentScore.Level == 359)
				{
					if (pMob[conn].extra.QuestInfo.Celestial.Lv360 == 1)
					{
						SendClientMessage(conn, g_pMessageStringTable[_NN_Youve_Done_It_Already]);
						SendItem(conn, m->SourType, m->SourPos, item);
						return;
					}
					else if (_rand < 70)
					{
						pMob[conn].extra.QuestInfo.Celestial.Lv360 = 1;

						SendEmotion(conn, 14, 3);

						if (amount > 1)
							BASE_SetItemAmount(item, amount - 1);

						else
							memset(item, 0, sizeof(STRUCT_ITEM));


						return;
					}
					else
					{
						SendClientMessage(conn, "Falha no destrave de nível.");
						if (amount > 1)
							BASE_SetItemAmount(item, amount - 1);

						else
							memset(item, 0, sizeof(STRUCT_ITEM));

						return;
					}
				}
			}
			else
			{
				SendMsgExp(conn, g_pMessageStringTable[_NN_Level_Limit2], TNColor::Default, false);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}
		}
		return;
	}
#pragma endregion
#pragma region Sussurro Demoníaco
	if (item->sIndex == 3478)
	{
		if (pMob[conn].extra.ClassMaster < CELESTIAL || pMob[conn].extra.ClassMaster > CELESTIALCS)
		{
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}
		else
		{
			if (pMob[conn].MOB.CurrentScore.Level == 239 || pMob[conn].MOB.CurrentScore.Level == 279 ||
				pMob[conn].MOB.CurrentScore.Level == 319 || pMob[conn].MOB.CurrentScore.Level == 359)
			{
				if (pMob[conn].MOB.CurrentScore.Level == 239)
				{
					if (pMob[conn].extra.QuestInfo.Celestial.Lv240 == 1)
					{
						SendClientMessage(conn, g_pMessageStringTable[_NN_Youve_Done_It_Already]);
						SendItem(conn, m->SourType, m->SourPos, item);
						return;
					}
					else
					{
						pMob[conn].extra.QuestInfo.Celestial.Lv240 = 1;

						SendEmotion(conn, 14, 3);


						if (amount > 1)
							BASE_SetItemAmount(item, amount - 1);

						else
							memset(item, 0, sizeof(STRUCT_ITEM));

						return;
					}
				}
				if (pMob[conn].MOB.CurrentScore.Level == 279)
				{
					if (pMob[conn].extra.QuestInfo.Celestial.Lv280 == 1)
					{
						SendClientMessage(conn, g_pMessageStringTable[_NN_Youve_Done_It_Already]);
						SendItem(conn, m->SourType, m->SourPos, item);
						return;
					}
					else
					{
						pMob[conn].extra.QuestInfo.Celestial.Lv280 = 1;

						SendEmotion(conn, 14, 3);

						if (amount > 1)
							BASE_SetItemAmount(item, amount - 1);

						else
							memset(item, 0, sizeof(STRUCT_ITEM));


						return;
					}
				}
				if (pMob[conn].MOB.CurrentScore.Level == 319)
				{
					if (pMob[conn].extra.QuestInfo.Celestial.Lv320 == 1)
					{
						SendClientMessage(conn, g_pMessageStringTable[_NN_Youve_Done_It_Already]);
						SendItem(conn, m->SourType, m->SourPos, item);
						return;
					}
					else
					{
						pMob[conn].extra.QuestInfo.Celestial.Lv320 = 1;

						SendEmotion(conn, 14, 3);

						if (amount > 1)
							BASE_SetItemAmount(item, amount - 1);

						else
							memset(item, 0, sizeof(STRUCT_ITEM));


						return;
					}
				}
				if (pMob[conn].MOB.CurrentScore.Level == 359)
				{
					if (pMob[conn].extra.QuestInfo.Celestial.Lv360 == 1)
					{
						SendClientMessage(conn, g_pMessageStringTable[_NN_Youve_Done_It_Already]);
						SendItem(conn, m->SourType, m->SourPos, item);
						return;
					}
					else
					{
						pMob[conn].extra.QuestInfo.Celestial.Lv360 = 1;

						SendEmotion(conn, 14, 3);

						if (amount > 1)
							BASE_SetItemAmount(item, amount - 1);

						else
							memset(item, 0, sizeof(STRUCT_ITEM));

						return;
					}
				}
			}
			else
			{
				SendMsgExp(conn, g_pMessageStringTable[_NN_Level_Limit2], TNColor::Default, false);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}
		}
		if (pMob[conn].extra.ClassMaster != CELESTIALCS)
		{
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}
		else
		{
			if (pMob[conn].MOB.CurrentScore.Level == 239 || pMob[conn].MOB.CurrentScore.Level == 279 ||
				pMob[conn].MOB.CurrentScore.Level == 319 || pMob[conn].MOB.CurrentScore.Level == 359)
			{
				if (pMob[conn].MOB.CurrentScore.Level == 239)
				{
					if (pMob[conn].extra.QuestInfo.Celestial.Lv240 == 1)
					{
						SendClientMessage(conn, g_pMessageStringTable[_NN_Youve_Done_It_Already]);
						SendItem(conn, m->SourType, m->SourPos, item);
						return;
					}
					else
					{
						pMob[conn].extra.QuestInfo.Celestial.Lv240 = 1;

						SendEmotion(conn, 14, 3);

						if (amount > 1)
							BASE_SetItemAmount(item, amount - 1);

						else
							memset(item, 0, sizeof(STRUCT_ITEM));


						return;
					}
				}
				if (pMob[conn].MOB.CurrentScore.Level == 279)
				{
					if (pMob[conn].extra.QuestInfo.Celestial.Lv280 == 1)
					{
						SendClientMessage(conn, g_pMessageStringTable[_NN_Youve_Done_It_Already]);
						SendItem(conn, m->SourType, m->SourPos, item);
						return;
					}
					else
					{
						pMob[conn].extra.QuestInfo.Celestial.Lv280 = 1;

						SendEmotion(conn, 14, 3);

						if (amount > 1)
							BASE_SetItemAmount(item, amount - 1);

						else
							memset(item, 0, sizeof(STRUCT_ITEM));

						return;
					}
				}
				if (pMob[conn].MOB.CurrentScore.Level == 319)
				{
					if (pMob[conn].extra.QuestInfo.Celestial.Lv320 == 1)
					{
						SendClientMessage(conn, g_pMessageStringTable[_NN_Youve_Done_It_Already]);
						SendItem(conn, m->SourType, m->SourPos, item);
						return;
					}
					else
					{
						pMob[conn].extra.QuestInfo.Celestial.Lv320 = 1;

						SendEmotion(conn, 14, 3);

						if (amount > 1)
							BASE_SetItemAmount(item, amount - 1);

						else
							memset(item, 0, sizeof(STRUCT_ITEM));

						return;
					}
				}
				if (pMob[conn].MOB.CurrentScore.Level == 359)
				{
					if (pMob[conn].extra.QuestInfo.Celestial.Lv360 == 1)
					{
						SendClientMessage(conn, g_pMessageStringTable[_NN_Youve_Done_It_Already]);
						SendItem(conn, m->SourType, m->SourPos, item);
						return;
					}
					else
					{
						pMob[conn].extra.QuestInfo.Celestial.Lv360 = 1;

						SendEmotion(conn, 14, 3);

						if (amount > 1)
							BASE_SetItemAmount(item, amount - 1);

						else
							memset(item, 0, sizeof(STRUCT_ITEM));


						return;
					}
				}
			}
			else
			{
				SendMsgExp(conn, g_pMessageStringTable[_NN_Level_Limit2], TNColor::Default, false);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}
		}
		return;
	}
#pragma endregion
#pragma region Remédio da Coragem
	if (item->sIndex == 4046 || item->sIndex == 646)
	{
		int sAffect = GetEmptyAffect(conn, 30);

		if (sAffect == -1 || pMob[conn].Affect[sAffect].Type == 30 && pMob[conn].Affect[sAffect].Value != 500)
		{
			SendMsgExp(conn, g_pMessageStringTable[_NN_CantEatMore], TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		pMob[conn].Affect[sAffect].Type = 30;
		pMob[conn].Affect[sAffect].Value = 1;
		pMob[conn].Affect[sAffect].Level = 500;
		pMob[conn].Affect[sAffect].Time = 100;

		if (pMob[conn].Affect[sAffect].Time >= 324000)
			pMob[conn].Affect[sAffect].Time = 324000;

		pMob[conn].GetCurrentScore(conn);
		SendScore(conn);

		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));

		return;
	}
#pragma endregion
#pragma region Elixir da Coragem
	if (Vol == 230 && (item->sIndex == 647 || item->sIndex == 3378))
	{
		int sAffect = GetEmptyAffect(conn, 30);

		if (sAffect == -1 || pMob[conn].Affect[sAffect].Type == 30 && pMob[conn].Affect[sAffect].Value != 2000)
		{
			SendMsgExp(conn, g_pMessageStringTable[_NN_CantEatMore], TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		pMob[conn].Affect[sAffect].Type = 30;
		pMob[conn].Affect[sAffect].Value = 1;
		pMob[conn].Affect[sAffect].Level = 2000;
		pMob[conn].Affect[sAffect].Time = item->sIndex != 3378 ? AFFECT_1H : AFFECT_1D * 30;

		if (pMob[conn].Affect[sAffect].Time >= 324000)
			pMob[conn].Affect[sAffect].Time = 324000;

		pMob[conn].GetCurrentScore(conn);
		SendScore(conn);

		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));
		return;
	}
#pragma endregion
#pragma region Feijão magico
	if (Vol == 186)
	{
		STRUCT_ITEM* dest = GetItemPointer(&pMob[conn].MOB, pUser[conn].Cargo, m->DestType, m->DestPos);

		if (dest == NULL)
			return;

		if (m->DestType || m->DestPos >= 9 && m->DestPos < 16 || m->DestType == ITEM_PLACE_EQUIP && m->DestPos == 0)
		{
			SendMsgExp(conn, g_pMessageStringTable[_NN_Only_To_Equips], TNColor::Default, false);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		int sanc = BASE_GetItemSanc(dest);

		if (sanc < 1)
		{
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (sanc < 7)
		{
			SendClientMessage(conn, "Possível somente para equipamentos acima de +6.");
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		int color = item->sIndex - 3407;
		//Removedor
		if (color == 10)
		{
			if ((dest->stEffect[0].cEffect && dest->stEffect[0].cEffect < 116 || dest->stEffect[0].cEffect && dest->stEffect[0].cEffect > 126))
			{
				if ((dest->stEffect[1].cEffect && dest->stEffect[1].cEffect < 116 || dest->stEffect[1].cEffect && dest->stEffect[1].cEffect > 126))
				{
					if ((dest->stEffect[2].cEffect && dest->stEffect[2].cEffect < 116 || dest->stEffect[2].cEffect && dest->stEffect[2].cEffect > 126))
					{
						SendMsgExp(conn, g_pMessageStringTable[_NN_Cant_Refine_More], TNColor::Default, false);
						SendItem(conn, m->SourType, m->SourPos, item);
						return;
					}
					dest->stEffect[2].cEffect = 43;
				}
				else
					dest->stEffect[1].cEffect = 43;
			}
			else
				dest->stEffect[0].cEffect = 43;
		}
		else
		{
			if (dest->stEffect[0].cEffect && dest->stEffect[0].cEffect != 43 && (dest->stEffect[0].cEffect && dest->stEffect[0].cEffect < 116 || dest->stEffect[0].cEffect && dest->stEffect[0].cEffect > 126))
			{
				if (dest->stEffect[1].cEffect && dest->stEffect[1].cEffect != 43 && (dest->stEffect[1].cEffect && dest->stEffect[1].cEffect < 116 || dest->stEffect[1].cEffect && dest->stEffect[1].cEffect > 126))
				{
					if (dest->stEffect[2].cEffect && dest->stEffect[2].cEffect != 43 && (dest->stEffect[2].cEffect && dest->stEffect[2].cEffect < 116 || dest->stEffect[2].cEffect && dest->stEffect[2].cEffect > 126))
					{
						SendMsgExp(conn, g_pMessageStringTable[_NN_Cant_Refine_More], TNColor::Default, false);
						SendItem(conn, m->SourType, m->SourPos, item);
						return;
					}
					dest->stEffect[2].cEffect = 116 + color;
				}
				else
					dest->stEffect[1].cEffect = 116 + color;
			}
			else
				dest->stEffect[0].cEffect = 116 + color;
		}

		pMob[conn].GetCurrentScore(conn);

		SendScore(conn);

		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));

		SendEquip(conn, 0);
		SendItem(conn, m->DestType, m->DestPos, dest);
		SendEmotion(conn, 14, 3);

		return;
	}
#pragma endregion


#pragma region Pergaminho do Perdão
	if (Vol == 203)
	{
		SetPKPoint(conn, 150);

		MSG_CreateMob sm_pp;
		memset(&sm_pp, 0, sizeof(MSG_CreateMob));
		GetCreateMob(conn, &sm_pp);

		GridMulticast(pMob[conn].TargetX, pMob[conn].TargetY, (MSG_STANDARD*)&sm_pp, 0);

		SendEmotion(conn, 14, 3);
		pMob[conn].extra.EMPTY[0] = 0; //remove puniçao cp
		pMob[conn].extra.EMPTY[1] = 0; //remove puniçao cp
		pMob[conn].GetCurrentScore(conn);
		SendScore(conn);
		SendEtc(conn);
		SendClientMessage(conn, "Punições CP foram removidas");
		SaveUser(conn, 0);

		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));

		return;
	}
#pragma endregion
#pragma region Gema de diamante
	if (Vol == 180)
	{
		STRUCT_ITEM* dest = GetItemPointer(&pMob[conn].MOB, pUser[conn].Cargo, m->DestType, m->DestPos);

		if (dest == NULL)
		{
			return;
		}

		if (m->DestType || m->DestPos >= 9 && m->DestPos < 16 || m->DestType == ITEM_PLACE_EQUIP && m->DestPos == 0)
		{
			SendMsgExp(conn, g_pMessageStringTable[_NN_Only_To_Equips], TNColor::Default, false);

			//ItemLog("err,use item fail - dest", pUser[conn].AccountName, pUser[conn].IP);

			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}


		int sanc = BASE_GetItemSanc(dest);
		int ItemId = dest->sIndex;

		if (ItemId >= 631 && ItemId <= 633)
		{
			SendMsgExp(conn, g_pMessageStringTable[_NN_Only_To_Equips], TNColor::Default, false);

			//ItemLog("err,use item fail - dest", pUser[conn].AccountName, pUser[conn].IP);

			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (sanc < REF_10 && g_pItemList[ItemId].Grade < 5)
		{
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (g_pItemList[ItemId].Grade == 6)
			ItemId -= 1;

		else if (g_pItemList[ItemId].Grade == 7)
			ItemId -= 2;

		else if (g_pItemList[ItemId].Grade == 8)
			ItemId -= 3;

		dest->sIndex = ItemId;

		if (sanc == REF_10)
			BASE_SetItemSanc(dest, 10, 0);

		else if (sanc == REF_11)
			BASE_SetItemSanc(dest, 11, 0);

		else if (sanc == REF_12)
			BASE_SetItemSanc(dest, 12, 0);

		else if (sanc == REF_13)
			BASE_SetItemSanc(dest, 13, 0);

		else if (sanc == REF_14)
			BASE_SetItemSanc(dest, 14, 0);

		else if (sanc == REF_15)
			BASE_SetItemSanc(dest, 15, 0);

		pMob[conn].GetCurrentScore(conn);

		SendScore(conn);

		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));

		SendItem(conn, m->DestType, m->DestPos, dest);
		SendEmotion(conn, 14, 3);

		return;
	}
#pragma endregion
#pragma region Gema de esmeralda
	if (Vol == 181)
	{
		STRUCT_ITEM* dest = GetItemPointer(&pMob[conn].MOB, pUser[conn].Cargo, m->DestType, m->DestPos);

		if (dest == NULL)
		{
			return;
		}

		if (m->DestType || m->DestPos >= 9 && m->DestPos < 16 || m->DestType == ITEM_PLACE_EQUIP && m->DestPos == 0)
		{
			SendMsgExp(conn, g_pMessageStringTable[_NN_Only_To_Equips], TNColor::Default, false);

			//ItemLog("err,use item fail - dest", pUser[conn].AccountName, pUser[conn].IP);

			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}


		int sanc = BASE_GetItemSanc(dest);
		int ItemId = dest->sIndex;

		if (ItemId >= 631 && ItemId <= 633)
		{
			SendMsgExp(conn, g_pMessageStringTable[_NN_Only_To_Equips], TNColor::Default, false);

			//ItemLog("err,use item fail - dest", pUser[conn].AccountName, pUser[conn].IP);

			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (sanc < REF_10 && g_pItemList[ItemId].Grade < 5)
		{
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (g_pItemList[ItemId].Grade == 5)
			ItemId += 1;

		else if (g_pItemList[ItemId].Grade == 7)
			ItemId -= 1;

		else if (g_pItemList[ItemId].Grade == 8)
			ItemId -= 2;

		dest->sIndex = ItemId;

		if (sanc == REF_10)
			BASE_SetItemSanc(dest, 10, 1);

		else if (sanc == REF_11)
			BASE_SetItemSanc(dest, 11, 1);

		else if (sanc == REF_12)
			BASE_SetItemSanc(dest, 12, 1);

		else if (sanc == REF_13)
			BASE_SetItemSanc(dest, 13, 1);

		else if (sanc == REF_14)
			BASE_SetItemSanc(dest, 14, 1);

		else if (sanc == REF_15)
			BASE_SetItemSanc(dest, 15, 1);

		pMob[conn].GetCurrentScore(conn);

		SendScore(conn);

		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));

		SendItem(conn, m->DestType, m->DestPos, dest);
		SendEmotion(conn, 14, 3);

		return;
	}
#pragma endregion
#pragma region Gema de Coral
	if (Vol == 182)
	{
		STRUCT_ITEM* dest = GetItemPointer(&pMob[conn].MOB, pUser[conn].Cargo, m->DestType, m->DestPos);

		if (dest == NULL)
		{
			return;
		}

		if (m->DestType || m->DestPos >= 9 && m->DestPos < 16 || m->DestType == ITEM_PLACE_EQUIP && m->DestPos == 0)
		{
			SendMsgExp(conn, g_pMessageStringTable[_NN_Only_To_Equips], TNColor::Default, false);

			//ItemLog("err,use item fail - dest", pUser[conn].AccountName, pUser[conn].IP);

			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}


		int sanc = BASE_GetItemSanc(dest);
		int ItemId = dest->sIndex;

		if (ItemId >= 631 && ItemId <= 633)
		{
			SendMsgExp(conn, g_pMessageStringTable[_NN_Only_To_Equips], TNColor::Default, false);

			//ItemLog("err,use item fail - dest", pUser[conn].AccountName, pUser[conn].IP);

			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (sanc < REF_10 && g_pItemList[ItemId].Grade < 5)
		{
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (g_pItemList[ItemId].Grade == 5)
			ItemId += 2;

		else if (g_pItemList[ItemId].Grade == 6)
			ItemId += 1;

		else if (g_pItemList[ItemId].Grade == 8)
			ItemId -= 1;

		dest->sIndex = ItemId;

		if (sanc == REF_10)
			BASE_SetItemSanc(dest, 10, 2);

		else if (sanc == REF_11)
			BASE_SetItemSanc(dest, 11, 2);

		else if (sanc == REF_12)
			BASE_SetItemSanc(dest, 12, 2);

		else if (sanc == REF_13)
			BASE_SetItemSanc(dest, 13, 2);

		else if (sanc == REF_14)
			BASE_SetItemSanc(dest, 14, 2);

		else if (sanc == REF_15)
			BASE_SetItemSanc(dest, 15, 2);

		pMob[conn].GetCurrentScore(conn);

		SendScore(conn);

		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));

		SendItem(conn, m->DestType, m->DestPos, dest);
		SendEmotion(conn, 14, 3);

		return;
	}
#pragma endregion
#pragma region Gema de Garnet
	if (Vol == 183)
	{
		STRUCT_ITEM* dest = GetItemPointer(&pMob[conn].MOB, pUser[conn].Cargo, m->DestType, m->DestPos);

		if (dest == NULL)
		{
			return;
		}

		if (m->DestType || m->DestPos >= 9 && m->DestPos < 16 || m->DestType == ITEM_PLACE_EQUIP && m->DestPos == 0)
		{
			SendMsgExp(conn, g_pMessageStringTable[_NN_Only_To_Equips], TNColor::Default, false);

			//ItemLog("err,use item fail - dest", pUser[conn].AccountName, pUser[conn].IP);

			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}


		int sanc = BASE_GetItemSanc(dest);
		int ItemId = dest->sIndex;

		if (ItemId >= 631 && ItemId <= 633)
		{
			SendMsgExp(conn, g_pMessageStringTable[_NN_Only_To_Equips], TNColor::Default, false);

			//ItemLog("err,use item fail - dest", pUser[conn].AccountName, pUser[conn].IP);

			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (sanc < REF_10 && g_pItemList[ItemId].Grade < 5)
		{
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (g_pItemList[ItemId].Grade == 5)
			ItemId += 3;

		else if (g_pItemList[ItemId].Grade == 6)
			ItemId += 2;

		else if (g_pItemList[ItemId].Grade == 7)
			ItemId += 1;

		dest->sIndex = ItemId;

		if (sanc == REF_10)
			BASE_SetItemSanc(dest, 10, 3);

		else if (sanc == REF_11)
			BASE_SetItemSanc(dest, 11, 3);

		else if (sanc == REF_12)
			BASE_SetItemSanc(dest, 12, 3);

		else if (sanc == REF_13)
			BASE_SetItemSanc(dest, 13, 3);

		else if (sanc == REF_14)
			BASE_SetItemSanc(dest, 14, 3);

		else if (sanc == REF_15)
			BASE_SetItemSanc(dest, 15, 3);

		pMob[conn].GetCurrentScore(conn);

		SendScore(conn);

		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));

		SendItem(conn, m->DestType, m->DestPos, dest);
		SendEmotion(conn, 14, 3);

		return;
	}
#pragma endregion
#pragma region Entrada do Território
	if (Vol == 188)
	{
		if (pMob[conn].TargetX >= 3604 && pMob[conn].TargetY >= 3601 && pMob[conn].TargetX <= 3690 && pMob[conn].TargetY <= 3690
			|| pMob[conn].TargetX >= 3734 && pMob[conn].TargetY >= 3476 && pMob[conn].TargetX <= 3818 && pMob[conn].TargetY <= 3561
			|| pMob[conn].TargetX >= 3860 && pMob[conn].TargetY >= 3602 && pMob[conn].TargetX <= 3946 && pMob[conn].TargetY <= 3690)
		{
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		int territorio = item->sIndex - 4111;
		pUser[conn].Territorio = 0;

		if (territorio == 0 && pMob[conn].extra.ClassMaster != MORTAL)
		{
			SendItem(conn, m->SourType, m->SourPos, item);
			SendClientMessage(conn, "Entrada permitida apenas para Mortal");
			return;
		}
		if (territorio == 1 && (pMob[conn].extra.ClassMaster != ARCH))
		{
			SendItem(conn, m->SourType, m->SourPos, item);
			SendClientMessage(conn, "Entrada permitida apenas para Arch");
			return;
		}
		if (territorio == 2 && (pMob[conn].extra.ClassMaster < CELESTIAL))
		{
			SendItem(conn, m->SourType, m->SourPos, item);
			SendClientMessage(conn, "Entrada permitida apenas para Celestial");
			return;
		}

		if (territorio == 0)
		{
			SendRecaptcha(conn, 1);
		}

		else if (territorio == 1)
		{
			SendRecaptcha(conn, 2);
		}

		else
		{
			SendRecaptcha(conn, 3);
		}

		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));

		return;
	}
#pragma endregion
#pragma region Barra de Prata
	if (Vol == 185)
	{
		int gold = 0;

		if (item->sIndex == 4010)
			gold = 100000000;

		else if (item->sIndex == 4011)
			gold = 1000000000;

		else if (item->sIndex == 4026)
			gold = 1000000;

		else if (item->sIndex == 4027)
			gold = 5000000;

		else if (item->sIndex == 4028)
			gold = 10000000;

		else if (item->sIndex == 4029)
			gold = 50000000;

		unsigned int fGold = pMob[conn].MOB.Coin + gold;

		if (fGold > 2000000000)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Cant_get_more_than_2G]);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		pMob[conn].MOB.Coin = fGold;
		SendEtc(conn);
		SendEmotion(conn, 14, 3);
		SaveUser(conn, 0);

		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));

		return;
	}
#pragma endregion
#pragma region Jóias PvP
	if (Vol == 242)
	{
		int sAffect = GetEmptyAffect(conn, 8);

		int joia = 0;

		if (item->sIndex == 3200)
			joia = 0;

		else if (item->sIndex == 3201)
			joia = 1;

		else if (item->sIndex == 3202)
			joia = 2;

		else if (item->sIndex == 3204)
			joia = 3;

		else if (item->sIndex == 3205)
			joia = 4;

		else if (item->sIndex == 3206)
			joia = 5;

		else if (item->sIndex == 3208)
			joia = 6;


		else if (item->sIndex == 3209)
			joia = 7;

		if (sAffect == -1)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_CantEatMore]);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (pMob[conn].Affect[sAffect].Time >= AFFECT_1H * 23) {
			SendClientMessage(conn, g_pMessageStringTable[_NN_CantEatMore]);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (pMob[conn].Affect[sAffect].Type != 8)
		{
			pMob[conn].Affect[sAffect].Type = 8;
			pMob[conn].Affect[sAffect].Level = 1 << joia;
			pMob[conn].Affect[sAffect].Value = 0;
		}

		else if ((pMob[conn].Affect[sAffect].Level & (1 << joia)) == 0)
			pMob[conn].Affect[sAffect].Level |= 1 << joia;

		
		pMob[conn].Affect[sAffect].Time += AFFECT_1H;		

		pMob[conn].GetCurrentScore(conn);
		SendScore(conn);

		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));

		return;
	}
#pragma endregion
#pragma region Armazenagem - Recuperação
	if (Vol == 243)
	{
		if (item->sIndex == 3203)
		{
			int flagSkillOff = FALSE;

			for (int k = 0; k < MAX_AFFECT; k++)
			{
				int skillAffectType = pMob[conn].Affect[k].Type;
				if (skillAffectType == 1 || skillAffectType == 3 || skillAffectType == 5 || skillAffectType == 7 || skillAffectType == 10 || skillAffectType == 12 || skillAffectType == 20 || skillAffectType == 32)
				{
					pMob[conn].Affect[k].Type = 0;
					flagSkillOff = TRUE;
				}
			}

			if (flagSkillOff == TRUE)
			{
				pMob[conn].GetCurrentScore(conn);
				SendScore(conn);
			}
		}

		if (item->sIndex == 3207)
			pMob[conn].JoiaOn = TRUE;

		if (item->sIndex == 415)
		{
			int flagSkillOff = FALSE;

			for (int k = 0; k < MAX_AFFECT; k++)
			{
				int skillAffectType = pMob[conn].Affect[k].Type;
				if (skillAffectType == 20 || skillAffectType == 1)
				{
					pMob[conn].Affect[k].Type = 0;
					flagSkillOff = TRUE;
				}
			}

			if (flagSkillOff == TRUE)
			{
				pMob[conn].GetCurrentScore(conn);
				SendScore(conn);
			}
		}

		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));

		return;
	}
#pragma endregion

#pragma region Selo das Almas
	if (Vol == 206)
	{
		if (item->stEffect[0].cEffect == 0)
		{//Selo Vazio
			if (pMob[conn].extra.ClassMaster != CELESTIAL)
			{
				SendClientMessage(conn, g_pMessageStringTable[_NN_GOD2CHARONLY_]);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}
			if (amount > 1)
				BASE_SetItemAmount(item, amount - 1);

			else
				memset(item, 0, sizeof(STRUCT_ITEM));
			CharLogOut(conn);

			MSG_STANDARDPARM sm_sa;
			memset(&sm_sa, 0, sizeof(MSG_STANDARDPARM));

			sm_sa.Size = sizeof(MSG_STANDARDPARM);
			sm_sa.Type = _MSG_DBPutInCapsule;
			sm_sa.ID = conn;

			sm_sa.Parm = pUser[conn].Slot;

			DBServerSocket.SendOneMessage((char*)&sm_sa, sizeof(MSG_STANDARDPARM));
		}

		return;
	}
#pragma endregion
	// EF_VOLATILE,184 - para caixas
#pragma region Bolsa da Sorte
	if (item->sIndex == 4104)
	{
		STRUCT_ITEM Item;
		memset(&Item, 0, sizeof(STRUCT_ITEM));

		int _rand = rand() % 100;

		if (_rand >= 0 && _rand <= 49) {
			int srand = rand() % 3;

			if (srand == 0) {
				Item.sIndex = 3326; // Pesa A
				Item.stEffect[0].cEffect = 61;
				Item.stEffect[0].cValue = 2;
			}
			else if (srand == 1) {
				Item.sIndex = 4141; //Lac 100
				Item.stEffect[0].cEffect = 0;
				Item.stEffect[0].cValue = 0;
			}
			else if (srand == 2) {
				Item.sIndex = 3182; // Perga A
				Item.stEffect[0].cEffect = 61;
				Item.stEffect[0].cValue = 15;
			}
		}
		if (_rand >= 50 && _rand <= 76) {
			int srand = rand() % 3;

			if (srand == 0) {
				Item.sIndex = 3326; // Pesa A
				Item.stEffect[0].cEffect = 61;
				Item.stEffect[0].cValue = 4;
			}
			else if (srand == 1) {
				Item.sIndex = 4141; // Lac 100
				Item.stEffect[0].cEffect = 61;
				Item.stEffect[0].cValue = 2;
			}
			else if (srand == 2) {
				Item.sIndex = 3182; // Perga A
				Item.stEffect[0].cEffect = 61;
				Item.stEffect[0].cValue = 30;
			}
		}
		if (_rand >= 77 && _rand <= 92) {
			int srand = rand() % 3;

			if (srand == 0) {
				Item.sIndex = 2411; // Âmago de Uni
				Item.stEffect[0].cEffect = 61;
				Item.stEffect[0].cValue = 15;
			}
			else if (srand == 1) {
				Item.sIndex = 2412; // Âmago de unisus
				Item.stEffect[0].cEffect = 61;
				Item.stEffect[0].cValue = 15;
			}
			else if (srand == 2) {
				Item.sIndex = 2413; // Âmago de Pégasus
				Item.stEffect[0].cEffect = 61;
				Item.stEffect[0].cValue = 15;
			}
		}
		if (_rand >= 93 && _rand <= 100) {
			int srand = rand() % 2;

			if (srand == 0) {
				Item.sIndex = 4010; //Barra 100kk
			}
			else if (srand == 1) {
				Item.sIndex = 3379; //Divina 7 Dias
			}
		}
		PutItem(conn, &Item);		

		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));

		SendCarry(conn);
		SendClientMessage(conn, strFmt("O item [%s] Foi entregue!", g_pItemList[Item.sIndex].Name));
		return;
	}
#pragma endregion
#pragma region Caixa de Arma Anct
	if (item->sIndex == 5772)
	{
		STRUCT_ITEM Item;
		memset(&Item, 0, sizeof(STRUCT_ITEM));
				
		int srand = rand() % 2;

		int ArmasDN[] = { 2487, 2547, 2607, 2727, 2787, 2891, 2931 };
		int ArmasMG[] = { 2667, 2847, 2855 };
		
		if (srand == 0) {
			int _rand = rand() % (sizeof(ArmasDN) / 4);
			Item.sIndex = ArmasDN[_rand];
			Item.stEffect[0].cEffect = 43;
			Item.stEffect[0].cValue = 9;
			Item.stEffect[1].cEffect = 2;
			Item.stEffect[1].cValue = 72;
		}
		else {
			int _rand = rand() % (sizeof(ArmasMG) / 4);
			Item.sIndex = ArmasMG[_rand];
			Item.stEffect[0].cEffect = 43;
			Item.stEffect[0].cValue = 9;
			Item.stEffect[1].cEffect = 60;
			Item.stEffect[1].cValue = 32;
		}

		PutItem(conn, &Item);

		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));

		SendCarry(conn);
		SendClientMessage(conn, strFmt("O item [%s] Foi entregue!", g_pItemList[Item.sIndex].Name));
		return;
	}
#pragma endregion
#pragma region Caixa de Planeta Aleatório
	if (item->sIndex == 5773)
	{
		STRUCT_ITEM Item;
		memset(&Item, 0, sizeof(STRUCT_ITEM));

		int Planetas[] = { 762, 763, 764, 765, 767 };

		int _rand = rand() % (sizeof(Planetas) / 4);
		Item.sIndex = Planetas[_rand];
		Item.stEffect[0].cEffect = 43;
		Item.stEffect[0].cValue = 9;

		PutItem(conn, &Item);

		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));

		SendCarry(conn);
		SendClientMessage(conn, strFmt("O item [%s] Foi entregue!", g_pItemList[Item.sIndex].Name));
		return;
	}
#pragma endregion
#pragma region Bolsa do Andarilho
	if (item->sIndex == 3467)
	{
		if (pMob[conn].MOB.Carry[60].sIndex == 3467 && pMob[conn].MOB.Carry[61].sIndex == 3467)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_MAX_BAG]);
			return;
		}

		if (pMob[conn].MOB.Carry[60].sIndex != 3467)
		{
			pMob[conn].MOB.Carry[60].sIndex = 3467;
			BASE_SetItemDate(&pMob[conn].MOB.Carry[60], 30);
			SendCarry(conn);
		}
		else
		{
			pMob[conn].MOB.Carry[61].sIndex = 3467;
			BASE_SetItemDate(&pMob[conn].MOB.Carry[61], 30);
			SendCarry(conn);
		}

		SendScore(conn);
		SendEtc(conn);
		SaveUser(conn, 0);

		pMob[conn].MaxCarry = 30;

		if (pMob[conn].MOB.Carry[60].sIndex == 3467)
			pMob[conn].MaxCarry += 15;

		if (pMob[conn].MOB.Carry[61].sIndex == 3467)
			pMob[conn].MaxCarry += 15;

		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));

		SendCarry(conn);

		return;
	}
#pragma endregion
#pragma region Flash Prateado
	if (item->sIndex == 3451)
	{
		if (pMob[conn].MOB.Equip[13].sIndex == 0)
		{
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}
		if (pMob[conn].MOB.Equip[13].sIndex == 3914)
		{
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}
		if (pMob[conn].MOB.Equip[13].sIndex == 3902 || pMob[conn].MOB.Equip[13].sIndex == 3905 || pMob[conn].MOB.Equip[13].sIndex == 3908)
		{
			pMob[conn].MOB.Equip[13].sIndex = 3914;
			SendItem(conn, ITEM_PLACE_EQUIP, 13, &pMob[conn].MOB.Equip[13]);


			if (amount > 1)
				BASE_SetItemAmount(item, amount - 1);

			else
				memset(item, 0, sizeof(STRUCT_ITEM));
			return;
		}
	}
#pragma endregion
#pragma region Flash Dourado
	if (item->sIndex == 3452)
	{
		if (pMob[conn].MOB.Equip[13].sIndex == 0)
		{
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}
		if (pMob[conn].MOB.Equip[13].sIndex == 3915)
		{
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}
		if (pMob[conn].MOB.Equip[13].sIndex == 3902 || pMob[conn].MOB.Equip[13].sIndex == 3905 || pMob[conn].MOB.Equip[13].sIndex == 3908)
		{
			pMob[conn].MOB.Equip[13].sIndex = 3915;
			SendItem(conn, ITEM_PLACE_EQUIP, 13, &pMob[conn].MOB.Equip[13]);


			if (amount > 1)
				BASE_SetItemAmount(item, amount - 1);

			else
				memset(item, 0, sizeof(STRUCT_ITEM));
			return;
		}
	}
#pragma endregion
#pragma region Acelerador de Nascimento
	if (item->sIndex == 3438)
	{
		STRUCT_ITEM* dest = GetItemPointer(&pMob[conn].MOB, pUser[conn].Cargo, m->DestType, m->DestPos);

		if (dest == NULL)
			return;

		if (m->DestPos != 14 || !dest)
		{
			SendItem(conn, m->SourType, m->SourPos, item);
			SendClientMessage(conn, "Utilizado somente em Ovos.");
			return;
		}

		if (dest->sIndex >= 2330 && dest->sIndex <= 2389)
		{
			SendItem(conn, m->SourType, m->SourPos, item);
			SendClientMessage(conn, "Utilizado somente em Ovos.");
			return;
		}

		dest->sIndex += 30;

		dest->stEffect[0].sValue = 20000;
		dest->stEffect[1].cEffect = 1;
		dest->stEffect[1].cValue = rand() % 20 + 10;
		dest->stEffect[2].cEffect = 30;
		dest->stEffect[2].cValue = 1;

		SendMsgExp(conn, g_pMessageStringTable[_NN_INCUBATED], TNColor::Default, false);
		MountProcess(conn, &pMob[conn].MOB.Equip[14]);

		AmountMinus(item);

		SendItem(conn, m->DestType, m->DestPos, dest);

		SendClientMessage(conn, "Seu ovo chocou !");
		SaveUser(conn, 0);

		return;
	}
#pragma endregion
#pragma region >> Catalizadores
	if (Vol == 94)
	{
		STRUCT_ITEM* dest = GetItemPointer(&pMob[conn].MOB, pUser[conn].Cargo, m->DestType, m->DestPos);

		if (dest == NULL)
		{
			return;
		}

		if (m->DestType || m->DestPos != 14)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Mount_Not_Match]);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}


		int mount = (dest->sIndex);
		int cat = item->sIndex - 3344;

		// Kapel
		if (mount >= 2333 && mount <= 2335) //Dente de Sabre, Dragão Menor, Urso
			mount = 0;

		// Acuban
		if (mount >= 2336 && mount <= 2338 || mount >= 2341 && mount <= 2343 || mount >= 2357 && mount <= 2358) // Cavalo Leve N e B, Cavalo Fantasma N e B, Cavalo S/Sela N e B, Svaldfire e Spleinir
			mount = 1;

		// Mencar
		if (mount == 2339 || mount == 2340 || mount >= 2344 && mount <= 2345) //  Andaluz N e B, Equipe N e B
			mount = 2;

		// Birago
		if (mount >= 2346 && mount <= 2348) //Dragão, Fenri das Sombras, Fenri
			mount = 3;

		// Yus
		if (mount >= 2351 && mount <= 2353) //Pegasus, Unisus
			mount = 4;

		// Makav
		if (mount >= 2354 && mount <= 2356) // Grifo, Hipo-Grifo, Grifo Sangrento
			mount = 5;

		// Alperath
		if (mount >= 2349 && mount <= 2350) //Dragão Vermelho, Tigre de Fogo
			mount = 6;

		if (mount != cat)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Mount_Not_Match]);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		dest->sIndex += 30;

		int life = dest->stEffect[1].cValue;
		dest->stEffect[1].cValue = life + rand() % 20 + 1;
		dest->stEffect[1].cEffect = 0;
		dest->stEffect[2].cValue = 0;

		SendClientMessage(conn, g_pMessageStringTable[_NN_Mount_Growth]);
		MountProcess(conn, &pMob[conn].MOB.Equip[14]);


		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));

		SendItem(conn, m->DestType, m->DestPos, dest);

		int sFace = pMob[conn].MOB.Equip[0].sIndex / 10;

		if (sFace)
			SendEmotion(conn, 15, 0);
		else
			SendEmotion(conn, 20, 0);

		SendItem(conn, m->DestType, m->DestPos, dest);

		RemoveParty(conn);

		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));

		SaveUser(conn, 0);
		return;
	}
#pragma endregion	
#pragma region Restauradores
	if (Vol == 93)
	{
		STRUCT_ITEM* dest = GetItemPointer(&pMob[conn].MOB, pUser[conn].Cargo, m->DestType, m->DestPos);

		if (dest == NULL)
			return;

		if (m->DestPos != 14 || !dest)
		{
			SendItem(conn, m->SourType, m->SourPos, item);
			SendClientMessage(conn, "Usado somente em montarias.");
			return;
		}

		if (dest->stEffect[1].cValue < 1 || dest->stEffect[1].cValue >= 60)
		{
			SendItem(conn, m->SourType, m->SourPos, item);
			SendClientMessage(conn, "Vitalidade da montaria está no máximo.");
			return;
		}

		if (!CheckMount(item, dest->sIndex))
		{
			SendItem(conn, m->SourType, m->SourPos, item);
			SendClientMessage(conn, "Usado apenas nas montarias citadas na descrição.");
			return;
		}

		srand(time(NULL) / 5 * (rand() % 500) * 5);

		static INT8 RandomVita[3] = { 1, 2, 3 };

		dest->stEffect[1].cValue += RandomVita[rand() % 3]; // 1~2~3

		if (dest->stEffect[1].cValue > 60)
			dest->stEffect[1].cValue = 60;

		AmountMinus(item);

		SendItem(conn, m->DestType, m->DestPos, dest);

		SendClientMessage(conn, "Montaria refinada com sucesso.");
		SaveUser(conn, 0);
		return;
	}
#pragma endregion
#pragma region Mandado de Exílio
	if (item->sIndex == 5602)
	{
		int Clan = pMob[conn].MOB.Clan;

		if (pMob[conn].MOB.Equip[15].sIndex == 0)
		{
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (pMob[conn].MOB.Equip[15].sIndex == 3199 || pMob[conn].MOB.Equip[15].sIndex == 549 || pMob[conn].MOB.Equip[15].sIndex == 3193 || pMob[conn].MOB.Equip[15].sIndex == 3196)
		{
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (pMob[conn].extra.ClassMaster >= MORTAL || pMob[conn].extra.ClassMaster <= ARCH)
		{

			if (pMob[conn].MOB.Equip[15].sIndex == 545 || pMob[conn].MOB.Equip[15].sIndex == 546)
			{
				pMob[conn].MOB.Equip[15].sIndex = 549;
				SendItem(conn, ITEM_PLACE_EQUIP, 15, &pMob[conn].MOB.Equip[15]);
				return;
			}

			if (pMob[conn].MOB.Equip[15].sIndex == 3191 || pMob[conn].MOB.Equip[15].sIndex == 3192)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3193;
				SendItem(conn, ITEM_PLACE_EQUIP, 15, &pMob[conn].MOB.Equip[15]);
				return;
			}

			if (pMob[conn].MOB.Equip[15].sIndex == 3194 || pMob[conn].MOB.Equip[15].sIndex == 3195)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3196;
				SendItem(conn, ITEM_PLACE_EQUIP, 15, &pMob[conn].MOB.Equip[15]);
				return;
			}
		}


		if (pMob[conn].extra.ClassMaster == CELESTIAL || pMob[conn].extra.ClassMaster == HARDCORE || pMob[conn].extra.ClassMaster == HARDCOREA || pMob[conn].extra.ClassMaster == HARDCORECS || pMob[conn].extra.ClassMaster == SHARDCORE)
		{
			pMob[conn].MOB.Equip[15].sIndex = 3199;
			SendItem(conn, ITEM_PLACE_EQUIP, 15, &pMob[conn].MOB.Equip[15]);
			return;
		}
		if (pMob[conn].extra.ClassMaster == SCELESTIAL || pMob[conn].extra.ClassMaster == CELESTIALCS)
		{
			if (Clan == 7) //blue
				pMob[conn].MOB.Equip[15].sIndex = 3197;
			else if (Clan == 8) //red
				pMob[conn].MOB.Equip[15].sIndex = 3198;

			SendEquip(conn, conn);
			SendItem(conn, ITEM_PLACE_EQUIP, 15, &pMob[conn].MOB.Equip[15]);
			return;
		}
		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));

		SendEtc(conn);
		SendCarry(conn);
		SendItem(conn, ITEM_PLACE_EQUIP, 15, &pMob[conn].MOB.Equip[15]);
		return;
	}
#pragma endregion 

#pragma region Barras Mytril
#pragma region Barra Mytril (Dano)
	if (Vol == 235)
	{
		STRUCT_ITEM* dest = GetItemPointer(&pMob[conn].MOB, pUser[conn].Cargo, m->DestType, m->DestPos);

		if (dest == NULL)
			return;


		if (m->DestType || m->DestPos >= 8 && m->DestPos < 16 || m->DestType == ITEM_PLACE_EQUIP && m->DestPos == 0 || m->DestType == ITEM_PLACE_EQUIP && m->DestPos == 1)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Only_To_Equips]);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		int sanc = BASE_GetItemSanc(dest);
		int ItemId = dest->sIndex;

		if (sanc < REF_11 || BASE_GetItemAbility(dest, EF_MOBTYPE) != 1)
		{
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		for (int a = 0; a < 3; a++) {
			if (dest->stEffect[a].cEffect == EF_DAMAGE || dest->stEffect[a].cEffect == EF_DAMAGE2) {
				dest->stEffect[a].cEffect = EF_DAMAGE;
				if (dest->stEffect[a].cValue < (m->DestPos != 6 && m->DestPos != 7 ? 12 : 24)) {
					SendClientMessage(conn, "Não é possível aprimorar este item.");
					SendItem(conn, m->SourType, m->SourPos, item);
					return;
				}
			}
		}

		for (int b = 0; b < 3; b++) {
			if (dest->stEffect[b].cEffect == EF_DAMAGE || dest->stEffect[b].cEffect == EF_DAMAGE2) {
				dest->stEffect[b].cEffect = EF_DAMAGE;
				if (dest->stEffect[b].cValue == (m->DestPos != 6 && m->DestPos != 7 ? 42 : 81)) {
					SendClientMessage(conn, "Não é possível aprimorar este item.");
					SendItem(conn, m->SourType, m->SourPos, item);
					return;
				}
			}
		}



		int RateSucess = 30;
		int _rand = rand() % 115;
		if (_rand > 100)
			_rand -= 15;

		if (_rand <= RateSucess && RateSucess)
		{
			for (int i = 0; i < 3; i++)
			{
				if (dest->stEffect[i].cEffect == EF_DAMAGE || dest->stEffect[i].cEffect == EF_DAMAGE2)
				{
					dest->stEffect[i].cEffect = EF_DAMAGE;
					dest->stEffect[i].cValue += m->DestPos != 6 && m->DestPos != 7 ? 6 : 9;

					if (dest->stEffect[i].cValue > (m->DestPos != 6 && m->DestPos != 7 ? 42 : 81))
						dest->stEffect[i].cValue = (m->DestPos != 6 && m->DestPos != 7 ? 42 : 81);

					break;
				}
			}
			pMob[conn].GetCurrentScore(conn);
			SendScore(conn);
			SendClientMessage(conn, "Upgrade +");

			if (amount > 1)
				BASE_SetItemAmount(item, amount - 1);

			else
				memset(item, 0, sizeof(STRUCT_ITEM));

			SendItem(conn, m->DestType, m->DestPos, dest);
			SendEmotion(conn, 14, 3);
		}

		else
		{
			if ((rand() % 7) == 0)
			{
				for (int i = 0; i < 3; i++)
				{
					if (dest->stEffect[i].cEffect == EF_DAMAGE || dest->stEffect[i].cEffect == EF_DAMAGE2)
					{
						dest->stEffect[i].cEffect = EF_DAMAGE;

						if (dest->stEffect[i].cValue >= (m->DestPos != 6 && m->DestPos != 7 ? 6 : 9))
							dest->stEffect[i].cValue -= m->DestPos != 6 && m->DestPos != 7 ? 6 : 9;

						break;
					}
				}
				SendItem(conn, m->DestType, m->DestPos, dest);
				SendClientMessage(conn, "Upgrade -");

			}
			else
			{
				SendClientMessage(conn, "O upgrade do item falhou.");
				int sFace = pMob[conn].MOB.Equip[0].sIndex / 10;

				if (sFace)
					SendEmotion(conn, 15, 0);

				else
					SendEmotion(conn, 20, 0);
			}


			if (amount > 1)
				BASE_SetItemAmount(item, amount - 1);

			else
				memset(item, 0, sizeof(STRUCT_ITEM));
		}

		return;
	}
#pragma endregion
#pragma region Barra Mytril (Magia)
	if (Vol == 236)
	{
		STRUCT_ITEM* dest = GetItemPointer(&pMob[conn].MOB, pUser[conn].Cargo, m->DestType, m->DestPos);

		if (dest == NULL)
			return;


		if (m->DestType || m->DestPos >= 8 && m->DestPos < 32 || m->DestType == ITEM_PLACE_EQUIP && m->DestPos == 0 || m->DestType == ITEM_PLACE_EQUIP && m->DestPos == 1)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Only_To_Equips]);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		int sanc = BASE_GetItemSanc(dest);
		int ItemId = dest->sIndex;

		if (sanc < REF_11 || BASE_GetItemAbility(dest, EF_MOBTYPE) != 1)
		{
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		for (int a = 0; a < 3; a++) {
			if (dest->stEffect[a].cEffect == EF_MAGIC || dest->stEffect[a].cEffect == EF_MAGICADD) {
				dest->stEffect[a].cEffect = EF_MAGIC;
				if (dest->stEffect[a].cValue < (m->DestPos != 6 && m->DestPos != 7 ? 6 : 16)) {
					SendClientMessage(conn, "Não é possível aprimorar este item.");
					SendItem(conn, m->SourType, m->SourPos, item);



					return;
				}
			}
		}


		for (int b = 0; b < 3; b++) {
			if (dest->stEffect[b].cEffect == EF_MAGIC || dest->stEffect[b].cEffect == EF_MAGICADD) {
				dest->stEffect[b].cEffect = EF_MAGIC;
				if (dest->stEffect[b].cValue == (m->DestPos != 6 && m->DestPos != 7 ? 14 : 36)) {
					SendClientMessage(conn, "Não é possível aprimorar este item.");
					SendItem(conn, m->SourType, m->SourPos, item);
					return;
				}
			}
		}


		int RateSucess = 30;
		int _rand = rand() % 115;
		if (_rand > 100)
			_rand -= 15;

		if (_rand <= RateSucess && RateSucess)
		{
			for (int i = 0; i < 3; i++)
			{
				if (dest->stEffect[i].cEffect == EF_MAGIC || dest->stEffect[i].cEffect == EF_MAGICADD)
				{
					dest->stEffect[i].cEffect = EF_MAGIC;
					dest->stEffect[i].cValue += m->DestPos != 6 && m->DestPos != 7 ? 2 : 4;

					if (dest->stEffect[i].cValue > (m->DestPos != 6 && m->DestPos != 7 ? 14 : 36))
						dest->stEffect[i].cValue = (m->DestPos != 6 && m->DestPos != 7 ? 14 : 36);

					break;
				}
			}
			pMob[conn].GetCurrentScore(conn);
			SendScore(conn);
			SendClientMessage(conn, "Upgrade +");

			if (amount > 1)
				BASE_SetItemAmount(item, amount - 1);

			else
				memset(item, 0, sizeof(STRUCT_ITEM));

			SendItem(conn, m->DestType, m->DestPos, dest);
			SendEmotion(conn, 14, 3);
		}

		else
		{
			if ((rand() % 7) == 0)
			{
				for (int i = 0; i < 3; i++)
				{
					if (dest->stEffect[i].cEffect == EF_MAGIC || dest->stEffect[i].cEffect == EF_MAGICADD)
					{
						dest->stEffect[i].cEffect = EF_MAGIC;

						if (dest->stEffect[i].cValue > (m->DestPos != 6 && m->DestPos != 7 ? 2 : 4))
							dest->stEffect[i].cValue -= m->DestPos != 6 && m->DestPos != 7 ? 2 : 4;

						break;
					}
				}

				SendItem(conn, m->DestType, m->DestPos, dest);
				SendClientMessage(conn, "Upgrade -");
			}
			else
			{
				SendClientMessage(conn, "O upgrade do item falhou.");
				int sFace = pMob[conn].MOB.Equip[0].sIndex / 10;

				if (sFace)
					SendEmotion(conn, 15, 0);

				else
					SendEmotion(conn, 20, 0);
			}

			if (amount > 1)
				BASE_SetItemAmount(item, amount - 1);

			else
				memset(item, 0, sizeof(STRUCT_ITEM));
		}

		return;
	}
#pragma endregion
#pragma region Barra Mytril (Defesa)
	if (Vol == 237)
	{
		STRUCT_ITEM* dest = GetItemPointer(&pMob[conn].MOB, pUser[conn].Cargo, m->DestType, m->DestPos);

		if (dest == NULL)
			return;


		if (m->DestType || m->DestPos >= 6 && m->DestPos < 16 || m->DestType == ITEM_PLACE_EQUIP && m->DestPos == 0 || m->DestType == ITEM_PLACE_EQUIP && m->DestPos == 1)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Only_To_Equips]);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (dest->sIndex >= 3500 && dest->sIndex <= 3507)
		{
			SendClientMessage(conn, "Impossível Utilizar com Cytheras");
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		int sanc = BASE_GetItemSanc(dest);
		int ItemId = dest->sIndex;

		if (sanc < REF_11 || BASE_GetItemAbility(dest, EF_MOBTYPE) != 1)
		{
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		int dam = 0;
		int effect = 0;

		for (int i = 0; i < 3; i++)
		{
			if (dest->stEffect[i].cEffect == EF_AC || dest->stEffect[i].cEffect == EF_ACADD2)
			{
				dam = dest->stEffect[i].cValue;
				effect = dest->stEffect[i].cEffect;

				break;
			}
		}

		int max_add = (effect == EF_AC && m->DestPos != 4 ? 40 : 70);
		int min_add = (effect == EF_AC && m->DestPos != 4 ? 15 : 15);



		if (dam < min_add)
		{
			SendItem(conn, m->SourType, m->SourPos, item);
			SendClientMessage(conn, "Não é possível aprimorar este item.");
			return;
		}

		if (dam >= max_add)
		{
			SendItem(conn, m->SourType, m->SourPos, item);
			SendClientMessage(conn, "Não é possível aprimorar este item.");
			return;
		}



		int RateSucess = 30;
		int _rand = rand() % 115;
		if (_rand > 100)
			_rand -= 15;

		if (_rand <= RateSucess && RateSucess)
		{
			for (int i = 0; i < 3; i++)
			{
				if (dest->stEffect[i].cEffect == EF_AC || dest->stEffect[i].cEffect == EF_ACADD2)
				{
					dest->stEffect[i].cValue += (dest->stEffect[i].cEffect == EF_AC ? 5 : 10);

					if (dest->stEffect[i].cValue > (dest->stEffect[i].cEffect == EF_AC && m->DestPos != 4 ? 40 : 70))
						dest->stEffect[i].cValue = (dest->stEffect[i].cEffect == EF_AC && m->DestPos != 4 ? 40 : 70);

					break;
				}
			}

			pMob[conn].GetCurrentScore(conn);
			SendScore(conn);
			SendClientMessage(conn, "Upgrade +");
			if (amount > 1)
				BASE_SetItemAmount(item, amount - 1);

			else
				memset(item, 0, sizeof(STRUCT_ITEM));

			SendItem(conn, m->DestType, m->DestPos, dest);
			SendEmotion(conn, 14, 3);
		}

		else
		{
			if ((rand() % 7) == 0)
			{
				for (int i = 0; i < 3; i++)
				{
					if (dest->stEffect[i].cEffect == EF_AC || dest->stEffect[i].cEffect == EF_ACADD2)
					{
						if (dest->stEffect[i].cEffect == EF_AC && dest->stEffect[i].cValue > 5 || dest->stEffect[i].cEffect == EF_ACADD2 && dest->stEffect[i].cValue > 10)
							dest->stEffect[i].cValue -= (dest->stEffect[i].cEffect == EF_AC ? 5 : 10);

						break;
					}
				}
				SendClientMessage(conn, "Upgrade -");
				SendItem(conn, m->DestType, m->DestPos, dest);
			}
			else
			{
				SendClientMessage(conn, "O upgrade do item falhou.");
				int sFace = pMob[conn].MOB.Equip[0].sIndex / 10;

				if (sFace)
					SendEmotion(conn, 15, 0);

				else
					SendEmotion(conn, 20, 0);
			}

			if (amount > 1)
				BASE_SetItemAmount(item, amount - 1);

			else
				memset(item, 0, sizeof(STRUCT_ITEM));
		}

		return;
	}
#pragma endregion
#pragma region Barra Mytril (Crítico)
	if (Vol == 238)
	{
		STRUCT_ITEM* dest = GetItemPointer(&pMob[conn].MOB, pUser[conn].Cargo, m->DestType, m->DestPos);

		if (dest == NULL)
			return;

		if (m->DestType || m->DestPos >= 8 && m->DestPos < 16 || m->DestType == ITEM_PLACE_EQUIP && m->DestPos == 0 || m->DestType == ITEM_PLACE_EQUIP && m->DestPos == 1)
		{
			SendClientMessage(conn, g_pMessageStringTable[_NN_Only_To_Equips]);
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		int sanc = BASE_GetItemSanc(dest);
		int ItemId = dest->sIndex;

		if (sanc < REF_10 || BASE_GetItemAbility(dest, EF_MOBTYPE) != 1)
		{
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		int dam = BASE_GetItemAbilityNosanc(dest, EF_CRITICAL2);

		int max_add = m->DestPos != 6 && m->DestPos != 7 ? 90 : 0;
		int min_add = m->DestPos != 6 && m->DestPos != 7 ? 30 : 0;

		if (dam < min_add)
		{
			SendItem(conn, m->SourType, m->SourPos, item);
			SendClientMessage(conn, "Não é possível aprimorar este item.");
			return;
		}

		if (dam >= max_add)
		{
			SendItem(conn, m->SourType, m->SourPos, item);
			SendClientMessage(conn, "Não é possível aprimorar este item.");
			return;
		}


		int RateSucess = 30;

		int _rand = rand() % 115;

		if (_rand > 100)
			_rand -= 15;

		if (_rand <= RateSucess && RateSucess)
		{
			for (int i = 0; i < 3; i++)
			{
				if (dest->stEffect[i].cEffect == EF_CRITICAL || dest->stEffect[i].cEffect == EF_CRITICAL2)
				{
					dest->stEffect[i].cEffect = EF_CRITICAL2;
					dest->stEffect[i].cValue += m->DestPos != 6 && m->DestPos != 7 ? 10 : 1;

					if (dest->stEffect[i].cValue > (m->DestPos != 6 && m->DestPos != 7 && m->DestPos != 4 ? 90 : 0))
						dest->stEffect[i].cValue = (m->DestPos != 6 && m->DestPos != 7 && m->DestPos != 4 ? 90 : 0);

					break;
				}
			}

			pMob[conn].GetCurrentScore(conn);
			SendScore(conn);
			SendClientMessage(conn, "Upgrade +");

			if (amount > 1)
				BASE_SetItemAmount(item, amount - 1);

			else
				memset(item, 0, sizeof(STRUCT_ITEM));

			SendItem(conn, m->DestType, m->DestPos, dest);
			SendEmotion(conn, 14, 3);
		}

		else
		{
			if ((rand() % 7) == 0)
			{
				for (int i = 0; i < 3; i++)
				{
					if (dest->stEffect[i].cEffect == EF_CRITICAL || dest->stEffect[i].cEffect == EF_CRITICAL2)
					{
						dest->stEffect[i].cEffect = EF_CRITICAL2;
						if (dest->stEffect[i].cValue > (m->DestPos != 6 && m->DestPos != 7 ? 10 : 10))
							dest->stEffect[i].cValue -= m->DestPos != 6 && m->DestPos != 7 ? 10 : 10;
						break;
					}
				}
				SendClientMessage(conn, "Upgrade -");
				SendItem(conn, m->DestType, m->DestPos, dest);

			}
			else
			{
				SendClientMessage(conn, "O upgrade do item falhou.");
				int sFace = pMob[conn].MOB.Equip[0].sIndex / 10;

				if (sFace)
					SendEmotion(conn, 15, 0);

				else
					SendEmotion(conn, 20, 0);
			}

			if (amount > 1)
				BASE_SetItemAmount(item, amount - 1);

			else
				memset(item, 0, sizeof(STRUCT_ITEM));
		}

		return;
	}
#pragma endregion
#pragma endregion

#pragma region Donate
	if (Vol == 189)
	{
		auto& pc = cSQL::instance();

		int Donate = 0;

		sprintf(hQuery, "SELECT * FROM `accounts` WHERE `username` = '%s'", pUser[conn].AccountName);
		MYSQL_ROW row;
		MYSQL* wSQL = pc.wStart();
		MYSQL_RES* result = pc.wRes(wSQL, hQuery);

		if (result == NULL) {
			return;
		}


		while ((row = mysql_fetch_row(result)) != NULL)
		{
			Donate = atoi(row[6]);
		}

		if (item->sIndex == 3394)
		{
			sprintf(xQuery, "UPDATE accounts SET donate = '%d' WHERE username = '%s' ", (Donate + 100), pUser[conn].AccountName);
			pc.wQuery(xQuery);

			SendMsgExp(conn, "Você ativou 100 de Donate.", TNColor::GoldenClaro, false);
			ItemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, "useitem, 3394 - Ativou 100 Donate");

			if (amount > 1)
				BASE_SetItemAmount(item, amount - 1);

			else
				memset(item, 0, sizeof(STRUCT_ITEM));

			UpdateDonate(conn);
			SaveUser(conn, 0);
			return;

		}

		else if (item->sIndex == 3395)
		{
			sprintf(xQuery, "UPDATE accounts SET donate = '%d' WHERE username = '%s' ", (Donate + 1000), pUser[conn].AccountName);
			pc.wQuery(xQuery);

			SendMsgExp(conn, "Você ativou 1.000 de Donate.", TNColor::GoldenClaro, false);
			ItemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, "useitem, 3395 - Ativou 1.000 Donate");

			if (amount > 1)
				BASE_SetItemAmount(item, amount - 1);

			else
				memset(item, 0, sizeof(STRUCT_ITEM));

			UpdateDonate(conn);
			SaveUser(conn, 0);
			return;

		}

		else if (item->sIndex == 3396)
		{
			sprintf(xQuery, "UPDATE accounts SET donate = '%d' WHERE username = '%s' ", (Donate + 5000), pUser[conn].AccountName);
			pc.wQuery(xQuery);

			SendMsgExp(conn, "Você ativou 5.000 de Donate.", TNColor::GoldenClaro, false);
			ItemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, "useitem, 3396 - Ativou 5.000 Donate");

			if (amount > 1)
				BASE_SetItemAmount(item, amount - 1);

			else
				memset(item, 0, sizeof(STRUCT_ITEM));

			UpdateDonate(conn);
			SaveUser(conn, 0);
			return;

		}
	}

#pragma endregion 
#pragma region extrações(Item)
#pragma region extração Elmo
	if (item->sIndex == 3021)
	{
		if (pMob[conn].MOB.Equip[1].sIndex == 0)
		{
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (pMob[conn].MOB.Equip[1].sIndex >= 3500 && pMob[conn].MOB.Equip[1].sIndex <= 3507)
		{
			SendClientMessage(conn, "Não é possível utilizar em cytheras.");
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		int sanc = BASE_GetItemSanc(&pMob[conn].MOB.Equip[1]);


		pMob[conn].MOB.Equip[1].stEffect[1].cEffect = item->stEffect[1].cEffect;
		pMob[conn].MOB.Equip[1].stEffect[1].cValue = item->stEffect[1].cValue;

		pMob[conn].MOB.Equip[1].stEffect[2].cEffect = item->stEffect[2].cEffect;
		pMob[conn].MOB.Equip[1].stEffect[2].cValue = item->stEffect[2].cValue;

		SendItem(conn, ITEM_PLACE_EQUIP, 1, &pMob[conn].MOB.Equip[1]);

		BASE_ClearItem(item);
		SendItem(conn, m->SourType, m->SourPos, item);

		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));

		SendEmotion(conn, 14, 3);
		return;
	}
#pragma endregion
#pragma region >> extração Elmo
	if (item->sIndex == 3021)
	{
		int extra = BASE_GetItemAbility(item, EF_ITEMLEVEL);

		if (pMob[conn].MOB.Equip[1].sIndex == 0)
		{
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (pMob[conn].MOB.Equip[1].sIndex >= 3500 && pMob[conn].MOB.Equip[1].sIndex <= 3507)
		{
			SendClientMessage(conn, "Não é possivel utilizar em Cytheras.");
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (extra <= 4)
		{
			int elmoextra = BASE_GetItemAbility(&pMob[conn].MOB.Equip[1], EF_ITEMLEVEL);
			int elmomobtype = BASE_GetItemAbility(&pMob[conn].MOB.Equip[1], EF_MOBTYPE);

			if (elmoextra != 0 && elmoextra != 4 || elmoextra != extra || elmomobtype != 2 && elmomobtype != 0)
			{
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			int sanc = BASE_GetItemSanc(&pMob[conn].MOB.Equip[1]);

			if (sanc > 9)
			{
				SendClientMessage(conn, strFmt(g_pMessageStringTable[_DN_SANCREQ], 9));
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			pMob[conn].MOB.Equip[1].stEffect[1].cEffect = item->stEffect[1].cEffect;
			pMob[conn].MOB.Equip[1].stEffect[1].cValue = item->stEffect[1].cValue;

			pMob[conn].MOB.Equip[1].stEffect[2].cEffect = item->stEffect[2].cEffect;
			pMob[conn].MOB.Equip[1].stEffect[2].cValue = item->stEffect[2].cValue;

			SendItem(conn, ITEM_PLACE_EQUIP, 1, &pMob[conn].MOB.Equip[1]);


			if (amount > 1)
				BASE_SetItemAmount(item, amount - 1);

			else
				memset(item, 0, sizeof(STRUCT_ITEM));

			SendEmotion(conn, 14, 3);
			return;
		}
	}

#pragma endregion
#pragma region >> extração Peito
	if (item->sIndex == 3022)
	{
		int extra = BASE_GetItemAbility(item, EF_ITEMLEVEL);

		if (pMob[conn].MOB.Equip[2].sIndex == 0)
		{
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (extra <= 4)
		{
			int destextra = BASE_GetItemAbility(&pMob[conn].MOB.Equip[2], EF_ITEMLEVEL);
			int desttype = BASE_GetItemAbility(&pMob[conn].MOB.Equip[2], EF_MOBTYPE);

			if (destextra != 0 && destextra != 4 || destextra != extra || desttype != 2 && desttype != 0)
			{
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			int sanc = BASE_GetItemSanc(&pMob[conn].MOB.Equip[2]);

			if (sanc > 9)
			{
				SendClientMessage(conn, strFmt(g_pMessageStringTable[_DN_SANCREQ], 9));
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			pMob[conn].MOB.Equip[2].stEffect[1].cEffect = item->stEffect[1].cEffect;
			pMob[conn].MOB.Equip[2].stEffect[1].cValue = item->stEffect[1].cValue;

			pMob[conn].MOB.Equip[2].stEffect[2].cEffect = item->stEffect[2].cEffect;
			pMob[conn].MOB.Equip[2].stEffect[2].cValue = item->stEffect[2].cValue;

			SendItem(conn, ITEM_PLACE_EQUIP, 2, &pMob[conn].MOB.Equip[2]);

			if (amount > 1)
				BASE_SetItemAmount(item, amount - 1);

			else
				memset(item, 0, sizeof(STRUCT_ITEM));

			SendEmotion(conn, 14, 3);
			return;
		}
	}
#pragma endregion
#pragma region >> extração Calça
	if (item->sIndex == 3023)
	{
		int extra = BASE_GetItemAbility(item, EF_ITEMLEVEL);

		if (pMob[conn].MOB.Equip[3].sIndex == 0)
		{
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (extra <= 4)
		{
			int destextra = BASE_GetItemAbility(&pMob[conn].MOB.Equip[3], EF_ITEMLEVEL);
			int desttype = BASE_GetItemAbility(&pMob[conn].MOB.Equip[3], EF_MOBTYPE);

			if (destextra != 0 && destextra != 4 || destextra != extra || desttype != 2 && desttype != 0)
			{
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			int sanc = BASE_GetItemSanc(&pMob[conn].MOB.Equip[3]);

			if (sanc > 9)
			{
				SendClientMessage(conn, strFmt(g_pMessageStringTable[_DN_SANCREQ], 9));
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			pMob[conn].MOB.Equip[3].stEffect[1].cEffect = item->stEffect[1].cEffect;
			pMob[conn].MOB.Equip[3].stEffect[1].cValue = item->stEffect[1].cValue;

			pMob[conn].MOB.Equip[3].stEffect[2].cEffect = item->stEffect[2].cEffect;
			pMob[conn].MOB.Equip[3].stEffect[2].cValue = item->stEffect[2].cValue;

			SendItem(conn, ITEM_PLACE_EQUIP, 3, &pMob[conn].MOB.Equip[3]);



			if (amount > 1)
				BASE_SetItemAmount(item, amount - 1);

			else
				memset(item, 0, sizeof(STRUCT_ITEM));

			SendEmotion(conn, 14, 3);
			return;
		}
	}
#pragma endregion
#pragma region >> extração Luva
	if (item->sIndex == 3024)
	{
		int extra = BASE_GetItemAbility(item, EF_ITEMLEVEL);

		if (pMob[conn].MOB.Equip[4].sIndex == 0)
		{
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (extra <= 4)
		{
			int destextra = BASE_GetItemAbility(&pMob[conn].MOB.Equip[4], EF_ITEMLEVEL);
			int desttype = BASE_GetItemAbility(&pMob[conn].MOB.Equip[4], EF_MOBTYPE);

			if (destextra != 0 && destextra != 4 || destextra != extra || desttype != 2 && desttype != 0)
			{
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			int sanc = BASE_GetItemSanc(&pMob[conn].MOB.Equip[4]);

			if (sanc > 9)
			{
				SendClientMessage(conn, strFmt(g_pMessageStringTable[_DN_SANCREQ], 9));
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			pMob[conn].MOB.Equip[4].stEffect[1].cEffect = item->stEffect[1].cEffect;
			pMob[conn].MOB.Equip[4].stEffect[1].cValue = item->stEffect[1].cValue;

			pMob[conn].MOB.Equip[4].stEffect[2].cEffect = item->stEffect[2].cEffect;
			pMob[conn].MOB.Equip[4].stEffect[2].cValue = item->stEffect[2].cValue;

			SendItem(conn, ITEM_PLACE_EQUIP, 4, &pMob[conn].MOB.Equip[4]);


			if (amount > 1)
				BASE_SetItemAmount(item, amount - 1);

			else
				memset(item, 0, sizeof(STRUCT_ITEM));

			SendEmotion(conn, 14, 3);
			return;
		}
	}
#pragma endregion
#pragma region >> extração Bota
	if (item->sIndex == 3025)
	{
		int extra = BASE_GetItemAbility(item, EF_ITEMLEVEL);

		if (pMob[conn].MOB.Equip[5].sIndex == 0)
		{
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (extra <= 4)
		{
			int destextra = BASE_GetItemAbility(&pMob[conn].MOB.Equip[5], EF_ITEMLEVEL);
			int desttype = BASE_GetItemAbility(&pMob[conn].MOB.Equip[5], EF_MOBTYPE);

			if (destextra != 0 && destextra != 4 || destextra != extra || desttype != 2 && desttype != 0)
			{
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			int sanc = BASE_GetItemSanc(&pMob[conn].MOB.Equip[5]);

			if (sanc > 9)
			{
				SendClientMessage(conn, strFmt(g_pMessageStringTable[_DN_SANCREQ], 9));
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			pMob[conn].MOB.Equip[5].stEffect[1].cEffect = item->stEffect[1].cEffect;
			pMob[conn].MOB.Equip[5].stEffect[1].cValue = item->stEffect[1].cValue;

			pMob[conn].MOB.Equip[5].stEffect[2].cEffect = item->stEffect[2].cEffect;
			pMob[conn].MOB.Equip[5].stEffect[2].cValue = item->stEffect[2].cValue;

			if (pMob[conn].MOB.Equip[5].stEffect[1].cEffect == EF_DAMAGE && BASE_GetStaticItemAbility(&pMob[conn].MOB.Equip[5], EF_DAMAGE) != 0)
				pMob[conn].MOB.Equip[5].stEffect[1].cValue -= BASE_GetStaticItemAbility(&pMob[conn].MOB.Equip[5], EF_DAMAGE);

			if (pMob[conn].MOB.Equip[5].stEffect[2].cEffect == EF_DAMAGE && BASE_GetStaticItemAbility(&pMob[conn].MOB.Equip[5], EF_DAMAGE) != 0)
				pMob[conn].MOB.Equip[5].stEffect[2].cValue -= BASE_GetStaticItemAbility(&pMob[conn].MOB.Equip[5], EF_DAMAGE);

			SendItem(conn, ITEM_PLACE_EQUIP, 5, &pMob[conn].MOB.Equip[5]);

			if (amount > 1)
				BASE_SetItemAmount(item, amount - 1);

			else
				memset(item, 0, sizeof(STRUCT_ITEM));

			SendEmotion(conn, 14, 3);
			return;
		}
	}
#pragma endregion

#pragma region >> Extração Arma
	if (item->sIndex == 3026)
	{
		if (item->stEffect[0].cEffect == 0 && item->stEffect[0].cValue == 0 && item->stEffect[1].cEffect == 0 && item->stEffect[1].cValue == 0 && item->stEffect[2].cEffect == 0 && item->stEffect[2].cValue == 0) {

			if (pMob[conn].MOB.Equip[6].sIndex == 0)
			{
				SendItem(conn, m->SourType, m->SourPos, item);
				SendClientMessage(conn, "Nenhuma arma equipada.");
				BASE_ClearItem(&pMob[conn].MOB.Equip[6]);
				SendCarry(conn);
				return;
			}


			int sanc = BASE_GetItemSanc(&pMob[conn].MOB.Equip[6]);

			if (sanc < 9)
			{
				sprintf_s(temp, g_pMessageStringTable[_DN_SANCREQ], 9);
				SendClientMessage(conn, temp);
				SendItem(conn, m->SourType, m->SourPos, item);
				SendCarry(conn);
				return;
			}
			int _rd = rand() % 100;
			if (_rd > 100)
				_rd = 100;

			if (_rd < 25) {
				item->stEffect[1].cEffect = pMob[conn].MOB.Equip[6].stEffect[1].cEffect;
				item->stEffect[1].cValue = pMob[conn].MOB.Equip[6].stEffect[1].cValue;
				item->stEffect[2].cEffect = pMob[conn].MOB.Equip[6].stEffect[2].cEffect;
				item->stEffect[2].cValue = pMob[conn].MOB.Equip[6].stEffect[2].cValue;

				memset(&pMob[conn].MOB.Equip[6], 0, sizeof(STRUCT_ITEM));

				SendItem(conn, ITEM_PLACE_EQUIP, 6, &pMob[conn].MOB.Equip[6]);
				SendEtc(conn);

				PutItem(conn, item);


				if (amount > 1)
					BASE_SetItemAmount(item, amount - 1);

				else
					memset(item, 0, sizeof(STRUCT_ITEM));

				SendEmotion(conn, 14, 3);
				SendClientMessage(conn, "Extraído com sucesso.");
				SendCarry(conn);
				return;
			}
			if (_rd > 25) {
				if (amount > 1)
					BASE_SetItemAmount(item, amount - 1);

				else
					memset(item, 0, sizeof(STRUCT_ITEM));

				SendEmotion(conn, 14, 3);
				SendClientMessage(conn, "Tentativa falhou.");
				SendCarry(conn);
				return;
			}
		}
		else {
			if (pMob[conn].MOB.Equip[6].sIndex == 0)
			{
				SendItem(conn, m->SourType, m->SourPos, item);
				SendClientMessage(conn, "Nenhuma arma equipada.");
				BASE_ClearItem(&pMob[conn].MOB.Equip[6]);
				SendCarry(conn);
				return;
			}

			int sanc = BASE_GetItemSanc(&pMob[conn].MOB.Equip[6]);

			if (sanc < 9)
			{
				sprintf_s(temp, g_pMessageStringTable[_DN_SANCREQ], 9);
				SendClientMessage(conn, temp);
				SendItem(conn, m->SourType, m->SourPos, item);
				SendCarry(conn);
				return;
			}
			int _rd = rand() % 100;
			if (_rd > 100)
				_rd = 100;

			if (_rd < 100) {
				pMob[conn].MOB.Equip[6].stEffect[1].cEffect = item->stEffect[1].cEffect;
				pMob[conn].MOB.Equip[6].stEffect[1].cValue = item->stEffect[1].cValue;
				pMob[conn].MOB.Equip[6].stEffect[2].cEffect = item->stEffect[2].cEffect;
				pMob[conn].MOB.Equip[6].stEffect[2].cValue = item->stEffect[2].cValue;

				SendItem(conn, ITEM_PLACE_EQUIP, 6, &pMob[conn].MOB.Equip[6]);
				pMob[conn].GetCurrentScore(conn);
				SendScore(conn);


				if (amount > 1)
					BASE_SetItemAmount(item, amount - 1);

				else
					memset(item, 0, sizeof(STRUCT_ITEM));

				SendEmotion(conn, 14, 3);
				SendClientMessage(conn, "Extraído com sucesso.");
				SendCarry(conn);
				return;
			}
		}
		return;
	}
#pragma endregion

#pragma endregion

#pragma region Transmutações 
	if (item->sIndex == 5614)
	{
		if (pMob[conn].extra.ClassMaster == MORTAL)
		{
			SendClientMessage(conn, "Sua classe atual não é permitida.");
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (pMob[conn].MOB.Equip[11].sIndex != 1760 && pMob[conn].MOB.Equip[11].sIndex != 1761 && pMob[conn].MOB.Equip[11].sIndex != 1762 && pMob[conn].MOB.Equip[11].sIndex != 1763)
		{
			SendClientMessage(conn, "Equipe um Sephiroth para continuar");
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		pMob[conn].MOB.Class = pMob[conn].MOB.Equip[11].sIndex - 1760;

		if (pMob[conn].MOB.Equip[0].sIndex >= 6 && pMob[conn].MOB.Equip[0].sIndex <= 9) {
			if (pMob[conn].MOB.Equip[11].sIndex == 1760)
				pMob[conn].MOB.Equip[0].sIndex = 6;

			if (pMob[conn].MOB.Equip[11].sIndex == 1761)
				pMob[conn].MOB.Equip[0].sIndex = 7;

			if (pMob[conn].MOB.Equip[11].sIndex == 1762)
				pMob[conn].MOB.Equip[0].sIndex = 8;

			if (pMob[conn].MOB.Equip[11].sIndex == 1763)
				pMob[conn].MOB.Equip[0].sIndex = 9;
		}

		else if (pMob[conn].MOB.Equip[0].sIndex >= 16 && pMob[conn].MOB.Equip[0].sIndex <= 19) {
			if (pMob[conn].MOB.Equip[11].sIndex == 1760)
				pMob[conn].MOB.Equip[0].sIndex = 16;

			if (pMob[conn].MOB.Equip[11].sIndex == 1761)
				pMob[conn].MOB.Equip[0].sIndex = 17;

			if (pMob[conn].MOB.Equip[11].sIndex == 1762)
				pMob[conn].MOB.Equip[0].sIndex = 18;

			if (pMob[conn].MOB.Equip[11].sIndex == 1763)
				pMob[conn].MOB.Equip[0].sIndex = 19;
		}


		else if (pMob[conn].MOB.Equip[1].sIndex >= 26 && pMob[conn].MOB.Equip[0].sIndex <= 29) {
			if (pMob[conn].MOB.Equip[11].sIndex == 1760)
				pMob[conn].MOB.Equip[0].sIndex = 26;

			if (pMob[conn].MOB.Equip[11].sIndex == 1761)
				pMob[conn].MOB.Equip[0].sIndex = 27;

			if (pMob[conn].MOB.Equip[11].sIndex == 1762)
				pMob[conn].MOB.Equip[0].sIndex = 28;

			if (pMob[conn].MOB.Equip[11].sIndex == 1763)
				pMob[conn].MOB.Equip[0].sIndex = 29;
		}


		else if (pMob[conn].MOB.Equip[1].sIndex >= 36 && pMob[conn].MOB.Equip[0].sIndex <= 39) {
			if (pMob[conn].MOB.Equip[11].sIndex == 1760)
				pMob[conn].MOB.Equip[0].sIndex = 36;

			if (pMob[conn].MOB.Equip[11].sIndex == 1761)
				pMob[conn].MOB.Equip[0].sIndex = 37;

			if (pMob[conn].MOB.Equip[11].sIndex == 1762)
				pMob[conn].MOB.Equip[0].sIndex = 38;

			if (pMob[conn].MOB.Equip[11].sIndex == 1763)
				pMob[conn].MOB.Equip[0].sIndex = 39;
		}


		pMob[conn].MOB.BaseScore.Str = BaseSIDCHM[pMob[conn].MOB.Class][0];
		pMob[conn].MOB.BaseScore.Int = BaseSIDCHM[pMob[conn].MOB.Class][1];
		pMob[conn].MOB.BaseScore.Dex = BaseSIDCHM[pMob[conn].MOB.Class][2];
		pMob[conn].MOB.BaseScore.Con = BaseSIDCHM[pMob[conn].MOB.Class][3];

		int special = pMob[conn].MOB.SpecialBonus;
		int specialreset = 55;

		for (int i = 0; i < 4; i++)
		{
			if (pMob[conn].MOB.BaseScore.Special[i] <= 55)
			{
				special += pMob[conn].MOB.BaseScore.Special[i];
				pMob[conn].MOB.BaseScore.Special[i] = 0;
			}
			else
			{
				special += specialreset;
				pMob[conn].MOB.BaseScore.Special[i] -= specialreset;
			}
		}

		pMob[conn].MOB.SpecialBonus = special;

		pMob[conn].MOB.LearnedSkill &= 0xFF000000;
		pMob[conn].extra.SecLearnedSkill &= 0xFF00FFFF;

		memset(item, 0, sizeof(STRUCT_ITEM));
		memset(&pMob[conn].MOB.Equip[11], 0, sizeof(STRUCT_ITEM));
		SendItem(conn, ITEM_PLACE_EQUIP, 11, &pMob[conn].MOB.Equip[11]);
		SendEtc(conn);
		SendCarry(conn);

		SendClientMessage(conn, "Sua Classe foi modificada");
		SaveUser(conn, 0);
		CharLogOut(conn);
		
	}
#pragma endregion
#pragma region Composto Equilibrio
	if (Vol == 193)
	{
		if (pMob[conn].extra.QuestInfo.Mortal.equilibrio)
		{
			SendClientMessage(conn, "Você já completou essa quest!");
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}
		if (pMob[conn].extra.ClassMaster != MORTAL)
		{
			SendClientMessage(conn, "Sua classe atual não é permitida.");
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		int minlevel = pMob[conn].extra.ClassMaster == MORTAL ? 119 : 119;
		int maxlevel = pMob[conn].extra.ClassMaster == MORTAL ? 124 : 124;

		if (pMob[conn].MOB.CurrentScore.Level < minlevel || pMob[conn].MOB.CurrentScore.Level >= maxlevel)
		{
			SendClientMessage(conn, "Seu nivel é insuficiente.");
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		int circlemode = 0;

		item->sIndex -= 4126;
		circlemode = 2;


		int specialreset = 50;

		if (circlemode == 2)
			specialreset = 100;

		int special = pMob[conn].MOB.SpecialBonus;

		for (int i = 1; i < 3; i++)
		{
			if (pMob[conn].MOB.BaseScore.Special[i] <= specialreset)
			{
				special += pMob[conn].MOB.BaseScore.Special[i];
				pMob[conn].MOB.BaseScore.Special[i] = 0;
			}
			else
			{
				special += specialreset;
				pMob[conn].MOB.BaseScore.Special[i] -= specialreset;
			}
		}

		pMob[conn].MOB.SpecialBonus = special;

		pMob[conn].MOB.LearnedSkill &= 0xFFFFFF00;
		pMob[conn].MOB.LearnedSkill &= 0xFFFF00FF;
		pMob[conn].MOB.LearnedSkill &= 0xFF00FFFF;

		BASE_GetBonusSkillPoint(&pMob[conn].MOB, &pMob[conn].extra);
		pMob[conn].extra.QuestInfo.Mortal.equilibrio = TRUE;

		SendEtc(conn);
		SendClientMessage(conn, g_pMessageStringTable[_NN_Initialize_Skill]);
		SetAffect(conn, 44, 20, 20);
		SendScore(conn);

		memset(item, 0, sizeof(STRUCT_ITEM));
		return;
	}

#pragma endregion
#pragma region Composto de chance
	if (Vol == 192)
	{
		if (pMob[conn].extra.QuestInfo.Mortal.bencao)
		{
			SendClientMessage(conn, "Você já completou essa quest!");
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}
		if (pMob[conn].extra.ClassMaster != MORTAL)
		{
			SendClientMessage(conn, "Sua classe atual não é permitida.");
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		int minlevel = pMob[conn].extra.ClassMaster == MORTAL ? 69 : 69;
		int maxlevel = pMob[conn].extra.ClassMaster == MORTAL ? 74 : 74;

		if (pMob[conn].MOB.CurrentScore.Level < minlevel || pMob[conn].MOB.CurrentScore.Level >= maxlevel)
		{
			SendClientMessage(conn, "Seu nivel é insuficiente.");
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		int circlemode = 0;

		item->sIndex -= 4124;
		circlemode = 2;


		int specialreset = 50;

		if (circlemode == 2)
			specialreset = 50;

		int special = pMob[conn].MOB.SpecialBonus;

		for (int i = 1; i < 3; i++)
		{
			if (pMob[conn].MOB.BaseScore.Special[i] <= specialreset)
			{
				special += pMob[conn].MOB.BaseScore.Special[i];
				pMob[conn].MOB.BaseScore.Special[i] = 0;
			}
			else
			{
				special += specialreset;
				pMob[conn].MOB.BaseScore.Special[i] -= specialreset;
			}
		}

		pMob[conn].MOB.SpecialBonus = special;

		pMob[conn].MOB.LearnedSkill &= 0xFFFFFF00;
		pMob[conn].MOB.LearnedSkill &= 0xFFFF00FF;
		pMob[conn].MOB.LearnedSkill &= 0xFF00FFFF;

		BASE_GetBonusSkillPoint(&pMob[conn].MOB, &pMob[conn].extra);
		pMob[conn].extra.QuestInfo.Mortal.bencao = TRUE;

		SendEtc(conn);
		SendClientMessage(conn, g_pMessageStringTable[_NN_Initialize_Skill]);
		SetAffect(conn, 44, 20, 20);
		SendScore(conn);

		memset(item, 0, sizeof(STRUCT_ITEM));
		return;
	}

#pragma endregion
#pragma region Baú Novato
	if (item->sIndex == 5644) // Baú Novato
	{
		int x = 0;
		int invfree = 0;
		// Random para buscar e verificar os slots do inventário. 
		for (x = 0; x < pMob[conn].MaxCarry; x++)
		{
			if (pMob[conn].MOB.Carry[x].sIndex == 0)
				invfree++;
		}
		if (invfree < 5)
		{
			SendClientMessage(conn, "Seu inventário está cheio.");
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		memset(item, 0, sizeof(STRUCT_ITEM));

		STRUCT_ITEM Item;
		memset(&Item, 0, sizeof(STRUCT_ITEM));

		Item.sIndex = 3200;
		BASE_SetItemDate(&Item, 3);
		PutItem(conn, &Item);

		Item.sIndex = 3201;
		BASE_SetItemDate(&Item, 3);
		PutItem(conn, &Item);

		Item.sIndex = 3202;
		BASE_SetItemDate(&Item, 3);
		PutItem(conn, &Item);

		Item.sIndex = 3204;
		BASE_SetItemDate(&Item, 3);
		PutItem(conn, &Item);

		Item.sIndex = 3205;
		BASE_SetItemDate(&Item, 3);
		PutItem(conn, &Item);


		return;
	}
#pragma endregion
#pragma region Forsa PT 300 // Baú Novato
	if (item->sIndex == 5611)
	{
		pUser[conn].Donate += 300;

		SendMsgExp(conn, "Você ativou 300 de Donate.", TNColor::GoldenClaro, false);

		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));

		SendEmotion(conn, 14, 3);
		SendEtc(conn);
		return;

	}
#pragma endregion

#pragma region Água das Fadas
	if (item->sIndex == 3367)
	{
		if (pMob[conn].MOB.Equip[13].sIndex == 0)
		{
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}
		if (pMob[conn].MOB.Equip[13].sIndex == 769 || pMob[conn].MOB.Equip[13].sIndex == 1726)
		{
			if (BASE_GetItemSanc(&pMob[conn].MOB.Equip[13]) < 6)
			{

				RefinarItemMais(&pMob[conn].MOB.Equip[13], 1);
				SendItem(conn, ITEM_PLACE_EQUIP, 13, &pMob[conn].MOB.Equip[13]);
				SendMsgExp(conn, g_pMessageStringTable[_NN_Refine_Success], TNColor::Default, false);

				if (amount > 1)
					BASE_SetItemAmount(item, amount - 1);
				else
					memset(item, 0, sizeof(STRUCT_ITEM));
				return;
			}
			else
			{
				SendMsgExp(conn, g_pMessageStringTable[_NN_Cant_Refine_More], TNColor::Default, false);
				SendItem(conn, m->SourType, m->SourPos, item);
			}
		}
		return;
	}
#pragma endregion
#pragma region Cubo da Maldade
	if (item->sIndex == 1772)
	{
		SendClientMessage(conn, "!!!");
		SendItem(conn, m->SourType, m->SourPos, item);
		if (pMob[conn].TargetX >= 1810 && pMob[conn].TargetY >= 3859 && pMob[conn].TargetX <= 1811 && pMob[conn].TargetY <= 3860)
		{
			if (CuboN.pRoom >= 6)
			{
				SendMsgExp(conn, "Esta quest atingiu o limite máximo de jogadores!", TNColor::Default, false);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			if (CuboN.Room != 0)
			{
				SendMsgExp(conn, g_pMessageStringTable[_NN_Someone_is_on_quest], TNColor::Default, false);
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}

			CuboN.pRoom++;

			DoTeleport(conn, *mNPCGen.pList[CuboN.Mobs[0]].SegmentListX, *mNPCGen.pList[CuboN.Mobs[0]].SegmentListY);

			if (amount > 1)
				BASE_SetItemAmount(item, amount - 1);
			else
				memset(item, 0, sizeof(STRUCT_ITEM));

			return;
		}
		else
		{
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		return;
	}
#pragma endregion


#pragma region Fogos PRM
	if (item->sIndex == 3442)
	{
		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);
		else
			memset(item, 0, sizeof(STRUCT_ITEM));

		return;
	}
#pragma endregion
	if (item->sIndex == 5571)
	{
		if (pMob[conn].MOB.Equip[1].sIndex == 0)
		{
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (pMob[conn].MOB.Equip[2].sIndex >= 3105 && pMob[conn].MOB.Equip[1].sIndex <= 3105 ||
			pMob[conn].MOB.Equip[2].sIndex >= 3105 && pMob[conn].MOB.Equip[1].sIndex <= 3105 ||
			g_pItemList[pMob[conn].MOB.Equip[1].sIndex].nPos == 256 ||
			g_pItemList[pMob[conn].MOB.Equip[1].sIndex].nPos == 512 ||
			g_pItemList[pMob[conn].MOB.Equip[1].sIndex].nPos == 3840 ||
			g_pItemList[pMob[conn].MOB.Equip[1].sIndex].nPos == 2048)
		{
			SendClientMessage(conn, "Não é possivel utilizar nesses itens.");
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		int sanc = BASE_GetItemSanc(&pMob[conn].MOB.Equip[1]);

		if (sanc < 8)
		{
			SendClientMessage(conn, strFmt(g_pMessageStringTable[_DN_SANCREQ], 8));
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		pMob[conn].MOB.Equip[1].stEffect[1].cEffect = item->stEffect[1].cEffect;
		pMob[conn].MOB.Equip[1].stEffect[1].cValue = item->stEffect[1].cValue;

		pMob[conn].MOB.Equip[1].stEffect[2].cEffect = item->stEffect[2].cEffect;
		pMob[conn].MOB.Equip[1].stEffect[2].cValue = item->stEffect[2].cValue;


		SendItem(conn, ITEM_PLACE_EQUIP, 2, &pMob[conn].MOB.Equip[1]);
		pMob[conn].GetCurrentScore(conn);
		SendScore(conn);

		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));

		SendEmotion(conn, 14, 3);
		return;
	}
#pragma region >> Baú de Cythera
	if (item->sIndex == 5627)
	{
		int rand_ = rand() % 100;
		STRUCT_ITEM Item;
		memset(&Item, 0, sizeof(STRUCT_ITEM));

		if (rand_ <= 20)
		{
			Item.sIndex = 3501;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 4; //efeito DN
			Item.stEffect[1].cValue = 50; //valor
			Item.stEffect[2].cEffect = 60; //efeito DN
			Item.stEffect[2].cValue = 10; //valor
		}

		else if (rand_ <= 40)
		{
			Item.sIndex = 3501;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 4; //efeito deff
			Item.stEffect[1].cValue = 60; //valor
			Item.stEffect[2].cEffect = 26; //efeito DN
			Item.stEffect[2].cValue = 18; //valor
		}

		else if (rand_ <= 60)
		{
			Item.sIndex = 3501;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 4; //efeito mg
			Item.stEffect[1].cValue = 50; //valor
			Item.stEffect[2].cEffect = 26; //efeito DN
			Item.stEffect[2].cValue = 16; //valor
		}

		else if (rand_ <= 80)
		{
			Item.sIndex = 3501;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 4; //efeito skill
			Item.stEffect[1].cValue = 60; //valor
			Item.stEffect[2].cEffect = 60; //efeito DN
			Item.stEffect[2].cValue = 12; //valor
		}

		else
		{
			Item.sIndex = 3501;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 4; //efeito crit
			Item.stEffect[1].cValue = 60; //valor
			Item.stEffect[2].cEffect = 3; //efeito DN
			Item.stEffect[2].cValue = 20; //valor
		}

		PutItem(conn, &Item);

		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));
		return;
	}
#pragma endregion
#pragma region >> Baú de Amuleto Arcano
	if (item->sIndex == 5633)
	{
		int rand_ = rand() % 100;
		STRUCT_ITEM Item;
		memset(&Item, 0, sizeof(STRUCT_ITEM));

		if (rand_ <= 25)
		{
			Item.sIndex = 567;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 69; //efeito DN
			Item.stEffect[1].cValue = 4; //valor

		}

		else if (rand_ <= 50)
		{
			Item.sIndex = 567;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 70; //efeito deff
			Item.stEffect[1].cValue = 4; //valor

		}

		else if (rand_ <= 75)
		{
			Item.sIndex = 567;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 60; //efeito mg
			Item.stEffect[1].cValue = 10; //valor

		}

		else
		{
			Item.sIndex = 567;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 2; //efeito skill
			Item.stEffect[1].cValue = 30; //valor

		}



		PutItem(conn, &Item);

		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));
		return;
	}
#pragma endregion
#pragma region >> Brinco Athena//6%HP / 6%MP / 8%MG / 36DN
	if (item->sIndex == 5628)
	{
		int rand_ = rand() % 100;
		STRUCT_ITEM Item;
		memset(&Item, 0, sizeof(STRUCT_ITEM));

		if (rand_ <= 25)
		{
			Item.sIndex = 591;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 69; //efeito DN
			Item.stEffect[1].cValue = 6; //valor
		}

		else if (rand_ <= 50)
		{
			Item.sIndex = 591;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 70; //efeito deff
			Item.stEffect[1].cValue = 6; //valor

		}

		else if (rand_ <= 75)
		{
			Item.sIndex = 591;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 60; //efeito mg
			Item.stEffect[1].cValue = 8; //valor

		}

		else
		{
			Item.sIndex = 591;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 2; //efeito skill
			Item.stEffect[1].cValue = 36; //valor

		}

		/*else
		{
			Item.sIndex = 591;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 0; //efeito crit
			Item.stEffect[1].cValue = 0; //valor

		}*/

		PutItem(conn, &Item);

		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));
		return;
	}
#pragma endregion
#pragma region >> Brinco  tita//6%HP / 6%MP / 8%MG / 36DN
	if (item->sIndex == 5629)
	{
		int rand_ = rand() % 100;
		STRUCT_ITEM Item;
		memset(&Item, 0, sizeof(STRUCT_ITEM));

		if (rand_ <= 25)
		{
			Item.sIndex = 592;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 69; //efeito DN
			Item.stEffect[1].cValue = 6; //valor
		}

		else if (rand_ <= 75)
		{
			Item.sIndex = 592;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 70; //efeito deff
			Item.stEffect[1].cValue = 6; //valor

		}

		else if (rand_ <= 75)
		{
			Item.sIndex = 592;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 60; //efeito mg
			Item.stEffect[1].cValue = 8; //valor

		}

		else
		{
			Item.sIndex = 592;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 2; //efeito skill
			Item.stEffect[1].cValue = 36; //valor

		}

		/*else
		{
			Item.sIndex = 592;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 0; //efeito crit
			Item.stEffect[1].cValue = 0; //valor

		}*/

		PutItem(conn, &Item);

		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));
		return;
	}
#pragma endregion
#pragma region >> Brinco  zeus//6%HP / 6%MP / 8%MG / 36DN
	if (item->sIndex == 5630)
	{
		int rand_ = rand() % 100;
		STRUCT_ITEM Item;
		memset(&Item, 0, sizeof(STRUCT_ITEM));

		if (rand_ <= 25)
		{
			Item.sIndex = 593;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 69; //efeito DN
			Item.stEffect[1].cValue = 6; //valor
		}

		else if (rand_ <= 50)
		{
			Item.sIndex = 593;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 70; //efeito deff
			Item.stEffect[1].cValue = 6; //valor

		}

		else if (rand_ <= 75)
		{
			Item.sIndex = 593;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 60; //efeito mg
			Item.stEffect[1].cValue = 8; //valor

		}

		else
		{
			Item.sIndex = 593;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 2; //efeito skill
			Item.stEffect[1].cValue = 36; //valor

		}

		/*else
		{
			Item.sIndex = 593;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 0; //efeito crit
			Item.stEffect[1].cValue = 0; //valor

		}*/

		PutItem(conn, &Item);

		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));
		return;
	}
#pragma endregion
#pragma region >> Brinco  hecate//6%HP / 6%MP / 8%MG / 36DN
	if (item->sIndex == 5631)
	{
		int rand_ = rand() % 100;
		STRUCT_ITEM Item;
		memset(&Item, 0, sizeof(STRUCT_ITEM));

		if (rand_ <= 25)
		{
			Item.sIndex = 594;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 69; //efeito DN
			Item.stEffect[1].cValue = 6; //valor
		}

		else if (rand_ <= 50)
		{
			Item.sIndex = 594;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 70; //efeito deff
			Item.stEffect[1].cValue = 6; //valor

		}

		else if (rand_ <= 75)
		{
			Item.sIndex = 594;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 60; //efeito mg
			Item.stEffect[1].cValue = 8; //valor

		}

		else
		{
			Item.sIndex = 594;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 2; //efeito skill
			Item.stEffect[1].cValue = 36; //valor

		}

		/*else
		{
			Item.sIndex = 594;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 0; //efeito crit
			Item.stEffect[1].cValue = 0; //valor

		}*/

		PutItem(conn, &Item);

		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));
		return;
	}
#pragma endregion
#pragma region >> Brinco  hercules//6%HP / 6%MP / 8%MG / 36DN
	if (item->sIndex == 5632)
	{
		int rand_ = rand() % 100;
		STRUCT_ITEM Item;
		memset(&Item, 0, sizeof(STRUCT_ITEM));

		if (rand_ <= 25)
		{
			Item.sIndex = 595;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 69; //efeito DN
			Item.stEffect[1].cValue = 6; //valor
		}

		else if (rand_ <= 50)
		{
			Item.sIndex = 595;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 70; //efeito deff
			Item.stEffect[1].cValue = 6; //valor

		}

		else if (rand_ <= 75)
		{
			Item.sIndex = 595;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 60; //efeito mg
			Item.stEffect[1].cValue = 8; //valor

		}

		else
		{
			Item.sIndex = 595;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 2; //efeito skill
			Item.stEffect[1].cValue = 36; //valor

		}

		/*else
		{
			Item.sIndex = 595;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 0; //efeito crit
			Item.stEffect[1].cValue = 0; //valor

		}*/

		PutItem(conn, &Item);

		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));
		return;
	}
#pragma endregion
#pragma region Honra
	if (item->sIndex == 3393)
	{
		{
			pUser[conn].Honra += 50;

			SendClientMessage(conn, "Voce Ativou 50 de Honra!");

			if (amount > 1)
				BASE_SetItemAmount(item, amount - 1);

			else
				memset(item, 0, sizeof(STRUCT_ITEM));

			SendEmotion(conn, 14, 3);
			SendEtc(conn);
			SaveUser(conn, 0);
			return;

		}
	}
#pragma endregion
#pragma region >> Colar de mana //6%HP / 6%MP / 8%MG / 36DN
	if (item->sIndex == 5634)
	{
		int rand_ = rand() % 100;
		STRUCT_ITEM Item;
		memset(&Item, 0, sizeof(STRUCT_ITEM));

		if (rand_ <= 25)
		{
			Item.sIndex = 640;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 70; //efeito DN
			Item.stEffect[1].cValue = 2; //valor
		}

		else if (rand_ <= 50)
		{
			Item.sIndex = 640;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 70; //efeito deff
			Item.stEffect[1].cValue = 4; //valor

		}

		else if (rand_ <= 75)
		{
			Item.sIndex = 640;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 70; //efeito mg
			Item.stEffect[1].cValue = 6; //valor

		}

		else
		{
			Item.sIndex = 640;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 70; //efeito skill
			Item.stEffect[1].cValue = 8; //valor

		}

		/*else
		{
			Item.sIndex = 595;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 0; //efeito crit
			Item.stEffect[1].cValue = 0; //valor

		}*/

		PutItem(conn, &Item);

		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));
		return;
	}
#pragma endregion
#pragma region >> Colar de cons //6%HP / 6%MP / 8%MG / 36DN
	if (item->sIndex == 5635)
	{
		int rand_ = rand() % 100;
		STRUCT_ITEM Item;
		memset(&Item, 0, sizeof(STRUCT_ITEM));

		if (rand_ <= 25)
		{
			Item.sIndex = 641;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 69; //efeito DN
			Item.stEffect[1].cValue = 2; //valor
		}

		else if (rand_ <= 50)
		{
			Item.sIndex = 641;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 69; //efeito deff
			Item.stEffect[1].cValue = 4; //valor

		}

		else if (rand_ <= 75)
		{
			Item.sIndex = 641;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 69; //efeito mg
			Item.stEffect[1].cValue = 6; //valor

		}

		else
		{
			Item.sIndex = 641;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 69; //efeito skill
			Item.stEffect[1].cValue = 8; //valor

		}

		/*else
		{
			Item.sIndex = 595;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 0; //efeito crit
			Item.stEffect[1].cValue = 0; //valor

		}*/

		PutItem(conn, &Item);

		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));
		return;
	}
#pragma endregion
#pragma region >> Colar de magia //6%HP / 6%MP / 8%MG / 36DN
	if (item->sIndex == 5636)
	{
		int rand_ = rand() % 100;
		STRUCT_ITEM Item;
		memset(&Item, 0, sizeof(STRUCT_ITEM));

		if (rand_ <= 25)
		{
			Item.sIndex = 642;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 60; //efeito DN
			Item.stEffect[1].cValue = 6; //valor
		}

		else if (rand_ <= 50)
		{
			Item.sIndex = 642;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 60; //efeito deff
			Item.stEffect[1].cValue = 8; //valor

		}

		else if (rand_ <= 75)
		{
			Item.sIndex = 642;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 70; //efeito mg
			Item.stEffect[1].cValue = 10; //valor

		}

		else
		{
			Item.sIndex = 642;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 60; //efeito skill
			Item.stEffect[1].cValue = 12; //valor

		}

		/*else
		{
			Item.sIndex = 595;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 0; //efeito crit
			Item.stEffect[1].cValue = 0; //valor

		}*/

		PutItem(conn, &Item);

		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));
		return;
	}
#pragma endregion

#pragma region >> Colar de mana //6%HP / 6%MP / 8%MG / 36DN
	if (item->sIndex == 5637)
	{
		int rand_ = rand() % 100;
		STRUCT_ITEM Item;
		memset(&Item, 0, sizeof(STRUCT_ITEM));

		if (rand_ <= 25)
		{
			Item.sIndex = 643;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 2; //efeito DN
			Item.stEffect[1].cValue = 16; //valor
		}

		else if (rand_ <= 50)
		{
			Item.sIndex = 643;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 2; //efeito deff
			Item.stEffect[1].cValue = 24; //valor

		}

		else if (rand_ <= 75)
		{
			Item.sIndex = 643;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 2; //efeito mg
			Item.stEffect[1].cValue = 30; //valor

		}

		else
		{
			Item.sIndex = 643;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 2; //efeito skill
			Item.stEffect[1].cValue = 36; //valor

		}

		/*else
		{
			Item.sIndex = 595;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 0; //efeito crit
			Item.stEffect[1].cValue = 0; //valor

		}*/

		PutItem(conn, &Item);

		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));
		return;
	}

#pragma region >> amuleto de cristal //45dn / 40dn / 24mg/ 20mg
	if (item->sIndex == 5638)
	{
		int rand_ = rand() % 100;
		STRUCT_ITEM Item;
		memset(&Item, 0, sizeof(STRUCT_ITEM));

		if (rand_ <= 25)
		{
			Item.sIndex = 563;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 2; //efeito DN
			Item.stEffect[1].cValue = 45; //valor
		}

		else if (rand_ <= 50)
		{
			Item.sIndex = 563;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 60;
			Item.stEffect[1].cValue = 24;

		}

		else if (rand_ <= 75)
		{
			Item.sIndex = 563;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 2; //efeito mg
			Item.stEffect[1].cValue = 40; //valor

		}

		else
		{
			Item.sIndex = 563;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 60; //efeito skill
			Item.stEffect[1].cValue = 20; //valor

		}

		/*else
		{
			Item.sIndex = 595;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 0; //efeito crit
			Item.stEffect[1].cValue = 0; //valor

		}*/

		PutItem(conn, &Item);

		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));
		return;
	}
#pragma endregion
#pragma region >> amuleto de cristal //45dn / 40dn / 24mg/ 20mg
	if (item->sIndex == 5639)
	{
		int rand_ = rand() % 100;
		STRUCT_ITEM Item;
		memset(&Item, 0, sizeof(STRUCT_ITEM));

		if (rand_ <= 25)
		{
			Item.sIndex = 564;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 2; //efeito DN
			Item.stEffect[1].cValue = 45; //valor
		}

		else if (rand_ <= 50)
		{
			Item.sIndex = 564;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 60;
			Item.stEffect[1].cValue = 24;

		}

		else if (rand_ <= 75)
		{
			Item.sIndex = 564;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 2; //efeito mg
			Item.stEffect[1].cValue = 40; //valor

		}

		else
		{
			Item.sIndex = 564;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 60; //efeito skill
			Item.stEffect[1].cValue = 20; //valor

		}

		/*else
		{
			Item.sIndex = 595;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 0; //efeito crit
			Item.stEffect[1].cValue = 0; //valor

		}*/

		PutItem(conn, &Item);

		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));
		return;
	}
#pragma endregion
#pragma region >> amuleto de cristal //45dn / 40dn / 24mg/ 20mg
	if (item->sIndex == 5640)
	{
		int rand_ = rand() % 100;
		STRUCT_ITEM Item;
		memset(&Item, 0, sizeof(STRUCT_ITEM));

		if (rand_ <= 25)
		{
			Item.sIndex = 565;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 2; //efeito DN
			Item.stEffect[1].cValue = 45; //valor
		}

		else if (rand_ <= 50)
		{
			Item.sIndex = 565;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 60;
			Item.stEffect[1].cValue = 24;

		}

		else if (rand_ <= 75)
		{
			Item.sIndex = 565;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 2; //efeito mg
			Item.stEffect[1].cValue = 40; //valor

		}

		else
		{
			Item.sIndex = 565;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 60; //efeito skill
			Item.stEffect[1].cValue = 20; //valor

		}

		/*else
		{
			Item.sIndex = 595;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 0; //efeito crit
			Item.stEffect[1].cValue = 0; //valor

		}*/

		PutItem(conn, &Item);

		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));
		return;
	}
#pragma endregion
#pragma region >> amuleto de cristal //45dn / 40dn / 24mg/ 20mg
	if (item->sIndex == 5641)
	{
		int rand_ = rand() % 100;
		STRUCT_ITEM Item;
		memset(&Item, 0, sizeof(STRUCT_ITEM));

		if (rand_ <= 25)
		{
			Item.sIndex = 566;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 2; //efeito DN
			Item.stEffect[1].cValue = 45; //valor
		}

		else if (rand_ <= 50)
		{
			Item.sIndex = 566;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 60;
			Item.stEffect[1].cValue = 24;

		}

		else if (rand_ <= 75)
		{
			Item.sIndex = 566;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 2; //efeito mg
			Item.stEffect[1].cValue = 40; //valor

		}

		else
		{
			Item.sIndex = 566;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 60; //efeito skill
			Item.stEffect[1].cValue = 20; //valor

		}

		/*else
		{
			Item.sIndex = 595;
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 0; //efeito crit
			Item.stEffect[1].cValue = 0; //valor

		}*/

		PutItem(conn, &Item);

		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);

		else
			memset(item, 0, sizeof(STRUCT_ITEM));
		return;
	}
#pragma endregion
#pragma region >> caixa premiada
	if (item->sIndex == 5642)
	{
		int rand_ = rand() % 100;
		STRUCT_ITEM Item;
		memset(&Item, 0, sizeof(STRUCT_ITEM));

		if (rand_ <= 10)
		{
			Item.sIndex = 1760;
			Item.stEffect[0].cEffect = 0; //efeito REF
			Item.stEffect[0].cValue = 0; //valor

		}
		else if (rand_ <= 20)
		{
			Item.sIndex = 1761;
			Item.stEffect[0].cEffect = 0; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
		}
		else if (rand_ <= 30)
		{
			Item.sIndex = 1762;
			Item.stEffect[0].cEffect = 0; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
		}
		else if (rand_ <= 40)
		{
			Item.sIndex = 1763;
			Item.stEffect[0].cEffect = 0; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
		}
		else if (rand_ <= 50)
		{
			Item.sIndex = 5643;
			Item.stEffect[0].cEffect = 0; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
		}
		else if (rand_ <= 60)
		{
			Item.sIndex = 413;
			Item.stEffect[0].cEffect = 61; //efeito REF
			Item.stEffect[0].cValue = 50; //valor
		}
		else if (rand_ <= 70)
		{
			Item.sIndex = 412;
			Item.stEffect[0].cEffect = 61; //efeito REF
			Item.stEffect[0].cValue = 100; //valor
		}
		else if (rand_ <= 80)
		{
			Item.sIndex = 2411;
			Item.stEffect[0].cEffect = 61; //efeito REF
			Item.stEffect[0].cValue = 100; //valor
		}
		else if (rand_ <= 90)
		{
			Item.sIndex = 2412;
			Item.stEffect[0].cEffect = 61; //efeito REF
			Item.stEffect[0].cValue = 100; //valor
		}
		else
		{
			Item.sIndex = 2413;
			Item.stEffect[0].cEffect = 61; //efeito REF
			Item.stEffect[0].cValue = 100; //valor
		}
		PutItem(conn, &Item);
		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);
		else
			memset(item, 0, sizeof(STRUCT_ITEM));
		return;
	}


#pragma endregion

#pragma region >> Bau Arcano 5647

	if (item->sIndex == 5647)
	{
		int x = 0;
		int invfree = 0;
		// Random para buscar e verificar os slots do inventário. 
		for (x = 0; x < pMob[conn].MaxCarry; x++)
		{
			if (pMob[conn].MOB.Carry[x].sIndex == 0)
				invfree++;
		}
		if (invfree < 2)
		{
			SendClientMessage(conn, "Seu inventário está cheio.");
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}
		int rand_ = rand() % 100;
		STRUCT_ITEM Item;
		memset(&Item, 0, sizeof(STRUCT_ITEM));
		if (rand_ <= 10)
		{
			Item.sIndex = 413; //lac
			Item.stEffect[0].cEffect = 0; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
		}
		else if (rand_ <= 20)
		{
			Item.sIndex = 412; //ori
			Item.stEffect[0].cEffect = 0; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
		}
		else if (rand_ <= 30)
		{
			Item.sIndex = 4127; //selado
			Item.stEffect[0].cEffect = 0; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
		}
		else if (rand_ <= 40)
		{
			Item.sIndex = 4027; //barra 5 kk
			Item.stEffect[0].cEffect = 0; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
		}
		else if (rand_ <= 50)
		{
			Item.sIndex = 5646; //bau de amago E
			Item.stEffect[0].cEffect = 0; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
		}
		else if (rand_ <= 60)
		{
			Item.sIndex = 612; // Orb
			Item.stEffect[0].cEffect = 0; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
		}
		else if (rand_ <= 70)
		{
			Item.sIndex = 613;// Orb
			Item.stEffect[0].cEffect = 0; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
		}
		else if (rand_ <= 80)
		{
			Item.sIndex = 614;// Orb
			Item.stEffect[0].cEffect = 0; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
		}
		else if (rand_ <= 90)
		{
			Item.sIndex = 615;// Orb
			Item.stEffect[0].cEffect = 0; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
		}
		else
		{
			Item.sIndex = 5645; //bau de ovo E
			Item.stEffect[0].cEffect = 0; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
		}
		PutItem(conn, &Item);
		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);
		else
			memset(item, 0, sizeof(STRUCT_ITEM));
		return;
	}

#pragma endregion
#pragma region >> Bau Mistico 5648

	if (item->sIndex == 5648)
	{
		int x = 0;
		int invfree = 0;
		// Random para buscar e verificar os slots do inventário. 
		for (x = 0; x < pMob[conn].MaxCarry; x++)
		{
			if (pMob[conn].MOB.Carry[x].sIndex == 0)
				invfree++;
		}
		if (invfree < 2)
		{
			SendClientMessage(conn, "Seu inventário está cheio.");
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}
		int rand_ = rand() % 100;
		STRUCT_ITEM Item;
		memset(&Item, 0, sizeof(STRUCT_ITEM));

		if (rand_ <= 7)
		{
			Item.sIndex = 413;//lac
			Item.stEffect[0].cEffect = 61; //efeito REF
			Item.stEffect[0].cValue = 5; //valor

		}
		else if (rand_ <= 14)
		{
			Item.sIndex = 412;//ori
			Item.stEffect[0].cEffect = 61; //efeito REF
			Item.stEffect[0].cValue = 10; //valor
		}
		else if (rand_ <= 21)
		{
			Item.sIndex = 3392;//pesa A ind
			Item.stEffect[0].cEffect = 0; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
		}
		else if (rand_ <= 28)
		{
			Item.sIndex = 3140;//luz
			Item.stEffect[0].cEffect = 0; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
		}
		else if (rand_ <= 35)
		{
			Item.sIndex = 4027;//5mi
			Item.stEffect[0].cEffect = 0; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
		}
		else if (rand_ <= 42)
		{
			Item.sIndex = 5643;//frag da alma
			Item.stEffect[0].cEffect = 0; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
		}
		else if (rand_ <= 49)
		{
			Item.sIndex = 3390;//pesa n ind
			Item.stEffect[0].cEffect = 0; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
		}
		else if (rand_ <= 56)
		{
			Item.sIndex = 3173;//perga n 
			Item.stEffect[0].cEffect = 61; //efeito REF
			Item.stEffect[0].cValue = 5; //valor
		}
		else if (rand_ <= 63)
		{
			Item.sIndex = 4051;//medal dourada
			Item.stEffect[0].cEffect = 61; //efeito REF
			Item.stEffect[0].cValue = 5; //valor
		}
		else if (rand_ <= 70)
		{
			Item.sIndex = 540;//abs perfu
			Item.stEffect[0].cEffect = 0; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
		}
		else if (rand_ <= 77)
		{
			Item.sIndex = 541;//pedra abs
			Item.stEffect[0].cEffect = 0; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
		}
		else if (rand_ <= 84)
		{
			Item.sIndex = 3314;//frango assado
			Item.stEffect[0].cEffect = 61; //efeito REF
			Item.stEffect[0].cValue = 2; //valor
		}
		else if (rand_ <= 91)
		{
			Item.sIndex = 1739;//chocolate do amor
			Item.stEffect[0].cEffect = 61; //efeito REFf
			Item.stEffect[0].cValue = 2; //valor
		}
		else
		{
			Item.sIndex = 3467;//bolsa do andarilho
			Item.stEffect[0].cEffect = 0; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
		}
		PutItem(conn, &Item);
		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);
		else
			memset(item, 0, sizeof(STRUCT_ITEM));
		return;
	}

#pragma endregion
#pragma region >> Bau Normal 5649

	if (item->sIndex == 5649)
	{
		int x = 0;
		int invfree = 0;
		// Random para buscar e verificar os slots do inventário. 
		for (x = 0; x < pMob[conn].MaxCarry; x++)
		{
			if (pMob[conn].MOB.Carry[x].sIndex == 0)
				invfree++;
		}
		if (invfree < 2)
		{
			SendClientMessage(conn, "Seu inventário está cheio.");
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}
		int rand_ = rand() % 100;
		STRUCT_ITEM Item;
		memset(&Item, 0, sizeof(STRUCT_ITEM));

		if (rand_ <= 2)
		{
			Item.sIndex = 3172;//carta n
			Item.stEffect[0].cEffect = 0; //efeito REF
			Item.stEffect[0].cValue = 0; //valor

		}
		else if (rand_ <= 10)
		{
			Item.sIndex = 413;//lac
			Item.stEffect[0].cEffect = 0; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
		}
		else if (rand_ <= 30)
		{
			Item.sIndex = 412;//ori
			Item.stEffect[0].cEffect = 0; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
		}
		else if (rand_ <= 35)
		{
			Item.sIndex = 578;//adaman
			Item.stEffect[0].cEffect = 0; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
		}
		else if (rand_ <= 40)
		{
			Item.sIndex = 3390;//pesa n ind
			Item.stEffect[0].cEffect = 0; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
		}
		else if (rand_ <= 50)
		{
			Item.sIndex = 2405;// anda B
			Item.stEffect[0].cEffect = 0; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
		}
		else if (rand_ <= 60)
		{
			Item.sIndex = 2400;//anda N
			Item.stEffect[0].cEffect = 0; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
		}
		else if (rand_ <= 70)
		{
			Item.sIndex = 4019;
			Item.stEffect[0].cEffect = 0; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
		}
		else if (rand_ <= 80)
		{
			Item.sIndex = 4026;
			Item.stEffect[0].cEffect = 0; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
		}
		else
		{
			Item.sIndex = 3173;
			Item.stEffect[0].cEffect = 0; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
		}
		PutItem(conn, &Item);
		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);
		else
			memset(item, 0, sizeof(STRUCT_ITEM));
		return;
	}

#pragma endregion

	//BAU DE OVOS UNI - PEGASUS - INISUS ANDAB - ANDA N - FERRIR  
#pragma region >> Bau Ovos E 5645

	if (item->sIndex == 5645)
	{
		int x = 0;
		int invfree = 0;
		// Random para buscar e verificar os slots do inventário. 
		for (x = 0; x < pMob[conn].MaxCarry; x++)
		{
			if (pMob[conn].MOB.Carry[x].sIndex == 0)
				invfree++;
		}
		if (invfree < 2)
		{
			SendClientMessage(conn, "Seu inventário está cheio.");
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}
		int rand_ = rand() % 100;
		STRUCT_ITEM Item;
		memset(&Item, 0, sizeof(STRUCT_ITEM));

		if (rand_ <= 10)
		{
			Item.sIndex = 2321; // Uni
			Item.stEffect[0].cEffect = 0; //efeito REF
			Item.stEffect[0].cValue = 0; //valor

		}
		else if (rand_ <= 20)
		{
			Item.sIndex = 2322; //pegasus
			Item.stEffect[0].cEffect = 0; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
		}
		else if (rand_ <= 30)
		{
			Item.sIndex = 2323;//unissus
			Item.stEffect[0].cEffect = 0; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
		}
		else if (rand_ <= 53)
		{
			Item.sIndex = 2315;//anda B
			Item.stEffect[0].cEffect = 0; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
		}
		else if (rand_ <= 76)
		{
			Item.sIndex = 2310;//anda N
			Item.stEffect[0].cEffect = 0; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
		}
		else
		{
			Item.sIndex = 2316;//fenrrir
			Item.stEffect[0].cEffect = 0; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
		}
		PutItem(conn, &Item);
		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);
		else
			memset(item, 0, sizeof(STRUCT_ITEM));
		return;
	}

#pragma endregion
#pragma region >> Bau amagos E 5646

	if (item->sIndex == 5646)
	{
		SendEmotion(conn, 100, rand() % 5);
		int x = 0;
		int invfree = 0;
		// Random para buscar e verificar os slots do inventário. 
		for (x = 0; x < pMob[conn].MaxCarry; x++)
		{
			if (pMob[conn].MOB.Carry[x].sIndex == 0)
				invfree++;
		}
		if (invfree < 2)
		{
			SendClientMessage(conn, "Seu inventário está cheio.");
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}
		int rand_ = rand() % 100;
		STRUCT_ITEM Item;
		memset(&Item, 0, sizeof(STRUCT_ITEM));

		if (rand_ <= 5)
		{
			Item.sIndex = 2411;
			Item.stEffect[0].cEffect = 0; //efeito REF
			Item.stEffect[0].cValue = 0; //valor

		}
		else if (rand_ <= 10)
		{
			Item.sIndex = 2412;//pegasus
			Item.stEffect[0].cEffect = 0; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
		}
		else if (rand_ <= 15)
		{
			Item.sIndex = 2413;//unissus
			Item.stEffect[0].cEffect = 0; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
		}
		else if (rand_ <= 20)
		{
			Item.sIndex = 2406;//fenrrir
			Item.stEffect[0].cEffect = 0; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
		}
		else if (rand_ <= 25)
		{
			Item.sIndex = 2405;//anda B
			Item.stEffect[0].cEffect = 0; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
		}
		else if (rand_ <= 30)
		{
			Item.sIndex = 2400;//anda N
			Item.stEffect[0].cEffect = 0; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
		}
		else if (rand_ <= 60)
		{
			Item.sIndex = 2415;//hipogrifo
			Item.stEffect[0].cEffect = 0; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
		}
		else
		{
			Item.sIndex = 2414;//anda N
			Item.stEffect[0].cEffect = 0; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
		}
		PutItem(conn, &Item);
		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);
		else
			memset(item, 0, sizeof(STRUCT_ITEM));
		return;
	}

#pragma endregion
#pragma region >> Griupam aleatorio 5650

	if (item->sIndex == 5650)
	{
		int x = 0;
		int invfree = 0;
		// Random para buscar e verificar os slots do inventário. 
		for (x = 0; x < pMob[conn].MaxCarry; x++)
		{
			if (pMob[conn].MOB.Carry[x].sIndex == 0)
				invfree++;
		}
		if (invfree < 2)
		{
			SendClientMessage(conn, "Seu inventário está cheio.");
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}
		int rand_ = rand() % 100;
		STRUCT_ITEM Item;
		memset(&Item, 0, sizeof(STRUCT_ITEM));

		if (rand_ <= 25)
		{
			Item.sIndex = 1726;//griupam
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 2; //efeito REF
			Item.stEffect[1].cValue = 36; //valor
		}
		else if (rand_ <= 50)
		{
			Item.sIndex = 1726;//griupam
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 60; //efeito REF
			Item.stEffect[1].cValue = 14; //valor
		}
		else if (rand_ <= 75)
		{
			Item.sIndex = 1726;//griupam
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 69; //efeito REF
			Item.stEffect[1].cValue = 5; //valor
		}
		else
		{
			Item.sIndex = 1726;//griupam
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 70; //efeito REF
			Item.stEffect[1].cValue = 5; //valor
		}
		PutItem(conn, &Item);
		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);
		else
			memset(item, 0, sizeof(STRUCT_ITEM));
		return;
	}
#pragma endregion
#pragma region
	if (item->sIndex == 3392)
	{
		SendClientMessage(conn, "Não permitido o uso do pesa individual");
		SendItem(conn, m->SourType, m->SourPos, &pMob[conn].MOB.Carry[m->SourPos]);

	}
#pragma endregion
#pragma region
	if (item->sIndex == 3326)
	{
		SendClientMessage(conn, "Não permitido o uso do pesa Grupo");
		SendItem(conn, m->SourType, m->SourPos, &pMob[conn].MOB.Carry[m->SourPos]);

	}
#pragma endregion

	//BAU EVENTO SO CLICLAR
#pragma region >> Bau do evento 1 // 486

	if (item->sIndex == 486)
	{
		int x = 0;
		int invfree = 0;
		// Random para buscar e verificar os slots do inventário. 
		for (x = 0; x < pMob[conn].MaxCarry; x++)
		{
			if (pMob[conn].MOB.Carry[x].sIndex == 0)
				invfree++;
		}
		if (invfree < 2)
		{
			SendClientMessage(conn, "Seu inventário está cheio.");
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}
		int rand_ = rand() % 100;
		STRUCT_ITEM Item;
		memset(&Item, 0, sizeof(STRUCT_ITEM));

		if (rand_ <= 14)
		{
			Item.sIndex = 413;//pl
			Item.stEffect[0].cEffect = 61; //efeito REF
			Item.stEffect[0].cValue = 5; //valor
			Item.stEffect[1].cEffect = 0; //efeito REF
			Item.stEffect[1].cValue = 0; //valor
		}
		else if (rand_ <= 28)
		{
			Item.sIndex = 412;//po
			Item.stEffect[0].cEffect = 61; //efeito REF
			Item.stEffect[0].cValue = 5; //valor
			Item.stEffect[1].cEffect = 0; //efeito REF
			Item.stEffect[1].cValue = 0; //valor
		}
		else if (rand_ <= 42)
		{
			Item.sIndex = 2406;//fenrrir
			Item.stEffect[0].cEffect = 61; //efeito REF
			Item.stEffect[0].cValue = 10; //valor
			Item.stEffect[1].cEffect = 0; //efeito REF
			Item.stEffect[1].cValue = 0; //valor
		}
		else if (rand_ <= 56)
		{
			Item.sIndex = 2405;//anda b
			Item.stEffect[0].cEffect = 61; //efeito REF
			Item.stEffect[0].cValue = 10; //valor
			Item.stEffect[1].cEffect = 0; //efeito REF
			Item.stEffect[1].cValue = 0; //valor
		}
		else if (rand_ <= 70)
		{
			Item.sIndex = 2400;//anda n
			Item.stEffect[0].cEffect = 61; //efeito REF
			Item.stEffect[0].cValue = 10; //valor
			Item.stEffect[1].cEffect = 0; //efeito REF
			Item.stEffect[1].cValue = 0; //valor
		}
		else if (rand_ <= 84)
		{
			Item.sIndex = 4027;//barra 5kk
			Item.stEffect[0].cEffect = 0; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 0; //efeito REF
			Item.stEffect[1].cValue = 0; //valor
		}
		else
		{
			Item.sIndex = 477;//bau II
			Item.stEffect[0].cEffect = 0; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 0; //efeito REF
			Item.stEffect[1].cValue = 0; //valor
		}
		PutItem(conn, &Item);
		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);
		else
			memset(item, 0, sizeof(STRUCT_ITEM));
		return;
	}

#pragma endregion
#pragma region >> Bau do evento 2 /477

	if (item->sIndex == 477)
	{
		int x = 0;
		int invfree = 0;
		// Random para buscar e verificar os slots do inventário. 
		for (x = 0; x < pMob[conn].MaxCarry; x++)
		{
			if (pMob[conn].MOB.Carry[x].sIndex == 0)
				invfree++;
		}
		if (invfree < 2)
		{
			SendClientMessage(conn, "Seu inventário está cheio.");
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}
		int rand_ = rand() % 100;
		STRUCT_ITEM Item;
		memset(&Item, 0, sizeof(STRUCT_ITEM));

		if (rand_ <= 20)
		{
			Item.sIndex = 5134;//pista+1
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 1; //valor
			Item.stEffect[1].cEffect = 0; //efeito REF
			Item.stEffect[1].cValue = 0; //valor
		}
		else if (rand_ <= 40)
		{
			Item.sIndex = 540;//abs
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 0; //efeito REF
			Item.stEffect[1].cValue = 0; //valor
		}
		else if (rand_ <= 60)
		{
			Item.sIndex = 541;//perfu
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 0; //efeito REF
			Item.stEffect[1].cValue = 0; //valor
		}
		else if (rand_ <= 80)
		{
			Item.sIndex = 4027;//barra 5kk
			Item.stEffect[0].cEffect = 0; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 0; //efeito REF
			Item.stEffect[1].cValue = 0; //valor
		}
		else
		{
			Item.sIndex = 478;//bau II
			Item.stEffect[0].cEffect = 0; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 0; //efeito REF
			Item.stEffect[1].cValue = 0; //valor
		}
		PutItem(conn, &Item);
		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);
		else
			memset(item, 0, sizeof(STRUCT_ITEM));
		return;
	}

#pragma endregion
#pragma region >> Bau do evento 3 //478

	if (item->sIndex == 478)
	{
		int x = 0;
		int invfree = 0;
		// Random para buscar e verificar os slots do inventário. 
		for (x = 0; x < pMob[conn].MaxCarry; x++)
		{
			if (pMob[conn].MOB.Carry[x].sIndex == 0)
				invfree++;
		}
		if (invfree < 2)
		{
			SendClientMessage(conn, "Seu inventário está cheio.");
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}
		int rand_ = rand() % 100;
		STRUCT_ITEM Item;
		memset(&Item, 0, sizeof(STRUCT_ITEM));

		if (rand_ <= 14)
		{
			Item.sIndex = 5643;//frag da arlma
			Item.stEffect[0].cEffect = 0; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 0; //efeito REF
			Item.stEffect[1].cValue = 0; //valor
		}
		else if (rand_ <= 28)
		{
			Item.sIndex = 2414;// amg de grifo
			Item.stEffect[0].cEffect = 61; //efeito REF
			Item.stEffect[0].cValue = 3; //valor
			Item.stEffect[1].cEffect = 0; //efeito REF
			Item.stEffect[1].cValue = 0; //valor
		}
		else if (rand_ <= 42)
		{
			Item.sIndex = 2411;//amg de uni
			Item.stEffect[0].cEffect = 61; //efeito REF
			Item.stEffect[0].cValue = 5; //valor
			Item.stEffect[1].cEffect = 0; //efeito REF
			Item.stEffect[1].cValue = 0; //valor
		}
		else if (rand_ <= 56)
		{
			Item.sIndex = 2412;//amg de pegasus
			Item.stEffect[0].cEffect = 61; //efeito REF
			Item.stEffect[0].cValue = 5; //valor
			Item.stEffect[1].cEffect = 0; //efeito REF
			Item.stEffect[1].cValue = 0; //valor
		}
		else if (rand_ <= 70)
		{
			Item.sIndex = 2413;//amg de unissus
			Item.stEffect[0].cEffect = 61; //efeito REF
			Item.stEffect[0].cValue = 5; //valor
			Item.stEffect[1].cEffect = 0; //efeito REF
			Item.stEffect[1].cValue = 0; //valor
		}
		else if (rand_ <= 84)
		{
			Item.sIndex = 4027;//barra 5kk
			Item.stEffect[0].cEffect = 0; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 0; //efeito REF
			Item.stEffect[1].cValue = 0; //valor
		}
		else
		{
			Item.sIndex = 479;//bau III
			Item.stEffect[0].cEffect = 0; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 0; //efeito REF
			Item.stEffect[1].cValue = 0; //valor
		}
		PutItem(conn, &Item);
		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);
		else
			memset(item, 0, sizeof(STRUCT_ITEM));
		return;
	}

#pragma endregion
#pragma region >> Bau do evento 4 //479

	if (item->sIndex == 479)
	{
		int x = 0;
		int invfree = 0;
		// Random para buscar e verificar os slots do inventário. 
		for (x = 0; x < pMob[conn].MaxCarry; x++)
		{
			if (pMob[conn].MOB.Carry[x].sIndex == 0)
				invfree++;
		}
		if (invfree < 2)
		{
			SendClientMessage(conn, "Seu inventário está cheio.");
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}
		int rand_ = rand() % 100;
		STRUCT_ITEM Item;
		memset(&Item, 0, sizeof(STRUCT_ITEM));

		if (rand_ <= 10)
		{
			Item.sIndex = 633;//abs/30/30
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 0; //efeito REF
			Item.stEffect[1].cValue = 0; //valor
		}
		else if (rand_ <= 20)
		{
			Item.sIndex = 4151;//medalha dourada
			Item.stEffect[0].cEffect = 0; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 0; //efeito REF
			Item.stEffect[1].cValue = 0; //valor
		}
		else if (rand_ <= 30)
		{
			Item.sIndex = 663;//ank da gloria
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 69; //efeito REF
			Item.stEffect[1].cValue = 12; //valor

		}
		else if (rand_ <= 40)
		{
			Item.sIndex = 663;//ank da gloria
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 2; //efeito REF
			Item.stEffect[1].cValue = 54; //valor

		}
		else if (rand_ <= 50)
		{
			Item.sIndex = 661;//ank da justiça
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 70; //efeito REF
			Item.stEffect[1].cValue = 12; //valor

		}
		else if (rand_ <= 60)
		{
			Item.sIndex = 661;// ank da justiça
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 60; //efeito REF
			Item.stEffect[1].cValue = 20; //valor
		}
		else if (rand_ <= 70)
		{
			Item.sIndex = 662;//ank da eternidade
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 69; //efeito REF
			Item.stEffect[1].cValue = 12; //valor
		}
		else if (rand_ <= 80)
		{
			Item.sIndex = 662;//ank da eternidade
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 60; //efeito REF
			Item.stEffect[1].cValue = 20; //valor
		}
		else if (rand_ <= 90)
		{
			Item.sIndex = 2324;//ovo de grifo
			Item.stEffect[0].cEffect = 0; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 0; //efeito REF
			Item.stEffect[1].cValue = 0; //valor
		}
		else
		{
			Item.sIndex = 489;//bau 5
			Item.stEffect[0].cEffect = 0; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 0; //efeito REF
			Item.stEffect[1].cValue = 0; //valor
		}
		PutItem(conn, &Item);
		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);
		else
			memset(item, 0, sizeof(STRUCT_ITEM));
		return;
	}

#pragma endregion
	// bau de armas 63 e 32 para trocar com + 50 de honra arma D com add top
#pragma region //troca com honra //bau de armas //bau 5 //489
	if (item->sIndex == 489) // id do bau
	{
		int x = 0;
		int invfree = 0;
		// Random para buscar e verificar os slots do inventário. 
		for (x = 0; x < pMob[conn].MaxCarry; x++)
		{
			if (pMob[conn].MOB.Carry[x].sIndex == 0)
				invfree++;
		}
		if (invfree < 2)
		{
			SendClientMessage(conn, "Seu inventário está cheio.");
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		int rand_ = rand() % 100;
		STRUCT_ITEM Item;
		memset(&Item, 0, sizeof(STRUCT_ITEM));

		if (rand_ <= 10)
		{
			Item.sIndex = 902;//ambar
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 60; //efeito REF
			Item.stEffect[1].cValue = 32; //valor
			Item.stEffect[2].cEffect = 0; //efeito REF
			Item.stEffect[2].cValue = 0; //valor
		}
		else if (rand_ <= 20)
		{
			Item.sIndex = 855;//triunfo
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 60; //efeito REF
			Item.stEffect[1].cValue = 32; //valor
			Item.stEffect[2].cEffect = 0; //efeito REF
			Item.stEffect[2].cValue = 0; //valor
		}
		else if (rand_ <= 30)
		{
			Item.sIndex = 900;//furia divida
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 60; //efeito REF
			Item.stEffect[1].cValue = 32; //valor
			Item.stEffect[2].cEffect = 0; //efeito REF
			Item.stEffect[2].cValue = 0; //valor
		}
		else if (rand_ <= 40)
		{
			Item.sIndex = 810;//martelo assassino
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 2; //efeito REF
			Item.stEffect[1].cValue = 63; //valor
			Item.stEffect[2].cEffect = 0; //efeito REF
			Item.stEffect[2].cValue = 0; //valor
		}
		else if (rand_ <= 50)
		{
			Item.sIndex = 840;//garra draco
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 2; //efeito REF
			Item.stEffect[1].cValue = 63; //valor
			Item.stEffect[2].cEffect = 0; //efeito REF
			Item.stEffect[2].cValue = 0; //valor
		}
		else if (rand_ <= 60)
		{
			Item.sIndex = 870;//vorpal
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 2; //efeito REF
			Item.stEffect[1].cValue = 63; //valor
			Item.stEffect[2].cEffect = 0; //efeito REF
			Item.stEffect[2].cValue = 0; //valor
		}
		else if (rand_ <= 70)
		{
			Item.sIndex = 825;//arco divino
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 2; //efeito REF
			Item.stEffect[1].cValue = 63; //valor
			Item.stEffect[2].cEffect = 0; //efeito REF
			Item.stEffect[2].cValue = 0; //valor
		}
		else if (rand_ <= 80)
		{
			Item.sIndex = 936;//mjonir
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 2; //efeito REF
			Item.stEffect[1].cValue = 63; //valor
			Item.stEffect[2].cEffect = 0; //efeito REF
			Item.stEffect[2].cValue = 0; //valor
		}
		else if (rand_ <= 90)
		{
			Item.sIndex = 885;//cruz sagrada
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 2; //efeito REF
			Item.stEffect[1].cValue = 63; //valor
			Item.stEffect[2].cEffect = 0; //efeito REF
			Item.stEffect[2].cValue = 0; //valor
		}
		else
		{
			Item.sIndex = 911;//solaris
			Item.stEffect[0].cEffect = 43; //efeito REF
			Item.stEffect[0].cValue = 0; //valor
			Item.stEffect[1].cEffect = 2; //efeito REF
			Item.stEffect[1].cValue = 63; //valor
			Item.stEffect[2].cEffect = 0; //efeito REF
			Item.stEffect[2].cValue = 0; //valor
		}
		PutItem(conn, &Item);
		SendEtc(conn);
		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);
		else
			memset(item, 0, sizeof(STRUCT_ITEM));
		return;
		SendClientMessage(conn, "Troca Concluida !! ");
		SendItem(conn, m->SourType, m->SourPos, &pMob[conn].MOB.Carry[m->SourPos]);
	}
#pragma endregion
	if (item->sIndex == 5774)//Alicate Cinto
	{		
		if (pUser[conn].Joias[pUser[conn].Slot][0].sIndex != 0) {
			memset(item, 0, sizeof(STRUCT_ITEM));
			SendItem(conn, m->SourType, m->SourPos, item);

			PutItem(conn, &pUser[conn].Joias[pUser[conn].Slot][0]);
			memset(&pUser[conn].Joias[pUser[conn].Slot][0], 0, sizeof(STRUCT_ITEM));
			pMob[conn].GetCurrentScore(conn);
			SendScore(conn);
			SendJoias(conn);
			SaveUser(conn, 0);
			SendClientMessage(conn, "Cinto retirado com sucesso");
		}
		else
		{
			SendClientMessage(conn, "Não há Cinto equipado");
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}
	}
	if (item->sIndex == 5775)//Alicate Colar
	{
		if (pUser[conn].Joias[pUser[conn].Slot][1].sIndex != 0) {
			memset(item, 0, sizeof(STRUCT_ITEM));
			SendItem(conn, m->SourType, m->SourPos, item);

			PutItem(conn, &pUser[conn].Joias[pUser[conn].Slot][1]);
			memset(&pUser[conn].Joias[pUser[conn].Slot][1], 0, sizeof(STRUCT_ITEM));
			pMob[conn].GetCurrentScore(conn);
			SendScore(conn);
			SendJoias(conn);
			SaveUser(conn, 0);
			SendClientMessage(conn, "Colar retirado com sucesso");
		}
		else
		{
			SendClientMessage(conn, "Não há Colares equipados");
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}
	}
#pragma region //skin de arma
	if (item->sIndex == 5662)//balmung
	{
		if (pMob[conn].MOB.Equip[6].sIndex <= 2490
			|| pMob[conn].MOB.Equip[6].sIndex >= 2495)
		{
			SendClientMessage(conn, "Voce deve equipar a arma correta no primeiro slot");
			SendItem(conn, m->SourType, m->SourPos, item);
			return;
		}

		if (pMob[conn].MOB.Equip[6].sIndex >= 2491 ||
			pMob[conn].MOB.Equip[6].sIndex <= 2494)
		{

			pMob[conn].MOB.Equip[6].sIndex = 1016;
			SendClientMessage(conn, "Skin adicionada com sucesso");
			SendItem(conn, ITEM_PLACE_EQUIP, 6, &pMob[conn].MOB.Equip[6]);

		}

		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);
		else
			memset(item, 0, sizeof(STRUCT_ITEM));
		return;
		SendItem(conn, m->SourType, m->SourPos, item);
		SendEmotion(conn, 14, 3);
	}
#pragma endregion
#pragma region//skin de arma
	if (item->sIndex == 5663)//sky
	{
		if (pMob[conn].MOB.Equip[6].sIndex <= 2550 ||
			pMob[conn].MOB.Equip[6].sIndex >= 2555)
		{
			SendItem(conn, m->SourType, m->SourPos, item);
			SendClientMessage(conn, "Voce deve equipar a arma correta no primeiro slot");
			return;
		}

		if (pMob[conn].MOB.Equip[6].sIndex >= 2551 ||
			pMob[conn].MOB.Equip[6].sIndex <= 2554)
		{
			pMob[conn].MOB.Equip[6].sIndex = 1020;
			SendClientMessage(conn, "Skin adicionada com sucesso");
			SendItem(conn, ITEM_PLACE_EQUIP, 6, &pMob[conn].MOB.Equip[6]);
		}
		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);
		else
			memset(item, 0, sizeof(STRUCT_ITEM));
		return;
		SendItem(conn, m->SourType, m->SourPos, &pMob[conn].MOB.Carry[m->SourPos]);
	}
#pragma endregion
#pragma region//skin de arma
	if (item->sIndex == 5664)//khy
	{
		if (pMob[conn].MOB.Equip[6].sIndex <= 2610 ||
			pMob[conn].MOB.Equip[6].sIndex >= 2615)
		{
			SendItem(conn, m->SourType, m->SourPos, item);
			SendClientMessage(conn, "Voce deve equipar a arma correta no primeiro slot");
			return;
		}

		if (pMob[conn].MOB.Equip[6].sIndex >= 2611 ||
			pMob[conn].MOB.Equip[6].sIndex <= 2614)
		{
			pMob[conn].MOB.Equip[6].sIndex = 1024;
			SendClientMessage(conn, "Skin adicionada com sucesso");
			SendItem(conn, ITEM_PLACE_EQUIP, 6, &pMob[conn].MOB.Equip[6]);
		}
		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);
		else
			memset(item, 0, sizeof(STRUCT_ITEM));
		return;
		SendItem(conn, m->SourType, m->SourPos, &pMob[conn].MOB.Carry[m->SourPos]);
	}
#pragma endregion
#pragma region//skin de arma
	if (item->sIndex == 5665)//gleip
	{
		if (pMob[conn].MOB.Equip[6].sIndex <= 2670 ||
			pMob[conn].MOB.Equip[6].sIndex >= 2675)
		{
			SendItem(conn, m->SourType, m->SourPos, item);
			SendClientMessage(conn, "Voce deve equipar a arma correta no primeiro slot");
			return;
		}

		if (pMob[conn].MOB.Equip[6].sIndex >= 2671 ||
			pMob[conn].MOB.Equip[6].sIndex <= 2674)
		{
			pMob[conn].MOB.Equip[6].sIndex = 1028;
			SendClientMessage(conn, "Skin adicionada com sucesso");
			SendItem(conn, ITEM_PLACE_EQUIP, 6, &pMob[conn].MOB.Equip[6]);
		}
		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);
		else
			memset(item, 0, sizeof(STRUCT_ITEM));
		return;
		SendItem(conn, m->SourType, m->SourPos, &pMob[conn].MOB.Carry[m->SourPos]);
	}
#pragma endregion
#pragma region//skin de arma
	if (item->sIndex == 5666)//cali
	{
		if (pMob[conn].MOB.Equip[6].sIndex <= 2730 ||
			pMob[conn].MOB.Equip[6].sIndex >= 2735)
		{
			SendItem(conn, m->SourType, m->SourPos, item);
			SendClientMessage(conn, "Voce deve equipar a arma correta no primeiro slot");
			return;
		}

		if (pMob[conn].MOB.Equip[6].sIndex >= 2731 ||
			pMob[conn].MOB.Equip[6].sIndex <= 2734)
		{
			pMob[conn].MOB.Equip[6].sIndex = 1032;
			SendClientMessage(conn, "Skin adicionada com sucesso");
			SendItem(conn, ITEM_PLACE_EQUIP, 6, &pMob[conn].MOB.Equip[6]);
		}
		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);
		else
			memset(item, 0, sizeof(STRUCT_ITEM));
		return;
		SendItem(conn, m->SourType, m->SourPos, &pMob[conn].MOB.Carry[m->SourPos]);
	}
#pragma endregion
#pragma region//skin de arma
	if (item->sIndex == 5667)//hermay
	{
		if (pMob[conn].MOB.Equip[6].sIndex <= 2790 ||
			pMob[conn].MOB.Equip[6].sIndex >= 2795)
		{
			SendItem(conn, m->SourType, m->SourPos, item);
			SendClientMessage(conn, "Voce deve equipar a arma correta no primeiro slot");
			return;
		}

		if (pMob[conn].MOB.Equip[6].sIndex >= 2791 ||
			pMob[conn].MOB.Equip[6].sIndex <= 2794)
		{
			pMob[conn].MOB.Equip[6].sIndex = 1036;
			SendClientMessage(conn, "Skin adicionada com sucesso");
			SendItem(conn, ITEM_PLACE_EQUIP, 6, &pMob[conn].MOB.Equip[6]);
		}
		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);
		else
			memset(item, 0, sizeof(STRUCT_ITEM));
		return;
		SendItem(conn, m->SourType, m->SourPos, &pMob[conn].MOB.Carry[m->SourPos]);
	}
#pragma endregion
#pragma region//skin de arma
	if (item->sIndex == 5668)//neo
	{
		if (pMob[conn].MOB.Equip[6].sIndex <= 2858 ||
			pMob[conn].MOB.Equip[6].sIndex >= 2863)
		{
			SendItem(conn, m->SourType, m->SourPos, item);
			SendClientMessage(conn, "Voce deve equipar a arma correta no primeiro slot");
			return;
		}

		if (pMob[conn].MOB.Equip[6].sIndex >= 2859 ||
			pMob[conn].MOB.Equip[6].sIndex <= 2862)
		{
			pMob[conn].MOB.Equip[6].sIndex = 1040;
			SendClientMessage(conn, "Skin adicionada com sucesso");
			SendItem(conn, ITEM_PLACE_EQUIP, 6, &pMob[conn].MOB.Equip[6]);
		}
		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);
		else
			memset(item, 0, sizeof(STRUCT_ITEM));
		return;
		SendItem(conn, m->SourType, m->SourPos, &pMob[conn].MOB.Carry[m->SourPos]);
	}
#pragma endregion
#pragma region//skin de arma
	if (item->sIndex == 5669)//eiranus
	{
		if (pMob[conn].MOB.Equip[6].sIndex <= 2862 ||
			pMob[conn].MOB.Equip[6].sIndex >= 2867)
		{
			SendItem(conn, m->SourType, m->SourPos, item);
			SendClientMessage(conn, "Voce deve equipar a arma correta no primeiro slot");
			return;
		}

		if (pMob[conn].MOB.Equip[6].sIndex >= 2863 ||
			pMob[conn].MOB.Equip[6].sIndex <= 2866)
		{
			pMob[conn].MOB.Equip[6].sIndex = 1044;
			SendClientMessage(conn, "Skin adicionada com sucesso");
			SendItem(conn, ITEM_PLACE_EQUIP, 6, &pMob[conn].MOB.Equip[6]);
		}
		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);
		else
			memset(item, 0, sizeof(STRUCT_ITEM));
		return;
		SendItem(conn, m->SourType, m->SourPos, &pMob[conn].MOB.Carry[m->SourPos]);
	}
#pragma endregion
#pragma region//skin de arma
	if (item->sIndex == 5670)//thray
	{
		if (pMob[conn].MOB.Equip[6].sIndex <= 2894 ||
			pMob[conn].MOB.Equip[6].sIndex >= 2899)
		{
			SendItem(conn, m->SourType, m->SourPos, item);
			SendClientMessage(conn, "Voce deve equipar a arma correta no primeiro slot");
			return;
		}

		if (pMob[conn].MOB.Equip[6].sIndex >= 2895 ||
			pMob[conn].MOB.Equip[6].sIndex <= 2898)
		{
			pMob[conn].MOB.Equip[6].sIndex = 1048;
			SendClientMessage(conn, "Skin adicionada com sucesso");
			SendItem(conn, ITEM_PLACE_EQUIP, 6, &pMob[conn].MOB.Equip[6]);
		}
		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);
		else
			memset(item, 0, sizeof(STRUCT_ITEM));
		return;
		SendItem(conn, m->SourType, m->SourPos, &pMob[conn].MOB.Carry[m->SourPos]);
	}
#pragma endregion
#pragma region//skin de arma
	if (item->sIndex == 5671)//basi
	{
		if (pMob[conn].MOB.Equip[6].sIndex >= 2939 ||
			pMob[conn].MOB.Equip[6].sIndex <= 2934)
		{
			SendItem(conn, m->SourType, m->SourPos, item);
			SendClientMessage(conn, "Voce deve equipar a arma correta no primeiro slot");
			return;
		}

		if (pMob[conn].MOB.Equip[6].sIndex <= 2935 ||
			pMob[conn].MOB.Equip[6].sIndex >= 2938)
		{
			pMob[conn].MOB.Equip[6].sIndex = 1052;
			SendClientMessage(conn, "Skin adicionada com sucesso");
			SendItem(conn, ITEM_PLACE_EQUIP, 6, &pMob[conn].MOB.Equip[6]);
		}
		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);
		else
			memset(item, 0, sizeof(STRUCT_ITEM));
		return;
		SendItem(conn, m->SourType, m->SourPos, &pMob[conn].MOB.Carry[m->SourPos]);
		SendEmotion(conn, 14, 3);
	}
#pragma endregion
#pragma region //Tintura de arma
	if (item->sIndex == 3480) //color arma
	{
		STRUCT_ITEM* dest = GetItemPointer(&pMob[conn].MOB, pUser[conn].Cargo, m->DestType, m->DestPos);

		if (dest == NULL)
			return;

		int nPos = g_pItemList[dest->sIndex].nPos;

		int sanc = BASE_GetItemSanc(dest);
		int ItemId = dest->sIndex;

		if (pMob[conn].MOB.Equip[6].sIndex >= 801 || pMob[conn].MOB.Equip[6].sIndex >= 1055 ||
			pMob[conn].MOB.Equip[6].sIndex >= 2451 || pMob[conn].MOB.Equip[6].sIndex >= 2938 ||
			pMob[conn].MOB.Equip[6].sIndex >= 3551 || pMob[conn].MOB.Equip[6].sIndex >= 3800)
		{
			pMob[conn].MOB.Equip[6].stEffect[0].cEffect = 116; //efeito REF
			SendClientMessage(conn, "Cor adicionada com sucesso");
			SendItem(conn, ITEM_PLACE_EQUIP, 6, &pMob[conn].MOB.Equip[6]);
		}
		SendEtc(conn);
		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);
		else
			memset(item, 0, sizeof(STRUCT_ITEM));
		return;
		SendItem(conn, m->SourType, m->SourPos, &pMob[conn].MOB.Carry[m->SourPos]);
	}
#pragma endregion
#pragma region//Tintura de arma
	if (item->sIndex == 3481) //color arma
	{
		STRUCT_ITEM* dest = GetItemPointer(&pMob[conn].MOB, pUser[conn].Cargo, m->DestType, m->DestPos);

		if (dest == NULL)
			return;

		int nPos = g_pItemList[dest->sIndex].nPos;

		int sanc = BASE_GetItemSanc(dest);
		int ItemId = dest->sIndex;

		if (pMob[conn].MOB.Equip[6].sIndex >= 801 || pMob[conn].MOB.Equip[6].sIndex >= 1055 ||
			pMob[conn].MOB.Equip[6].sIndex >= 2451 || pMob[conn].MOB.Equip[6].sIndex >= 2938 ||
			pMob[conn].MOB.Equip[6].sIndex >= 3551 || pMob[conn].MOB.Equip[6].sIndex >= 3800)
		{
			pMob[conn].MOB.Equip[6].stEffect[0].cEffect = 117; //efeito REF
			SendClientMessage(conn, "Cor adicionada com sucesso");
			SendItem(conn, ITEM_PLACE_EQUIP, 6, &pMob[conn].MOB.Equip[6]);
		}
		SendEtc(conn);
		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);
		else
			memset(item, 0, sizeof(STRUCT_ITEM));
		return;
		SendItem(conn, m->SourType, m->SourPos, &pMob[conn].MOB.Carry[m->SourPos]);
	}
#pragma endregion
#pragma region//Tintura de arma
	if (item->sIndex == 3482) //color arma
	{
		STRUCT_ITEM* dest = GetItemPointer(&pMob[conn].MOB, pUser[conn].Cargo, m->DestType, m->DestPos);

		if (dest == NULL)
			return;

		int nPos = g_pItemList[dest->sIndex].nPos;

		int sanc = BASE_GetItemSanc(dest);
		int ItemId = dest->sIndex;


		if (pMob[conn].MOB.Equip[6].sIndex >= 801 || pMob[conn].MOB.Equip[6].sIndex >= 1055 ||
			pMob[conn].MOB.Equip[6].sIndex >= 2451 || pMob[conn].MOB.Equip[6].sIndex >= 2938 ||
			pMob[conn].MOB.Equip[6].sIndex >= 3551 || pMob[conn].MOB.Equip[6].sIndex >= 3800)
		{
			pMob[conn].MOB.Equip[6].stEffect[0].cEffect = 118
				; //efeito REF
			SendClientMessage(conn, "Cor adicionada com sucesso");
			SendItem(conn, ITEM_PLACE_EQUIP, 6, &pMob[conn].MOB.Equip[6]);
		}
		SendEtc(conn);
		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);
		else
			memset(item, 0, sizeof(STRUCT_ITEM));
		return;
		SendItem(conn, m->SourType, m->SourPos, &pMob[conn].MOB.Carry[m->SourPos]);
	}
#pragma endregion
#pragma region//Tintura de arma
	if (item->sIndex == 3483) //color arma
	{
		STRUCT_ITEM* dest = GetItemPointer(&pMob[conn].MOB, pUser[conn].Cargo, m->DestType, m->DestPos);

		if (dest == NULL)
			return;

		int nPos = g_pItemList[dest->sIndex].nPos;
		int sanc = BASE_GetItemSanc(dest);
		int ItemId = dest->sIndex;


		if (pMob[conn].MOB.Equip[6].sIndex >= 801 || pMob[conn].MOB.Equip[6].sIndex >= 1055 ||
			pMob[conn].MOB.Equip[6].sIndex >= 2451 || pMob[conn].MOB.Equip[6].sIndex >= 2938 ||
			pMob[conn].MOB.Equip[6].sIndex >= 3551 || pMob[conn].MOB.Equip[6].sIndex >= 3800)
		{
			pMob[conn].MOB.Equip[6].stEffect[0].cEffect = 119; //efeito REF
			SendClientMessage(conn, "Cor adicionada com sucesso");
			SendItem(conn, ITEM_PLACE_EQUIP, 6, &pMob[conn].MOB.Equip[6]);
		}
		SendEtc(conn);
		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);
		else
			memset(item, 0, sizeof(STRUCT_ITEM));
		return;
		SendItem(conn, m->SourType, m->SourPos, &pMob[conn].MOB.Carry[m->SourPos]);
	}
#pragma endregion
#pragma region//Tintura de arma
	if (item->sIndex == 3484) //color arma
	{
		STRUCT_ITEM* dest = GetItemPointer(&pMob[conn].MOB, pUser[conn].Cargo, m->DestType, m->DestPos);

		if (dest == NULL)
			return;

		int nPos = g_pItemList[dest->sIndex].nPos;

		int sanc = BASE_GetItemSanc(dest);
		int ItemId = dest->sIndex;


		if (pMob[conn].MOB.Equip[6].sIndex >= 801 || pMob[conn].MOB.Equip[6].sIndex >= 1055 ||
			pMob[conn].MOB.Equip[6].sIndex >= 2451 || pMob[conn].MOB.Equip[6].sIndex >= 2938 ||
			pMob[conn].MOB.Equip[6].sIndex >= 3551 || pMob[conn].MOB.Equip[6].sIndex >= 3800)
		{
			pMob[conn].MOB.Equip[6].stEffect[0].cEffect = 120; //efeito REF
			SendClientMessage(conn, "Cor adicionada com sucesso");
			SendItem(conn, ITEM_PLACE_EQUIP, 6, &pMob[conn].MOB.Equip[6]);
		}
		SendEtc(conn);
		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);
		else
			memset(item, 0, sizeof(STRUCT_ITEM));
		return;
		SendItem(conn, m->SourType, m->SourPos, &pMob[conn].MOB.Carry[m->SourPos]);
	}
#pragma endregion
#pragma region//Tintura de arma
	if (item->sIndex == 3485) //color arma
	{
		STRUCT_ITEM* dest = GetItemPointer(&pMob[conn].MOB, pUser[conn].Cargo, m->DestType, m->DestPos);

		if (dest == NULL)
			return;

		int nPos = g_pItemList[dest->sIndex].nPos;

		int sanc = BASE_GetItemSanc(dest);
		int ItemId = dest->sIndex;


		if (pMob[conn].MOB.Equip[6].sIndex >= 801 || pMob[conn].MOB.Equip[6].sIndex >= 1055 ||
			pMob[conn].MOB.Equip[6].sIndex >= 2451 || pMob[conn].MOB.Equip[6].sIndex >= 2938 ||
			pMob[conn].MOB.Equip[6].sIndex >= 3551 || pMob[conn].MOB.Equip[6].sIndex >= 3800)
		{
			pMob[conn].MOB.Equip[6].stEffect[0].cEffect = 121; //efeito REF
			SendClientMessage(conn, "Cor adicionada com sucesso");
			SendItem(conn, ITEM_PLACE_EQUIP, 6, &pMob[conn].MOB.Equip[6]);
		}
		SendEtc(conn);
		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);
		else
			memset(item, 0, sizeof(STRUCT_ITEM));
		return;
		SendItem(conn, m->SourType, m->SourPos, &pMob[conn].MOB.Carry[m->SourPos]);
	}
#pragma endregion
#pragma region//Tintura de arma
	if (item->sIndex == 3486) //color arma
	{
		STRUCT_ITEM* dest = GetItemPointer(&pMob[conn].MOB, pUser[conn].Cargo, m->DestType, m->DestPos);

		if (dest == NULL)
			return;

		int nPos = g_pItemList[dest->sIndex].nPos;

		int sanc = BASE_GetItemSanc(dest);
		int ItemId = dest->sIndex;


		if (pMob[conn].MOB.Equip[6].sIndex >= 801 || pMob[conn].MOB.Equip[6].sIndex >= 1055 ||
			pMob[conn].MOB.Equip[6].sIndex >= 2451 || pMob[conn].MOB.Equip[6].sIndex >= 2938 ||
			pMob[conn].MOB.Equip[6].sIndex >= 3551 || pMob[conn].MOB.Equip[6].sIndex >= 3800)
		{
			pMob[conn].MOB.Equip[6].stEffect[0].cEffect = 122; //efeito REF
			SendClientMessage(conn, "Cor adicionada com sucesso");
			SendItem(conn, ITEM_PLACE_EQUIP, 6, &pMob[conn].MOB.Equip[6]);
		}
		SendEtc(conn);
		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);
		else
			memset(item, 0, sizeof(STRUCT_ITEM));
		return;
		SendItem(conn, m->SourType, m->SourPos, &pMob[conn].MOB.Carry[m->SourPos]);
	}
#pragma endregion
#pragma region//Tintura de arma
	if (item->sIndex == 3487) //color arma
	{
		STRUCT_ITEM* dest = GetItemPointer(&pMob[conn].MOB, pUser[conn].Cargo, m->DestType, m->DestPos);

		if (dest == NULL)
			return;

		int nPos = g_pItemList[dest->sIndex].nPos;
		int sanc = BASE_GetItemSanc(dest);
		int ItemId = dest->sIndex;


		if (pMob[conn].MOB.Equip[6].sIndex >= 801 || pMob[conn].MOB.Equip[6].sIndex >= 1055 ||
			pMob[conn].MOB.Equip[6].sIndex >= 2451 || pMob[conn].MOB.Equip[6].sIndex >= 2938 ||
			pMob[conn].MOB.Equip[6].sIndex >= 3551 || pMob[conn].MOB.Equip[6].sIndex >= 3800)
		{
			pMob[conn].MOB.Equip[6].stEffect[0].cEffect = 123; //efeito REF
			SendClientMessage(conn, "Cor adicionada com sucesso");
			SendItem(conn, ITEM_PLACE_EQUIP, 6, &pMob[conn].MOB.Equip[6]);
		}
		SendEtc(conn);
		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);
		else
			memset(item, 0, sizeof(STRUCT_ITEM));
		return;
		SendItem(conn, m->SourType, m->SourPos, &pMob[conn].MOB.Carry[m->SourPos]);
	}
#pragma endregion
#pragma region//Tintura de arma
	if (item->sIndex == 3488) //color arma
	{
		STRUCT_ITEM* dest = GetItemPointer(&pMob[conn].MOB, pUser[conn].Cargo, m->DestType, m->DestPos);

		if (dest == NULL)
			return;

		int nPos = g_pItemList[dest->sIndex].nPos;
		int sanc = BASE_GetItemSanc(dest);
		int ItemId = dest->sIndex;


		if (pMob[conn].MOB.Equip[6].sIndex >= 801 || pMob[conn].MOB.Equip[6].sIndex >= 1055 ||
			pMob[conn].MOB.Equip[6].sIndex >= 2451 || pMob[conn].MOB.Equip[6].sIndex >= 2938 ||
			pMob[conn].MOB.Equip[6].sIndex >= 3551 || pMob[conn].MOB.Equip[6].sIndex >= 3800)
		{
			pMob[conn].MOB.Equip[6].stEffect[0].cEffect = 124; //efeito REF
			SendClientMessage(conn, "Cor adicionada com sucesso");
			SendItem(conn, ITEM_PLACE_EQUIP, 6, &pMob[conn].MOB.Equip[6]);
		}
		SendEtc(conn);
		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);
		else
			memset(item, 0, sizeof(STRUCT_ITEM));
		return;
		SendItem(conn, m->SourType, m->SourPos, &pMob[conn].MOB.Carry[m->SourPos]);
	}
#pragma endregion
#pragma region//Tintura de arma
	if (item->sIndex == 3489) //color arma
	{
		STRUCT_ITEM* dest = GetItemPointer(&pMob[conn].MOB, pUser[conn].Cargo, m->DestType, m->DestPos);

		if (dest == NULL)
			return;

		int nPos = g_pItemList[dest->sIndex].nPos;
		int sanc = BASE_GetItemSanc(dest);
		int ItemId = dest->sIndex;


		if (pMob[conn].MOB.Equip[6].sIndex >= 801 || pMob[conn].MOB.Equip[6].sIndex >= 1055 ||
			pMob[conn].MOB.Equip[6].sIndex >= 2451 || pMob[conn].MOB.Equip[6].sIndex >= 2938 ||
			pMob[conn].MOB.Equip[6].sIndex >= 3551 || pMob[conn].MOB.Equip[6].sIndex >= 3800)
		{
			pMob[conn].MOB.Equip[6].stEffect[0].cEffect = 125; //efeito REF
			SendClientMessage(conn, "Cor adicionada com sucesso");
			SendItem(conn, ITEM_PLACE_EQUIP, 6, &pMob[conn].MOB.Equip[6]);
		}
		SendEtc(conn);
		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);
		else
			memset(item, 0, sizeof(STRUCT_ITEM));
		return;
		SendItem(conn, m->SourType, m->SourPos, &pMob[conn].MOB.Carry[m->SourPos]);
	}
#pragma endregion

#pragma region //add de capa cele
	if (item->sIndex == 3033) //add capa
	{
		if (pMob[conn].MOB.Equip[15].sIndex == 3197) //capa blue
		{
			int rand_ = rand() % 100;
			if (rand_ <= 2)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3197;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 69;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 2;
			}
			else if (rand_ <= 4)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3197;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 69;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 4;
			}
			else if (rand_ <= 6)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3197;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 69;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 6;
			}
			else if (rand_ <= 8)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3197;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 69;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 8;
			}
			else if (rand_ <= 10)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3197;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 69;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 10;
			}
			else if (rand_ <= 12)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3197;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 69;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 12;
			}
			else if (rand_ <= 14)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3197;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 69;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 14;
			}
			else if (rand_ <= 16)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3197;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 69;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 15;
			}
			else if (rand_ <= 18)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3197;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 69;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 16;
			}
			else if (rand_ <= 20)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3197;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 3;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 10;
			}
			else if (rand_ <= 22)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3197;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 3;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 20;
			}
			else if (rand_ <= 24)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3197;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 3;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 30;
			}
			else if (rand_ <= 26)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3197;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 3;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 40;
			}
			else if (rand_ <= 28)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3197;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 3;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 50;
			}
			else if (rand_ <= 30)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3197;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 3;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 60;
			}
			else if (rand_ <= 32)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3197;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 3;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 70;
			}
			else if (rand_ <= 34)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3197;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 3;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 75;
			}
			else if (rand_ <= 36)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3197;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 3;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 78;
			}
			else if (rand_ <= 38)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3197;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 54;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 2;
			}
			else if (rand_ <= 40)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3197;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 54;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 4;
			}
			else if (rand_ <= 42)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3197;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 54;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 6;
			}
			else if (rand_ <= 46)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3197;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 54;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 8;
			}
			else if (rand_ <= 48)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3197;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 54;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 10;
			}
			else if (rand_ <= 50)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3197;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 54;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 12;
			}
			else if (rand_ <= 52)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3197;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 54;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 14;
			}
			else if (rand_ <= 54)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3197;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 54;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 15;
			}
			else if (rand_ <= 56)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3197;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 54;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 16;
			}
			else if (rand_ <= 58)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3197;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 70;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 2;
			}
			else if (rand_ <= 60)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3197;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 70;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 4;
			}
			else if (rand_ <= 62)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3197;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 70;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 6;
			}
			else if (rand_ <= 64)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3197;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 70;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 8;
			}
			else if (rand_ <= 66)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3197;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 70;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 10;
			}
			else if (rand_ <= 68)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3197;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 70;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 12;
			}
			else if (rand_ <= 70)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3197;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 70;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 14;
			}
			else if (rand_ <= 72)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3197;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 70;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 15;
			}
			else if (rand_ <= 74)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3197;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 70;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 16;
			}
			else if (rand_ <= 76)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3197;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 2;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 10;
			}
			else if (rand_ <= 78)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3197;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 2;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 20;
			}
			else if (rand_ <= 80)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3197;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 2;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 30;
			}
			else if (rand_ <= 82)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3197;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 2;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 40;
			}
			else if (rand_ <= 84)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3197;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 2;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 50;
			}
			else if (rand_ <= 86)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3197;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 2;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 60;
			}
			else if (rand_ <= 88)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3197;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 2;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 70;
			}
			else if (rand_ <= 90)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3197;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 60;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 4;
			}
			else if (rand_ <= 92)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3197;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 60;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 8;
			}
			else if (rand_ <= 94)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3197;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 60;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 12;
			}
			else if (rand_ <= 96)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3197;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 60;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 16;
			}
			else if (rand_ <= 98)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3197;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 60;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 24;
			}
			else
			{
				pMob[conn].MOB.Equip[15].sIndex = 3197;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 60;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 28;
			}
			SendClientMessage(conn, "Sua CAPA Recebeu Um Novo Adicional !!!");
			SendItem(conn, ITEM_PLACE_EQUIP, 15, &pMob[conn].MOB.Equip[15]);
		}
		if (pMob[conn].MOB.Equip[15].sIndex == 3198) //capa blue
		{
			int rand_ = rand() % 100;
			if (rand_ <= 2)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3198;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 69;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 2;
			}
			else if (rand_ <= 4)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3198;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 69;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 4;
			}
			else if (rand_ <= 6)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3198;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 69;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 6;
			}
			else if (rand_ <= 8)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3198;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 69;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 8;
			}
			else if (rand_ <= 10)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3198;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 69;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 10;
			}
			else if (rand_ <= 12)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3198;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 69;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 12;
			}
			else if (rand_ <= 14)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3198;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 69;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 14;
			}
			else if (rand_ <= 16)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3198;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 69;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 15;
			}
			else if (rand_ <= 18)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3198;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 69;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 16;
			}
			else if (rand_ <= 20)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3198;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 3;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 10;
			}
			else if (rand_ <= 22)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3198;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 3;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 20;
			}
			else if (rand_ <= 24)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3198;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 3;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 30;
			}
			else if (rand_ <= 26)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3198;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 3;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 40;
			}
			else if (rand_ <= 28)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3198;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 3;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 50;
			}
			else if (rand_ <= 30)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3198;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 3;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 60;
			}
			else if (rand_ <= 32)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3198;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 3;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 70;
			}
			else if (rand_ <= 34)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3198;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 3;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 75;
			}
			else if (rand_ <= 36)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3198;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 3;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 78;
			}
			else if (rand_ <= 38)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3198;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 54;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 2;
			}
			else if (rand_ <= 40)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3198;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 54;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 4;
			}
			else if (rand_ <= 42)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3198;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 54;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 6;
			}
			else if (rand_ <= 46)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3198;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 54;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 8;
			}
			else if (rand_ <= 48)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3198;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 54;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 10;
			}
			else if (rand_ <= 50)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3198;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 54;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 12;
			}
			else if (rand_ <= 52)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3198;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 54;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 14;
			}
			else if (rand_ <= 54)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3198;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 54;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 15;
			}
			else if (rand_ <= 56)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3198;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 54;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 16;
			}
			else if (rand_ <= 58)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3198;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 70;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 2;
			}
			else if (rand_ <= 60)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3198;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 70;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 4;
			}
			else if (rand_ <= 62)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3198;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 70;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 6;
			}
			else if (rand_ <= 64)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3198;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 70;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 8;
			}
			else if (rand_ <= 66)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3198;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 70;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 10;
			}
			else if (rand_ <= 68)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3198;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 70;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 12;
			}
			else if (rand_ <= 70)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3198;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 70;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 14;
			}
			else if (rand_ <= 72)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3198;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 70;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 15;
			}
			else if (rand_ <= 74)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3198;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 70;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 16;
			}
			else if (rand_ <= 76)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3198;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 2;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 10;
			}
			else if (rand_ <= 78)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3198;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 2;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 20;
			}
			else if (rand_ <= 80)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3198;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 2;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 30;
			}
			else if (rand_ <= 82)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3198;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 2;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 40;
			}
			else if (rand_ <= 84)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3198;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 2;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 50;
			}
			else if (rand_ <= 86)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3198;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 2;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 60;
			}
			else if (rand_ <= 88)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3198;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 2;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 70;
			}
			else if (rand_ <= 90)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3198;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 60;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 4;
			}
			else if (rand_ <= 92)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3198;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 60;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 8;
			}
			else if (rand_ <= 94)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3198;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 60;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 12;
			}
			else if (rand_ <= 96)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3198;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 60;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 16;
			}
			else if (rand_ <= 98)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3198;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 60;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 24;
			}
			else
			{
				pMob[conn].MOB.Equip[15].sIndex = 3198;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 60;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 28;
			}
			SendClientMessage(conn, "Sua CAPA Recebeu Um Novo Adicional !!!");
			SendItem(conn, ITEM_PLACE_EQUIP, 15, &pMob[conn].MOB.Equip[15]);
		}
		if (pMob[conn].MOB.Equip[15].sIndex == 3199) //capa blue
		{
			int rand_ = rand() % 100;
			if (rand_ <= 2)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3199;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 69;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 2;
			}
			else if (rand_ <= 4)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3199;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 69;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 4;
			}
			else if (rand_ <= 6)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3199;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 69;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 6;
			}
			else if (rand_ <= 8)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3199;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 69;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 8;
			}
			else if (rand_ <= 10)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3199;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 69;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 10;
			}
			else if (rand_ <= 12)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3199;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 69;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 12;
			}
			else if (rand_ <= 14)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3199;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 69;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 14;
			}
			else if (rand_ <= 16)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3199;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 69;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 15;
			}
			else if (rand_ <= 18)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3199;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 69;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 16;
			}
			else if (rand_ <= 20)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3199;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 3;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 10;
			}
			else if (rand_ <= 22)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3199;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 3;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 20;
			}
			else if (rand_ <= 24)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3199;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 3;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 30;
			}
			else if (rand_ <= 26)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3199;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 3;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 40;
			}
			else if (rand_ <= 28)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3199;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 3;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 50;
			}
			else if (rand_ <= 30)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3199;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 3;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 60;
			}
			else if (rand_ <= 32)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3199;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 3;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 70;
			}
			else if (rand_ <= 34)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3199;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 3;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 75;
			}
			else if (rand_ <= 36)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3199;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 3;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 78;
			}
			else if (rand_ <= 38)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3199;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 54;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 2;
			}
			else if (rand_ <= 40)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3199;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 54;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 4;
			}
			else if (rand_ <= 42)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3199;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 54;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 6;
			}
			else if (rand_ <= 46)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3199;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 54;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 8;
			}
			else if (rand_ <= 48)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3199;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 54;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 10;
			}
			else if (rand_ <= 50)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3199;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 54;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 12;
			}
			else if (rand_ <= 52)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3199;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 54;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 14;
			}
			else if (rand_ <= 54)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3199;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 54;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 15;
			}
			else if (rand_ <= 56)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3199;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 54;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 16;
			}
			else if (rand_ <= 58)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3199;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 70;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 2;
			}
			else if (rand_ <= 60)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3199;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 70;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 4;
			}
			else if (rand_ <= 62)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3199;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 70;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 6;
			}
			else if (rand_ <= 64)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3199;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 70;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 8;
			}
			else if (rand_ <= 66)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3199;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 70;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 10;
			}
			else if (rand_ <= 68)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3199;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 70;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 12;
			}
			else if (rand_ <= 70)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3199;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 70;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 14;
			}
			else if (rand_ <= 72)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3199;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 70;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 15;
			}
			else if (rand_ <= 74)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3199;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 70;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 16;
			}
			else if (rand_ <= 76)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3199;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 2;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 10;
			}
			else if (rand_ <= 78)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3199;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 2;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 20;
			}
			else if (rand_ <= 80)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3199;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 2;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 30;
			}
			else if (rand_ <= 82)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3199;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 2;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 40;
			}
			else if (rand_ <= 84)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3199;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 2;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 50;
			}
			else if (rand_ <= 86)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3199;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 2;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 60;
			}
			else if (rand_ <= 88)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3199;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 2;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 70;
			}
			else if (rand_ <= 90)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3199;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 60;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 4;
			}
			else if (rand_ <= 92)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3199;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 60;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 8;
			}
			else if (rand_ <= 94)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3199;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 60;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 12;
			}
			else if (rand_ <= 96)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3199;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 60;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 16;
			}
			else if (rand_ <= 98)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3199;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 60;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 24;
			}
			else
			{
				pMob[conn].MOB.Equip[15].sIndex = 3199;
				pMob[conn].MOB.Equip[15].stEffect[1].cEffect = 60;
				pMob[conn].MOB.Equip[15].stEffect[1].cValue = 28;
			}
			SendClientMessage(conn, "Sua CAPA Recebeu Um Novo Adicional !!!");
			SendItem(conn, ITEM_PLACE_EQUIP, 15, &pMob[conn].MOB.Equip[15]);
		}
		SendEtc(conn);
		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);
		else
			memset(item, 0, sizeof(STRUCT_ITEM));
		return;
		SendItem(conn, m->SourType, m->SourPos, &pMob[conn].MOB.Carry[m->SourPos]);
	}
#pragma endregion
	if (item->sIndex >= 4500 && item->sIndex <= 4549) {
		int Traje = item->sIndex - 4500 + 22;

		for (int i = 1; i < 16; i++) {
			if (pUser[conn].Keys[i] == 0) {
				pUser[conn].Keys[i] = Traje;
				SendClientMessage(conn, "Traje Salvo com Sucesso!");
				break;
			}
			if (pUser[conn].Keys[i] == Traje) {
				SendClientMessage(conn, "Esse Traje já foi utilizado");
				SendItem(conn, m->SourType, m->SourPos, item);
				break;
			}
			if (i == 15 && pUser[conn].Keys[i] != 0) {
				SendClientMessage(conn, "Não há slots de trajes disponíveis");
				SendItem(conn, m->SourType, m->SourPos, item);
				return;
			}
		}
		SendKeys(conn);
		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);
		else
			memset(item, 0, sizeof(STRUCT_ITEM));
		return;
		SendItem(conn, m->SourType, m->SourPos, &pMob[conn].MOB.Carry[m->SourPos]);
	}

#pragma region //add de capa cele
	if (item->sIndex == 5680) //add capa
	{
		if (pMob[conn].MOB.Equip[15].sIndex == 3197) //capa blue
		{
			int rand_ = rand() % 100;
			if (rand_ <= 20)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3197;
				pMob[conn].MOB.Equip[15].stEffect[2].cEffect = 57;
				pMob[conn].MOB.Equip[15].stEffect[2].cValue = 10;
			}
			else if (rand_ <= 40)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3197;
				pMob[conn].MOB.Equip[15].stEffect[2].cEffect = 57;
				pMob[conn].MOB.Equip[15].stEffect[2].cValue = 15;
			}
			else if (rand_ <= 60)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3197;
				pMob[conn].MOB.Equip[15].stEffect[2].cEffect = 57;
				pMob[conn].MOB.Equip[15].stEffect[2].cValue = 20;
			}
			else if (rand_ <= 80)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3197;
				pMob[conn].MOB.Equip[15].stEffect[2].cEffect = 57;
				pMob[conn].MOB.Equip[15].stEffect[2].cValue = 25;
			}
			else
			{
				pMob[conn].MOB.Equip[15].sIndex = 3197;
				pMob[conn].MOB.Equip[15].stEffect[2].cEffect = 57;
				pMob[conn].MOB.Equip[15].stEffect[2].cValue = 30;
			}
			SendClientMessage(conn, "Sua CAPA Recebeu Um Novo Adicional !!!");
			SendItem(conn, ITEM_PLACE_EQUIP, 15, &pMob[conn].MOB.Equip[15]);
		}
		if (pMob[conn].MOB.Equip[15].sIndex == 3198) //capa blue
		{
			int rand_ = rand() % 100;
			if (rand_ <= 20)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3198;
				pMob[conn].MOB.Equip[15].stEffect[2].cEffect = 57;
				pMob[conn].MOB.Equip[15].stEffect[2].cValue = 10;
			}
			else if (rand_ <= 40)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3198;
				pMob[conn].MOB.Equip[15].stEffect[2].cEffect = 57;
				pMob[conn].MOB.Equip[15].stEffect[2].cValue = 15;
			}
			else if (rand_ <= 60)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3198;
				pMob[conn].MOB.Equip[15].stEffect[2].cEffect = 57;
				pMob[conn].MOB.Equip[15].stEffect[2].cValue = 20;
			}
			else if (rand_ <= 80)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3198;
				pMob[conn].MOB.Equip[15].stEffect[2].cEffect = 57;
				pMob[conn].MOB.Equip[15].stEffect[2].cValue = 25;
			}
			else
			{
				pMob[conn].MOB.Equip[15].sIndex = 3198;
				pMob[conn].MOB.Equip[15].stEffect[2].cEffect = 57;
				pMob[conn].MOB.Equip[15].stEffect[2].cValue = 30;
			}
			SendClientMessage(conn, "Sua CAPA Recebeu Um Novo Adicional !!!");
			SendItem(conn, ITEM_PLACE_EQUIP, 15, &pMob[conn].MOB.Equip[15]);
		}
		if (pMob[conn].MOB.Equip[15].sIndex == 3199) //capa blue
		{
			int rand_ = rand() % 100;
			if (rand_ <= 20)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3199;
				pMob[conn].MOB.Equip[15].stEffect[2].cEffect = 57;
				pMob[conn].MOB.Equip[15].stEffect[2].cValue = 10;
			}
			else if (rand_ <= 40)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3199;
				pMob[conn].MOB.Equip[15].stEffect[2].cEffect = 57;
				pMob[conn].MOB.Equip[15].stEffect[2].cValue = 15;
			}
			else if (rand_ <= 60)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3199;
				pMob[conn].MOB.Equip[15].stEffect[2].cEffect = 57;
				pMob[conn].MOB.Equip[15].stEffect[2].cValue = 20;
			}
			else if (rand_ <= 80)
			{
				pMob[conn].MOB.Equip[15].sIndex = 3199;
				pMob[conn].MOB.Equip[15].stEffect[2].cEffect = 57;
				pMob[conn].MOB.Equip[15].stEffect[2].cValue = 25;
			}
			else
			{
				pMob[conn].MOB.Equip[15].sIndex = 3199;
				pMob[conn].MOB.Equip[15].stEffect[2].cEffect = 57;
				pMob[conn].MOB.Equip[15].stEffect[2].cValue = 30;
			}
			SendClientMessage(conn, "Sua CAPA Recebeu Um Novo Adicional !!!");
			SendItem(conn, ITEM_PLACE_EQUIP, 15, &pMob[conn].MOB.Equip[15]);
		}
		SendEtc(conn);
		if (amount > 1)
			BASE_SetItemAmount(item, amount - 1);
		else
			memset(item, 0, sizeof(STRUCT_ITEM));
		return;
		SendItem(conn, m->SourType, m->SourPos, &pMob[conn].MOB.Carry[m->SourPos]);
	}
#pragma endregion
}



# -------------------- _MSG_War.cpp --------------------

/*
*   Copyright (C) {2015}  {Victor Klafke, Charles TheHouse}
*
*   This program is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program.  If not, see [http://www.gnu.org/licenses/].
*
*   Contact at: victor.klafke@ecomp.ufsm.br
*/
#include "ProcessClientMessage.h"

void Exec_MSG_War(int conn, char *pMsg)
{
	if (pUser[conn].Atraso != 0)
	{
		int isTime = GetTickCount64() - pUser[conn].Atraso; // ATRASO PACOTE DE MORTE

		if (isTime < 2000)
		{
			return;
		}
		
	}

	pUser[conn].Atraso = GetTickCount64();

	MSG_STANDARDPARM2 *m = (MSG_STANDARDPARM2*)pMsg;

	int Size = m->Size;

	if (Size > sizeof(MSG_STANDARDPARM2)) //CONTROLE DE SIZE
	{
		SendClientMessage(conn, "Impossível executar ação55, tente mais tarde. ");
		return;
	}

	int Guild = m->Parm1;
	int Enemy = m->Parm2;

	if(Guild <= 0 || Guild >= 65536)
		return;

	if(Enemy <= 0 || Enemy >= 65536)
		return;

	if(pMob[conn].MOB.Guild != Guild || pMob[conn].MOB.GuildLevel != 9)
		return;

	MSG_STANDARDPARM2 sm_war;
	memset(&sm_war, 0, sizeof(MSG_STANDARDPARM2));

	sm_war.Size = sizeof(MSG_STANDARDPARM2);
	sm_war.Type = _MSG_War;
	sm_war.ID = conn;

	sm_war.Parm1 = Guild;
	sm_war.Parm2 = Enemy;

	DBServerSocket.SendOneMessage((char*)&sm_war, sizeof(MSG_STANDARDPARM2));
}

# -------------------- _MSG_Withdraw.cpp --------------------


#include "ProcessClientMessage.h"

void Exec_MSG_Withdraw(int conn, char *pMsg)
{
	MSG_STANDARDPARM *m = (MSG_STANDARDPARM*)pMsg;

	int Size = m->Size;

	if (Size > sizeof(MSG_STANDARDPARM)) //CONTROLE DE SIZE
	{
		SendClientMessage(conn, "Impossível executar ação56, tente mais tarde. ");
		return;
	}

	if (pMob[conn].MOB.CurrentScore.Hp == 0 || pUser[conn].Mode != USER_PLAY)
	{
		SendHpMode(conn);
		AddCrackError(conn, 10, 2);
		return;
	}

	int coin = m->Parm;

	if (coin < 0 || coin > 2000000000)
		return;

	if (pUser[conn].Coin >= coin && coin >= 0 && coin <= 2000000000)
	{
		int tcoin = coin + pMob[conn].MOB.Coin;

		if (tcoin >= 0 && tcoin <= 2000000000)
		{
			pMob[conn].MOB.Coin = tcoin;
			pUser[conn].Coin -= coin;

			m->ID = 30000;

			int Size = m->Size;

			if (Size > sizeof(MSG_STANDARDPARM))
			{
				m->Size = 0;
				return;
			}
			if (!pUser[conn].cSock.AddMessage((char*)m, sizeof(MSG_STANDARDPARM)))
				CloseUser(conn);

			SendCargoCoin(conn);

			sprintf_s(temp, "etc,retirada do bau V:%d R:%d", coin, pUser[conn].Coin);
			SystemLog(pUser[conn].AccountName, pUser[conn].MacAddress, pUser[conn].IP, temp);
		}
		else
			SendClientMessage(conn, g_pMessageStringTable[_NN_Cant_get_more_than_2G]);
	}
	else
		SendClientMessage(conn, g_pMessageStringTable[_NN_Cant_Withdraw_That_Much]);
}

